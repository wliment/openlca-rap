/*******************************************************************************
 * Copyright (c) 2010, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

/*global qxvariants:true*/

qxvariants = {
  "qx.debug" : "on"
};

/*******************************************************************************
 * Copyright (c) 2004, 2014 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

/*global rwt:true, namespace:true*/
/*jshint unused: false*/

rwt = {

  define: function( name, object ) {
    var splits = name.split( "." );
    var parent = window;
    var part = splits[ 0 ];
    for( var i = 0, len = splits.length - 1; i < len; i++, part = splits[ i ] ) {
      if( !parent[ part ] ) {
        parent = parent[ part ] = {};
      } else {
        parent = parent[ part ];
      }
    }
    if( !( part in parent ) ) {
      parent[ part ] = object || {};
    }
    return part;
  }

};

// TODO [rst] Use rwt.define instead of namespace
var namespace = rwt.define;

/*******************************************************************************
 *  Copyright: 2004, 2014 1&1 Internet AG, Germany, http://www.1und1.de,
 *                        and EclipseSource
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v1.0 which accompanies this
 * distribution, and is available at http://www.eclipse.org/legal/epl-v10.html
 *
 *  Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

if (!Error.prototype.toString || Error.prototype.toString() == "[object Error]")
{
  /**
   * Some browsers (e.g. Internet Explorer) do not support to stringify
   * error objects like other browsers usually do. This feature is added to
   * those browsers.
   *
   * @type member
   * @return {var} TODOC
   */
  Error.prototype.toString = function() {
    return this.message;
  };
}

if (!Array.prototype.indexOf)
{
  /**
   * Returns the first index at which a given element can be found in the array,
   * or <code>-1</code> if it is not present. It compares <code>searchElement</code> to elements of the Array
   * using strict equality (the same method used by the <code>===</code>, or
   * triple-equals, operator).
   *
   * Natively supported in Gecko since version 1.8.
   * http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Objects:Array:indexOf
   *
   * @type member
   * @param searchElement {var} Element to locate in the array.
   * @param fromIndex {Integer} The index at which to begin the search. Defaults to 0, i.e. the whole
   *         array will be searched. If the index is greater than or equal to the length of the array,
   *         <code>-1</code> is returned, i.e. the array will not be searched. If negative, it is taken as the
   *         offset from the end of the array. Note that even when the index is negative, the array is still
   *         searched from front to back. If the calculated index is less than 0, the whole array will be searched.
   * @return {var} TODOC
   */
  Array.prototype.indexOf = function(searchElement, fromIndex)
  {
    if (fromIndex == null) {
      fromIndex = 0;
    } else if (fromIndex < 0) {
      fromIndex = Math.max(0, this.length + fromIndex);
    }

    for (var i=fromIndex; i<this.length; i++)
    {
      if (this[i] === searchElement) {
        return i;
      }
    }

    return -1;
  };
}

if( /iPad|iPhone|iPod/.test( navigator.userAgent ) && /Version\/6/.test( navigator.userAgent ) ) {

// From https://gist.github.com/ronkorving/3755461:
(function (window) {

        // This library re-implements setTimeout, setInterval, clearTimeout, clearInterval for iOS6.
        // iOS6 suffers from a bug that kills timers that are created while a page is scrolling.
        // This library fixes that problem by recreating timers after scrolling finishes (with interval correction).
    // This code is free to use by anyone (MIT, blabla).
    // Author: rkorving@wizcorp.jp

        var timeouts = {};
        var intervals = {};
        var orgSetTimeout = window.setTimeout;
        var orgSetInterval = window.setInterval;
        var orgClearTimeout = window.clearTimeout;
        var orgClearInterval = window.clearInterval;


        function createTimer(set, map, args) {
                var id, cb = args[0], repeat = (set === orgSetInterval);

                function callback() {
                        if (cb) {
                                cb.apply(window, arguments);

                                if (!repeat) {
                                        delete map[id];
                                        cb = null;
                                }
                        }
                }

                args[0] = callback;

                id = set.apply(window, args);

                map[id] = { args: args, created: Date.now(), cb: cb, id: id };

                return id;
        }


        function resetTimer(set, clear, map, virtualId ) {
                var timer = map[virtualId];

                if (!timer) {
                        return;
                }

                var repeat = (set === orgSetInterval);

                // cleanup

                clear(timer.id);

                // reduce the interval (arg 1 in the args array)

                if (!repeat) {
                        var interval = timer.args[1];

                        var reduction = Date.now() - timer.created;
                        if (reduction < 0) {
                                reduction = 0;
                        }

                        interval -= reduction;
                        if (interval < 0) {
                                interval = 0;
                        }

                        timer.args[1] = interval;
                }

                // recreate

                function callback() {
                        if (timer.cb) {
                                timer.cb.apply(window, arguments);
                                if (!repeat) {
                                        delete map[virtualId];
                                        timer.cb = null;
                                }
                        }
                }

                timer.args[0] = callback;
                timer.created = Date.now();
                timer.id = set.apply(window, timer.args);
        }


        window.setTimeout = function () {
                return createTimer(orgSetTimeout, timeouts, arguments);
        };


        window.setInterval = function () {
                return createTimer(orgSetInterval, intervals, arguments);
        };

        window.clearTimeout = function (id) {
                var timer = timeouts[id];

                if (timer) {
                        delete timeouts[id];
                        orgClearTimeout(timer.id);
                }
        };

        window.clearInterval = function (id) {
                var timer = intervals[id];

                if (timer) {
                        delete intervals[id];
                        orgClearInterval(timer.id);
                }
        };

        window.addEventListener('scroll', function () {
                // recreate the timers using adjusted intervals
                // we cannot know how long the scroll-freeze lasted, so we cannot take that into account

                var virtualId;

                for (virtualId in timeouts) {
                        resetTimer(orgSetTimeout, orgClearTimeout, timeouts, virtualId);
                }

                for (virtualId in intervals) {
                        resetTimer(orgSetInterval, orgClearInterval, intervals, virtualId);
                }
        });

}(window));

}

/*******************************************************************************
 * Copyright (c) 2004, 2014 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

namespace( "rwt.util" );

/**
 * Helper functions for arrays.
 */
rwt.util.Arrays = {

  /**
   * Convert an arguments object into an array.
   */
  fromArguments : function( args ) {
    return Array.prototype.slice.call( args, 0 );
  },

  /**
   * Expand shorthand definition to a four element array.
   * Used for box properties such as padding and margin.
   */
  fromShortHand : function( input ) {
    var len = input.length;
    if( len === 0 || len > 4 ) {
      throw new Error( "Invalid number of arguments!" );
    }
    var result = rwt.util.Arrays.copy( input );
    if( len === 1 ) {
      result[1] = result[2] = result[3] = result[0];
    } else if( len === 2 ) {
      result[2] = result[0];
      result[3] = result[1];
    } else if( len === 3 ) {
      result[3] = result[1];
    }
    return result;
  },

  /**
   * Checks whether the array contains the given element.
   */
  contains : function( arr, obj ) {
    return arr.indexOf( obj ) != -1;
  },

  /**
   * Creates a copy of the given array.
   */
  copy : function( arr ) {
    return arr.concat();
  },

  /**
   * Return the first element of the given array.
   */
  getFirst : function( arr ) {
    return arr[0];
  },

  /**
   * Returns the last element of the given array.
   */
  getLast : function( arr ) {
    return arr[arr.length - 1];
  },

  /**
   * Insert an element into the array at the given position.
   */
  insertAt : function( arr, obj, i ) {
    arr.splice( i, 0, obj );
    return arr;
  },

  /**
   * Remove the element at the given index from the array. Returns the removed element.
   */
  removeAt : function( arr, i ) {
    return arr.splice( i, 1 )[0];
  },

  /**
   * Removes an element from an array. Returns the removed element.
   */
  remove : function( arr, obj ) {
    var i = arr.indexOf( obj );
    if( i != -1 ) {
      arr.splice( i, 1 );
      return obj;
    }
  }

};

/*******************************************************************************
 * Copyright (c) 2004, 2014 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

namespace( "rwt.util" );

(function() {

var shadowsKeys = !( { toString: null } ).propertyIsEnumerable( "toString" );

var shadowedKeys = [
  "isPrototypeOf",
  "hasOwnProperty",
  "toLocaleString",
  "toString",
  "valueOf",
  "constructor"
];

/**
 * Helper functions for objects.
 */
rwt.util.Objects = {

  /**
   * Returns a copy of an object.
   */
  copy : function( source ) {
    var clone = {};
    for( var key in source ) {
      clone[key] = source[key];
    }
    return clone;
  },

  /**
   * Convert an array into a object.
   *
   * All elements of the array become keys of the returned object by
   * calling "toString" on the array elements. The values of the
   * object are set to "true"
   */
  fromArray: function( array ) {
    var obj = {};
    for( var i = 0, l = array.length; i < l; i++ ) {
      obj[array[i].toString()] = true;
    }
    return obj;
  },

  /**
   * Checks if the given object contains any keys.
   */
  isEmpty : function( object ) {
    /*jshint unused:false */
    for( var key in object ) {
      return false;
    }
    return true;
  },

  /**
   * Retrieves all keys of an object and its prototype chain.
   */
  getKeys : function( object ) {
    var arr = [];
    for( var key in object ) {
      arr.push( key );
    }
    // Old IEs don't include "shadowed" keys in a for-each loop even if they are defined directly
    // in the object.
    if( shadowsKeys ) {
      for( var i = 0, l = shadowedKeys.length; i < l; i++ ) {
        if( object.hasOwnProperty( shadowedKeys[i] ) ) {
          arr.push( shadowedKeys[i] );
        }
      }
    }
    return arr;
  },

  /**
   * Retrieves all values of an object and its prototype chain.
   */
  getValues : function( object ) {
    var arr = [];
    for( var key in object ) {
      arr.push( object[key] );
    }
    return arr;
  },

  /**
   * Inserts all keys of the source object into the target object. The target object is modified.
   * Returns the modified target object.
   */
  mergeWith : function( target, source, overwrite ) {
    if( overwrite === undefined ) {
      overwrite = true;
    }
    for( var key in source ) {
      if( overwrite || target[key] === undefined ) {
        target[key] = source[key];
      }
    }
    return target;
  }

};

})();

/*******************************************************************************
 * Copyright (c) 2004, 2014 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

namespace( "rwt.util" );

/**
 * Helper functions for strings.
 */
rwt.util.Strings = {

  /**
   * Checks whether the string contains a given substring.
   */
  contains : function( str, substr ) {
    return str.indexOf( substr ) !== -1;
  },

  /**
   * Returns a string with the first character converted to upper case.
   */
  toFirstUp : function( str ) {
    return str.charAt( 0 ).toUpperCase() + str.substr( 1 );
  }

};

/*******************************************************************************
 * Copyright (c) 2004, 2014 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

namespace( "rwt.util" );

/**
 * Helper functions for numbers.
 */
rwt.util.Numbers = {

  /**
   * Checks whether a value is a valid number. NaN is not considered valid.
   */
  isNumber : function( value ) {
    return typeof value === "number" && !isNaN( value );
  },

  /**
   * Check whether the number is between a given range.
   */
  isBetween : function( nr, vmin, vmax) {
    return nr > vmin && nr < vmax;
  },

  /**
   * Limit the number to the given range.
   */
  limit : function( n, vmin, vmax ) {
    if( typeof vmax === "number" && n > vmax ) {
      return vmax;
    }
    if( typeof vmin === "number" && n < vmin ) {
      return vmin;
    }
    return n;
  }

};

/*******************************************************************************
 * Copyright (c) 2004, 2014 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

/**
 * Helper functions for functions.
 */
rwt.define( "rwt.util.Functions", {

  /**
   * Always returns true.
   */
  returnTrue : function() {
    return true;
  },

  /**
   * Always returns false.
   */
  returnFalse : function() {
    return false;
  },

  /**
   * Always returns null.
   */
  returnNull : function() {
    return null;
  },

  /**
   * Always returns 0.
   */
  returnZero : function() {
    return 0;
  },

  /**
   * Binds a function to a context object, i.e. `this` will be bound to the context object.
   */
  bind: function( fn, context ) {
    return function() {
      return fn.apply( context, arguments );
    };
  }

});

/*******************************************************************************
 * Copyright (c) 2004, 2014 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

namespace( "rwt.util" );

(function() {

/**
 * Methods to convert colors between different color spaces.
 */
rwt.util.Colors = {

  /**
   * Detects if a string is a valid color.
   */
  isValid : function( str ) {
    return isNamedColor( str ) || isHex3String( str ) || isHex6String( str ) || isRgbString( str );
  },

  /**
   * Converts a string to an RGB array. Supports named colors, rgb(), #xxx, and #xxxxxx.
   */
  stringToRgb : function( str ) {
    if( isNamedColor( str ) ) {
      return NAMED[str];
    } else if( isRgbString( str ) ) {
      return rgbStringToRgb();
    } else if( isHex3String( str ) ) {
      return hex3StringToRgb();
    } else if( isHex6String( str ) ) {
      return hex6StringToRgb();
    }
    throw new Error( "Could not parse color: " + str );
  },

  /**
   * Converts an RGB array to a string of the form "rgb(r, g, b)".
   */
  rgbToRgbString : function( rgb ) {
    return "rgb(" + rgb[0] + "," + rgb[1] + "," + rgb[2] + ")";
  },

  /**
   * Converts a RGB array to a string of the form "xxxxxx".
   */
  rgbToHexString : function( rgb ) {
    return hexstr( rgb[0] ) + hexstr( rgb[1] ) + hexstr( rgb[2] );
  }

};

var hexstr = function( number ) {
  var hexstr = number.toString( 16 ).toLowerCase();
  return hexstr.length == 1 ? "0" + hexstr : hexstr;
};

var REGEXP = {
  hex3 : /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex6 : /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  rgb : /^rgb\(\s*([0-9]{1,3}\.{0,1}[0-9]*)\s*,\s*([0-9]{1,3}\.{0,1}[0-9]*)\s*,\s*([0-9]{1,3}\.{0,1}[0-9]*)\s*\)$/
};

/*
 * Basic color keywords as defined in CSS 3
 * See http://www.w3.org/TR/css3-color/#html4
 */
var NAMED = {
  black : [0, 0, 0],
  silver : [192, 192, 192],
  gray : [128, 128, 128],
  white : [255, 255, 255],
  maroon : [128, 0, 0],
  red : [255, 0, 0],
  purple : [128, 0, 128],
  fuchsia : [255, 0, 255],
  green : [0, 128, 0],
  lime : [0, 255, 0],
  olive : [128, 128, 0],
  yellow : [255, 255, 0],
  navy : [0, 0, 128],
  blue : [0, 0, 255],
  teal : [0, 128, 128],
  aqua : [0, 255, 255],
  transparent : [-1, -1, -1]
};

var isNamedColor = function( value ) {
  return NAMED[value] !== undefined;
};

var isHex3String = function( str ) {
  return REGEXP.hex3.test( str );
};

var isHex6String = function( str ) {
  return REGEXP.hex6.test( str );
};

var isRgbString = function( str ) {
  return REGEXP.rgb.test( str );
};

var hex3StringToRgb = function() {
  var r = parseInt( RegExp.$1, 16 ) * 17;
  var g = parseInt( RegExp.$2, 16 ) * 17;
  var b = parseInt( RegExp.$3, 16 ) * 17;
  return [r, g, b];
};

var hex6StringToRgb = function() {
  var r = (parseInt( RegExp.$1, 16 ) * 16) + parseInt( RegExp.$2, 16 );
  var g = (parseInt( RegExp.$3, 16 ) * 16) + parseInt( RegExp.$4, 16 );
  var b = (parseInt( RegExp.$5, 16 ) * 16) + parseInt( RegExp.$6, 16 );
  return [r, g, b];
};

var rgbStringToRgb = function() {
  var r = parseInt( RegExp.$1, 10 );
  var g = parseInt( RegExp.$2, 10 );
  var b = parseInt( RegExp.$3, 10 );
  return [r, g, b];
};

})();

/*******************************************************************************
 * Copyright (c) 2004, 2014 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource, and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

/*global qxvariants:false*/

/**
 * Manage variants of source code. May it be for different debug options,
 * browsers or other environment flags.
 *
 * Variants enable the selection and removal of code from the build version.
 * A variant consists of a collection of states from which exactly one is active
 * at load time of the framework. The global map <code>qxvariants</code> can be
 * used to select a variant before the Framework is loades.
 *
 * Depending on the selected variant a specific code
 * path can be choosen using the <code>select</code> method. The generator is
 * able to set a variant and remove all code paths which are
 * not selected by the variant.
 *
 * Variants are used to implement browser optimized builds and to remove
 * debugging code from the build version. It is very similar to conditional
 * compilation in C/C++.
 */
rwt.util.Variant = {

  /** {Map} stored variants */
  __variants : {},

  /**
   * Import settings from global qxvariants into current environment
   */
  __init : function() {
    if( window.qxvariants ) {
      for( var name in qxvariants ) {
        this.__variants[ name ] = qxvariants[ name ];
      }
      window.qxvariants = undefined;
      try {
        delete window.qxvariants;
      } catch( ex ) {
      }
    }
  },

  /**
   * Define a variant
   *
   * @param name {String} unique name for the variant
   * @param value {String} value for the variant
   */
  define : function( name, value ) {
    if( name in this.__variants ) {
      throw new Error( "Variant already defined: '" + name + "'" );
    }
    this.__variants[ name ] = value;
  },

  /**
   * Get the current value of a variant.
   *
   * @param name {String} name of the variant
   * @return {String} current value of the variant
   */
  get : function( name ) {
    var data = this.__variants[ name ];
    if( data === undefined ) {
      throw new Error( 'Undefined variant "' + name + '"' );
    }
    return data;
  },

  /**
   * Select a function depending on the value of the variant.
   *
   * Example:
   *
   * <pre class='javascript'>
   * var f = rwt.util.Variant.select( "qx.client", {
   *   "gecko": function() { ... },
   *   "trident|webkit": function() { ... },
   *   "default": function() { ... }
   * });
   * </pre>
   *
   * Depending on the value of the <code>"qx.client"</code> variant this will select the
   * corresponding function. The first case is selected if the variant is "gecko", the second
   * is selected if the variant is "trident" or "webkit" and the third function is selected if
   * none of the other names match the variant.
   *
   * @param name {String} name of the variant. To enable the generator to optimize
   *   this selection, the name must be a string literal.
   * @param functions {Map} map with variant names as names and functions as values.
   * @return {Function} The selected function from the map.
   */
  select : function( name, functions ) {
    if( typeof this.__variants[ name ] === "undefined" ) {
      throw new Error( "Variant not defined: '" + name + "'" );
    }
    for( var variant in functions ) {
      if( this.isSet( name, variant ) ) {
        return functions[ variant ];
      }
    }
    if( functions[ "default" ] !== undefined ) {
      return functions[ "default" ];
    }
    throw new Error( "No match for variant: '" + name + "'" );
  },

  /**
   * Check whether a variant is set to a given value. To enable the generator to optimize
   * this selection, both parameters must be string literals.
   *
   * This method is meant to be used in if statements to select code paths. If the condition of
   * an if statement is only this method, the generator is able to optimize the if
   * statement.
   *
   * Example:
   *
   * <pre class='javascript'>
   * if (rwt.util.Variant.isSet("qx.client", "trident")) {
   *   // some Internet Explorer specific code
   * } else if(rwt.util.Variant.isSet("qx.client", "webkit")){
   *   // Opera specific code
   * } else {
   *   // common code for all other browsers
   * }
   * </pre>
   *
   * @param name {String} name of the variant
   * @param variants {String} value to check for. Several values can be "or"-combined by
   *   separating them with a "|" character. A value of "trident|webkit" would for example
   *   check if the variant is set to "trident" or "webkit"
   * @return {Boolean} whether the variant is set to the given value
   */
  isSet : function( name, variants ) {
    // fast path
    var actual = this.get( name );
    if( variants.indexOf( "|" ) < 0 ) {
      return actual === variants;
    }
    var nameParts = variants.split( "|" );
    for( var i = 0, l = nameParts.length; i < l; i++ ) {
      if( actual === nameParts[ i ] ) {
        return true;
      }
    }
    return false;
  }

};

rwt.util.Variant.define( "qx.debug", "off" );
rwt.util.Variant.__init();

/*******************************************************************************
 * Copyright: 2004, 2015 1&1 Internet AG, Germany, http://www.1und1.de,
 *                       and EclipseSource
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v1.0 which accompanies this
 * distribution, and is available at http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

namespace( "rwt.client" );

/**
 * Basic client detection implementation.
 *
 * Version names follow the wikipedia scheme: major.minor[.revision[.build]] at
 * http://en.wikipedia.org/wiki/Software_version
 */
rwt.client.Client = {

  __init : function() {
    this._engineName = "unknown";
    this._browserName = "unknown";
    this._engineVersion = 0;
    this._engineVersionMajor = 0;
    this._engineVersionMinor = 0;
    this._engineVersionRevision = 0;
    this._engineVersionBuild = 0;
    this._browserPlatform = "other";
    this._runsLocally = window.location.protocol === "file:";
    this._defaultLocale = "en";
    // NOTE: Order is important!
    this._initKonqueror();
    this._initTrident();
    this._initBlink();
    this._initWebkit();
    this._initGecko();
    this._initBoxSizing();
    this._initLocale();
    this._initPlatform();
  },

  getRunsLocally : function() {
    return this._runsLocally;
  },

  getEngine : function() {
    return this._engineName;
  },

  getBrowser : function() {
    return this._browserName;
  },

  getVersion : function() {
    return this._engineVersion;
  },

  getMajor : function() {
    return this._engineVersionMajor;
  },

  getMinor : function() {
    return this._engineVersionMinor;
  },

  getRevision : function() {
    return this._engineVersionRevision;
  },

  getBuild : function() {
    return this._engineVersionBuild;
  },

  isTrident : function() {
    return this._engineName === "trident";
  },

  isGecko : function() {
    return this._engineName === "gecko";
  },

  isBlink : function() {
    return this._engineName === "blink";
  },

  isWebkit : function() {
    return this._engineName === "webkit";
  },

  getTimezoneOffset : function() {
    return ( new Date() ).getTimezoneOffset();
  },

  getLocale : function() {
    return this._browserLocale;
  },

  getLanguage : function() {
    var locale = this.getLocale();
    var language;
    var pos = locale.indexOf( "_" );
    if( pos == -1 ) {
      language = locale;
    } else {
      language = locale.substring( 0, pos );
    }
    return language;
  },

  getTerritory : function() {
    return this.getLocale().split( "_" )[ 1 ] || "";
  },

  getDefaultLocale : function() {
    return this._defaultLocale;
  },

  usesDefaultLocale : function() {
    return this._browserLocale === this._defaultLocale;
  },

  getEngineBoxSizingAttributes : function() {
    return this._engineBoxSizingAttributes;
  },

  getPlatform : function() {
    return this._browserPlatform;
  },

  isMobileSafari : function() {
    return this.getPlatform() === "ios" && this.getBrowser() === "safari";
  },

  isMobileChrome : function() {
    return this.getPlatform() === "android" && this.getBrowser() === "chrome";
  },

  isAndroidBrowser : function() {
    return this.getPlatform() === "android" && this.getBrowser() === "android";
  },

  isMobileFirefox : function() {
    return this.getPlatform() === "android" && this.getBrowser() === "firefox";
  },

  supportsFileDrop : function() {
    return !!window.FormData;
  },

  supportsTouch : function() {
    return    this.isMobileSafari()
           || this.isAndroidBrowser()
           || this.isMobileChrome()
           || this.isMobileFirefox();
  },

  // NOTE: This returns true if the browser sufficiently implements
  // border-radius, drop-shadow and linear-gradient.
  supportsCss3 : function() {
    var engine = rwt.client.Client.getEngine();
    var version = rwt.client.Client.getVersion();
    return    engine === "blink"
           || engine === "webkit" && version >= 522
           || engine === "gecko" && version >= 2 // firefox 4+
           || engine === "trident" && version >= 9;
  },

  // NOTE [tb] : only works in IE right now.
  // Inspired by https://github.com/yonran/detect-zoom
  isZoomed : function() {
    var result = false;
    if( this._engineName === "trident" ) {
      if( this._engineVersionMajor >= 8 ) {
        result = ( screen.deviceXDPI / screen.logicalXDPI ) !== 1;
      } else {
        try {
          var rect = document.body.getBoundingClientRect();
          var zoom = ( rect.right - rect.left ) / document.body.offsetWidth;
          result = zoom !== 1;
        } catch( ex ) { // only happens in tests due to different bootstrap
          result = false;
        }
      }
    }
    return result;
  },

  getBasePath : function() {
    if( !this._basePath ) {
      this._basePath = this._computeBasePath( document.location.href );
    }
    return this._basePath;
  },

  //////////
  // Helper

  _computeBasePath : function( url ) {
    var result = url;
    if( result.indexOf( "?" ) !== -1 ) {
      result = result.slice( 0, result.indexOf( "?" ) );
    }
    if( result.indexOf( "#" ) !== -1 ) {
      result = result.slice( 0, result.indexOf( "#" ) );
    }
    return result.slice( 0, result.lastIndexOf( "/" ) + 1 );
  },

  _initKonqueror : function() {
    if( !this._isBrowserDetected() ) {
      var vendor = navigator.vendor;
      var isKonqueror =    typeof vendor === "string" && vendor === "KDE"
                        && /KHTML\/([0-9\-\.]*)/.test( navigator.userAgent );
      if( isKonqueror ) {
        this._engineName = "webkit";
        this._browserName = "konqueror";
        // Howto translate KDE Version to Webkit Version? Currently emulate Safari 3.0.x for all versions.
        // this._engineVersion = RegExp.$1;
        this._parseVersion( "420" );
      }
    }
  },

  _initBlink : function() {
    if( !this._isBrowserDetected() ) {
      var userAgent = navigator.userAgent;
      // Some Blink browsers like Opera Mobile or Maxthon lack the window.chrome object.
      // A v8 feature check is necessary to cover all current Blink engine browsers as of Dec 2014.
      var isBlink = window.chrome || ( window.Intl && window.Intl.v8BreakIterator );
      if( isBlink ) {
        this._engineName = "blink";
        if( userAgent.indexOf( "OPR" ) !== -1 ) {
          this._browserName = "opera";
          /OPR\/([^ ]+)/.test( userAgent );
          this._parseVersion( RegExp.$1 );
        } else if( userAgent.indexOf( "Chrome" ) !== -1 ) {
          this._browserName = "chrome";
          /Chrome\/([^ ]+)/.test( userAgent );
          this._parseVersion( RegExp.$1 );
        } else {
          this._browserName = "other blink";
        }
      }
    }
  },

  _initWebkit : function() {
    if( !this._isBrowserDetected() ) {
      var userAgent = navigator.userAgent;
      var isWebkit =    userAgent.indexOf( "AppleWebKit" ) != -1
                     && /AppleWebKit\/([^ ]+)/.test( userAgent );
      if( isWebkit ) {
        this._engineName = "webkit";
        var version = RegExp.$1;
        var invalidCharacter = /[^\.0-9]/.exec( version );
        if( invalidCharacter ) {
          version = version.slice( 0, invalidCharacter.index );
        }
        this._parseVersion( version );
        if( userAgent.indexOf( "Safari" ) != -1 ) {
          if( userAgent.indexOf( "Android" ) != -1 ) {
            this._browserName = "android";
          } else {
            this._browserName = "safari";
          }
        } else if( userAgent.indexOf( "OmniWeb" ) != -1 ) {
          this._browserName = "omniweb";
        } else if( userAgent.indexOf( "Shiira" ) != -1 ) {
          this._browserName = "shiira";
        } else if( userAgent.indexOf( "NetNewsWire" ) != -1 ) {
          this._browserName = "netnewswire";
        } else if( userAgent.indexOf( "RealPlayer" ) != -1 ) {
          this._browserName = "realplayer";
        } else if( userAgent.indexOf( "Mobile" ) != -1 ) {
          // iPad reports this in fullscreen mode
          this._browserName = "safari";
        } else {
          this._browserName = "other webkit";
        }
      }
    }
  },

  _initGecko : function() {
    if( !this._isBrowserDetected() ) {
      var userAgent = navigator.userAgent;
      var isGecko =    userAgent.indexOf( "like Gecko" ) === -1
                    && userAgent.indexOf( "Gecko/" ) !== -1
                    && /rv\:([^\);]+)(\)|;)/.test( userAgent );
      if( isGecko ) {
        // http://www.mozilla.org/docs/dom/domref/dom_window_ref13.html
        this._engineName = "gecko";
        this._parseVersion( RegExp.$1 );
        if( userAgent.indexOf( "Firefox" ) != -1) {
          this._browserName = "firefox";
        } else if ( userAgent.indexOf( "Camino" ) != -1) {
          this._browserName = "camino";
        } else if ( userAgent.indexOf( "Galeon" ) != -1) {
          this._browserName = "galeon";
        } else {
          this._browserName = "other gecko";
        }
      }
    }
  },

  _initTrident : function() {
    if( !this._isBrowserDetected() ) {
      var userAgent = navigator.userAgent;
      if( /MSIE\s+([^\);]+)(\)|;)/.test( userAgent ) ) {
        this._parseVersion( RegExp.$1 );
        this._engineName = "trident";
        this._browserName = "explorer";
      } else if( userAgent.indexOf( "Trident" ) != -1 && /rv\:([^\);]+)(\)|;)/.test( userAgent ) ) {
        this._parseVersion( RegExp.$1 );
        this._engineName = "trident";
        this._browserName = "explorer";
      } else if( /Edge\/([^ ]+)/.test( userAgent ) ) {
        this._parseVersion( RegExp.$1 );
        this._engineName = "trident";
        this._browserName = "edge";
      }
    }
  },

  _isBrowserDetected : function() {
    return this._engineName !== "unknown";
  },

  _parseVersion : function( versionStr ) {
    if( typeof versionStr === "string" ) {
      var versionArr = versionStr.split( "." );
      this._engineVersion = parseFloat( versionStr );
      this._engineVersionMajor = parseInt( versionArr[ 0 ] || 0, 10 );
      this._engineVersionMinor = parseFloat( versionArr[ 1 ] || 0 );
      this._engineVersionRevision = parseFloat( versionArr[ 2 ] || 0 );
      this._engineVersionBuild = parseInt( versionArr[ 3 ] || 0, 10 );
    }
  },

  _initBoxSizing : function() {
    var vEngineBoxSizingAttr = [];
    switch( this._engineName ) {
      case "gecko":
        vEngineBoxSizingAttr.push( "-moz-box-sizing" );
      break;
      case "webkit":
      case "blink":
        vEngineBoxSizingAttr.push( "-khtml-box-sizing" );
        vEngineBoxSizingAttr.push( "-webkit-box-sizing" );
      break;
      default:
        vEngineBoxSizingAttr.push( "box-sizing" );
    }
    this._engineBoxSizingAttributes = vEngineBoxSizingAttr;
  },

  _initLocale : function() {
    var language =   ( this._engineName === "trident" )
                   ? navigator.userLanguage
                   : navigator.language;
    var browserLocale = language.toLowerCase();
    var browserLocaleVariantIndex = browserLocale.indexOf( "-" );
    if( browserLocaleVariantIndex != -1 ) {
      browserLocale = browserLocale.substr( 0, browserLocaleVariantIndex );
    }
    this._browserLocale = browserLocale;
  },

  _initPlatform : function() {
    var platformStr = navigator.platform;
    if(    platformStr.indexOf( "Windows" ) != -1
        || platformStr.indexOf( "Win32" ) != -1
        || platformStr.indexOf( "Win64" ) != -1 )
    {
      this._browserPlatform = "win";
    } else if(    platformStr.indexOf( "Macintosh" ) != -1
               || platformStr.indexOf( "MacPPC" ) != -1
               || platformStr.indexOf( "MacIntel" ) != -1 )
    {
      this._browserPlatform = "mac";
    } else if(   platformStr.indexOf( "X11" ) != -1
              || platformStr.indexOf( "Linux" ) != -1
              || platformStr.indexOf( "BSD" ) != -1 )
    {
      if( navigator.userAgent.indexOf( "Android" ) != -1 ) {
        this._browserPlatform = "android";
      } else {
        this._browserPlatform = "unix";
      }
    } else if(    platformStr.indexOf( "iPhone" ) != -1
               || platformStr.indexOf( "iPod" ) != -1
               || platformStr.indexOf( "iPad" ) != -1 )
    {
      this._browserPlatform = "ios";
    } else {
      this._browserPlatform = "other";
    }
  }

};

rwt.client.Client.__init();
rwt.util.Variant.define( "qx.client", rwt.client.Client.getEngine() );

/*******************************************************************************
 * Copyright (c) 2004, 2014 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource, and others.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

/*global alert:false */

namespace( "rwt.qx" );

/**
 * Each instance of a class defined by {@link #define} has the following keys attached to the
 * constructor and the prototype:
 *
 * - classname - The fully-qualified name of the class (e.g. <code>"qx.ui.core.Widget"</code>)
 * - basename - The namespace part of the class name (e.g. <code>"qx.ui.core"</code>)
 * - constructor - A reference to the constructor of the class
 * - superclass - A reference to the constructor of the super class
 *
 * Each method may access static members of the same class by using `this.self(arguments)`
 * ({@link rwt.qx.Object#self}):
 * <pre class='javascript'>
 * statics : { FOO : "bar" },
 * members: {
 *   baz: function(x) {
 *     this.self(arguments).FOO;
 *     ...
 *   }
 * }
 * </pre>
 *
 * Each overriding method may call the overridden method by using
 * <code>this.base(arguments [, ...])</code> ({@link rwt.qx.Object#base}). This is also true for
 * calling the constructor of the superclass.
 * <pre class='javascript'>
 * members: {
 *   foo: function(x) {
 *     this.base(arguments, x);
 *     ...
 *   }
 * }
 * </pre>
 */
rwt.qx.Class = {

  _normalizeConfig : function( config ) {
    if( !config ) {
      config = {};
    }
    if( config.include && !( config.include instanceof Array ) ) {
      config.include = [ config.include ];
    }
    return config;
  },

  /**
   * Define a new class using the qooxdoo class system. This sets up the
   * namespace for the class and generates the class from the definition map.
   *
   * Example:
   * <pre class='javascript'>
   * rwt.qx.Class.define( "name", {
   *   extend : Object, // superclass
   *   include : [Mixins],
   *
   *   statics: {
   *     CONSTANT : 3.141,
   *
   *     publicMethod: function() {},
   *     _protectedMethod: function() {},
   *     __privateMethod: function() {}
   *   },
   *
   *   properties: {
   *     "tabIndexOld": { type: "number", defaultValue : -1 }
   *     "tabIndex": { check: "Number", init : -1 }
   *   },
   *
   *   members: {
   *     publicField: "foo",
   *     publicMethod: function() {},
   *
   *     _protectedField: "bar",
   *     _protectedMethod: function() {},
   *
   *     __privateField: "baz",
   *     __privateMethod: function() {}
   *   }
   * } );
   * </pre>
   *
   * @param name {String} Name of the class
   * @param config {Map ? null} Class definition structure. The configuration map has the
   *   following keys:
   *   - extend {Class}: The super class the current class inherits from.
   *   - include {Mixin | Mixin[]}: Single mixin or array of mixins, which will be merged into the
   *     class.
   *   - construct {Function} The constructor of the class.
   *   - statics {Map} Map of static members of the class.
   *   - properties {Map} Map of property definitions. For a description of the format of a
   *     property definition see {@link rwt.qx.Property}
   *   - members {Map}: Map of instance members of the class.
   *   - events {Map}: Map of events the class fires. The keys are the names of the events and the
   *     values are the corresponding event type class names.
   *   - defer {Function}: Function that is called at the end of processing the class
   *     declaration. It allows access to the declared statics, members and properties.
   *   - destruct {Function}: The destructor of the class.
   */
  define : function( name, config ) {
    if( this._stopLoading ) {
      throw new Error( "Stop loading " + name );
    }
    try {
      config = this._normalizeConfig( config );
      var clazz;
      if( !config.extend ) {
        clazz = config.statics || {};
      } else {
        if( !config.construct ) {
          config.construct = this.__createDefaultConstructor();
        }
        clazz = this.__wrapConstructor( config.construct, name );
        if( config.statics ) {
          var key;
          for( var i = 0, a = rwt.util.Objects.getKeys( config.statics ), l = a.length; i < l; i++ ) {
            key = a[ i ];
            clazz[ key ] = config.statics[ key ];
          }
        }
      }
      var basename = rwt.define( name, clazz, false );
      clazz.name = clazz.classname = name;
      clazz.basename = basename;
      this.__registry[ name ] = clazz;

      // Attach toString
      if( !clazz.hasOwnProperty( "toString" ) ) {
        clazz.toString = this.genericToString;
      }

      if( config.extend ) {
        var Helper = function() {};
        Helper.prototype = config.extend.prototype;
        var proto = new Helper();
        clazz.prototype = proto;
        proto.name = proto.classname = name;
        proto.basename = basename;
        config.construct.base = clazz.superclass = config.extend;
        config.construct.self = proto.constructor = clazz;
        if( config.destruct ) {
          clazz.$$destructor = config.destruct;
        }
        var that = this;
        clazz.$$initializer = function() {
          if( config.properties ) {
            that.__addProperties( clazz, config.properties, true );
          }
          if( config.members ) {
            that.__addMembers( clazz, config.members, true, true, false );
          }
          if( config.events ) {
            that.__addEvents( clazz, config.events, true );
          }
          if( config.include ) {
            for( var i = 0, l = config.include.length; i < l; i++ ) {
              that.__addMixin( clazz, config.include[ i ], false );
            }
          }
        };
      }
      if( config.defer ) {
        this.__initializeClass( clazz );
        config.defer.self = clazz;
        config.defer( clazz, clazz.prototype, {
          add : function( name, config ) {
            var properties = {};
            properties[ name ] = config;
            rwt.qx.Class.__addProperties( clazz, properties, true );
          }
        } );
      }
    } catch( ex ) {
      // Use alert here since ErrorHandler.js might not be parsed yet. In case of a class loader
      // error, this is the only way to be sure the user sees the message.
      alert( "Error loading class " + name + ": " + ( ex.message ? ex.message : ex ) );
      this._stopLoading = true;
      throw ex;
    }
  },

  /**
   * Whether the given class exists
   *
   * @param name {String} class name to check
   * @return {Boolean} true if class exists
   */
  isDefined : function( name ) {
    return this.__registry[ name ] !== undefined;
  },

  /**
   * Include all features of the given mixin into the class. The mixin must
   * not include any methods or properties that are already available in the
   * class. This would only be possible using the {@link #patch} method.
   *
   * @param clazz {Class} An existing class which should be modified by including the mixin.
   * @param mixin {Mixin} The mixin to be included.
   */
  include : function( clazz, mixin ) {
    rwt.qx.Class.__addMixin( clazz, mixin, false );
  },

  /**
   * Include all features of the given mixin into the class. The mixin may
   * include features which are already defined in the target class. Existing
   * features of equal name will be overwritten.
   * Please keep in mind that this functionality is not intented for regular
   * use, but as a formalized way (and a last resort) in order to patch
   * existing classes.
   *
   * <b>WARNING</b>: You may break working classes and features.
   *
   * @param clazz {Class} An existing class which should be modified by including the mixin.
   * @param mixin {Mixin} The mixin to be included.
   */
  patch : function( clazz, mixin ) {
    rwt.qx.Class.__addMixin( clazz, mixin, true );
  },

  /**
   * This method will be attached to all classes to return
   * a nice identifier for them.
   *
   * @internal
   * @return {String} The class identifier
   */
  genericToString : function() {
    return "[Class " + this.classname + "]";
  },

  /** Stores all defined classes */
  __registry : {},

  /**
   * Attach events to the class
   *
   * @param clazz {Class} class to add the events to
   * @param events {Map} map of event names the class fires.
   * @param patch {Boolean ? false} Enable redefinition of event type?
   */
  __addEvents : function( clazz, events ) {
    if( clazz.$$events ) {
      for( var key in events ) {
        clazz.$$events[ key ] = events[ key ];
      }
    } else {
      clazz.$$events = events;
    }
  },

  /**
   * Attach properties to classes
   *
   * @param clazz {Class} class to add the properties to
   * @param properties {Map} map of properties
   * @param patch {Boolean ? false} Overwrite property with the limitations of a property
   *         which means you are able to refine but not to replace (esp. for new properties)
   */
  __addProperties : function( clazz, properties, patch ) {
    var config;
    if( patch === undefined ) {
      patch = false;
    }
    var attach = !!clazz.$$propertiesAttached;
    for( var name in properties ) {
      config = properties[ name ];

      // Store name into configuration
      config.name = name;

      // Add config to local registry
      if( !config.refine ) {
        if( clazz.$$properties === undefined ) {
          clazz.$$properties = {};
        }
        clazz.$$properties[ name ] = config;
      }

      // Store init value to prototype. This makes it possible to
      // overwrite this value in derived classes.
      if( config.init !== undefined ) {
        clazz.prototype[ "__init$" + name ] = config.init;
      }

      // register event name
      if( config.event !== undefined ) {
        var event = {};
        event[ config.event ] = "rwt.event.ChangeEvent";
        this.__addEvents( clazz, event, patch );
      }

      // Remember inheritable properties
      if( config.inheritable ) {
        rwt.qx.Property.$$inheritable[ name ] = true;
      }

      // If instances of this class were already created, we
      // need to attach the new style properties functions, directly.
      if( attach ) {
        rwt.qx.Property.attachMethods( clazz, name, config );
      }

      // Create old style properties
      if( config._fast ) {
        rwt.qx.LegacyProperty.addFastProperty( config, clazz.prototype );
      } else if( config._cached ) {
        rwt.qx.LegacyProperty.addCachedProperty( config, clazz.prototype );
      }
    }
  },

  /**
   * Attach members to a class
   *
   * @param clazz {Class} clazz to add members to
   * @param members {Map} The map of members to attach
   * @param patch {Boolean ? false} Enable patching of
   * @param base (Boolean ? true) Attach base flag to mark function as members
   *     of this class
   * @param wrap {Boolean ? false} Whether the member method should be wrapped.
   *     this is needed to allow base calls in patched mixin members.
   */
  __addMembers : function( clazz, members, patch, base, wrap ) {
    var proto = clazz.prototype;
    var key, member;
    for( var i = 0, a = rwt.util.Objects.getKeys( members ), l = a.length; i < l; i++ ) {
      key = a[ i ];
      member = members[ key ];
      // Added helper stuff to functions
      // Hint: Could not use typeof function because RegExp objects are functions, too
      if( base !== false && member instanceof Function ) {
        if( wrap === true ) {
          // wrap "patched" mixin member
          member = this.__mixinMemberWrapper( member, proto[ key ] );
        } else {
          // Configure extend (named base here)
          // Hint: proto[key] is not yet overwritten here
          if( proto[ key ] ) {
            member.base = proto[ key ];
          }
          member.self = clazz;
        }
      }
      // Attach member
      proto[ key ] = member;
    }
  },

  /**
   * Wraps a member function of a mixin, which is included using "patch". This
   * allows "base" calls in the mixin member function.
   *
   * @param member {Function} The mixin method to wrap
   * @param base {Function} The overwritten method
   * @return {Function} the wrapped mixin member
   */
  __mixinMemberWrapper : function( member, base ) {
    if( base ) {
      return function() {
        var oldBase = member.base;
        member.base = base;
        var retval = member.apply( this, arguments );
        member.base = oldBase;
        return retval;
      };
    } else {
      return member;
    }
  },

  /**
   * Include all features of the mixin into the given class (recursive).
   *
   * @param clazz {Class} A class previously defined where the mixin should be attached.
   * @param mixin {Mixin} Include all features of this mixin
   * @param patch {Boolean} Overwrite existing fields, functions and properties
   */
  __addMixin : function( clazz, mixin, patch ) {
    if( mixin.$$properties ) {
      this.__addProperties( clazz, mixin.$$properties, patch );
    }
    if( mixin.$$members ) {
      this.__addMembers( clazz, mixin.$$members, patch, patch, patch );
    }
    if( clazz.$$includes ) {
      clazz.$$includes.push( mixin );
    } else {
      clazz.$$includes = [ mixin ];
    }
  },

  /**
   * Returns the default constructor.
   * This constructor just calles the constructor of the base class.
   *
   * @return {Function} The default constructor.
   */
  __createDefaultConstructor : function() {
    function defaultConstructor() {
      arguments.callee.base.apply( this, arguments );
    }
    return defaultConstructor;
  },

  __initializeClass : function( clazz ) {
    if( clazz.$$initializer ) {
      var inits = [];
      var target = clazz;
      while( target.$$initializer ) {
        inits.push( target );
        target = target.superclass;
      }
      while( inits.length > 0 ) {
        target = inits.pop();
        target.$$initializer();
        delete target.$$initializer;
      }
    }
  },

  /**
   * Generate a wrapper of the original class constructor in order to enable
   * some of the advanced OO features (e.g. abstract class, singleton, mixins)
   *
   * @param original {Function} the original constructor
   * @param name {String} name of the class
   */
  __wrapConstructor : function( original ) {
    return function() {
      var clazz = arguments.callee; // i.e. "wrapper"
      rwt.qx.Class.__initializeClass( clazz );
      if( !clazz.$$propertiesAttached ) {
        rwt.qx.Property.attach( clazz );
      }
      original.apply( this, arguments );
      if( clazz.$$includes ) {
        for( var i = 0, l = clazz.$$includes.length; i < l; i++ ) {
          if( clazz.$$includes[ i ].$$constructor ) {
            clazz.$$includes[ i ].$$constructor.apply( this, arguments );
          }
        }
      }
    };
  }

};

/*******************************************************************************
 * Copyright (c) 2004, 2014 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource, and others.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/


/**
 * This class is used to define mixins (similar to mixins in Ruby).
 *
 * Mixins are collections of code and variables, which can be merged into
 * other classes. They are similar to classes but don't support inheritance.
 *
 * See the description of the {@link #define} method how a mixin is defined.
 */
rwt.qx.Class.define( "rwt.qx.Mixin", {

  statics : {

    /**
     * Defines a new mixin.
     *
     * @param name {String} name of the mixin
     * @param config {Map} Mixin definition structure. The configuration map has the
     *   following keys:
     *   - construct {Function} An optional mixin constructor. It is called on instantiation each
     *         class including this mixin. The constructor takes no parameters.
     *   - destruct {Function} An optional mixin destructor.
     *   - include {Mixin[]} Array of mixins, which will be merged into the mixin.
     *   - statics {Map} Map of statics of the mixin. The statics will not get copied into the
     *         target class. They remain acceccible from the mixin. This is the same behaviour as
     *         statics in interfaces ({@link qx.Interface#define}).
     *   - members {Map} Map of members of the mixin.
     *   - properties {Map} Map of property definitions.
     */
    define : function( name, config ) {
      var mixin = config.statics ? config.statics : {};
      mixin.$$constructor = config.construct;
      mixin.$$properties = config.properties;
      mixin.$$members = config.members;
      mixin.$$destructor = config.destruct;
      mixin.$$type = "Mixin";
      mixin.name = name;
      mixin.toString = this.genericToString;
      rwt.define( name, mixin );
    },


    /**
     * This method will be attached to all mixins to return
     * a nice identifier for them.
     *
     * @internal
     * @return {String} The mixin identifier
     */
    genericToString : function() {
      return "[Mixin " + this.name + "]";
    }


  }

} );

/*******************************************************************************
 * Copyright (c) 2004, 2014 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource, and others.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/


/**
 * Internal class for handling dynamic properties.
 *
 * WARNING: This is a legacy class to support the old-style dynamic properties
 * in 0.6.x. Its much improved successor is {@link rwt.qx.Property}.
 *
 * @deprecated This class is supposed to be removed in qooxdoo 0.7
 */
/*jshint boss: true */
rwt.qx.Class.define( "rwt.qx.LegacyProperty", {

  statics : {

    /**
     * Adds a so-named fast property to a prototype.
     *
     * config fields:
     * - name
     * - defaultValue
     * - noCompute
     * - setOnlyOnce
     *
     * @param config {Map} Configuration structure
     * @param proto {Object} Prototype where the methods should be attached
     */
    addFastProperty : function( config, proto ) {
      var vName = config.name;
      var vUpName = rwt.util.Strings.toFirstUp( vName );
      var vStorageField = "_value" + vUpName;
      var vGetterName = "get" + vUpName;
      var vSetterName = "set" + vUpName;
      var vComputerName = "_compute" + vUpName;
      proto[ vStorageField ] = typeof config.defaultValue !== "undefined" ? config.defaultValue
                                                                          : null;
      if( config.noCompute ) {
        proto[ vGetterName ] = function() {
          return this[ vStorageField ];
        };
      } else {
        proto[ vGetterName ] = function() {
          return this[ vStorageField ] == null ? this[ vStorageField ] = this[ vComputerName ]()
                                               : this[ vStorageField ];
        };
      }
      proto[ vGetterName ].self = proto.constructor;
      if( config.setOnlyOnce ) {
        proto[ vSetterName ] = function( vValue ) {
          this[ vStorageField ] = vValue;
          this[ vSetterName ] = null;
          return vValue;
        };
      } else {
        proto[ vSetterName ] = function( vValue ) {
          return this[ vStorageField ] = vValue;
        };
      }
      proto[ vSetterName ].self = proto.constructor;
      if( !config.noCompute ) {
        proto[ vComputerName ] = function() {
          return null;
        };
        proto[ vComputerName ].self = proto.constructor;
      }
    },

    /**
     * Adds a so-named cached property to a prototype.
     *
     * config fields:
     * - name
     * - defaultValue
     * - addToQueueRuntime
     *
     * @param config {Map} Configuration structure
     * @param proto {Object} Prototype where the methods should be attached
     */
    addCachedProperty : function( config, proto ) {
      var vName = config.name;
      var vUpName = rwt.util.Strings.toFirstUp( vName );
      var vStorageField = "_cached" + vUpName;
      var vComputerName = "_compute" + vUpName;
      var vChangeName = "_change" + vUpName;
      if( typeof config.defaultValue !== "undefined" ) {
        proto[ vStorageField ] = config.defaultValue;
      }
      proto[ "get" + vUpName ] = function() {
        if( this[ vStorageField ] == null ) {
          this[ vStorageField ] = this[ vComputerName ]();
        }
        return this[ vStorageField ];
      };
      proto[ "_invalidate" + vUpName ] = function() {
        if( this[ vStorageField ] != null ) {
          this[ vStorageField ] = null;
          if( config.addToQueueRuntime ) {
            this.addToQueueRuntime( config.name );
          }
        }
      };
      proto[ "_recompute" + vUpName ] = function() {
        var vOld = this[ vStorageField ];
        var vNew = this[ vComputerName ]();
        if( vNew != vOld ) {
          this[ vStorageField ] = vNew;
          this[ vChangeName ]( vNew, vOld );
          return true;
        }
        return false;
      };
      proto[ vChangeName ] = function( /* vNew, vOld */ ) {};
      proto[ vComputerName ] = function() {
        return null;
      };
      proto[ "get" + vUpName ].self = proto.constructor;
      proto[ "_invalidate" + vUpName ].self = proto.constructor;
      proto[ "_recompute" + vUpName ].self = proto.constructor;
    }

  }

} );

/*******************************************************************************
 * Copyright (c) 2004, 2014 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource, and others.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/


/**
 * Internal class for handling of dynamic properties. Should only be used
 * through the methods provided by {@link rwt.qx.Class}.
 *
 * For a complete documentation of properties take a
 * look at http://qooxdoo.org/documentation/developer_manual/properties.
 *
 *
 * *Normal properties*
 *
 * The <code>properties</code> key in the class definition map of {@link rwt.qx.Class#define}
 * is used to generate the properties.
 *
 * Valid keys of a property definition are:
 *
 * - check {Array, String, Function}
 *   The check is used to validate the incoming value of a property. The check can be:
 *   - a custom check function. The function takes the incoming value as a parameter and must
 *     return a boolean value to indicate whether the values is valid.
 *   - inline check code as a string e.g. <code>"value &gt; 0 && value &lt; 100"</code>
 *   - a class name e.g. <code>rwt.widgets.Button</code>
 *   - a name of an interface the value must implement, e.g. <code>qx.application.IAplpication</code>
 *   - an array of all valid values</li>
 *   - one of the predefined checks: Boolean, String, Number, Integer, Float, Double,
 *     Object, Array, Map, Class, Mixin, Interface, Theme, Error, RegExp, Function,
 *     Date, Node, Element, Document, Window, Event
 * - init {var}
 *   Sets the default/initial value of the property. If no property value is set or the property
 *   gets reset, the getter will return the <code>init</code> value.
 * - apply {String}
 *   On change of the property value the method of the specified name will be called. The
 *   signature of the method is <code>function(newValue, oldValue)</code>.
 * - event {String}
 *   On change of the property value an event with the given name will be dispached. The event
 *   type is {@link rwt.event.ChangeEvent}.
 * - themeable {Boolean}
 *   Whether this property can be set using themes.
 * - inheritable {Boolean}
 *   Whether the property value should be inheritable. If the property does not have a user
 *   defined or an init value, the property will try to get the value from the parent of the
 *   current object.
 * - nullable {Boolean}
 *   Whether <code>null</code> is an allowed value of the property. This is complemental to the
 *   check defined using the <code>check</code> key.
 * - refine {Boolean}
 *   Whether the property definition is a refinemnet of a property in one of the super classes of
 *   the class. Only the <code>init</code> value can be changed using refine.
 * - transform {String}
 *   On setting of the property value the method of the specified name will
 *   be called. The signature of the method is <code>function(value)</code>.
 *   The parameter <code>value</code> is the value passed to the setter.
 *   The function must return the modified or unmodified value.
 *   Transformation occurs before the check function, so both may be
 *   specified if desired.  Alternatively, the transform function may throw
 *   an error if the value passed to it is invalid.
 *
 * Property groups
 * ---------------
 *
 * Property groups are defined in a similar way but support a different set of keys:
 *
 * - group {String[]}
 *   A list of property names which should be set using the propery group.
 * - mode {String}
 *   If mode is set to <code>"shorthand"</code>, the properties can be set using a CSS like
 *   shorthand mode.
 * - themeable {Boolean}
 *   Whether this property can be set using themes.
 */
rwt.qx.Class.define( "rwt.qx.Property", {

  statics : {

    /**
     * Built-in checks
     * The keys could be used in the check of the properties
     */
    __checks : {
      "Boolean"   : 'typeof value === "boolean"',
      "String"    : 'typeof value === "string"',
      "NonEmptyString" : 'typeof value === "string" && value.length > 0',

      "Number"    : 'typeof value === "number" && isFinite(value)',
      "Integer"   : 'typeof value === "number" && isFinite(value) && value%1 === 0',
      "Float"     : 'typeof value === "number" && isFinite(value)',
      "Double"    : 'typeof value === "number" && isFinite(value)',

      "Error"     : 'value instanceof Error',
      "RegExp"    : 'value instanceof RegExp',

      "Object"    : 'value !== null && typeof value === "object"',
      "Array"     : 'value instanceof Array',
      "Map"       : 'value !== null && typeof value === "object" && !(value instanceof Array) && !(value instanceof rwt.qx.Object)',

      "Function"  : 'value instanceof Function',
      "Date"      : 'value instanceof Date',
      "Node"      : 'value !== null && value.nodeType !== undefined',
      "Element"   : 'value !== null && value.nodeType === 1 && value.attributes',
      "Document"  : 'value !== null && value.nodeType === 9 && value.documentElement',
      "Window"    : 'value !== null && window.document',
      "Event"     : 'value !== null && value.type !== undefined',

      "Class"     : 'value !== null && value.$$type === "Class"',
      "Mixin"     : 'value !== null && value.$$type === "Mixin"',
      "Interface" : 'value !== null && value.$$type === "Interface"',
      "Theme"     : 'value !== null && value.$$type === "Theme"',

      "Color"     : 'typeof value === "string" && rwt.util.Colors.isValid(value)',
      "Border"    : 'value !== null',
      "Font"      : 'value !== null',
      "Label"     : 'value !== null && typeof value === "string"'
    },

    /**
     * Contains types from {@link #__checks} list which need to be disposed
     */
    __dispose : {
      "Object"    : true,
      "Array"     : true,
      "Map"       : true,
      "Function"  : true,
      "Date"      : true,
      "Node"      : true,
      "Element"   : true,
      "Document"  : true,
      "Window"    : true,
      "Event"     : true,
      "Class"     : true,
      "Mixin"     : true,
      "Interface" : true,
      "Theme"     : true,
      "Border"    : true,
      "Font"      : true
    },

    /**
     * Inherit value, used to override defaults etc. to force inheritance
     * even if property value is not undefined (through multi-values)
     */
    $$inherit : "inherit",

    /**
     * Used in build version for storage names
     */
    $$idcounter : 0,

    /**
     * Caching field names for each property created
     */
    $$store : {
      user : {},
      theme : {},
      inherit : {},
      init : {},
      useinit : {}
    },

    /**
     * Caching function names for each property created
     */
    $$method : {
      get : {},
      set : {},
      reset : {},
      init : {},
      refresh : {},
      style : {},
      unstyle : {}
    },

    /**
     * Supported keys for property defintions
     */
    $$allowedKeys : {
      name         : "string",   // String
      dispose     : "boolean",  // Boolean
      inheritable : "boolean",  // Boolean
      nullable    : "boolean",  // Boolean
      themeable   : "boolean",  // Boolean
      refine      : "boolean",  // Boolean
      init        : null,       // var
      apply       : "string",   // String
      event       : "string",   // String
      check       : null,       // Array, String, Function
      transform   : "string",   // String
      deferredInit : "boolean"   // Boolean
    },

    $$allowedGroupKeys : {
      name       : "string",   // String
      group      : "object",   // Array
      mode       : "string",   // String
      themeable  : "boolean"   // Boolean
    },

    /** Contains names of inheritable properties, filled by {@link rwt.qx.Class.define} */
    $$inheritable : {},

    /**
     * Refreshes widget whose parent has changed (including the children)
     *
     * @param widget {rwt.widgets.base.Widget} the widget
     */
    refresh : function( widget ) {
      var parent = widget.getParent();
      if( parent ) {
        var clazz = widget.constructor;
        var inherit = this.$$store.inherit;
        var refresh = this.$$method.refresh;
        var properties;
        while( clazz ) {
          properties = clazz.$$properties;
          if( properties ) {
            for( var name in this.$$inheritable ) {
              // Whether the property is available in this class
              // and whether it is inheritable in this class as well
              if( properties[name] && widget[refresh[name]] ) {
                widget[refresh[name]]( parent[inherit[name]] );
              }
            }
          }
          clazz = clazz.superclass;
        }
      }
    },

    /**
     * Attach properties to class prototype
     *
     * @param clazz {Class} Class to attach properties to
     */
    attach : function( clazz ) {
      var properties = clazz.$$properties;
      if( properties ) {
        for( var name in properties ) {
          this.attachMethods( clazz, name, properties[ name ] );
        }
      }
      clazz.$$propertiesAttached = true;
    },

    /**
     * Attach one property to class
     *
     * @param clazz {Class} Class to attach properties to
     * @param name {String} Name of property
     * @param config {Map} Configuration map of property
     */
    attachMethods : function( clazz, name, config ) {
      // Filter old properties
      if( config._fast || config._cached ) {
        return;
      }

      // Generate property method prefixes and postfixes
      var prefix, postfix;

      if( name.charAt(0) === "_" ) {
        if( name.charAt(1) === "_" ) {
          prefix = "__";
          postfix = rwt.util.Strings.toFirstUp(name.substring(2));
        } else {
          prefix = "_";
          postfix = rwt.util.Strings.toFirstUp(name.substring(1));
        }
      } else {
        prefix = "";
        postfix = rwt.util.Strings.toFirstUp(name);
      }

      // Attach methods
      if( config.group ) {
        this.__attachGroupMethods( clazz, config, prefix, postfix );
      } else {
        this.__attachPropertyMethods( clazz, config, prefix, postfix );
      }
    },

    /**
     * Attach group methods
     *
     * @param clazz {Class} Class to attach properties to
     * @param config {Map} Property configuration
     * @param prefix {String} Prefix of property e.g. "__" or "_" for private or protected properties
     * @param postfix {String} Camelcase name of property e.g. name=width => postfix=Width
     */
    __attachGroupMethods : function( clazz, config, prefix, postfix ) {
      var members = clazz.prototype;
      var name = config.name;
      var themeable = config.themeable === true;

      var setter = [];
      var resetter = [];

      if( themeable ) {
        var styler = [];
        var unstyler = [];
      }

      var argHandler = "var a=arguments[0] instanceof Array?arguments[0]:arguments;";

      setter.push( argHandler );

      if( themeable ) {
        styler.push( argHandler );
      }

      if( config.mode == "shorthand" ) {
        var shorthand = "a=rwt.util.Arrays.fromShortHand(rwt.util.Arrays.fromArguments(a));";
        setter.push( shorthand );

        if( themeable ) {
          styler.push( shorthand );
        }
      }

      for( var i = 0, a = config.group, l = a.length; i < l; i++ ) {
        if( rwt.util.Variant.isSet( "qx.debug", "on" ) ) {
          if( !this.$$method.set[ a[ i ] ] || !this.$$method.reset[ a[ i ] ] ) {
            throw new Error( "Cannot create property group '" + name + "' including non-existing property '" + a[ i ] + "'!" );
          }
        }

        setter.push( "this.", this.$$method.set[a[i]], "(a[", i, "]);" );
        resetter.push( "this.", this.$$method.reset[a[i]], "();" );

        if( themeable ) {
          if( rwt.util.Variant.isSet( "qx.debug", "on" ) ) {
            if( !this.$$method.style[a[i]] ) {
              throw new Error( "Cannot add the non themable property '" + a[i] + "' to the themable property group '"+ name +"'" );
            }
          }
          styler.push("this.", this.$$method.style[a[i]], "(a[", i, "]);" );
          unstyler.push("this.", this.$$method.unstyle[a[i]], "();" );
        }
      }

      // Attach setter
      this.$$method.set[name] = prefix + "set" + postfix;
      members[this.$$method.set[name]] = new Function( setter.join( "" ) );

      // Attach resetter
      this.$$method.reset[name] = prefix + "reset" + postfix;
      members[this.$$method.reset[name]] = new Function( resetter.join( "" ) );

      if( themeable ) {
        // Attach styler
        this.$$method.style[name] = prefix + "style" + postfix;
        members[this.$$method.style[name]] = new Function( styler.join( "" ) );

        // Attach unstyler
        this.$$method.unstyle[name] = prefix + "unstyle" + postfix;
        members[this.$$method.unstyle[name]] = new Function( unstyler.join( "" ) );
      }
    },

    /**
     * Attach property methods
     *
     * @param clazz {Class} Class to attach properties to
     * @param config {Map} Property configuration
     * @param prefix {String} Prefix of property e.g. "__" or "_" for private or protected properties
     * @param postfix {String} Camelcase name of property e.g. name=width => postfix=Width
     */
    __attachPropertyMethods : function( clazz, config, prefix, postfix ) {
      var members = clazz.prototype;
      var name = config.name;

      // Fill dispose value
      if( config.dispose === undefined && typeof config.check === "string" ) {
        config.dispose = this.__dispose[ config.check ] || rwt.qx.Class.isDefined( config.check );
      }

      var method = this.$$method;
      var store = this.$$store;

      store.user[ name ] = "__user$" + name;
      store.theme[ name ] = "__theme$" + name;
      store.init[ name ] = "__init$" + name;
      store.inherit[ name ] = "__inherit$" + name;
      store.useinit[ name ] = "__useinit$" + name;

      method.get[name] = prefix + "get" + postfix;
      members[method.get[name]] = function() {
        return rwt.qx.Property.executeOptimizedGetter( this, clazz, name, "get" );
      };

      method.set[name] = prefix + "set" + postfix;
      members[method.set[name]] = function() {
        return rwt.qx.Property.executeOptimizedSetter( this, clazz, name, "set", arguments );
      };

      method.reset[name] = prefix + "reset" + postfix;
      members[method.reset[name]] = function() {
        return rwt.qx.Property.executeOptimizedSetter( this, clazz, name, "reset" );
      };

      if( config.inheritable || config.apply || config.event || config.deferredInit ) {
        method.init[name] = prefix + "init" + postfix;
        members[method.init[name]] = function() {
          return rwt.qx.Property.executeOptimizedSetter( this, clazz, name, "init", arguments );
        };
      }

      if( config.inheritable ) {
        method.refresh[name] = prefix + "refresh" + postfix;
        members[method.refresh[name]] = function() {
          return rwt.qx.Property.executeOptimizedSetter( this, clazz, name, "refresh", arguments );
        };
      }

      if( config.themeable ) {
        method.style[name] = prefix + "style" + postfix;
        members[method.style[name]] = function() {
          return rwt.qx.Property.executeOptimizedSetter( this, clazz, name, "style", arguments );
        };

        method.unstyle[name] = prefix + "unstyle" + postfix;
        members[method.unstyle[name]] = function() {
          return rwt.qx.Property.executeOptimizedSetter( this, clazz, name, "unstyle" );
        };
      }

      if( config.check === "Boolean" ) {
        members[prefix + "toggle" + postfix] = new Function("return this." + method.set[name] + "(!this." + method.get[name] + "())");
        members[prefix + "is" + postfix] = new Function("return this." + method.get[name] + "()");
      }
    },

    /** {Map} Internal data field for error messages used by {@link #error} */
    __errors : {
      0 : 'Could not change or apply init value after constructing phase!',
      1 : 'Requires exactly one argument!',
      2 : 'Undefined value is not allowed!',
      3 : 'Does not allow any arguments!',
      4 : 'Null value is not allowed!',
      5 : 'Is invalid!'
    },

    /**
     * Error method used by the property system to report errors.
     *
     * @param obj {rwt.qx.Object} Any qooxdoo object
     * @param id {Integer} Numeric error identifier
     * @param property {String} Name of the property
     * @param variant {String} Name of the method variant e.g. "set", "reset", ...
     * @param value {var} Incoming value
     */
    error : function( obj, id, property, variant, value ) {
      var classname = obj.constructor.classname;
      var msg = "Error in property " + property + " of class " + classname + " in method " + this.$$method[variant][property] + " with incoming value '" + value + "': ";

      // Additional object error before throwing exception because gecko
      // often has issues to throw the error correctly in the debug console otherwise

      throw new Error( msg + ( this.__errors[id] || "Unknown reason: " + id ) );
    },

    /**
     * Compiles a string builder object to a function, executes the function and
     * returns the return value.
     *
     * @param instance {Object} Instance which have called the original method
     * @param members {Object} Prototype members map where the new function should be stored
     * @param name {String} Name of the property
     * @param variant {String} Function variant e.g. get, set, reset, ...
     * @param code {Array} Array which contains the code
     * @param args {arguments} Incoming arguments of wrapper method
     * @return {var} Return value of the generated function
     */
    __unwrapFunctionFromCode : function(instance, members, name, variant, code, args ) {
      var store = this.$$method[variant][name];

      // Output generate code
      if( rwt.util.Variant.isSet( "qx.debug", "on" ) ) {

        // Overriding temporary wrapper
        try{
          members[store] = new Function( "value", code.join( "" ) );
          // eval("members[store] = function " + instance.classname.replace(/\./g, "_") + "$" + store + "(value) { " + code.join("") + "}");
        } catch( ex ) {
          throw new Error( "Malformed generated code to unwrap method: " + this.$$method[variant][name] + "\n" + code.join( "" ) );
        }
      }
      else {
        members[store] = new Function("value", code.join(""));
        // eval("members[store] = function " + instance.classname.replace(/\./g, "_") + "$" + store + "(value) { " + code.join("") + "}");
      }

      // Executing new function
      if( args === undefined ) {
        return instance[store]();
      } else if( rwt.util.Variant.isSet( "qx.debug", "on" ) ) {
        return instance[store].apply( instance, args );
      } else {
        return instance[store]( args[0] );
      }
    },

    /**
     * Generates the optimized getter
     * Supported variants: get
     *
     * @param instance {Object} the instance which calls the method
     * @param clazz {Class} the class which originally defined the property
     * @param name {String} name of the property
     * @param variant {String} Method variant.
     * @return {var} Execute return value of apply generated function, generally the incoming value
     */
    executeOptimizedGetter : function( instance, clazz, name, variant ) {
      var config = clazz.$$properties[name];
      var members = clazz.prototype;
      var code = [];

      if( config.inheritable ) {
        code.push( 'if(this.', this.$$store.inherit[name], '!==undefined)' );
        code.push( 'return this.', this.$$store.inherit[name], ';' );
        code.push( 'else ' );
      }

      code.push( 'if(this.', this.$$store.user[name], '!==undefined)' );
      code.push( 'return this.', this.$$store.user[name], ';' );

      if( config.themeable ) {
        code.push( 'else if(this.', this.$$store.theme[name], '!==undefined)' );
        code.push( 'return this.', this.$$store.theme[name], ';' );
      }

      if( config.deferredInit && config.init === undefined ) {
        code.push( 'else if(this.', this.$$store.init[name], '!==undefined)' );
        code.push( 'return this.', this.$$store.init[name], ';' );
      }

      code.push( 'else ' );

      if( config.init !== undefined ) {
        code.push( 'return this.', this.$$store.init[name], ';' );
      } else if( config.inheritable || config.nullable ) {
        code.push( 'return null;' );
      } else {
        code.push( 'throw new Error("Property ', name, ' of an instance of ', clazz.classname, ' is not (yet) ready!");' );
      }

      return this.__unwrapFunctionFromCode( instance, members, name, variant, code );
    },

    /**
     * Generates the optimized setter
     * Supported variants: set, reset, init, refresh, style, unstyle
     *
     * @param instance {Object} the instance which calls the method
     * @param clazz {Class} the class which originally defined the property
     * @param name {String} name of the property
     * @param variant {String} Method variant.
     * @param args {arguments} Incoming arguments of wrapper method
     * @return {var} Execute return value of apply generated function, generally the incoming value
     */
    executeOptimizedSetter : function( instance, clazz, name, variant, args ) {
      var config = clazz.$$properties[name];
      var members = clazz.prototype;
      var code = [];

      var incomingValue =    variant === "set"
                          || variant === "style"
                          || ( variant === "init" && config.init === undefined );
      var resetValue = variant === "reset" || variant === "unstyle";
      var hasCallback = config.apply || config.event || config.inheritable;
      if( variant === "style" || variant === "unstyle" ) {
        var store = this.$$store.theme[name];
      } else if( variant === "init" ) {
        var store = this.$$store.init[name];
      } else {
        var store = this.$$store.user[name];
      }

      // [1] INTEGRATE ERROR HELPER METHOD

      // [2] PRE CONDITIONS

      if( !config.nullable || config.check || config.inheritable ) {
        code.push( 'var prop=rwt.qx.Property;' );
      }

      // Undefined check
      // TODO [rh] unused: changed as in patch to http://bugzilla.qooxdoo.org/show_bug.cgi?id=599
      if( rwt.util.Variant.isSet( "qx.debug", "on" ) && variant === "set" ) {
        code.push( 'if(value===undefined)prop.error(this,2,"' + name + '","' + variant + '",value);' );
      }

      // [3] PREPROCESSING INCOMING VALUE

      if( incomingValue ) {
        // Call user-provided transform method, if one is provided.  Transform
        // method should either throw an error or return the new value.
        if( config.transform ) {
          code.push( 'value=this.', config.transform, '(value);' );
        }
      }

      // [4] COMPARING (LOCAL) NEW AND OLD VALUE

      // Old/new comparision
      if( hasCallback ) {
        if( incomingValue ) {
          code.push( 'if(this.', store, '===value)return value;' );
        } else if( resetValue ) {
          code.push( 'if(this.', store, '===undefined)return;' );
        }
      }

      // [5] CHECKING VALUE

      if( config.inheritable ) {
        code.push( 'var inherit=prop.$$inherit;' );
      }

      // Generate checks only in debug mode

      // TODO [rh] unused: changed as in patch to http://bugzilla.qooxdoo.org/show_bug.cgi?id=599
      if( incomingValue && rwt.util.Variant.isSet( "qx.debug", "on" ) ) {
        // Null check
        if( !config.nullable ) {
          code.push( 'if(value===null)prop.error(this,4,"'+name+'","'+variant+'",value);' );
        }

        // Processing check definition
        if( config.check !== undefined ) {
          // Accept "null"
          if( config.nullable ) {
            code.push( 'if(value!==null)' );
          }

          // Inheritable properties always accept "inherit" as value
          if( config.inheritable ) {
            code.push( 'if(value!==inherit)' );
          }

          code.push( 'if(' );

          if( this.__checks[config.check] !== undefined ) {
            code.push( '!(', this.__checks[config.check], ')' );
          }
          else if( rwt.qx.Class.isDefined( config.check ) ) {
            code.push( '!(value instanceof ', config.check, ')' );
          }
          else if( typeof config.check === "function" ) {
            code.push( '!', clazz.classname, '.$$properties.', name );
            code.push( '.check.call(this, value)' );
          }
          else if( typeof config.check === "string" ) {
            code.push( '!(', config.check, ')' );
          }
          else if( config.check instanceof Array ) {
            // reconfigure for faster access trough map usage
            config.checkMap = rwt.util.Objects.fromArray(config.check);

            code.push(clazz.classname, '.$$properties.', name);
            code.push( '.checkMap[value]===undefined' );
          }
          else {
            throw new Error( "Could not add check to property " + name + " of class " + clazz.classname );
          }

          code.push( ')prop.error(this,5,"'+name+'","'+variant+'",value);' );
        }
      }

      if( !hasCallback ) {
        if( variant === "set" ) {
          code.push( 'this.', this.$$store.user[name], '=value;' );
        }
        else if( variant === "reset" ) {
          code.push( 'if(this.', this.$$store.user[name], '!==undefined)' );
          code.push( 'delete this.', this.$$store.user[name], ';' );
        }
        // Store incoming value
        else if( variant === "style" ) {
          code.push( 'this.', this.$$store.theme[name], '=value;' );
        }
        else if( variant === "unstyle" ) {
          code.push( 'if(this.', this.$$store.theme[name], '!==undefined)' );
          code.push( 'delete this.', this.$$store.theme[name], ';' );
        }
        else if( variant === "init" && incomingValue ) {
          code.push( 'this.', this.$$store.init[name], '=value;' );
        }
      }
      else {
        if( config.inheritable ) {
          code.push( 'var computed, old=this.', this.$$store.inherit[name], ';' );
        }
        else {
          code.push( 'var computed, old;' );
        }

        // OLD = USER VALUE

        code.push( 'if(this.', this.$$store.user[name], '!==undefined){' );

        if( variant === "set" ) {
          if( !config.inheritable ) {
            // Remember old value
            code.push( 'old=this.', this.$$store.user[name], ';' );
          }

          // Replace it with new value
          code.push( 'computed=this.', this.$$store.user[name], '=value;' );
        }
        else if( variant === "reset" ) {
          if( !config.inheritable ) {
            // Remember old value
            code.push( 'old=this.', this.$$store.user[name], ';' );
          }

          // Delete field
          code.push( 'delete this.', this.$$store.user[name], ';' );

          // Complex compution of new value
          code.push( 'if(this.', this.$$store.theme[name], '!==undefined)' );
          code.push( 'computed=this.', this.$$store.theme[name], ';' );
          code.push( 'else if(this.', this.$$store.init[name], '!==undefined){' );
          code.push( 'computed=this.', this.$$store.init[name], ';' );
          code.push( 'this.', this.$$store.useinit[name], '=true;' );
          code.push( '}' );
        }
        else {
          if( config.inheritable ) {
            // Use user value where it has higher priority
            code.push( 'computed=this.', this.$$store.user[name], ';' );
          }
          else {
            // Use user value where it has higher priority
            code.push( 'old=computed=this.', this.$$store.user[name], ';' );
          }

          // Store incoming value
          if( variant === "style" ) {
            code.push( 'this.', this.$$store.theme[name], '=value;' );
          }
          else if( variant === "unstyle" ) {
            code.push( 'delete this.', this.$$store.theme[name], ';' );
          }
          else if( variant === "init" && incomingValue ) {
            code.push( 'this.', this.$$store.init[name], '=value;' );
          }
        }

        code.push( '}' );

        // OLD = THEMED VALUE

        if( config.themeable ) {
          code.push( 'else if(this.', this.$$store.theme[name], '!==undefined){' );

          if( !config.inheritable ) {
            code.push( 'old=this.', this.$$store.theme[name], ';' );
          }

          if( variant === "set" ) {
            code.push( 'computed=this.', this.$$store.user[name], '=value;' );
          }

          // reset() is impossible, because the user has higher priority than
          // the themed value, so the themed value has no chance to ever get used,
          // when there is a user value, too.

          else if( variant === "style" ) {
            code.push( 'computed=this.', this.$$store.theme[name], '=value;' );
          }
          else if( variant === "unstyle" ) {
            // Delete entry
            code.push( 'delete this.', this.$$store.theme[name], ';' );

            // Fallback to init value
            code.push( 'if(this.', this.$$store.init[name], '!==undefined){' );
            code.push( 'computed=this.', this.$$store.init[name], ';' );
            code.push( 'this.', this.$$store.useinit[name], '=true;' );
            code.push( '}' );
          }
          else if( variant === "init" ) {
            if( incomingValue ) {
              code.push( 'this.', this.$$store.init[name], '=value;' );
            }

            code.push( 'computed=this.', this.$$store.theme[name], ';' );
          }
          else if( variant === "refresh" ) {
            code.push( 'computed=this.', this.$$store.theme[name], ';' );
          }

          code.push( '}' );
        }

        // OLD = INIT VALUE

        code.push( 'else if(this.', this.$$store.useinit[name], '){' );

        if( !config.inheritable ) {
          code.push( 'old=this.', this.$$store.init[name], ';' );
        }

        if( variant === "init" ) {
          if( incomingValue ) {
            code.push( 'computed=this.', this.$$store.init[name], '=value;' );
          } else {
            code.push( 'computed=this.', this.$$store.init[name], ';' );
          }

          // useinit flag is already initialized
        }

        // reset() and unstyle() are impossible, because the user and themed values have a
        // higher priority than the init value, so the themed value has no chance to ever get used,
        // when there is a user or themed value, too.

        else if( variant === "set" || variant === "style" || variant === "refresh" ) {
          code.push( 'delete this.', this.$$store.useinit[name], ';' );

          if( variant === "set" ) {
            code.push( 'computed=this.', this.$$store.user[name], '=value;' );
          } else if( variant === "style" ) {
            code.push( 'computed=this.', this.$$store.theme[name], '=value;' );
          } else if( variant === "refresh" ) {
            code.push( 'computed=this.', this.$$store.init[name], ';' );
          }
        }

        code.push( '}' );

        // OLD = NONE

        // reset() and unstyle() are impossible because otherwise there
        // is already an old value

        if( variant === "set" || variant === "style" || variant === "init" ) {
          code.push( 'else{' );

          if( variant === "set" ) {
            code.push( 'computed=this.', this.$$store.user[name], '=value;' );
          } else if( variant === "style" ) {
            code.push( 'computed=this.', this.$$store.theme[name], '=value;' );
          } else if(  variant === "init" ) {
            if( incomingValue ) {
              code.push( 'computed=this.', this.$$store.init[name], '=value;' );
            } else {
              code.push( 'computed=this.', this.$$store.init[name], ';' );
            }
            code.push( 'this.', this.$$store.useinit[name], '=true;' );
          }
          // refresh() will work with the undefined value, later
          code.push( '}' );
        }
      }

      if( config.inheritable ) {
        code.push( 'if(computed===undefined||computed===inherit){' );

          if( variant === "refresh" ) {
            code.push( 'computed=value;' );
          } else {
            code.push( 'var pa=this.getParent();if(pa)computed=pa.', this.$$store.inherit[name], ';' );
          }

          // Fallback to init value if inheritance was unsuccessful
          code.push( 'if((computed===undefined||computed===inherit)&&' );
          code.push( 'this.', this.$$store.init[name], '!==undefined&&' );
          code.push( 'this.', this.$$store.init[name], '!==inherit){' );
          code.push( 'computed=this.', this.$$store.init[name], ';' );
          code.push( 'this.', this.$$store.useinit[name], '=true;' );
          code.push( '}else{' );
          code.push( 'delete this.', this.$$store.useinit[name], ';}' );

        code.push( '}' );

        // Compare old/new computed value
        code.push( 'if(old===computed)return value;' );

        // Note: At this point computed can be "inherit" or "undefined".

        // Normalize "inherit" to undefined and delete inherited value
        code.push( 'if(computed===inherit){' );
        code.push( 'computed=undefined;delete this.', this.$$store.inherit[name], ';' );
        code.push( '}' );

        // Only delete inherited value
        code.push( 'else if(computed===undefined)' );
        code.push( 'delete this.', this.$$store.inherit[name], ';' );

        // Store inherited value
        code.push( 'else this.', this.$$store.inherit[name], '=computed;' );

        // Protect against normalization
        code.push( 'var backup=computed;' );

        // After storage finally normalize computed and old value
        code.push( 'if(computed===undefined)computed=null;' );
        code.push( 'if(old===undefined)old=null;' );
      }
      else if( hasCallback ) {
        // Properties which are not inheritable have no possiblity to get
        // undefined at this position. (Hint: set() and style() only allow non undefined values)
        if( variant !== "set" && variant !== "style" ) {
          code.push( 'if(computed===undefined)computed=null;' );
        }

        // Compare old/new computed value
        code.push( 'if(old===computed)return value;' );

        // Normalize old value
        code.push( 'if(old===undefined)old=null;' );
      }

      // [12] NOTIFYING DEPENDEND OBJECTS

      if( hasCallback ) {
        // Execute user configured setter
        if( config.apply ) {
          code.push( 'this.', config.apply, '(computed, old);' );
        }

        // Fire event
        if( config.event ) {
          code.push( 'this.createDispatchChangeEvent("', config.event, '", computed, old);' );
        }

        // Refresh children
        // Require the parent/children interface
        if( config.inheritable && members.getChildren ) {
          code.push( 'var a=this.getChildren();if(a)for(var i=0,l=a.length;i<l;i++){' );
          code.push( 'if(a[i].', this.$$method.refresh[name], ')a[i].', this.$$method.refresh[name], '(backup);' );
          code.push( '}' );
        }
      }

      // [13] RETURNING WITH ORIGINAL INCOMING VALUE

      // Return value
      if( incomingValue ) {
        code.push( 'return value;' );
      }

      return this.__unwrapFunctionFromCode( instance, members, name, variant, code, args );
    }
  }

} );

/*******************************************************************************
 * Copyright (c) 2004, 2014 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource, and others.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

/*global console: false */


/**
 * The qooxdoo root class. All other classes are direct or indirect subclasses of this one.
 *
 * This class contains methods for:
 *
 * * object management (creation and destruction)
 * * generic setter support
 * * user friendly OO interfaces like {@link #self} or {@link #base}
 */
rwt.qx.Class.define( "rwt.qx.Object", {

  extend : Object,

  construct : function() {
    this._hashCode = rwt.qx.Object.__availableHashCode++;
    if( this._autoDispose ) {
      // try to get a re-usable key
      this.__dbKey=rwt.qx.Object.__freeAvailableDbKeys.pop();
      if( !this.__dbKey ) {
        // no re-usable key found ==> append to registry
        this.__dbKey = rwt.qx.Object.__db.length;
        rwt.qx.Object.__db.push( this );
      } else {
        // re-use key
        rwt.qx.Object.__db[ this.__dbKey ] = this;
      }
    }
  },

  statics : {
    __availableHashCode : 0,

    __freeAvailableDbKeys : [],

    __db : [],

    __disposeAll : false,

    /** Internal type */
    $$type : "Object",

    /**
     * Returns an unique identifier for the given object. If such an identifier
     * does not yet exist, create it.
     *
     * @param obj {Object} the Object to get the hashcode for
     * @return {Integer} unique identifier for the given object
     */
    toHashCode : function( obj ) {
      /*jshint boss: true */
      if( obj._hashCode != null ) {
        return obj._hashCode;
      }
      return obj._hashCode = this.__availableHashCode++;
    },

    /**
     * Returns the database created, but not yet disposed elements.
     * Please be sure to not modify the given array!
     *
     * @return {Array} The database
     */
    getDb : function() {
      return this.__db;
    },

    /**
     * Destructor. This method is called by qooxdoo on object destruction.
     *
     * Any class that holds resources like links to DOM nodes must override
     * this method and free these resources.
     *
     * @param unload {Boolean?false} Whether the dispose is fired through the page unload event
     */
    dispose : function( unload ) {
      if( this.__disposed ) {
        return;
      }
      this.__disposed = true;
      this.__unload = unload || false;
      // var vStart = (new Date).valueOf();
      var vObject, vObjectDb = this.__db;
      for( var i = vObjectDb.length - 1; i >= 0; i-- ) {
        vObject = vObjectDb[ i ];
        if( vObject && vObject.__disposed === false ) {
          vObject.dispose();
        }
      }
    },

    /**
     * Returns whether a global dispose is currently taking place.
     *
     * @return {Boolean} whether a global dispose is taking place.
     */
    inGlobalDispose : function() {
      return this.__disposed || false;
    },

    /**
     * Returns whether a global unload (page unload) is currently taking place.
     *
     * @return {Boolean} whether a global unload is taking place.
     */
    isPageUnload : function() {
      return this.__unload || false;
    }
  },

  members : {

    /** If the object should automatically be disposed on application unload */
    _autoDispose : true,

    /**
     * Store user defined data inside the object.
     *
     * @param key {String} the key
     * @param value {Object} the value of the user data
     */
    setUserData : function( key, value ) {
      if( !this.__userData ) {
        this.__userData = {};
      }
      this.__userData[ key ] = value;
    },

    /**
     * Load user defined data from the object
     *
     * @param key {String} the key
     * @return {Object} the user data
     */
    getUserData : function( key ) {
      if( !this.__userData ) {
        return null;
      }
      var data = this.__userData[ key ];
      return data === undefined ? null : data;
    },

    // ------------------------------------------------------------------------
    // BASICS
    // ------------------------------------------------------------------------

    /**
     * Return unique hash code of object
     *
     * @return {Integer} unique hash code of the object
     */
    toHashCode : function() {
      return this._hashCode;
    },

    /**
     * Returns a string represantation of the qooxdoo object.
     *
     * @return {String} string representation of the object
     */
    toString : function() {
      if( this.classname ) {
        return "[object " + this.classname + "]";
      }
      return "[object Object]";
    },

    /**
     * Call the same method of the super class.
     *
     * @param args {*} the arguments variable of the calling method
     * @param varags {...*} variable number of arguments passed to the overwritten function
     * @return {var} the return value of the method of the base class.
     */
    base : function( args ) {
      if( arguments.length === 1 ) {
        return args.callee.base.call( this );
      } else {
        return args.callee.base.apply( this, Array.prototype.slice.call( arguments, 1 ) );
      }
    },

    /**
     * Returns the static class (to access static members of this class)
     *
     * @param args {arguments} the arguments variable of the calling method
     * @return {var} the return value of the method of the base class.
     */
    self : function( args ) {
      return args.callee.self;
    },

    /**
     * Returns the key of the object used in the objects DB
     * received by {@link #getDb()}.
     *
     * @return {Integer} The key in the db for the current object.
     */
    getDbKey: function() {
      return this.__dbKey;
    },

    // ------------------------------------------------------------------------
    // COMMON SETTER/GETTER/RESETTER SUPPORT
    // ------------------------------------------------------------------------

    /**
     * Sets multiple properties at once by using a property list or
     * sets one property and its value by the first and second argument.
     *
     * @param data {Map | String} a map of property values. The key is the name of the property.
     * @param value {var?} the value, only used when <code>data</code> is a string.
     * @return {Object} this instance.
     * @throws an Exception if a property defined does not exist
     */
    set : function( data, value ) {
      var setter = rwt.qx.Property.$$method.set;
      if( typeof data === "string" ) {
        return this[ setter[ data ] ]( value );
      } else {
        for( var prop in data ) {
          this[ setter[ prop ] ]( data[ prop ] );
        }
        return this;
      }
    },

    /**
     * Returns the value of the given property.
     *
     * @param prop {String} Name of the property.
     * @return {var} The value of the value
     * @throws an Exception if a property defined does not exist
     */
    get : function( prop ) {
      var getter = rwt.qx.Property.$$method.get;
      return this[ getter[ prop ] ]();
    },

    /**
     * Resets the value of the given property.
     *
     * @param prop {String} Name of the property.
     * @throws an Exception if a property defined does not exist
     */
    reset : function( prop ) {
      var resetter = rwt.qx.Property.$$method.reset;
      this[ resetter[ prop ] ]();
    },

    // ------------------------------------------------------------------------
    // DISPOSER
    // ------------------------------------------------------------------------

    __disposed : false,

    /**
     * Returns true if the object is disposed.
     *
     * @return {Boolean} whether the object has been disposed
     */
    getDisposed : function() {
      return this.__disposed;
    },

    /**
     * Returns true if the object is disposed.
     *
     * @return {Boolean} whether the object has been disposed
     */
    isDisposed : function() {
      return this.__disposed;
    },

    /**
     * Dispose this object
     */
    dispose : function() {
      // Check first
      if( this.__disposed ) {
        return;
      }
      // Mark as disposed (directly, not at end, to omit recursions)
      this.__disposed = true;
      // Deconstructor support for classes
      var clazz = this.constructor;
      var mixins;
      while( clazz.superclass ) {
        // Processing this class...
        if( clazz.$$destructor ) {
          clazz.$$destructor.call( this );
        }
        // Destructor support for mixins
        if( clazz.$$includes ) {
          mixins = clazz.$$includes;
          for( var i = 0, l = mixins.length; i < l; i++ ) {
            if( mixins[ i ].$$destructor ) {
              mixins[ i ].$$destructor.call( this );
            }
          }
        }
        // Jump up to next super class
        clazz = clazz.superclass;
      }
    },

    // Prevent old custom widgets using logging from crashing:
    debug : rwt.util.Variant.select( "qx.debug", {
      "on" : function( msg ) {
        if( window.console && typeof console.log === "function" ) {
          console.log( msg );
        }
      },
      "default" : function() {
      }
    } ),

    info : function( msg ) {
      this.debug( "INFO: " + msg );
    },

    warn : function( msg ) {
      this.debug( "WARN: " + msg );
    },

    error : function( msg ) {
      this.debug( "ERROR: " + msg );
    },

    printStackTrace : rwt.util.Variant.select( "qx.debug", {
      "on" : function() {
        if( console && typeof console.trace === "function" ) {
          this.debug( "Current stack trace:" );
          console.trace();
        }
      },
      "default" : function() {
      }
    } ),

    // ------------------------------------------------------------------------
    // DISPOSER UTILITIES
    // ------------------------------------------------------------------------

    /**
     * Disconnects given fields from instance.
     *
     * @param varargs {arguments} fields to dispose
     */
    _disposeFields : function() {
      var name;
      for( var i = 0, l = arguments.length; i < l; i++ ) {
        name = arguments[ i ];
        if( this[ name ] == null ) {
          continue;
        }
        if( !this.hasOwnProperty( name ) ) {
          continue;
        }
        this[ name ] = null;
      }
    },

    /**
     * Disconnects and disposes given objects from instance.
     * Only works with rwt.qx.Object based objects e.g. Widgets.
     *
     * @param varargs {arguments} fields to dispose
     */
    _disposeObjects : function() {
      var name;
      for( var i = 0, l = arguments.length; i < l; i++ ) {
        name = arguments[ i ];
        if( this[ name ] == null ) {
          continue;
        }
        if( !this.hasOwnProperty( name ) ) {
          continue;
        }
        if( !this[ name ].dispose ) {
          throw new Error( this.classname + "." + name + " is not a qooxdoo object. Use _disposeFields instead of _disposeObjects." );
        }
        this[ name ].dispose();
        this[ name ] = null;
      }
    },

    /**
     * Disconnects and disposes given objects (deeply) from instance.
     * Works with arrays, maps and qooxdoo objects.
     *
     * @param name {String} field name to dispose
     * @param deep {Number} how deep to following sub objects. Deep=0 means
     *   just the object and all its keys. Deep=1 also dispose deletes the
     *   objects object content.
     */
    _disposeObjectDeep : function( name, deep ) {
      var name;
      if( this[ name ] == null ) {
        return;
      }
      if( !this.hasOwnProperty( name ) ) {
        return;
      }
      this.__disposeObjectsDeepRecurser( this[ name ], deep || 0 );
      this[ name ] = null;
    },

    /**
     * Helper method for _disposeObjectDeep. Do the recursive work.
     *
     * @param obj {Object} object to dispose
     * @param deep {Number} how deep to following sub objects. Deep=0 means
     *   just the object and all its keys. Deep=1 also dispose deletes the
     *   objects object content.
     */
    __disposeObjectsDeepRecurser : function( obj, deep ) {
      // qooxdoo
      if( obj instanceof rwt.qx.Object ) {
        obj.dispose();
      }
      // Array
      else if( obj instanceof Array ) {
        for( var i = 0, l = obj.length; i < l; i++ ) {
          var entry = obj[ i ];
          if( entry == null ) {
            continue;
          }
          if( typeof entry == "object" ) {
            if( deep > 0 ) {
              this.__disposeObjectsDeepRecurser( entry, deep - 1 );
            }
            obj[ i ] = null;
          } else if( typeof entry == "function" ) {
            obj[ i ] = null;
          }
        }
      }
      // Map
      else if( obj instanceof Object ) {
        for( var key in obj ) {
          if( obj[ key ] == null || !obj.hasOwnProperty( key ) ) {
            continue;
          }
          var entry = obj[ key ];
          if( typeof entry == "object" ) {
            if( deep > 0 ) {
              this.__disposeObjectsDeepRecurser( entry, deep - 1 );
            }
            obj[ key ] = null;
          } else if( typeof entry == "function" ) {
            obj[ key ] = null;
          }
        }
      }
    }
  },

  destruct : function() {
    // Cleanup properties
    var clazz = this.constructor;
    var properties;
    var store = rwt.qx.Property.$$store;
    var storeUser = store.user;
    var storeTheme = store.theme;
    var storeInherit = store.inherit;
    var storeUseinit = store.useinit;
    var storeInit = store.init;
    while( clazz ) {
      properties = clazz.$$properties;
      if( properties ) {
        for( var name in properties ) {
          if( properties[ name ].dispose ) {
            this[ storeUser[ name ] ] = undefined;
            this[ storeTheme[ name ] ] = undefined;
            this[ storeInherit[ name ] ] = undefined;
            this[ storeUseinit[ name ] ] = undefined;
            this[ storeInit[ name ] ] = undefined;
          }
        }
      }
      clazz = clazz.superclass;
    }
    this._disposeFields( "__userData" );
    // Delete Entry from Object DB
    if( this.__dbKey != null ) {
      if( rwt.qx.Object.__disposeAll ) {
        rwt.qx.Object.__db[ this.__dbKey ] = null;
      } else {
        delete rwt.qx.Object.__db[ this.__dbKey ];
      }
      rwt.qx.Object.__freeAvailableDbKeys.push( this.__dbKey );
    }
  }

} );

/*******************************************************************************
 * Copyright (c) 2004, 2015 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 *
 * This class contains code based on the following work:
 *
 *  * Yahoo! UI Library, version 2.2.0
 *    http://developer.yahoo.com/yui
 *    Copyright (c) 2007, Yahoo! Inc.
 *    License: BSD, http://developer.yahoo.com/yui/license.txt
 ******************************************************************************/

/**
 * Includes library functions to work with the client's viewport (window).
 */
rwt.qx.Class.define("rwt.html.Viewport",
{
  statics :
  {
    /**
     * Returns the current width of the viewport (excluding a eventually visible scrollbar).
     *
     * <code>clientWidth</code> is the inner width of an element in pixels. It includes padding
     * but not the vertical scrollbar (if present, if rendered), border or margin.
     *
     * The property <code>innerWidth</code> is not useable as defined by the standard as it includes the scrollbars
     * which is not the indented behavior of this method. We can decrement the size by the scrollbar
     * size but there are easier possibilities to work around this.
     *
     * Safari 2 and 3 beta (3.0.2) do not correctly implement <code>clientWidth</code> on documentElement/body,
     * but <code>innerWidth</code> works there. Interesting is that webkit do not correctly implement
     * <code>innerWidth</code>, too. It calculates the size excluding the scroll bars and this
     * differs from the behavior of all other browsers - but this is exactly what we want to have
     * in this case.
     *
     * Opera as of 9.21 only works well using <code>body.clientWidth</code>.
     *
     * Verified to correctly work with:
     *
     * * Mozilla Firefox 2.0.0.4
     * * Opera 9.2.1
     * * Safari 3.0 beta (3.0.2)
     * * Internet Explorer 7.0
     *
     * @type static
     * @signature function(win)
     * @param win {Window?window} The window to query
     * @return {Integer} The width of the viewable area of the page (excludes scrollbars).
     */
    getWidth : rwt.util.Variant.select("qx.client",
    {
      "webkit|blink" : function(win) {
        return (win||window).innerWidth;
      },

      "default" : function(win)
      {
        var doc = (win||window).document;
        return doc.compatMode === "CSS1Compat" ? doc.documentElement.clientWidth : doc.body.clientWidth;
      }
    }),


    /**
     * Returns the current height of the viewport (excluding a eventually visible scrollbar).
     *
     * <code>clientHeight</code> is the inner height of an element in pixels. It includes padding
     * but not the vertical scrollbar (if present, if rendered), border or margin.
     *
     * The property <code>innerHeight</code> is not useable as defined by the standard as it includes the scrollbars
     * which is not the indented behavior of this method. We can decrement the size by the scrollbar
     * size but there are easier possibilities to work around this.
     *
     * Safari 2 and 3 beta (3.0.2) do not correctly implement <code>clientHeight</code> on documentElement/body,
     * but <code>innerHeight</code> works there. Interesting is that webkit do not correctly implement
     * <code>innerHeight</code>, too. It calculates the size excluding the scroll bars and this
     * differs from the behavior of all other browsers - but this is exactly what we want to have
     * in this case.
     *
     * Opera as of 9.21 only works well using <code>body.clientHeight</code>.
     *
     * Verified to correctly work with:
     *
     * * Mozilla Firefox 2.0.0.4
     * * Opera 9.2.1
     * * Safari 3.0 beta (3.0.2)
     * * Internet Explorer 7.0
     *
     * @type static
     * @signature function(win)
     * @param win {Window?window} The window to query
     * @return {Integer} The Height of the viewable area of the page (excludes scrollbars).
     */
    getHeight : rwt.util.Variant.select("qx.client",
    {
      "webkit|blink" : function(win) {
        return (win||window).innerHeight;
      },

      "default" : function(win)
      {
        var doc = (win||window).document;
        return doc.compatMode === "CSS1Compat" ? doc.documentElement.clientHeight : doc.body.clientHeight;
      }
    }),


    /**
     * Returns the scroll position of the viewport
     *
     * All clients except old IE supports the non-standard property <code>pageXOffset</code>.
     * As this is easier to evaluate we prefer this property over <code>scrollLeft</code>.
     *
     * @type static
     * @signature function(win)
     * @param win {Window?window} The window to query
     * @return {Integer} Scroll position from left edge, always a positive integer
     */
    getScrollLeft : function( win ) {
      return (win||window).pageXOffset;
    },

    /**
     * Returns the scroll position of the viewport
     *
     * All clients except old IE supports the non-standard property <code>pageYOffset</code>.
     * As this is easier to evaluate we prefer this property over <code>scrollTop</code>.
     *
     * @type static
     * @signature function(win)
     * @param win {Window?window} The window to query
     * @return {Integer} Scroll position from left edge, always a positive integer
     */
    getScrollTop : function(win) {
      return (win||window).pageYOffset;
    }

  }
});

/*******************************************************************************
 * Copyright (c) 2004, 2014 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource, and others.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/


/**
 * This is the main constructor for all objects that need to be connected to rwt.event.Event objects.
 *
 * In objects created with this constructor, you find functions to addEventListener or
 * removeEventListener to or from the created object. Each event to connect to has a type in
 * form of an identification string. This type could be the name of a regular dom event like "click"
 * or something self-defined like "ready".
 */
rwt.qx.Class.define( "rwt.qx.Target", {

  extend : rwt.qx.Object,

  construct : function() {
    this.base( arguments );
  },

  members : {

    /**
     * Add event listener to an object.
     *
     * @param type {String} name of the event type
     * @param func {Function} event callback function
     * @param obj {Object ? window} reference to the 'this' variable inside the callback
     */
    addEventListener : function( type, func, obj ) {
      if( this.getDisposed() ) {
        return;
      }

      // If this is the first event of given type, we need to create a subobject
      // that contains all the actions that will be assigned to this type
      if( this.__listeners === undefined ) {
        this.__listeners = {};
      }

      if( this.__listeners[ type ] === undefined ) {
        this.__listeners[ type ] = {};
      }

      // Create a special key string to allow identification of each bound action
      var key = "event" + rwt.qx.Object.toHashCode( func ) +
        ( obj ? "$" + rwt.qx.Object.toHashCode( obj ) : "" );

      // Finally set up the listeners object
      this.__listeners[ type ][ key ] = {
        handler : func,
        object  : obj
      };
    },

    /**
     * Remove event listener from object
     *
     * @param type {String} name of the event type
     * @param func {Function} event callback function
     * @param obj {Object ? window} reference to the 'this' variable inside the callback
     */
    removeEventListener : function( type, func, obj ) {
      if( this.getDisposed() ) {
        return;
      }

      var listeners = this.__listeners;

      if( !listeners || listeners[ type ] === undefined ) {
        return;
      }

      if( typeof func !== "function" ) {
        throw new Error( "rwt.qx.Target: removeEventListener(" + type + "): '" + func
                         + "' is not a function!" );
      }

      // Create a special key string to allow identification of each bound action
      var key = "event" + rwt.qx.Object.toHashCode( func ) +
        ( obj ? "$" + rwt.qx.Object.toHashCode( obj ) : "" );

      // Delete object entry for this action
      delete this.__listeners[ type ][ key ];
    },

    // ------------------------------------------------------------------------
    // EVENT CONNECTION UTILITIES
    // ------------------------------------------------------------------------

    /**
     * Check if there are one or more listeners for an event type.
     *
     * @param type {String} name of the event type
     */
    hasEventListeners : function( type ) {
      return this.__listeners &&
        this.__listeners[ type ] !== undefined &&
        !rwt.util.Objects.isEmpty( this.__listeners[ type ] );
    },


    /**
     * Checks if the event is registered. If so it creates an event object and dispatches it.
     *
     * @param type {String} name of the event type
     */
    createDispatchEvent : function( type ) {
      if( this.hasEventListeners( type ) ) {
        this.dispatchEvent( new rwt.event.Event( type ), true );
      }
    },

    /**
     * Checks if the event is registered. If so it creates an event object and dispatches it.
     *
     * @param type {String} name of the event type
     * @param data {Object} user defined data attached to the event object
     */
    createDispatchDataEvent : function( type, data ) {
      if( this.hasEventListeners( type ) ) {
        this.dispatchEvent( new rwt.event.DataEvent( type, data ), true );
      }
    },

    /**
     * Checks if the event is registered. If so it creates an event object and dispatches it.
     *
     * @param type {String} name of the event type
     * @param value {Object} property value attached to the event object
     * @param old {Object} old property value attached to the event object
     */
    createDispatchChangeEvent : function( type, value, old ) {
      if( this.hasEventListeners( type ) ) {
        this.dispatchEvent( new rwt.event.ChangeEvent( type, value, old ), true );
      }
    },

    // ------------------------------------------------------------------------
    // EVENT DISPATCH
    // ------------------------------------------------------------------------

    /**
     * Dispatch an event
     *
     * @param evt {rwt.event.Event} event to dispatch
     * @param dispose {Boolean} whether the event object should be disposed after all event handlers run.
     * @return {Boolean} whether the event default was prevented or not. Returns true, when the event was NOT prevented.
     */
    dispatchEvent : function( evt, dispose ) {
      // Ignore event if eventTarget is disposed
      if( this.getDisposed() ) {
        return;
      }
      if( evt.getTarget() == null ) {
        evt.setTarget(this);
      }
      if( evt.getCurrentTarget() == null ) {
        evt.setCurrentTarget( this );
      }
      // Dispatch Event
      this._dispatchEvent( evt, dispose );
      // Read default prevented
      var defaultPrevented = evt.getDefaultPrevented();
      // enable dispose for event?
      if( dispose ) {
        evt.dispose();
      }
      return !defaultPrevented;
    },

    dispatchSimpleEvent : function( type, data, bubbles ) {
      var listeners = this.__listeners;
      var propagate = bubbles === true;
      var result = true;
      if( listeners ) {
        var typeListeners = listeners[ type ];
        if( typeListeners ) {
          var func;
          var obj;
          for( var hashCode in typeListeners ) {
            // Shortcuts for handler and object
            func = typeListeners[ hashCode ].handler;
            obj = typeListeners[ hashCode ].object || this;
            result = func.call( obj, data ) && result !== false;
            if( result === false ) {
              propagate = false;
            }
          }
        }
      }
      if( propagate && typeof( this.getParent ) === "function" ) {
        var parent = this.getParent();
        if( parent && !parent.getDisposed() && parent.getEnabled() ) {
          parent.dispatchSimpleEvent( type, data, bubbles );
        }
      }
      return result !== false;
    },

    /**
     * Internal event dispatch method
     *
     * @param evt {rwt.event.Event} event to dispatch
     */
    _dispatchEvent : function( evt ) {
      var listeners = this.__listeners;
      if( listeners && this._allowDispatch( evt ) ) {
        // Setup current target
        evt.setCurrentTarget( this );
        // Shortcut for listener data
        var typeListeners = listeners[ evt.getType() ];
        if( typeListeners ) {
          var func, obj;
          // Handle all events for the specified type
          for( var vHashCode in typeListeners ) {
            // Shortcuts for handler and object
            func = typeListeners[ vHashCode ].handler;
            obj = typeListeners[ vHashCode ].object || this;
            // Call object function
            func.call( obj, evt );
          }
        }
      }

      // Bubble event to parents
      // TODO: Move this to Parent or Widget?
      if( evt.getBubbles() && !evt.getPropagationStopped() && typeof( this.getParent ) == "function" )
      {
        var parent = this.getParent();
        if( parent && !parent.getDisposed() ) {
          parent._dispatchEvent( evt );
        }
      }
    },

    _allowDispatch : function( event ) {
      var result = true;
      if( this.getEnabled && event instanceof rwt.event.DomEvent ) {
        result = this.getEnabled();
      }
      return result;
    }

  },

  destruct : function() {
    this._disposeObjectDeep( "__listeners", 2 );
  }

} );

/*******************************************************************************
 * Copyright (c) 2004, 2013 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

/**
 * The qooxdoo core event object. Each event object for rwt.qx.Targets should extend this class.
 */
rwt.qx.Class.define("rwt.event.Event",
{
  extend : rwt.qx.Object,




  /*
  *****************************************************************************
     CONSTRUCTOR
  *****************************************************************************
  */

  construct : function(vType)
  {
    this.base(arguments);

    this.setType(vType);
  },




  /*
  *****************************************************************************
     PROPERTIES
  *****************************************************************************
  */

  properties :
  {
    type :
    {
      _fast       : true,
      setOnlyOnce : true
    },

    originalTarget :
    {
      _fast       : true,
      setOnlyOnce : true
    },

    target :
    {
      _fast       : true,
      setOnlyOnce : true
    },

    relatedTarget :
    {
      _fast       : true,
      setOnlyOnce : true
    },

    currentTarget : { _fast : true },

    bubbles :
    {
      _fast        : true,
      defaultValue : false,
      noCompute    : true
    },

    propagationStopped :
    {
      _fast        : true,
      defaultValue : true,
      noCompute    : true
    },

    defaultPrevented :
    {
      _fast        : true,
      defaultValue : false,
      noCompute    : true
    }
  },




  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {
    _autoDispose : false,


    /*
    ---------------------------------------------------------------------------
      SHORTCUTS
    ---------------------------------------------------------------------------
    */

    /**
     * TODOC
     *
     * @type member
     * @return {void}
     */
    preventDefault : function() {
      this.setDefaultPrevented(true);
    },


    /**
     * TODOC
     *
     * @type member
     * @return {void}
     */
    stopPropagation : function() {
      this.setPropagationStopped(true);
    }
  },




  /*
  *****************************************************************************
     DESTRUCTOR
  *****************************************************************************
  */

  destruct : function() {
    this._disposeFields("_valueOriginalTarget", "_valueTarget", "_valueRelatedTarget", "_valueCurrentTarget");
  }
});

/*******************************************************************************
 * Copyright (c) 2004, 2013 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

/** Event object for data transfers. */
rwt.qx.Class.define("rwt.event.DataEvent",
{
  extend : rwt.event.Event,




  /*
  *****************************************************************************
     CONSTRUCTOR
  *****************************************************************************
  */

 /**
  * @param vType {String} the type name of the event
  * @param vData {var} additional data which should be passed to the event listener
  */
  construct : function(vType, vData)
  {
    this.base(arguments, vType);

    this.setData(vData);
  },




  /*
  *****************************************************************************
     PROPERTIES
  *****************************************************************************
  */

  properties :
  {
    propagationStopped :
    {
      _fast        : true,
      defaultValue : false
    },

    data : { _fast : true }
  },




  /*
  *****************************************************************************
     DESTRUCTOR
  *****************************************************************************
  */

  destruct : function() {
    this._disposeFields("_valueData");
  }
});

/*******************************************************************************
 * Copyright (c) 2004, 2013 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

/** Event object for property changes. */
rwt.qx.Class.define("rwt.event.ChangeEvent",
{
  extend : rwt.event.Event,




  /*
  *****************************************************************************
     CONSTRUCTOR
  *****************************************************************************
  */

 /**
  * @param type {String} the type name of the event
  * @param value {var} additional value which should be passed to the event listener
  * @param old {var} additional old value which should be passed to the event listener
  */
  construct : function(type, value, old)
  {
    this.base(arguments, type);

    this.setValue(value);
    this.setOldValue(old);
  },




  /*
  *****************************************************************************
     PROPERTIES
  *****************************************************************************
  */

  properties :
  {
    value : { _fast : true },
    oldValue : { _fast : true }
  },





  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {
    /**
     * Returns the event data
     *
     * @deprecated use {@link #getValue} instead
     */
    getData : function() {
      return this.getValue();
    }
  },





  /*
  *****************************************************************************
     DESTRUCTOR
  *****************************************************************************
  */

  destruct : function() {
    this._disposeFields("_valueValue", "_valueOldValue");
  }
});

/*******************************************************************************
 * Copyright (c) 2004, 2014 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

/**
 * Global timer support.
 *
 * This class can be used to periodically fire an event. This event can be
 * used to simulate e.g. a background task. The static method
 * {@link #once} is a special case. It will call a function deferred after a
 * given timeout.
 */
rwt.qx.Class.define("rwt.client.Timer",
{
  extend : rwt.qx.Target,




  /*
  *****************************************************************************
     CONSTRUCTOR
  *****************************************************************************
  */

  /**
   * @param interval {Number} initial interval in milliseconds of the timer.
   */
  construct : function(interval)
  {
    this.base(arguments);

    this.setEnabled(false);

    if (interval != null) {
      this.setInterval(interval);
    }

    this.__oninterval = rwt.util.Functions.bind(this._oninterval, this);

    //Event instance to dispatch when interval fires
    this.__event = new rwt.event.Event("interval");

  },

  /*
  *****************************************************************************
     STATICS
  *****************************************************************************
  */

  statics :
  {
    /**
     * Start a function after a given timeout.
     *
     * @type static
     * @param func {Function} Function to call
     * @param obj {Object} context (this), the function is called with
     * @param timeout {Number} Number of milliseconds to wait before the function is called.
     */
    once : function(func, obj, timeout)
    {
      // Create time instance
      var timer = new rwt.client.Timer(timeout);

      // Add event listener to interval
      timer.addEventListener("interval", function(e)
      {
        timer.dispose();
        func.call(obj, e);

        obj = null;
      },
      obj);

      // Directly start timer
      timer.start();
    }
  },




  /*
  *****************************************************************************
     PROPERTIES
  *****************************************************************************
  */

  properties :
  {
    /**
     * With the enabled property the Timer can be started and suspended.
     * Setting it to "true" is equivalent to {@link #start}, setting it
     * to "false" is equivalent to {@link #stop}.
     */
    enabled :
    {
      init : true,
      check : "Boolean",
      apply : "_applyEnabled"
    },

    /**
     * Time in milliseconds between two callback calls.
     * This property can be set to modify the interval of
     * a running timer.
     */
    interval :
    {
      check : "Integer",
      init : 1000,
      apply : "_applyInterval"
    }
  },




  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {
    __intervalHandler : null,




    /*
    ---------------------------------------------------------------------------
      APPLY ROUTINES
    ---------------------------------------------------------------------------
    */

    /**
     * Apply the interval of the timer.
     *
     * @type member
     * @param value {var} Current value
     * @param old {var} Previous value
     */
    _applyInterval : function()
    {
      if (this.getEnabled()) {
        this.restart();
      }
    },


    /**
     * Apply the enabled state of the timer.
     *
     * @type member
     * @param value {var} Current value
     * @param old {var} Previous value
     */
    _applyEnabled : function(value, old)
    {
      if (old)
      {
        window.clearInterval(this.__intervalHandler);
        this.__intervalHandler = null;
      }
      else if (value)
      {
        this.__intervalHandler = window.setInterval(this.__oninterval, this.getInterval());
      }
    },




    /*
    ---------------------------------------------------------------------------
      USER-ACCESS
    ---------------------------------------------------------------------------
    */

    /**
     * Start the timer
     *
     * @type member
     */
    start : function() {
      this.setEnabled(true);
    },


    /**
     * Start the timer with a given interval
     *
     * @type member
     * @param interval {Integer} Time in milliseconds between two callback calls.
     */
    startWith : function(interval)
    {
      this.setInterval(interval);
      this.start();
    },


    /**
     * Stop the timer.
     *
     * @type member
     */
    stop : function() {
      this.setEnabled(false);
    },


    /**
     * Restart the timer.
     * This makes it possible to change the interval of a running timer.
     *
     * @type member
     */
    restart : function()
    {
      this.stop();
      this.start();
    },


    /**
     * Restart the timer. with a given interval.
     *
     * @type member
     * @param interval {Integer} Time in milliseconds between two callback calls.
     */
    restartWith : function(interval)
    {
      this.stop();
      this.startWith(interval);
    },




    /*
    ---------------------------------------------------------------------------
      EVENT-MAPPER
    ---------------------------------------------------------------------------
    */

    /**
     * timer callback
     *
     * @type member
     */
    _oninterval : function() {
      try {
        if (this.getEnabled() && this.hasEventListeners("interval")) {
          this.dispatchEvent(this.__event, false);
        }
      } catch( ex ) {
        rwt.runtime.ErrorHandler.processJavaScriptError( ex );
      }
    }
  },




  /*
  *****************************************************************************
     DESTRUCTOR
  *****************************************************************************
  */

  destruct : function()
  {
    if (this.__intervalHandler) {
      window.clearInterval(this.__intervalHandler);
    }

    this._disposeFields("__intervalHandler", "__oninterval", "__event");
  }
});

/*******************************************************************************
 * Copyright (c) 2004, 2013 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

/**
 * A Collection of utility functions to escape and unescape strings.
 */
rwt.qx.Class.define( "rwt.html.Entity", {

  statics : {

    /** Mapping of HTML entity names to the corresponding char code */
    TO_CHARCODE : {
      "quot"     : 34, // " - double-quote
      "amp"      : 38, // &
      "lt"       : 60, // <
      "gt"       : 62, // >

      // http://www.w3.org/TR/REC-html40/sgml/entities.html
      // ISO 8859-1 characters
      "nbsp"     : 160, // no-break space
      "iexcl"    : 161, // inverted exclamation mark
      "cent"     : 162, // cent sign
      "pound"    : 163, // pound sterling sign
      "curren"   : 164, // general currency sign
      "yen"      : 165, // yen sign
      "brvbar"   : 166, // broken (vertical) bar
      "sect"     : 167, // section sign
      "uml"      : 168, // umlaut (dieresis)
      "copy"     : 169, // copyright sign
      "ordf"     : 170, // ordinal indicator, feminine
      "laquo"    : 171, // angle quotation mark, left
      "not"      : 172, // not sign
      "shy"      : 173, // soft hyphen
      "reg"      : 174, // registered sign
      "macr"     : 175, // macron
      "deg"      : 176, // degree sign
      "plusmn"   : 177, // plus-or-minus sign
      "sup2"     : 178, // superscript two
      "sup3"     : 179, // superscript three
      "acute"    : 180, // acute accent
      "micro"    : 181, // micro sign
      "para"     : 182, // pilcrow (paragraph sign)
      "middot"   : 183, // middle dot
      "cedil"    : 184, // cedilla
      "sup1"     : 185, // superscript one
      "ordm"     : 186, // ordinal indicator, masculine
      "raquo"    : 187, // angle quotation mark, right
      "frac14"   : 188, // fraction one-quarter
      "frac12"   : 189, // fraction one-half
      "frac34"   : 190, // fraction three-quarters
      "iquest"   : 191, // inverted question mark
      "Agrave"   : 192, // capital A, grave accent
      "Aacute"   : 193, // capital A, acute accent
      "Acirc"    : 194, // capital A, circumflex accent
      "Atilde"   : 195, // capital A, tilde
      "Auml"     : 196, // capital A, dieresis or umlaut mark
      "Aring"    : 197, // capital A, ring
      "AElig"    : 198, // capital AE diphthong (ligature)
      "Ccedil"   : 199, // capital C, cedilla
      "Egrave"   : 200, // capital E, grave accent
      "Eacute"   : 201, // capital E, acute accent
      "Ecirc"    : 202, // capital E, circumflex accent
      "Euml"     : 203, // capital E, dieresis or umlaut mark
      "Igrave"   : 204, // capital I, grave accent
      "Iacute"   : 205, // capital I, acute accent
      "Icirc"    : 206, // capital I, circumflex accent
      "Iuml"     : 207, // capital I, dieresis or umlaut mark
      "ETH"      : 208, // capital Eth, Icelandic
      "Ntilde"   : 209, // capital N, tilde
      "Ograve"   : 210, // capital O, grave accent
      "Oacute"   : 211, // capital O, acute accent
      "Ocirc"    : 212, // capital O, circumflex accent
      "Otilde"   : 213, // capital O, tilde
      "Ouml"     : 214, // capital O, dieresis or umlaut mark
      "times"    : 215, // multiply sign
      "Oslash"   : 216, // capital O, slash
      "Ugrave"   : 217, // capital U, grave accent
      "Uacute"   : 218, // capital U, acute accent
      "Ucirc"    : 219, // capital U, circumflex accent
      "Uuml"     : 220, // capital U, dieresis or umlaut mark
      "Yacute"   : 221, // capital Y, acute accent
      "THORN"    : 222, // capital THORN, Icelandic
      "szlig"    : 223, // small sharp s, German (sz ligature)
      "agrave"   : 224, // small a, grave accent
      "aacute"   : 225, // small a, acute accent
      "acirc"    : 226, // small a, circumflex accent
      "atilde"   : 227, // small a, tilde
      "auml"     : 228, // small a, dieresis or umlaut mark
      "aring"    : 229, // small a, ring
      "aelig"    : 230, // small ae diphthong (ligature)
      "ccedil"   : 231, // small c, cedilla
      "egrave"   : 232, // small e, grave accent
      "eacute"   : 233, // small e, acute accent
      "ecirc"    : 234, // small e, circumflex accent
      "euml"     : 235, // small e, dieresis or umlaut mark
      "igrave"   : 236, // small i, grave accent
      "iacute"   : 237, // small i, acute accent
      "icirc"    : 238, // small i, circumflex accent
      "iuml"     : 239, // small i, dieresis or umlaut mark
      "eth"      : 240, // small eth, Icelandic
      "ntilde"   : 241, // small n, tilde
      "ograve"   : 242, // small o, grave accent
      "oacute"   : 243, // small o, acute accent
      "ocirc"    : 244, // small o, circumflex accent
      "otilde"   : 245, // small o, tilde
      "ouml"     : 246, // small o, dieresis or umlaut mark
      "divide"   : 247, // divide sign
      "oslash"   : 248, // small o, slash
      "ugrave"   : 249, // small u, grave accent
      "uacute"   : 250, // small u, acute accent
      "ucirc"    : 251, // small u, circumflex accent
      "uuml"     : 252, // small u, dieresis or umlaut mark
      "yacute"   : 253, // small y, acute accent
      "thorn"    : 254, // small thorn, Icelandic
      "yuml"     : 255, // small y, dieresis or umlaut mark

      // Latin Extended-B
      "fnof"     : 402, // latin small f with hook = function= florin, U+0192 ISOtech

      // Greek
      "Alpha"    : 913, // greek capital letter alpha, U+0391
      "Beta"     : 914, // greek capital letter beta, U+0392
      "Gamma"    : 915, // greek capital letter gamma,U+0393 ISOgrk3
      "Delta"    : 916, // greek capital letter delta,U+0394 ISOgrk3
      "Epsilon"  : 917, // greek capital letter epsilon, U+0395
      "Zeta"     : 918, // greek capital letter zeta, U+0396
      "Eta"      : 919, // greek capital letter eta, U+0397
      "Theta"    : 920, // greek capital letter theta,U+0398 ISOgrk3
      "Iota"     : 921, // greek capital letter iota, U+0399
      "Kappa"    : 922, // greek capital letter kappa, U+039A
      "Lambda"   : 923, // greek capital letter lambda,U+039B ISOgrk3
      "Mu"       : 924, // greek capital letter mu, U+039C
      "Nu"       : 925, // greek capital letter nu, U+039D
      "Xi"       : 926, // greek capital letter xi, U+039E ISOgrk3
      "Omicron"  : 927, // greek capital letter omicron, U+039F
      "Pi"       : 928, // greek capital letter pi, U+03A0 ISOgrk3
      "Rho"      : 929, // greek capital letter rho, U+03A1

      // there is no Sigmaf, and no U+03A2 character either
      "Sigma"    : 931, // greek capital letter sigma,U+03A3 ISOgrk3
      "Tau"      : 932, // greek capital letter tau, U+03A4
      "Upsilon"  : 933, // greek capital letter upsilon,U+03A5 ISOgrk3
      "Phi"      : 934, // greek capital letter phi,U+03A6 ISOgrk3
      "Chi"      : 935, // greek capital letter chi, U+03A7
      "Psi"      : 936, // greek capital letter psi,U+03A8 ISOgrk3
      "Omega"    : 937, // greek capital letter omega,U+03A9 ISOgrk3
      "alpha"    : 945, // greek small letter alpha,U+03B1 ISOgrk3
      "beta"     : 946, // greek small letter beta, U+03B2 ISOgrk3
      "gamma"    : 947, // greek small letter gamma,U+03B3 ISOgrk3
      "delta"    : 948, // greek small letter delta,U+03B4 ISOgrk3
      "epsilon"  : 949, // greek small letter epsilon,U+03B5 ISOgrk3
      "zeta"     : 950, // greek small letter zeta, U+03B6 ISOgrk3
      "eta"      : 951, // greek small letter eta, U+03B7 ISOgrk3
      "theta"    : 952, // greek small letter theta,U+03B8 ISOgrk3
      "iota"     : 953, // greek small letter iota, U+03B9 ISOgrk3
      "kappa"    : 954, // greek small letter kappa,U+03BA ISOgrk3
      "lambda"   : 955, // greek small letter lambda,U+03BB ISOgrk3
      "mu"       : 956, // greek small letter mu, U+03BC ISOgrk3
      "nu"       : 957, // greek small letter nu, U+03BD ISOgrk3
      "xi"       : 958, // greek small letter xi, U+03BE ISOgrk3
      "omicron"  : 959, // greek small letter omicron, U+03BF NEW
      "pi"       : 960, // greek small letter pi, U+03C0 ISOgrk3
      "rho"      : 961, // greek small letter rho, U+03C1 ISOgrk3
      "sigmaf"   : 962, // greek small letter final sigma,U+03C2 ISOgrk3
      "sigma"    : 963, // greek small letter sigma,U+03C3 ISOgrk3
      "tau"      : 964, // greek small letter tau, U+03C4 ISOgrk3
      "upsilon"  : 965, // greek small letter upsilon,U+03C5 ISOgrk3
      "phi"      : 966, // greek small letter phi, U+03C6 ISOgrk3
      "chi"      : 967, // greek small letter chi, U+03C7 ISOgrk3
      "psi"      : 968, // greek small letter psi, U+03C8 ISOgrk3
      "omega"    : 969, // greek small letter omega,U+03C9 ISOgrk3
      "thetasym" : 977, // greek small letter theta symbol,U+03D1 NEW
      "upsih"    : 978, // greek upsilon with hook symbol,U+03D2 NEW
      "piv"      : 982, // greek pi symbol, U+03D6 ISOgrk3

      // General Punctuation
      "bull"     : 8226, // bullet = black small circle,U+2022 ISOpub

      // bullet is NOT the same as bullet operator, U+2219
      "hellip"   : 8230, // horizontal ellipsis = three dot leader,U+2026 ISOpub
      "prime"    : 8242, // prime = minutes = feet, U+2032 ISOtech
      "Prime"    : 8243, // double prime = seconds = inches,U+2033 ISOtech
      "oline"    : 8254, // overline = spacing overscore,U+203E NEW
      "frasl"    : 8260, // fraction slash, U+2044 NEW

      // Letterlike Symbols
      "weierp"   : 8472, // script capital P = power set= Weierstrass p, U+2118 ISOamso
      "image"    : 8465, // blackletter capital I = imaginary part,U+2111 ISOamso
      "real"     : 8476, // blackletter capital R = real part symbol,U+211C ISOamso
      "trade"    : 8482, // trade mark sign, U+2122 ISOnum
      "alefsym"  : 8501, // alef symbol = first transfinite cardinal,U+2135 NEW

      // alef symbol is NOT the same as hebrew letter alef,U+05D0 although the same glyph could be used to depict both characters
      // Arrows
      "larr"     : 8592, // leftwards arrow, U+2190 ISOnum
      "uarr"     : 8593, // upwards arrow, U+2191 ISOnum-->
      "rarr"     : 8594, // rightwards arrow, U+2192 ISOnum
      "darr"     : 8595, // downwards arrow, U+2193 ISOnum
      "harr"     : 8596, // left right arrow, U+2194 ISOamsa
      "crarr"    : 8629, // downwards arrow with corner leftwards= carriage return, U+21B5 NEW
      "lArr"     : 8656, // leftwards double arrow, U+21D0 ISOtech

      // ISO 10646 does not say that lArr is the same as the 'is implied by' arrowbut also does not have any other character for that function. So ? lArr canbe used for 'is implied by' as ISOtech suggests
      "uArr"     : 8657, // upwards double arrow, U+21D1 ISOamsa
      "rArr"     : 8658, // rightwards double arrow,U+21D2 ISOtech

      // ISO 10646 does not say this is the 'implies' character but does not have another character with this function so ?rArr can be used for 'implies' as ISOtech suggests
      "dArr"     : 8659, // downwards double arrow, U+21D3 ISOamsa
      "hArr"     : 8660, // left right double arrow,U+21D4 ISOamsa

      // Mathematical Operators
      "forall"   : 8704, // for all, U+2200 ISOtech
      "part"     : 8706, // partial differential, U+2202 ISOtech
      "exist"    : 8707, // there exists, U+2203 ISOtech
      "empty"    : 8709, // empty set = null set = diameter,U+2205 ISOamso
      "nabla"    : 8711, // nabla = backward difference,U+2207 ISOtech
      "isin"     : 8712, // element of, U+2208 ISOtech
      "notin"    : 8713, // not an element of, U+2209 ISOtech
      "ni"       : 8715, // contains as member, U+220B ISOtech

      // should there be a more memorable name than 'ni'?
      "prod"     : 8719, // n-ary product = product sign,U+220F ISOamsb

      // prod is NOT the same character as U+03A0 'greek capital letter pi' though the same glyph might be used for both
      "sum"      : 8721, // n-ary summation, U+2211 ISOamsb

      // sum is NOT the same character as U+03A3 'greek capital letter sigma' though the same glyph might be used for both
      "minus"    : 8722, // minus sign, U+2212 ISOtech
      "lowast"   : 8727, // asterisk operator, U+2217 ISOtech
      "radic"    : 8730, // square root = radical sign,U+221A ISOtech
      "prop"     : 8733, // proportional to, U+221D ISOtech
      "infin"    : 8734, // infinity, U+221E ISOtech
      "ang"      : 8736, // angle, U+2220 ISOamso
      "and"      : 8743, // logical and = wedge, U+2227 ISOtech
      "or"       : 8744, // logical or = vee, U+2228 ISOtech
      "cap"      : 8745, // intersection = cap, U+2229 ISOtech
      "cup"      : 8746, // union = cup, U+222A ISOtech
      "int"      : 8747, // integral, U+222B ISOtech
      "there4"   : 8756, // therefore, U+2234 ISOtech
      "sim"      : 8764, // tilde operator = varies with = similar to,U+223C ISOtech

      // tilde operator is NOT the same character as the tilde, U+007E,although the same glyph might be used to represent both
      "cong"     : 8773, // approximately equal to, U+2245 ISOtech
      "asymp"    : 8776, // almost equal to = asymptotic to,U+2248 ISOamsr
      "ne"       : 8800, // not equal to, U+2260 ISOtech
      "equiv"    : 8801, // identical to, U+2261 ISOtech
      "le"       : 8804, // less-than or equal to, U+2264 ISOtech
      "ge"       : 8805, // greater-than or equal to,U+2265 ISOtech
      "sub"      : 8834, // subset of, U+2282 ISOtech
      "sup"      : 8835, // superset of, U+2283 ISOtech

      // note that nsup, 'not a superset of, U+2283' is not covered by the Symbol font encoding and is not included. Should it be, for symmetry?It is in ISOamsn  --> <!ENTITY nsub": 8836,  //not a subset of, U+2284 ISOamsn
      "sube"     : 8838, // subset of or equal to, U+2286 ISOtech
      "supe"     : 8839, // superset of or equal to,U+2287 ISOtech
      "oplus"    : 8853, // circled plus = direct sum,U+2295 ISOamsb
      "otimes"   : 8855, // circled times = vector product,U+2297 ISOamsb
      "perp"     : 8869, // up tack = orthogonal to = perpendicular,U+22A5 ISOtech
      "sdot"     : 8901, // dot operator, U+22C5 ISOamsb

      // dot operator is NOT the same character as U+00B7 middle dot
      // Miscellaneous Technical
      "lceil"    : 8968, // left ceiling = apl upstile,U+2308 ISOamsc
      "rceil"    : 8969, // right ceiling, U+2309 ISOamsc
      "lfloor"   : 8970, // left floor = apl downstile,U+230A ISOamsc
      "rfloor"   : 8971, // right floor, U+230B ISOamsc
      "lang"     : 9001, // left-pointing angle bracket = bra,U+2329 ISOtech

      // lang is NOT the same character as U+003C 'less than' or U+2039 'single left-pointing angle quotation mark'
      "rang"     : 9002, // right-pointing angle bracket = ket,U+232A ISOtech

      // rang is NOT the same character as U+003E 'greater than' or U+203A 'single right-pointing angle quotation mark'
      // Geometric Shapes
      "loz"      : 9674, // lozenge, U+25CA ISOpub

      // Miscellaneous Symbols
      "spades"   : 9824, // black spade suit, U+2660 ISOpub

      // black here seems to mean filled as opposed to hollow
      "clubs"    : 9827, // black club suit = shamrock,U+2663 ISOpub
      "hearts"   : 9829, // black heart suit = valentine,U+2665 ISOpub
      "diams"    : 9830, // black diamond suit, U+2666 ISOpub

      // Latin Extended-A
      "OElig"    : 338, //  -- latin capital ligature OE,U+0152 ISOlat2
      "oelig"    : 339, //  -- latin small ligature oe, U+0153 ISOlat2

      // ligature is a misnomer, this is a separate character in some languages
      "Scaron"   : 352, //  -- latin capital letter S with caron,U+0160 ISOlat2
      "scaron"   : 353, //  -- latin small letter s with caron,U+0161 ISOlat2
      "Yuml"     : 376, //  -- latin capital letter Y with diaeresis,U+0178 ISOlat2

      // Spacing Modifier Letters
      "circ"     : 710, //  -- modifier letter circumflex accent,U+02C6 ISOpub
      "tilde"    : 732, // small tilde, U+02DC ISOdia

      // General Punctuation
      "ensp"     : 8194, // en space, U+2002 ISOpub
      "emsp"     : 8195, // em space, U+2003 ISOpub
      "thinsp"   : 8201, // thin space, U+2009 ISOpub
      "zwnj"     : 8204, // zero width non-joiner,U+200C NEW RFC 2070
      "zwj"      : 8205, // zero width joiner, U+200D NEW RFC 2070
      "lrm"      : 8206, // left-to-right mark, U+200E NEW RFC 2070
      "rlm"      : 8207, // right-to-left mark, U+200F NEW RFC 2070
      "ndash"    : 8211, // en dash, U+2013 ISOpub
      "mdash"    : 8212, // em dash, U+2014 ISOpub
      "lsquo"    : 8216, // left single quotation mark,U+2018 ISOnum
      "rsquo"    : 8217, // right single quotation mark,U+2019 ISOnum
      "sbquo"    : 8218, // single low-9 quotation mark, U+201A NEW
      "ldquo"    : 8220, // left double quotation mark,U+201C ISOnum
      "rdquo"    : 8221, // right double quotation mark,U+201D ISOnum
      "bdquo"    : 8222, // double low-9 quotation mark, U+201E NEW
      "dagger"   : 8224, // dagger, U+2020 ISOpub
      "Dagger"   : 8225, // double dagger, U+2021 ISOpub
      "permil"   : 8240, // per mille sign, U+2030 ISOtech
      "lsaquo"   : 8249, // single left-pointing angle quotation mark,U+2039 ISO proposed
      // lsaquo is proposed but not yet ISO standardized
      "rsaquo"   : 8250, // single right-pointing angle quotation mark,U+203A ISO proposed
      // rsaquo is proposed but not yet ISO standardized
      "euro"     : 8364 //  -- euro sign, U+20AC NEW
    }
  }

} );

/*******************************************************************************
 * Copyright (c) 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

/*jshint newcap: false */
namespace( "rwt.runtime" );

rwt.runtime.Singletons = {

  _holder : {},
  _sequence : 0,

  get : function( type ) {
    var id = this._getId( type );
    if( !this._holder[ id ] ) {
      this._holder[ id ] = new type();
    }
    return this._holder[ id ];
  },

  clear : function( type ) {
    if( type ) {
      this._clearId( this._getId( type ) );
    } else {
      for( var id in this._holder ) {
        this._dispose( this._holder[ id ] );
      }
      this._holder = {};
    }
  },

  // NOTE: Marked "private" since it's supposed to be a temporary solution that should not be used
  //       anywhere but TestUtil.js. Remove once tests don't need it anymore.
  _clearExcept : function( types ) {
    for( var id in this._holder ) {
      if( !this._isException( this._holder[ id ], types ) ) {
        this._clearId( id );
      }
    }
  },

  _isException : function( instance, exceptions ) {
    for( var i = 0; i < exceptions.length; i++ ) {
      if( instance instanceof exceptions[ i ] ) {
        return true;
      }
    }
    return false;
  },

  _clearId : function( id ) {
    if( this._holder[ id ] ) {
      this._dispose( this._holder[ id ] );
    }
    delete this._holder[ id ];
  },

  _getId : function( type ) {
    if( typeof type.__singleton === "undefined" ) {
      type.__singleton = "s" + this._sequence++;
    }
    return type.__singleton;
  },

  _dispose : function( instance ) {
    if( typeof instance.destroy === "function" ) {
      instance.destroy();
    } else if( typeof instance.dispose === "function" ) {
      instance.dispose();
    }
  }

};


/*******************************************************************************
 * Copyright (c) 2004, 2015 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource, and others.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

namespace( "rwt.event" );


rwt.event.EventHandlerUtil = {

  _lastUpDownType : {},
  _lastKeyCode : null,

  cleanUp : function() {
    delete this.__onKeyEvent;
    delete this._lastUpDownType;
    delete this._lastKeyCode;
  },

  applyBrowserFixes  : rwt.util.Variant.select( "qx.client", {
    "gecko" : function() {
      // Fix for bug 295475:
      // Prevent url-dropping in FF as a whole (see bug 304651)
      var doc = rwt.widgets.base.ClientDocument.getInstance();
      doc.getElement().setAttribute( "ondrop", "event.preventDefault();" );
      var docElement = document.documentElement;
      // also see ErrorHandler.js#_enableTextSelection
      this._ffMouseFixListener = function( event ) {
        var tagName = null;
        try {
          tagName = event.originalTarget.tagName;
        } catch( e ) {
          // Firefox bug: On the very first mousedown, access to the events target
          // is forbidden and causes an error.
        }
        // NOTE: See also Bug 321372
        if( event.button === 0 && tagName != null && tagName != "INPUT" ) {
          event.preventDefault();
        }
      };
      docElement.addEventListener( "mousedown", this._ffMouseFixListener, false );
    },
    "default" : function() { }
  } ),

  /////////////////////////
  // GENERAL EVENT HANDLING

  getDomTarget : rwt.util.Variant.select( "qx.client", {
    "webkit|blink" : function( vDomEvent ) {
      var vNode = vDomEvent.target || vDomEvent.srcElement;
      // Safari takes text nodes as targets for events
      if( vNode && ( vNode.nodeType == rwt.html.Nodes.TEXT ) ) {
        vNode = vNode.parentNode;
      }
      return vNode;
    },
    "default" : function( vDomEvent ) {
      return vDomEvent.target;
    }
  } ),

  stopDomEvent : function( vDomEvent ) {
    vDomEvent._prevented = true;
    if( vDomEvent.preventDefault ) {
      vDomEvent.preventDefault();
    }
    try {
      // this allows us to prevent some key press events in IE and Firefox.
      // See bug #1049
      vDomEvent.keyCode = 0;
    } catch( ex ) {
      // do nothing
    }
    vDomEvent.returnValue = false;
  },

  wasStopped : function( domEvent ) {
    return domEvent._prevented ? true : false;
  },


  blockUserDomEvents : function( element, value ) {
    if( value ) {
      for( var i = 0; i < this._userEventTypes.length; i++ ) {
        element.addEventListener( this._userEventTypes[ i ], this._domEventBlocker, false );
      }
    } else {
      for( var i = 0; i < this._userEventTypes.length; i++ ) {
        element.removeEventListener( this._userEventTypes[ i ], this._domEventBlocker, false );
      }
    }
  },

  _userEventTypes : [
    "mouseover",
    "mousemove",
    "mouseout",
    "mousedown",
    "mouseup",
    "click",
    "dblclick",
    "contextmenu",
    ( rwt.client.Client.isGecko() ? "DOMMouseScroll" : "mousewheel" ),
    "keydown",
    "keypress",
    "keyup"
  ],

  _domEventBlocker : function( event ) {
    rwt.event.EventHandlerUtil.stopDomEvent( event );
    event.cancelBubble = true; // MSIE
    if( event.stopPropagation ) {
      event.stopPropagation();
    }
  },

  // BUG: http://xscroll.mozdev.org/
  // If your Mozilla was built with an option `--enable-default-toolkit=gtk2',
  // it can not return the correct event target for DOMMouseScroll.
  getOriginalTargetObject : function( vNode ) {
    // Events on the HTML element, when using absolute locations which
    // are outside the HTML element. Opera does not seem to fire events
    // on the HTML element.
    if( vNode == document.documentElement ) {
      vNode = document.body;
    }
    // Walk up the tree and search for an rwt.widgets.base.Widget
    try {
      while( vNode != null && vNode.rwtWidget == null )       {
        vNode = vNode.parentNode;
      }
    } catch( vDomEvent ) {
      vNode = null;
    }
    return vNode ? vNode.rwtWidget : null;
  },

  getOriginalTargetObjectFromEvent : function( vDomEvent, vWindow ) {
    var vNode = this.getDomTarget( vDomEvent );
    // Especially to fix key events.
    // 'vWindow' is the window reference then
    if( vWindow ) {
      var vDocument = vWindow.document;
      if(    vNode == vWindow
          || vNode == vDocument
          || vNode == vDocument.documentElement
          || vNode == vDocument.body )
      {
        return vDocument.body.rwtWidget;
      }
    }
    return this.getOriginalTargetObject( vNode );
  },

  getRelatedTargetObjectFromEvent : function( vDomEvent ) {
    var EventHandlerUtil = rwt.event.EventHandlerUtil;
    var target = vDomEvent.relatedTarget;
    if( !target ) {
      if( vDomEvent.type == "mouseover" ) {
        target = vDomEvent.fromElement;
      } else {
        target = vDomEvent.toElement;
      }
    }
    return EventHandlerUtil.getTargetObject( target );
  },

  getTargetObject : function( vNode, vObject, allowDisabled ) {
    if( !vObject ) {
      var vObject = this.getOriginalTargetObject( vNode );
      if( !vObject ) {
        return null;
      }
    }
    while( vObject ) {
      if( !allowDisabled && !vObject.getEnabled() ) {
        return null;
      }
      if( !vObject.getAnonymous() ) {
        break;
      }
      vObject = vObject.getParent();
    }
    return vObject;
  },

  /////////////////
  // MOUSE HANDLING

  handleFocusedChild : function( target ) {
    if( target.getEnabled() && !( target instanceof rwt.widgets.base.ClientDocument ) ) {
      rwt.widgets.util.FocusHandler.mouseFocus = true;
      var root = target.getFocusRoot();
      if( root ) {
        rwt.event.EventHandler.setFocusRoot( root );
        var focusTarget = target;
        while( !focusTarget.isFocusable() && focusTarget != root ) {
          focusTarget = focusTarget.getParent();
        }
        // We need to focus first and active afterwards.
        // Otherwise the focus will activate another widget if the
        // active one is not tabable.
        root.setFocusedChild( focusTarget );
        root.setActiveChild( target );
      }
    }
  },

  ///////////////
  // KEY HANDLING

  getKeyCode : rwt.util.Variant.select( "qx.client", {
    "gecko" : function( event ) {
      return event.keyCode;
    },
    "default" : function( event ) {
      // the value in "keyCode" on "keypress" is actually the charcode:
      var hasKeyCode = event.type !== "keypress" || event.keyCode === 13 || event.keyCode === 27;
      return hasKeyCode ? event.keyCode : 0;
    }
  } ),

  getCharCode : rwt.util.Variant.select( "qx.client", {
    "default" : function( event ) {
      var hasCharCode = event.type === "keypress" && event.keyCode !== 13 && event.keyCode !== 27;
      return hasCharCode ? event.charCode : 0;
    },
    "trident" : function( event ) {
      var hasCharCode = event.type === "keypress" && event.keyCode !== 13 && event.keyCode !== 27;
      return hasCharCode ? event.keyCode : 0;
    }
  } ),

  isFirstKeyDown : function( keyCode ) {
    return this._lastUpDownType[ keyCode ] !== "keydown";
  },

  getEventPseudoTypes : rwt.util.Variant.select( "qx.client", {
    "default" : function( event, keyCode ) {
      var result;
      if( event.type === "keydown" ) {
        var printable = !this.isNonPrintableKeyCode( keyCode );
        if( this.isFirstKeyDown( keyCode ) ) {
          // add a "keypress" for non-printable keys:
          result = printable ? [ "keydown" ] : [ "keydown", "keypress" ];
        } else {
          // convert non-printable "keydown" to "keypress", suppress other:
          result = printable ? [] : [ "keypress" ];
        }
      } else {
        result = [ event.type ];
      }
      return result;
    },
    "gecko" : function( event, keyCode ) {
      var result;
      if( event.type === "keydown" && this.isModifier( keyCode ) ) {
        if( this.isFirstKeyDown( keyCode ) ) {
          result = [ "keydown", "keypress" ];
        } else {
          result = [ "keypress" ];
        }
      } else {
        if( event.type === "keydown" && !this.isFirstKeyDown( keyCode ) ) {
          // suppress unwanted "keydown":
          result = [];
        } else {
          result = [ event.type ];
        }
      }
      return result;
    }
  } ),

  mustRestoreKeyup  : function( keyCode, pseudoTypes  ) {
    // For these keys it is assumed to be more likely that a keyup event was missed
    // than the key being hold down while another key is pressed.
    var result = [];
    if( pseudoTypes[ 0 ] === "keydown" ) {
      if( !this.isFirstKeyDown( 93 ) && keyCode !== 93 ) {
        result.push( 93 );
      }
    }
    return result;
  },

  mustRestoreKeypress  : rwt.util.Variant.select( "qx.client", {
    "default" : function( event, pseudoTypes ) {
      var result = false;
      if( this.wasStopped( event ) ) {
        result =    ( pseudoTypes.length === 1 && pseudoTypes[ 0 ] === "keydown" )
                 || pseudoTypes.length === 0;
      }
      return result;
    },
    "gecko" : function() {
      return false;
    }
  } ),

  saveData : function( event, keyCode ) {
    if( event.type !== "keypress" ) {
      this._lastUpDownType[ keyCode ] = event.type;
      this._lastKeyCode = keyCode;
    }
  },

  clearStuckKey : function( keyCode ) {
    this._lastUpDownType[ keyCode ] = "keyup";
  },

  keyCodeToIdentifier : function( keyCode ) {
    var result = "Unidentified";
    if( this._numpadToCharCode[ keyCode ] !== undefined ) {
      result = String.fromCharCode( this._numpadToCharCode[ keyCode ] );
    } else if( this._keyCodeToIdentifierMap[ keyCode ] !== undefined ) {
      result = this._keyCodeToIdentifierMap[ keyCode ];
    } else if( this._specialCharCodeMap[ keyCode ] !== undefined ) {
      result = this._specialCharCodeMap[ keyCode ];
    } else if( this.isAlphaNumericKeyCode( keyCode ) ) {
      result = String.fromCharCode( keyCode );
    }
    return result;
  },

  charCodeToIdentifier : function( charCode ) {
    var result;
    if( this._specialCharCodeMap[ charCode ] !== undefined ) {
      result = this._specialCharCodeMap[ charCode ];
    } else {
      result = String.fromCharCode( charCode ).toUpperCase();
    }
    return result;
  },

  isNonPrintableKeyCode  : rwt.util.Variant.select( "qx.client", {
    "default" : function( keyCode ) {
      return this._keyCodeToIdentifierMap[ keyCode ] ? true : false;
    },
    "webkit|blink" : function( keyCode ) {
      return ( this._keyCodeToIdentifierMap[ keyCode ] || keyCode === 27 ) ? true : false;
    }
  } ),

  isSpecialKeyCode : function( keyCode ) {
    return this._specialCharCodeMap[ keyCode ] ? true : false;
  },

  isModifier : function( keyCode ) {
    return keyCode >= 16 && keyCode <= 20 && keyCode !== 19;
  },

  isAlphaNumericKeyCode : function( keyCode ) {
    var result = false;
    if(    ( keyCode >= this._charCodeA && keyCode <= this._charCodeZ )
        || ( keyCode >= this._charCode0 && keyCode <= this._charCode9 ) )
    {
      result = true;
    }
    return result;
  },

  /**
   * Determines if this key event should be blocked if key events are disabled
   */
  shouldBlock : function( type, keyCode, charCode, event ) {
    var result = true;
    var keyIdentifier;
    if( !isNaN( keyCode ) && keyCode !== 0 ) {
      keyIdentifier = this.keyCodeToIdentifier( keyCode );
    } else {
      keyIdentifier = this.charCodeToIdentifier( charCode );
    }
    if( this._nonBlockableKeysMap[ keyIdentifier ] || event.altKey ) {
      result = false;
    } else if( event.ctrlKey ) {
      // block only those combos that are used for text editing:
      result = this._blockableCtrlKeysMap[ keyIdentifier ] === true;
    }
    return result;
  },

  getElementAt : function( x, y ) {
    return document.elementFromPoint( x, y );
  },

  ///////////////
  // Helper-maps:

  _specialCharCodeMap : {
    13  : "Enter",
    27  : "Escape",
    32 : "Space"
  },

  _nonBlockableKeysMap : {
    "Control" : true,
    "Alt" : true,
    "Shift" : true,
    "Meta" : true,
    "Win" : true,
    "F1" : true,
    "F2" : true,
    "F3" : true,
    "F4" : true,
    "F5" : true,
    "F6" : true,
    "F7" : true,
    "F8" : true,
    "F9" : true,
    "F10" : true,
    "F11" : true,
    "F12" : true
  },

  _blockableCtrlKeysMap : {
    "F" : true,
    "A" : true,
    "C" : true,
    "V" : true,
    "X" : true,
    "Z" : true,
    "Y" : true
  },

  _keyCodeToIdentifierMap : {
    8   : "Backspace",
    9   : "Tab",
    16  : "Shift",
    17  : "Control",
    18  : "Alt",
    20  : "CapsLock",
    224 : "Meta",
    37  : "Left",
    38  : "Up",
    39  : "Right",
    40  : "Down",
    33  : "PageUp",
    34  : "PageDown",
    35  : "End",
    36  : "Home",
    45  : "Insert",
    46  : "Delete",
    112 : "F1",
    113 : "F2",
    114 : "F3",
    115 : "F4",
    116 : "F5",
    117 : "F6",
    118 : "F7",
    119 : "F8",
    120 : "F9",
    121 : "F10",
    122 : "F11",
    123 : "F12",
    144 : "NumLock",
    44  : "PrintScreen",
    145 : "Scroll",
    19  : "Pause",
    91  : "Win", // The Windows Logo key
    93  : "Apps" // The Application key (Windows Context Menu)
  },

  /** maps the keycodes of the numpad keys to the right charcodes */
  _numpadToCharCode : {
    96  : "0".charCodeAt( 0 ),
    97  : "1".charCodeAt( 0 ),
    98  : "2".charCodeAt( 0 ),
    99  : "3".charCodeAt( 0 ),
    100 : "4".charCodeAt( 0 ),
    101 : "5".charCodeAt( 0 ),
    102 : "6".charCodeAt( 0 ),
    103 : "7".charCodeAt( 0 ),
    104 : "8".charCodeAt( 0 ),
    105 : "9".charCodeAt( 0 ),
    106 : "*".charCodeAt( 0 ),
    107 : "+".charCodeAt( 0 ),
    109 : "-".charCodeAt( 0 ),
    110 : ",".charCodeAt( 0 ),
    111 : "/".charCodeAt( 0 )
  },

  _charCodeA : "A".charCodeAt( 0 ),
  _charCodeZ : "Z".charCodeAt( 0 ),
  _charCode0 : "0".charCodeAt( 0 ),
  _charCode9 : "9".charCodeAt( 0 )

};

/*******************************************************************************
 * Copyright (c) 2011, 2012 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

namespace( "rwt.remote" );

rwt.remote.HandlerRegistry = {

  _registry : {},

  add : function( key, handler ) {
    this._registry[ key ] = handler;
  },

  remove : function( key ) {
    delete this._registry[ key ];
  },

  getHandler : function( key ) {
    var result = this._registry[ key ];
    if( result === undefined ) {
      throw new Error( "No Handler for type " + key );
    }
    return result;
  },

  hasHandler : function( key ) {
    return this._registry[ key ] != null;
  }

};

/*******************************************************************************
 * Copyright (c) 2011, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

namespace( "rwt.remote" );

rwt.remote.ObjectRegistry = {

  _map : {},
  _callbacks : {},

  add : function( id, object, handler ) {
    this._map[ id ] = {
      "object" : object,
      "handler" : handler
    };
    object._rwtId = id;
    if( typeof object.applyObjectId === "function" ) {
      object.applyObjectId( id );
    }
    if( this._callbacks[ id ] ) {
      for( var i = 0; i < this._callbacks[ id ].length; i++ ) {
        this._callbacks[ id ][ i ]( object );
      }
      delete this._callbacks[ id ];
    }
  },

  remove : function( id ) {
    if( id != null && this._map[ id ] != null) {
      delete this._map[ id ].object._rwtId;
      delete this._map[ id ];
    }
  },

  getId : function( object ) {
    var result = null;
    if( object != null && object._rwtId != null ) {
      result = object._rwtId;
    }
    return result;
  },

  getObject : function( id ) {
    var entry = this.getEntry( id );
    return entry ? entry.object : null;
  },

  containsObject : function( object ) {
    return object ? object._rwtId != null : false;
  },

  getEntry : function( id ) {
    var result = this._map[ id ];
    if( result == null && rwt.remote.HandlerRegistry.hasHandler( id ) ) {
      var handler = rwt.remote.HandlerRegistry.getHandler( id );
      if( handler.service === true ) {
        this.add( id, handler.factory(), handler );
        result = this._map[ id ];
      }
    }
    return result;
  },

  addRegistrationCallback : function( id, fun ) {
    if( !this._callbacks[ id ] ) {
      this._callbacks[ id ] = [];
    }
    this._callbacks[ id ].push( fun );
  }

};

/*******************************************************************************
 * Copyright (c) 2011, 2015 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

namespace( "rwt.remote" );

rwt.remote.HandlerUtil = {

  SERVER_DATA : "org.eclipse.swt.widgets.Widget#data",

  _controlDestructor : function( widget ) {
    rwt.remote.HandlerUtil._widgetDestructor( widget );
  },

  _childrenFinder : function( widget ) {
    return rwt.remote.HandlerUtil.getDestroyableChildren( widget );
  },

  _widgetDestructor : function( widget ) {
    var parent = widget.getUserData( "protocolParent" );
    if( parent ) {
      rwt.remote.HandlerUtil.removeDestroyableChild( parent, widget );
    }
    widget.setToolTipText( null );
    widget.destroy();
  },

  _controlProperties : [
    "parent",
    "children",
    "tabIndex",
    "toolTipMarkupEnabled",
    /**
     * @name setToolTipText
     * @methodOf Control#
     * @description Sets the receiver's tool tip text to the argument, which
     * may be null indicating that no tool tip text should be shown.
     * @param {string|null} toolTipText the new tool tip text (or null)
     */
    "toolTip",
    /**
     * @name setVisible
     * @methodOf Control#
     * @description Marks the receiver as visible if the argument is <code>true</code>,
     * and marks it invisible otherwise.
     * <p>
     * If one of the receiver's ancestors is not visible or some
     * other condition makes the receiver not visible, marking
     * it visible may not actually cause it to be displayed.
     * </p>
     * <p>
     * <b>NOTE:</b> If there is a <code>Show</code> or <code>Hide</code> Java listener attached
     * to this widget, it may be notified at a later point in time. <code>ClientListener</code>
     * are notified right away.
     * </p>
     * @param {boolean} visible the new visibility state
     */
    "visibility",
    /**
     * @name setEnabled
     * @methodOf Control#
     * @description Enables the receiver if the argument is <code>true</code>,
     * and disables it otherwise. A disabled control is typically
     * not selectable from the user interface and draws with an
     * inactive or "grayed" look.
     *
     * @param {boolean} enabled the new enabled state
     */
    "enabled",
    /**
     * @name setForeground
     * @methodOf Control#
     * @description Sets the receiver's foreground color to the color specified
     * by the argument, or to the default system color for the control
     * if the argument is null.
     * @param {int[]|null} color the new color as array [ red, green, blue ] or null
     */
    "foreground",
    /**
     * @name setBackground
     * @methodOf Control#
     * @description Sets the receiver's background color to the color specified
     * by the argument, or to the default system color for the control
     * if the argument is null.
     * @param {int[]|null} color the new color as array [ red, green, blue ] or null
     */
    "background",
    "backgroundImage",
    /**
     * @name setCursor
     * @methodOf Control#
     * Sets the receiver's cursor to the cursor specified by the
     * argument, or to the default cursor for that kind of control
     * if the argument is null.
     * <p>
     * When the mouse pointer passes over a control its appearance
     * is changed to match the control's cursor.
     * </p>
     * <p>
     * All possible values are available as constants on the {@link SWT} object.
     * </p>
     * @param {string|null} cursor the new cursor (or null)
     */
    "cursor",
    "customVariant",
    "bounds",
    "font",
    "menu",
    "activeKeys",
    "cancelKeys",
    "data"
  ],

  _controlPropertyHandler : {
    "parent" : function( widget, value ) {
      var oldParent = widget.getParent();
      var oldParentId = oldParent == null ? null : rwt.remote.ObjectRegistry.getId( oldParent );
      if( oldParentId !== value ) {
        widget.setUserData( "scrolledComposite", null );
        widget.setUserData( "tabFolder", null );
        if( oldParent != null ) {
          rwt.remote.HandlerUtil.removeDestroyableChild( oldParent, widget );
        }
        rwt.remote.HandlerUtil.setParent( widget, value );
      }
    },
    "data" : function( target, value ) {
      var map = rwt.remote.HandlerUtil.getServerData( target );
      rwt.util.Objects.mergeWith( map, value );
      target.dispatchSimpleEvent( "dataChanged" );
    },
    "children" : function( widget, value ) {
      if( value !== null ) {
        var childrenCount = value.length;
        var applyZIndex = function( child ) {
          var index = value.indexOf( rwt.remote.ObjectRegistry.getId( child ) );
          child.setZIndex( childrenCount - index );
        };
        for( var i = 0; i < childrenCount; i++ ) {
          rwt.remote.HandlerUtil.callWithTarget( value[ i ], applyZIndex );
        }
      }
      widget.setUserData( "rwt_Children", value );
    },
    "foreground" : function( widget, value ) {
      if( value === null ) {
        widget.resetTextColor();
      } else {
        widget.setTextColor( rwt.util.Colors.rgbToRgbString( value ) );
      }
    },
    "background" : function( widget, value ) {
      if( value === null ) {
        widget.resetBackgroundColor();
        if( widget.__user$backgroundGradient == null ) {
          widget.resetBackgroundGradient();
        }
      } else {
        if( widget.__user$backgroundGradient == null ) {
          widget.setBackgroundGradient( null );
        }
        var color = value[ 3 ] === 0 ? "transparent" : rwt.util.Colors.rgbToRgbString( value );
        widget.setBackgroundColor( color );
      }
    },
    "backgroundImage" : function( widget, value ) {
      if( value === null ) {
        widget.resetBackgroundImage();
        widget.setUserData( "backgroundImageSize", null );
      } else {
        widget.setUserData( "backgroundImageSize", value.slice( 1 ) );
        widget.setBackgroundImage( value[ 0 ] );
      }
    },
    "cursor" : function( widget, value ) {
      if( value === null ) {
        widget.resetCursor();
      } else {
        widget.setCursor( value );
      }
    },
    "bounds" : function( widget, value ) {
      var bounds = value;
      if( widget.getUserData( "tabFolder" ) !== null ) {
        bounds[ 0 ] = 0;
        bounds[ 1 ] = 0;
      }
      if( widget.getUserData( "scrolledComposite" ) === null ) {
        widget.setLeft( bounds[ 0 ] );
        widget.setTop( bounds[ 1 ] );
      }
      widget.setWidth( bounds[ 2 ] );
      widget.setHeight( bounds[ 3 ] );
    },
    "toolTipMarkupEnabled" : function( widget, value ) {
      widget.setUserData( "toolTipMarkupEnabled", value );
    },
    "toolTip" : function( widget, value ) {
      rwt.widgets.base.WidgetToolTip.setToolTipText( widget, value );
    },
    "font" : function( widget, fontData ) {
      if( widget.setFont ) { // test if font property is supported - why wouldn't it? [tb]
        if( fontData === null ) {
          widget.resetFont();
        } else {
          var font = rwt.html.Font.fromArray( fontData );
          widget.setFont( font );
        }
      }
    },
    "menu" : function( widget, value ) {
      rwt.remote.HandlerUtil.callWithTarget( value, function( menu ) {
        widget.setContextMenu( menu );
        var detectByKey = rwt.widgets.Menu.menuDetectedByKey;
        var detectByMouse = rwt.widgets.Menu.menuDetectedByMouse;
        if( menu == null ) {
          widget.removeEventListener( "keydown", detectByKey );
          widget.removeEventListener( "mouseup", detectByMouse );
        } else {
          widget.addEventListener( "keydown", detectByKey );
          widget.addEventListener( "mouseup", detectByMouse );
        }
      } );
    },
    "activeKeys" : function( widget, value ) {
      var map = rwt.util.Objects.fromArray( value );
      widget.setUserData( "activeKeys", map );
    },
    "cancelKeys" : function( widget, value ) {
      var map = rwt.util.Objects.fromArray( value );
      widget.setUserData( "cancelKeys", map );
    }
  },

  _controlListeners : [
    "FocusIn",
    "FocusOut",
    "MouseDown",
    "MouseUp",
    "MouseDoubleClick",
    "KeyDown",
    "Traverse",
    "MenuDetect",
    "Help",
    "Activate",
    "Deactivate"
  ],

  _controlListenerHandler : {
    "KeyDown" : function( widget, value ) {
      widget.setUserData( "keyListener", value ? true : null );
    },
    "Traverse" : function( widget, value ) {
      widget.setUserData( "traverseListener", value ? true : null );
    },
    "FocusIn" : function( widget, value ) {
      var context = rwt.remote.EventUtil;
      var focusGained = rwt.remote.EventUtil.focusGained;
      if( value ) {
        widget.addEventListener( "focusin", focusGained, context );
      } else {
        widget.removeEventListener( "focusin", focusGained, context );
      }
    },
    "FocusOut" : function( widget, value ) {
      var context = rwt.remote.EventUtil;
      var focusLost = rwt.remote.EventUtil.focusLost;
      if( value ) {
        widget.addEventListener( "focusout", focusLost, context );
      } else {
        widget.removeEventListener( "focusout", focusLost, context );
      }
    },
    "MouseDown" : function( widget, value ) {
      var context;
      var mouseDown = rwt.remote.EventUtil.mouseDown;
      if( value ) {
        widget.addEventListener( "mousedown", mouseDown, context );
      } else {
        widget.removeEventListener( "mousedown", mouseDown, context );
      }
    },
    "MouseUp" : function( widget, value ) {
      var context;
      var mouseUp = rwt.remote.EventUtil.mouseUp;
      if( value ) {
        widget.addEventListener( "mouseup", mouseUp, context );
      } else {
        widget.removeEventListener( "mouseup", mouseUp, context );
      }
    },
    "MouseDoubleClick" : function( widget, value ) {
      var context;
      var mouseDoubleClick = rwt.remote.EventUtil.mouseDoubleClick;
      var mouseUpCounter = rwt.remote.EventUtil.mouseUpCounter;
      if( value ) {
        widget.addEventListener( "mousedown", mouseDoubleClick, context );
        widget.addEventListener( "mouseup", mouseUpCounter, context );
      } else {
        widget.removeEventListener( "mousedown", mouseDoubleClick, context );
        widget.removeEventListener( "mouseup", mouseUpCounter, context );
      }
    },
    "MenuDetect" : function( widget, value ) {
      var context;
      var detectByKey = rwt.remote.EventUtil.menuDetectedByKey;
      var detectByMouse = rwt.remote.EventUtil.menuDetectedByMouse;
      if( value ) {
        widget.addEventListener( "keydown", detectByKey, context );
        widget.addEventListener( "mouseup", detectByMouse, context );
      } else {
        widget.removeEventListener( "keydown", detectByKey, context );
        widget.removeEventListener( "mouseup", detectByMouse, context );
      }
    },
    "Help" : function( widget, value ) {
      var context;
      var helpRequested = rwt.remote.EventUtil.helpRequested;
      if( value ) {
        widget.addEventListener( "keydown", helpRequested, context );
      } else {
        widget.removeEventListener( "keydown", helpRequested, context );
      }
    },
    "Activate" : function( widget, value ) {
      widget.setUserData( "activateListener", value ? true : null );
    },
    "Deactivate" : function( widget, value ) {
      widget.setUserData( "deactivateListener", value ? true : null );
    }
  },

  _specialHandler : {
    "backgroundGradient" : function( widget, value ) {
      var gradient = null;
      if( value ) {
        var colors = value[ 0 ];
        var percents = value[ 1 ];
        var vertical = value[ 2 ];
        gradient = [];
        for( var i = 0; i < colors.length; i++ ) {
          gradient[ i ] = [ percents[ i ] / 100, rwt.util.Colors.rgbToRgbString( colors[ i ] ) ];
        }
        gradient.horizontal = !vertical;
      }
      widget.setBackgroundGradient( gradient );
    },
    "roundedBorder" : function( widget, value ) {
      if( value ) {
        var width = value[ 0 ];
        var color = rwt.util.Colors.rgbToRgbString( value[ 1 ] );
        var radii = value.slice( -4 );
        var border = new rwt.html.Border( width, "solid", color, radii );
        widget.setBorder( border );
      } else {
        widget.resetBorder();
      }
    }
  },

  _listenerMethodHandler : {
    "addListener": function( widget, properties ) {
      rwt.remote.HandlerUtil.callWithTarget( properties.listenerId, function( targetFunction ) {
        rwt.scripting.EventBinding.addListener( widget, properties.eventType, targetFunction );
      } );
    },
    "removeListener": function( widget, properties ) {
      rwt.remote.HandlerUtil.callWithTarget( properties.listenerId, function( targetFunction ) {
        rwt.scripting.EventBinding.removeListener( widget, properties.eventType, targetFunction );
      } );
    }
  },

  /**
   * @private
   * @class RWT Scripting analog to org.eclipse.swt.widgets.Control. All controls given by
   * {@link rap.getObject} are instances of this type, even if their specific subtype is not
   * documented.
   * @name Control
   * @extends Widget
   * @description The constructor is not public.
   * @since 2.2
   */
  _controlScriptingMethods : /** @lends Control.prototype */ {

    /**
     * @description  Forces the receiver to have the <em>keyboard focus</em>, causing
     * all keyboard events to be delivered to it.
     * @return {boolean} <code>true</code> if the control got focus, and <code>false</code> if it was unable to.
     */
    forceFocus : function() {
      var result = false;
      if( this.getEnabled() && rwt.widgets.util.WidgetUtil.isVisible( this ) ) {
        var id = rwt.remote.ObjectRegistry.getId( this );
        rwt.widgets.Display.getCurrent().setFocusControl( id );
        result = true;
      }
      return result;
    },

    /**
     * @description Returns the receiver's background color.
     * @return {int[]} the background color as array [ red, green, blue ]
     */
    getBackground : function() {
      return rwt.util.Colors.stringToRgb( this.getBackgroundColor() );
    },

    /**
     * @description Returns the receiver's foreground color.
     * @return {int[]} the foreground color as array [ red, green, blue ]
     */
    getForeground : function() {
      return rwt.util.Colors.stringToRgb( this.getTextColor() );
    },

    /**
    * @description Returns the receiver's tool tip text, or null if it has
    * not been set.
    * @return {string|null} the receiver's tool tip text
    */
    getToolTipText : function() {
      return this.getToolTipText();
    },

    /**
    * @description Returns <code>true</code> if the receiver is visible, and
    * <code>false</code> otherwise.
    * <p>
    * If one of the receiver's ancestors is not visible or some
    * other condition makes the receiver not visible, this method
    * may still indicate that it is considered visible even though
    * it may not actually be showing.
    * </p>
    * @return {boolean} the receiver's visibility state
    */
    getVisible : function() {
      return this.getVisibility();
    },

    /**
    * @description Returns <code>true</code> if the receiver is enabled, and
    * <code>false</code> otherwise. A disabled control is typically
    * not selectable from the user interface and draws with an
    * inactive or "grayed" look.
    * @return {boolean} the receiver's enabled state
    */
    getEnabled : function() {
     return this.getEnabled();
    },

    /**
    * @description Returns the receiver's cursor, or null if it has not been set.
    * <p>
    * When the mouse pointer passes over a control its appearance
    * is changed to match the control's cursor.
    * </p>
    * <p>
    * All possible values are available as constants on the {@link SWT} object.
    * </p>
    * @return {string|null} the receiver's cursor or <code>null</code>
    */
    getCursor : function() {
      return this.__user$cursor || null;
    }

  },

  _widgetScriptingMethods : /** @lends Widget.prototype */ {

    /**
     * @name addListener
     * @methodOf Control#
     * @description Register the function as a listener of the given type
     * @param {string} type The type of the event (e.g. SWT.Resize).
     * @param {Function} listener The callback function. It is executed in global context.
     */
    addListener : function( type, listener ) {
      rwt.scripting.EventBinding.addListener( this, type, listener );
    },

    /**
     * @name removeListener
     * @methodOf Control#
     * @description De-register the function as a listener of the given type
     * @param {string} type The type of the event (e.g. SWT.Resize).
     * @param {Function} listener The callback function
     */
    removeListener : function( type, listener ) {
      rwt.scripting.EventBinding.removeListener( this, type, listener );
    },

    /**
     * @description Sets the application defined property of the receiver
     * with the specified name to the given value.
     * <p>
     *   The java widget is not affected by this method, but can itself set this object's
     *   properties if the name was registered with WidgetUtil.registerDataKeys.
     * </p>
     * @param {string} property the name of the property
     * @param {*} value the new value for the property
     * @see Widget#getData
     */
    setData : function( property, value ) {
      if( arguments.length !== 2 ) {
        var msg =  "Wrong number of arguments in setData: Expected 2, found " + arguments.length;
        throw new Error( msg );
      }
      var data = rwt.remote.HandlerUtil.getServerData( this );
      data[ property ] = value;
      this.dispatchSimpleEvent( "dataChanged" );
    },

    /**
     * @description  Returns the application defined property of the receiver
     * with the specified name, or null if it has not been set.
     * <p>
     *   The java widget properties can be accessed if the
     *   property name was registered with WidgetUtil.registerDataKeys.
     * </p>
     * @param {string} property the name of the property
     * @return {*} the value
     * @see Widget#setData
     */
    getData : function( property ) {
      if( arguments.length !== 1 ) {
        var msg =  "Wrong number of arguments in getData: Expected 1, found " + arguments.length;
        throw new Error( msg );
      }
      var result = null;
      var data = rwt.remote.HandlerUtil.getServerData( this );
      if( typeof data[ property ] !== "undefined" ) {
        result = data[ property ];
      }
      return result;
    }

  },

  ////////////////////
  // lists and handler

  getWidgetDestructor : function() {
    return this._widgetDestructor;
  },

  getControlDestructor : function() {
    return this._controlDestructor;
  },

  getDestroyableChildrenFinder : function() {
    return this._childrenFinder;
  },

  extendControlProperties : function( list ) {
    return list.concat( this._controlProperties );
  },

  extendControlPropertyHandler : function( handler ) {
    return rwt.util.Objects.mergeWith( handler, this._controlPropertyHandler, false );
  },

  extendListenerMethodHandler : function( handler ) {
    return rwt.util.Objects.mergeWith( handler, this._listenerMethodHandler, false );
  },

  extendControlListeners : function( list ) {
    return list.concat( this._controlListeners );
  },

  extendControlListenerHandler : function( handler ) {
    return rwt.util.Objects.mergeWith( handler, this._controlListenerHandler, false );
  },

  extendControlScriptingMethods : function( methods ) {
    return rwt.util.Objects.mergeWith( methods, this._controlScriptingMethods, false );
  },

  getBackgroundGradientHandler : function() {
    return this._specialHandler.backgroundGradient;
  },

  getRoundedBorderHandler : function() {
    return this._specialHandler.roundedBorder;
  },

  getControlPropertyHandler : function( property ) {
    return this._controlPropertyHandler[ property ];
  },

  getControlListenerHandler : function( handler ) {
    return this._controlListenerHandler[ handler ];
  },

  /////////////////////
  // Helper for handler

  addStatesForStyles : function( targetObject, styleArray ) {
    if( styleArray ) {
      for( var i = 0; i < styleArray.length; i++ ) {
        targetObject.addState( "rwt_" + styleArray[ i ] );
      }
    }
    targetObject._renderAppearance();
    delete targetObject._isInGlobalStateQueue;
  },

  createStyleMap : function( styleArray ) {
    var result = {};
    if( styleArray ) {
      for( var i = 0; i < styleArray.length; i++ ) {
        result[ styleArray[ i ] ] = true;
      }
    }
    return result;
  },

  setParent : function( widget, parentId ) {
    var impl = this._setParentImplementation;
    this.callWithTarget( parentId, function( parent ) {
      impl( widget, parent );
    } );
  },

  _setParentImplementation : function( widget, parent ) {
    // TODO [rh] there seems to be a difference between add and setParent
    //      when using add sizes and clipping are treated differently
    // parent.add( widget );
    if( parent instanceof rwt.widgets.ScrolledComposite ) {
      // [if] do nothing, parent is set in ScrolledComposite#setContent which is called from the
      // server-side - see bug 349161
      widget.setUserData( "scrolledComposite", parent ); // Needed by "bounds" handler
    } else if ( parent instanceof rwt.widgets.TabFolder ) {
      widget.setUserData( "tabFolder", parent ); // Needed by "bounds" handler
    } else if( parent instanceof rwt.widgets.ExpandBar ) {
      parent.addWidget( widget );
    } else {
      widget.setParent( parent );
    }
    rwt.remote.HandlerUtil.addDestroyableChild( parent, widget );
    widget.setUserData( "protocolParent", parent );
  },

  callWithTarget : function( id, fun ) {
    if( id == null ) {
      fun( null );
    } else {
      var target = rwt.remote.ObjectRegistry.getObject( id );
      if( target ) {
        fun( target );
      } else {
        rwt.remote.ObjectRegistry.addRegistrationCallback( id, fun );
      }
    }
  },

  callWithTargets : function( ids, func ) {
    var result = [];
    result.resolved = 0;
    for( var i = 0; i < ids.length; i++ ) {
      this.callWithTarget( ids[ i ], this._createPartCallback( result, ids, i, func ) );
    }
  },

  _createPartCallback : function( result, ids, index, func ) {
    return function( target ) {
      result[ index ] = target;
      result.resolved++;
      if( result.resolved === ids.length ) {
        delete result.resolved;
        func( result );
      }
    };
  },

  filterUnregisteredObjects : function( list ) {
    var ObjectRegistry = rwt.remote.ObjectRegistry;
    var result = [];
    for( var i = 0; i < list.length; i++ ) {
      if( ObjectRegistry.getId( list[ i ] ) ) {
        result.push( list[ i ] );
      }
    }
    return result;
  },

  // TODO : Can we use "children" property in most cases instead??
  addDestroyableChild : function( parent, child ) {
    var list = parent.getUserData( "destroyableChildren" );
    if( list == null ) {
      list = {};
      parent.setUserData( "destroyableChildren", list );
    }
    list[ rwt.qx.Object.toHashCode( child ) ] = child;
  },

  removeDestroyableChild : function( parent, child ) {
    var list = parent.getUserData( "destroyableChildren" );
    if( list != null ) {
      delete list[ rwt.qx.Object.toHashCode( child ) ];
    }
  },

  getDestroyableChildren : function( parent ) {
    var list = parent.getUserData( "destroyableChildren" );
    if( list == null ) {
      list = {};
    }
    var result = [];
    for( var key in list ) {
      result.push( list[ key ] );
    }
    return result;
  },

  getServerData : function( target ) {
    var result = target.getUserData( rwt.remote.HandlerUtil.SERVER_DATA );
    if( result == null ) {
      result = {};
      target.setUserData( rwt.remote.HandlerUtil.SERVER_DATA, result );
    }
    return result;
  }

};

/*******************************************************************************
 * Copyright (c) 2011, 2015 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

namespace( "rwt.util" );

rwt.util.Encoding = {

  _escapeRegExp : /(&|<|>|\")/g,
  _escapeRegExpMnemonics : /(&&|&|<|>|")/g,
  _newlineRegExp : /(\r\n|\n|\r)/g,
  _outerWhitespaceRegExp : /(^ {1,1}| +$)/g,
  _outerWhitespaceRegExp2 : /(^ {1,}| +$)/g,
  _whitespaceRegExp : / {2,}/g,

  _escapeResolver : null,
  _escapeResolverMnemonics : null,
  _mnemonicFound : false,

  _escapeMap : {
    "<" : "&lt;",
    ">" : "&gt;",
    "\"" : "&quot;",
    "&&" : "&amp;",
    "&" : "&amp;"
  },

  /**
   * Replaces all occurrences of the characters <,>,&," with their corresponding HTML entities.
   * When the parameter mnemonic is set to true, this method handles ampersand characters in the
   * text as mnemonics in the same manner as SWT does.
   * Note: In contrast to SWT, the characters following an ampersand are currently not underlined.
   *
   * @param text the input text
   * @param mnemonics if true, the function removes the firest "&"
   *                  if a numbner, underlines that character (other option will be removed)
   *
   * @return the resulting text
   */
  // Note [rst]: Single quotes are not escaped as the entity &apos; is not
  //             defined in HTML 4. They should be handled by this method once
  //             we produce XHTML output.
  escapeText : function( text, mnemonics ) {
    if( text === null ) {
      throw new Error( "escapeText with parameter null not allowed" );
    }
    var result;
    this._mnemonicFound = false; // first found mnemonic may be resolved
    if( mnemonics === true ) {
      result = text.replace( this._escapeRegExpMnemonics, this._getEscapeResolverMnemonics() );
    } else {
      if( typeof mnemonics === "number" ) {
        result = this._escapeWithMnemonic( text, mnemonics );
      } else {
        result = text.replace( this._escapeRegExp, this._getEscapeResolver() );
      }
    }
    return this.truncateAtZero( result );
  },

  truncateAtZero : function( text ) {
    var result = text;
    var index = result.indexOf( String.fromCharCode( 0 ) );
    if( index !== -1 ) {
      result = result.substring( 0, index );
    }
    return result;
  },

  /**
   * Replaces all newline characters in the specified input string with the
   * given replacement string. All common newline characters are replaced (Unix,
   * Windows, and MacOS).
   *
   * @param input the string to process
   * @param replacement the string to replace line feeds with.
   * @return a copy of the input string with all newline characters replaced
   */
  replaceNewLines : function( text, optionalReplacement ) {
    var replacement = arguments.length > 1 ? optionalReplacement : "\\n";
    return text.replace( this._newlineRegExp, replacement );
  },

  /**
   * Replaces white spaces in the specified input string with &nbsp;.
   * For correct word wrapping, the last white space in a sequence of white
   * spaces is not replaced, if there is a different character following.
   * A single white space between words is not replaced whereas a single
   * leading white space is replaced.
   *
   * @param input the string to process
   * @return a copy of the input string with white spaces replaced
   */
  replaceWhiteSpaces : function( text ) {
    var result = text.replace( this._outerWhitespaceRegExp, this._outerWhitespaceResolver );
    result = result.replace( this._whitespaceRegExp, this._whitespaceResolver );
    return result;
  },

  /**
   * Escapes all leading and trailing spaces in the given input string.
   *
   * @param text input the string to process
   * @return a copy of the input string with all leading and trailing spaces
   * replaced
   */
  escapeLeadingTrailingSpaces : function( text ) {
    return text.replace( this._outerWhitespaceRegExp2, this._outerWhitespaceResolver );
  },


  /**
   * Escapes all chars that have a special meaning in regular expressions
   *
   * @type static
   * @param str {String} the string where to escape the chars.
   * @return {String} the string with the escaped chars.
   */
  escapeRegexpChars : function( str ) {
    return str.replace( /([\\\.\(\)\[\]\{\}\^\$\?\+\*])/g, "\\$1" );
  },


  /**
   * Unescapes a string containing entity escapes to a string
   * containing the actual Unicode characters corresponding to the
   * escapes. Supports HTML 4.0 entities.
   *
   * For example, the string "&amp;lt;Fran&amp;ccedil;ais&amp;gt;"
   * will become "&lt;Fran&ccedil;ais&gt;"
   *
   * If an entity is unrecognized, it is left alone, and inserted
   * verbatim into the result string. e.g. "&amp;gt;&amp;zzzz;x" will
   * become "&gt;&amp;zzzz;x".
   *
   * @type static
   * @param str {String} the String to unescape, may be null
   * @return {var} a new unescaped String
   * @see #escape
   */
  unescape : function( str ) {
    return this._unescapeEntities( str, rwt.html.Entity.TO_CHARCODE );
  },

  removeAmpersandControlCharacters : function( text ) {
    return text.replace(/(&&|&)/g, function( match ) {
      if( match === "&&" ) {
        return "&";
      }
      return "";
    } );
  },

  /////////
  // Helper

  _escapeWithMnemonic : function( text, index ) {
    var split = [
      text.slice( 0, index ).replace( this._escapeRegExp, this._getEscapeResolver() ),
      "<span style=\"text-decoration:underline\">",
      text.charAt( index ).replace( this._escapeRegExp, this._getEscapeResolver() ),
      "</span>",
      text.slice( index + 1 ).replace( this._escapeRegExp, this._getEscapeResolver() )
    ];
    return split.join( "" );
  },

  _getEscapeResolverMnemonics : function() {
    if( this._escapeResolverMnemonics ===  null ) {
      this._getEscapeResolver(); // implicitly create default resolver
      var EncodingUtil = this;
      this._escapeResolverMnemonics = function( match ) {
        var result;
        if( match === "&" && !EncodingUtil._mnemonicFound ) {
          result = "";
          EncodingUtil._mnemonicFound = true;
        } else {
          result = EncodingUtil._escapeResolver( match );
        }
        return result;
      };
    }
    return this._escapeResolverMnemonics;
  },

  _getEscapeResolver : function() {
    if( this._escapeResolver === null ) {
      var EncodingUtil = this;
      this._escapeResolver = function( match ) {
        return EncodingUtil._escapeMap[ match ];
      };
    }
    return this._escapeResolver;
  },

  _outerWhitespaceResolver : function( match ) {
    return match.replace( / /g, "&nbsp;" );
  },

  _whitespaceResolver : function( match ) {
    return match.slice( 1 ).replace( / /g, "&nbsp;" ) + " ";
  },

  _unescapeEntities : function( str, entitiesToCharCode ) {
    return str.replace( /&[#\w]+;/gi, function( entity ) {
      var chr = entity;
      var entity = entity.substring( 1, entity.length - 1 );
      var code = entitiesToCharCode[ entity ];
      if( code ) {
        chr = String.fromCharCode( code );
      } else {
        if( entity.charAt( 0 ) === '#' ) {
          if( entity.charAt(1).toUpperCase() === 'X' ) {
            code = entity.substring( 2 );
            // match hex number
            if( code.match( /^[0-9A-Fa-f]+$/gi ) ) {
              chr = String.fromCharCode( parseInt( code, 16 ) );
            }
          } else {
            code = entity.substring( 1 );
            // match integer
            if( code.match( /^\d+$/gi ) ) {
              chr = String.fromCharCode( parseInt( code, 10 ) );
            }
          }
        }
      }
      return chr;
    } );
  }


};

/*******************************************************************************
 * Copyright (c) 2011, 2015 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

namespace( "rwt.widgets" );

rwt.widgets.Display = function() {
  this._document = rwt.widgets.base.ClientDocument.getInstance();
  this._server = rwt.remote.Connection.getInstance();
  this._exitConfirmation = null;
  this._hasResizeListener = false;
  this._initialized = false;
  if( rwt.widgets.Display._current !== undefined ) {
    throw new Error( "Display can not be created twice" );
  } else {
    rwt.widgets.Display._current = this;
  }
};

rwt.widgets.Display.getCurrent = function() {
  return rwt.widgets.Display._current;
};


rwt.widgets.Display._onAppearFocus = function() {
  var widget = this;
  widget.focus();
  widget.removeEventListener( "appear", rwt.widgets.Display._onAppearFocus, widget );
};

rwt.widgets.Display.prototype = {

  applyObjectId : function() {
    if( !this._initialized ) {
      this.init();
    }
  },

  init : function() {
    this._appendWindowSize();
    this._appendSystemDPI();
    this._appendColorDepth();
    this._appendInitialHistoryEvent();
    this._appendTimezoneOffset();
    this._appendStartupParameters();
    this._attachListener();
    this._server.send();
    this._initialized = true;
  },

  allowEvent : function() {
    // NOTE : in the future might need a parameter if there are multiple types of cancelable events
    rwt.remote.KeyEventSupport.getInstance().allowEvent();
  },

  cancelEvent : function() {
    rwt.remote.KeyEventSupport.getInstance().cancelEvent();
  },

  beep : function() {
    // do nothing for now, used by native clients
  },

  /**
   * An exit confirmation dialog will be displayed if the given message is not
   * null. If the message is empty, the dialog will be displayed but without a
   * message.
   */
  setExitConfirmation : function( message ) {
    this._exitConfirmation = message;
  },

  setFocusControl : function( widgetId ) {
    var widget = rwt.remote.ObjectRegistry.getObject( widgetId );
    if( widget.isSeeable() ) {
      widget.focus();
    } else {
      widget.addEventListener( "appear", rwt.widgets.Display._onAppearFocus, widget );
    }
  },

  setMnemonicActivator : function( value ) {
    rwt.widgets.util.MnemonicHandler.getInstance().setActivator( value );
  },

  setEnableUiTests : function( value ) {
    rwt.widgets.base.Widget._renderHtmlIds = value;
  },

  getDPI : function() {
    var result = [ 0, 0 ];
    if( typeof screen.systemXDPI == "number" ) {
      result[ 0 ] = parseInt( screen.systemXDPI, 10 );
      result[ 1 ] = parseInt( screen.systemYDPI, 10 );
    } else {
      var testElement = document.createElement( "div" );
      testElement.style.width = "1in";
      testElement.style.height = "1in";
      testElement.style.padding = 0;
      document.body.appendChild( testElement );
      result[ 0 ] = parseInt( testElement.offsetWidth, 10 );
      result[ 1 ] = parseInt( testElement.offsetHeight, 10 );
      document.body.removeChild( testElement );
    }
    return result;
  },

  setHasResizeListener : function( value ) {
    this._hasResizeListener = value;
  },

  ////////////////////////
  // Global Event handling

  _attachListener : function() {
    this._document.addEventListener( "windowresize", this._onResize, this );
    this._document.addEventListener( "keypress", this._onKeyPress, this );
    this._server.addEventListener( "send", this._onSend, this );
    rwt.remote.KeyEventSupport.getInstance(); // adds global KeyListener
    rwt.runtime.System.getInstance().addEventListener( "beforeunload", this._onBeforeUnload, this );
    rwt.runtime.System.getInstance().addEventListener( "unload", this._onUnload, this );
  },

  _onResize : function() {
    this._appendWindowSize();
    if( this._hasResizeListener ) {
      rwt.remote.Connection.getInstance().getRemoteObject( this ).notify( "Resize", null, 500 );
    }
  },

  _onKeyPress : function( evt ) {
    if( evt.getKeyIdentifier() == "Escape" ) {
      evt.preventDefault();
    }
  },

  _onSend : function() {
    // TODO [tb] : This will attach the cursorLocation as the last operation, but should be first
    var pageX = rwt.event.MouseEvent.getPageX();
    var pageY = rwt.event.MouseEvent.getPageY();
    var location = [ Math.round( pageX ), Math.round( pageY ) ];
    rwt.remote.Connection.getInstance().getRemoteObject( this ).set( "cursorLocation", location );
  },

  _onBeforeUnload : function( event ) {
    if( this._exitConfirmation !== null && this._exitConfirmation !== "" ) {
      event.getDomEvent().returnValue = this._exitConfirmation;
      event.setUserData( "returnValue", this._exitConfirmation );
    }
  },

  _onUnload : function() {
    this._document.removeEventListener( "windowresize", this._onResize, this );
    this._document.removeEventListener( "keypress", this._onKeyPress, this );
    this._server.removeEventListener( "send", this._onSend, this );
    this._sendShutdown();
  },

  ///////////////////
  // client to server

  _sendShutdown : function() {
    var server = rwt.remote.Connection.getInstance();
    server.getMessageWriter().appendHead( "shutdown", true );
    server.sendImmediate( false );
  },

  _appendWindowSize : function() {
    var bounds = [ 0, 0, window.innerWidth, window.innerHeight ];
    rwt.remote.Connection.getInstance().getRemoteObject( this ).set( "bounds", bounds );
  },

  _appendSystemDPI : function() {
    var dpi = this.getDPI();
    rwt.remote.Connection.getInstance().getRemoteObject( this ).set( "dpi", dpi );
  },

  _appendColorDepth : function() {
    var depth = 16;
    if( typeof screen.colorDepth == "number" ) {
      depth = parseInt( screen.colorDepth, 10 );
    }
    if( rwt.client.Client.isGecko() ) {
      // Firefox detects 24bit and 32bit as 24bit, but 32bit is more likely
      depth = depth == 24 ? 32 : depth;
    }
    rwt.remote.Connection.getInstance().getRemoteObject( this ).set( "colorDepth", depth );
  },

  _appendInitialHistoryEvent : function() {
    var state = window.location.hash;
    if( state !== "" ) {
      var type = "rwt.client.BrowserNavigation";
      var history = rwt.client.BrowserNavigation.getInstance();
      var handler = rwt.remote.HandlerRegistry.getHandler( type );
      // TODO: Temporary workaround for 388835
      rwt.remote.ObjectRegistry.add( type, history, handler );
      rwt.remote.Connection.getInstance().getRemoteObject( history ).notify( "Navigation", {
        "state" : decodeURIComponent( state.substr( 1 ) )
      } );
    }
  },

  _appendTimezoneOffset : function() {
    var timezoneOffset = rwt.client.Client.getTimezoneOffset();
    var writer = rwt.remote.Connection.getInstance().getMessageWriter();
    writer.appendSet( "rwt.client.ClientInfo", "timezoneOffset", timezoneOffset );
  },

  _appendStartupParameters : function() {
    var parameters = rwt.runtime.System.getInstance().getStartupParameters();
    if( parameters ) {
      var writer = rwt.remote.Connection.getInstance().getMessageWriter();
      writer.appendSet( "rwt.client.StartupParameters", "parameters", parameters );
    }
  }

};

/*******************************************************************************
 * Copyright (c) 2011, 2013 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.remote.HandlerRegistry.add( "rwt.widgets.Display", {

  factory : function( properties ) {
    return new rwt.widgets.Display( properties );
  },

  destructor : null, // destroy is currently not called for display

  properties : [
    "exitConfirmation",
    "mnemonicActivator",
    "focusControl",
    "enableUiTests",
    "activeKeys",
    "cancelKeys"
  ],

  methods : [
    "allowEvent",
    "cancelEvent",
    "beep"
  ],

  propertyHandler : {
    "activeKeys" : function( object, value ) {
      var map = rwt.util.Objects.fromArray( value );
      rwt.remote.KeyEventSupport.getInstance().setKeyBindings( map );
    },
    "cancelKeys" : function( object, value ) {
      var map = rwt.util.Objects.fromArray( value );
      rwt.remote.KeyEventSupport.getInstance().setCancelKeys( map );
    }
  },

  listeners : [ "KeyDown", "Resize" ]

} );

/*******************************************************************************
 * Copyright (c) 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.qx.Mixin.define( "rwt.widgets.util.OverStateMixin", {

  construct : function() {
    this.addEventListener( "mouseover", this._onMouseOver, this );
    this.addEventListener( "mouseout", this._onMouseOut, this );
  },

  members : {

    _onMouseOver : function( event ) {
      if( event.getTarget() === this ) {
        this.addState( "over" );
      }
    },

    _onMouseOut : function( event ) {
      if( event.getTarget() === this ) {
        this.removeState( "over" );
      }
    }

  }

} );

/*******************************************************************************
 * Copyright (c) 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.qx.Mixin.define( "rwt.widgets.util.HtmlAttributesMixin", {

  destruct : function() {
    delete this._htmlAttributes;
  },

  members : {

    applyObjectId : function( id ) {
      if( rwt.widgets.base.Widget._renderHtmlIds ) {
        this.setHtmlAttribute( "id", id );
      }
    },

    clearHtmlAttributes : function() {
      if( !this._htmlAttributes ) {
        return;
      }
      if( this._element ) {
        for( var attribute in this._htmlAttributes ) {
          this._element.removeAttribute( attribute );
        }
      }
      this._htmlAttributes = {};
    },

    setHtmlAttributes : function( map ) {
      for( var key in map ) {
        this.setHtmlAttribute( key, map[ key ] );
      }
    },

    setHtmlAttribute : function( attribute, value ) {
      if( !this._htmlAttributes && !value ) {
        return;
      } else if( !this._htmlAttributes ) {
        this._htmlAttributes = {};
      }
      if( value === null ) {
        delete this._htmlAttributes[ attribute ];
        if( this._element ) {
          this._element.removeAttribute( attribute );
        }
      } else {
        this._htmlAttributes[ attribute ] = value;
        if( this._element ) {
          this._element.setAttribute( attribute, value );
        }
      }
      if( this._update ) {
        this._update();
      }
    },

    getHtmlAttribute : function( attribute ) { // not used in RWT, but in tests and add-ons
      return this.getHtmlAttributes()[ attribute ] || "";
    },

    getHtmlAttributes : function() {
      return this._htmlAttributes || {}; // NOT a save copy!
    }

  }

} );

/*******************************************************************************
 * Copyright (c) 2007, 2015 Innoopract Informationssysteme GmbH.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Innoopract Informationssysteme GmbH - initial API and implementation
 *    EclipseSource - ongoing development
 ******************************************************************************/

/**
 * This class contains static helper functions for widgets.
 */
rwt.qx.Class.define( "rwt.widgets.util.WidgetUtil", {

  statics : {

    getControl : function( widget ) {
      var widgetManager = rwt.remote.WidgetManager.getInstance();
      var result = widget;
      while( result != null && !widgetManager.isControl( result ) ) {
        result = result.getParent ? result.getParent() : null;
      }
      return result;
    },

    getShell : function( widget ) {
      var result = widget;
      while( result != null && result.classname !== "rwt.widgets.Shell" ) {
        result = result.getParent();
      }
      return result;
    },

    getChildIds : function( widget ) {
      return widget.getUserData( "rwt_Children" );
    },

    isVisible : function( widget ) {
      var result = true;
      var current = widget;
      while( current && result ) {
        result = current.getVisibility();
        current = current.getParent();
      }
      return result;
    },

    getGC : function( widget ) {
      var gc = widget.getUserData( "rwt.widgets.GC" );
      if( gc == null ) {
        gc = new rwt.widgets.GC( widget );
        widget.setUserData( "rwt.widgets.GC", gc );
      }
      return gc;
    },

    callWithElement : function( widget, callback ) {
      if( widget.getElement() ) {
        callback( widget.getElement() );
      } else {
        var listener = function listener(){
          callback( widget.getElement() );
          widget.removeEventListener( "create", listener );
        };
        widget.addEventListener( "create", listener );
      }
    },

    isWidget : function( target ) {
      return    ( ( target.classname || "" ).indexOf( "rwt.widgets" ) === 0 )
        || ( target instanceof rwt.widgets.base.Widget );
    },

    /**
     * Can be used simulate mouseEvents on the qooxdoo event-layer.
     * Manager and handler that are usually notified by
     * rwt.event.EventHandler will not receive the event.
     */
    _fakeMouseEvent : function( originalTarget, type ) {
      if( !( originalTarget instanceof rwt.widgets.base.Widget ) ) {
        originalTarget = rwt.event.EventHandlerUtil.getTargetObject( originalTarget );
        originalTarget = originalTarget || rwt.widgets.base.ClientDocument.getInstance();
      }
      if( originalTarget.getEnabled() ) {
        var domTarget = originalTarget._getTargetNode();
        var EventHandlerUtil = rwt.event.EventHandlerUtil;
        var target = EventHandlerUtil.getTargetObject( null, originalTarget, true );
        var domEvent = {
          "type" : type,
          "target" : domTarget,
          "button" : 0,
          "wheelData" : 0,
          "detail" : 0,
          "pageX" : 0,
          "pageY" : 0,
          "clientX" : 0,
          "clientY" : 0,
          "screenX" : 0,
          "screenY" : 0,
          "shiftKey" : false,
          "ctrlKey" : false,
          "altKey" : false,
          "metaKey" : false,
          "preventDefault" : function(){}
        };
        var event = new rwt.event.MouseEvent( type,
                                              domEvent,
                                              domTarget,
                                              target,
                                              originalTarget,
                                              null );
        target.dispatchEvent( event );
      }
    }

  }
});

/*******************************************************************************
 * Copyright: 2004, 2015 1&1 Internet AG, Germany, http://www.1und1.de,
 *                       and EclipseSource
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v1.0 which accompanies this
 * distribution, and is available at http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 *
 *   This class contains code based on the following work:
 *
 *   * Prototype JS
 *     http://www.prototypejs.org/
 *     Version 1.5
 *
 *     Copyright:
 *       (c) 2006-2007, Prototype Core Team
 *
 *     License:
 *       MIT: http://www.opensource.org/licenses/mit-license.php
 *
 *     Authors:
 *       * Prototype Core Team
 *
 ******************************************************************************/

(function() {

var Client = rwt.client.Client;

/**
 * Style querying and modification of HTML elements.
 *
 * Automatically normalizes cross-browser differences. Optimized for
 * performance.
 */
rwt.qx.Class.define( "rwt.html.Style", {

  statics : {

    VENDOR_PREFIX_VALUE : rwt.util.Variant.select( "qx.client", {
      "gecko" : "-moz-",
      "webkit|blink" : "-webkit-",
      "trident" : "-ms-",
      "default" : ""
    } ),

    VENDOR_PREFIX_PROPERTY : rwt.util.Variant.select( "qx.client", {
      "gecko" : "Moz",
      "webkit|blink" : "webkit",
      "trident" : "ms",
      "default" : ""
    } ),

    /**
     * Gets the value of a style property.
     *
     * *Computed*
     *
     * Returns the computed value of a style property. Compared to the cascaded style,
     * this one also interprets the values e.g. translates <code>em</code> units to
     * <code>px</code>.
     *
     * *Cascaded*
     *
     * Returns the cascaded value of a style property.
     *
     * *Local*
     *
     * Ignores inheritance cascade. Does not interpret values.
     *
     * @type static
     * @signature function(element, name)
     * @param element {Element} The DOM element to modify
     * @param name {String} Name of the style attribute (js variant e.g. marginTop, wordSpacing)
     * @return {var} The value of the property
     */
    get : function( element, name ) {
      // Opera, Mozilla and Safari 3+ also have a global getComputedStyle which is identical
      // to the one found under document.defaultView.

      // The problem with this is however that this does not work correctly
      // when working with frames and access an element of another frame.
      // Then we must use the <code>getComputedStyle</code> of the document
      // where the element is defined.
      var doc = rwt.html.Nodes.getDocument(element);
      var computed = doc.defaultView.getComputedStyle(element, null);

      // All relevant browsers expose the configured style properties to
      // the CSSStyleDeclaration objects
      return computed ? computed[name] : null;
    },

    /**
     * Gets the computed (CSS) style property of a given DOM element.
     */
    // TODO: check if all supported browser have document.defaultView.getComputedStyle
    getStyleProperty : ( document.defaultView && document.defaultView.getComputedStyle )
      ? function( el, prop ) {
        try {
          return el.ownerDocument.defaultView.getComputedStyle(el, "")[prop];
        } catch(ex) {
          throw new Error("Could not evaluate computed style: " + el + "[" + prop + "]: " + ex);
        }
      }
      : function( el, prop ) {
        try {
          return el.style[prop];
        } catch( ex ) {
          throw new Error( "Could not evaluate computed style: " + el + "[" + prop + "]" );
        }
      },

    /**
     * Get a (CSS) style property of a given DOM element and interpret the property as integer value
     *
     * @type static
     * @param vElement {Element} the DOM element
     * @param propertyName {String} the name of the style property. e.g. "paddingTop", "marginLeft", ...
     * @return {Integer} the (CSS) style property converted to an integer value
     */
    getStyleSize : function(vElement, propertyName) {
      return parseInt( rwt.html.Style.getStyleProperty( vElement, propertyName ), 10 ) || 0;
    },


    /**
     * Get the element's left margin.
     *
     * @type static
     * @param vElement {Element} the DOM element
     * @return {Integer} the element's left margin size
     */
    getMarginLeft : function(vElement) {
      return rwt.html.Style.getStyleSize(vElement, "marginLeft");
    },


    /**
     * Get the element's top margin.
     *
     * @type static
     * @param vElement {Element} the DOM element
     * @return {Integer} the element's top margin size
     */
    getMarginTop : function(vElement) {
      return rwt.html.Style.getStyleSize(vElement, "marginTop");
    },


    /**
     * Get the element's right margin.
     *
     * @type static
     * @param vElement {Element} the DOM element
     * @return {Integer} the element's right margin size
     */
    getMarginRight : function(vElement) {
      return rwt.html.Style.getStyleSize(vElement, "marginRight");
    },


    /**
     * Get the element's bottom margin.
     *
     * @type static
     * @param vElement {Element} the DOM element
     * @return {Integer} the element's bottom margin size
     */
    getMarginBottom : function(vElement) {
      return rwt.html.Style.getStyleSize(vElement, "marginBottom");
    },


    /**
     * Get the element's left padding.
     *
     * @type static
     * @param vElement {Element} the DOM element
     * @return {Integer} the element's left padding size
     */
    getPaddingLeft : function(vElement) {
      return rwt.html.Style.getStyleSize(vElement, "paddingLeft");
    },


    /**
     * Get the element's top padding.
     *
     * @type static
     * @param vElement {Element} the DOM element
     * @return {Integer} the element's top padding size
     */
    getPaddingTop : function(vElement) {
      return rwt.html.Style.getStyleSize(vElement, "paddingTop");
    },


    /**
     * Get the element's right padding.
     *
     * @type static
     * @param vElement {Element} the DOM element
     * @return {Integer} the element's right padding size
     */
    getPaddingRight : function(vElement) {
      return rwt.html.Style.getStyleSize(vElement, "paddingRight");
    },


    /**
     * Get the element's bottom padding.
     *
     * @type static
     * @param vElement {Element} the DOM element
     * @return {Integer} the element's bottom padding size
     */
    getPaddingBottom : function(vElement) {
      return rwt.html.Style.getStyleSize(vElement, "paddingBottom");
    },


    /**
     * Get the element's left border width.
     *
     * @type static
     * @param vElement {Element} the DOM element
     * @return {Integer} the element's left border width
     */
    getBorderLeft : function(vElement) {
      return rwt.html.Style.getStyleProperty(vElement, "borderLeftStyle") == "none" ? 0 : rwt.html.Style.getStyleSize(vElement, "borderLeftWidth");
    },


    /**
     * Get the element's top border width.
     *
     * @type static
     * @param vElement {Element} the DOM element
     * @return {Integer} the element's top border width
     */
    getBorderTop : function(vElement) {
      return rwt.html.Style.getStyleProperty(vElement, "borderTopStyle") == "none" ? 0 : rwt.html.Style.getStyleSize(vElement, "borderTopWidth");
    },


    /**
     * Get the element's right border width.
     *
     * @type static
     * @param vElement {Element} the DOM element
     * @return {Integer} the element's right border width
     */
    getBorderRight : function(vElement) {
      return rwt.html.Style.getStyleProperty(vElement, "borderRightStyle") == "none" ? 0 : rwt.html.Style.getStyleSize(vElement, "borderRightWidth");
    },

    /**
     * Get the element's bottom border width.
     *
     * @type static
     * @param vElement {Element} the DOM element
     * @return {Integer} the element's bottom border width
     */
    getBorderBottom : function(vElement) {
      return rwt.html.Style.getStyleProperty(vElement, "borderBottomStyle") == "none" ? 0 : rwt.html.Style.getStyleSize(vElement, "borderBottomWidth");
    },

    /**
     * Sets the given gradient as a background for the target element/widget.
     * The syntax is [ [ position, color ]* ], with position <= 1 and >= 0.
     * Color is any valid css string for colors.
     * The position has to increase from every previous position.
     * The gradient flows from top to bottom unless a "horizontal" flag is added as
     * a field to the gradient object, in which case it flows from left to right.
     *
     * If a background color is set, the gradient is rendered on top of it.
     * If a background image is set, the gradient is not rendered until it is removed.
     * If the browser does not support CSS3, the gradient is never rendered.
     */
    setBackgroundGradient : function( target, gradient ) {
      // Tests for identity, not equality, which is okay since this is just an optimization
      if( target.___rwtStyle__backgroundGradient !== gradient ) {
        target.___rwtStyle__backgroundGradient = gradient;
        if( !target.___rwtStyle__backgroundImage ) {
          this._updateBackground( target );
        }
      }
    },

    getBackgroundGradient : function( target ) {
      var gradient = target.___rwtStyle__backgroundGradient;
      if( !gradient ) {
        return undefined;
      }
      var args = [ gradient.horizontal === true ? "to right" : "to bottom" ];
      for( var i = 0; i < gradient.length; i++ ) {
        var position = ( gradient[ i ][ 0 ] * 100 ) + "%";
        var color = gradient[ i ][ 1 ];
        args.push( " " + color + " " + position );
      }
      return "linear-gradient( " + args.join() + " )";
    },

    /**
     * Sets the given image url as a background for the target element/widget.
     * If a background color is set, the image is rendered on top of it.
     * If a background gradient is set, only the image is rendered.
     * For background repeat/position to be respected, they have to be set by
     * setBackgroundPosition/Repeat, never directly.
     */
    setBackgroundImage : function( target, image ) {
      if( target.___rwtStyle__backgroundImage !== image ) {
        target.___rwtStyle__backgroundImage = image;
        this._updateBackground( target );
      }
    },

    getBackgroundImage : function( target ) {
      var image = target.___rwtStyle__backgroundImage;
      if( !image ) {
        return "none";
      }
      return "url(" + image + ")";
    },

    setBackgroundRepeat : function( target, repeat ) {
      if( target.___rwtStyle__backgroundRepeat !== repeat ) {
        target.___rwtStyle__backgroundRepeat = repeat;
        if( target.___rwtStyle__backgroundImage ) {
          this._updateBackground( target );
        }
      }
    },

    getBackgroundRepeat : function( target ) {
      return target.___rwtStyle__backgroundRepeat;
    },

    setBackgroundPosition : function( target, position ) {
      if( target.___rwtStyle__backgroundPosition !== position ) {
        target.___rwtStyle__backgroundPosition = position;
        if( target.___rwtStyle__backgroundImage ) {
          this._updateBackground( target );
        }
      }
    },

    getBackgroundPosition : function( target ) {
      return target.___rwtStyle__backgroundPosition;
    },

    setBackgroundSize : function( target, size ) {
      if( target.___rwtStyle__backgroundSize !== size ) {
        target.___rwtStyle__backgroundSize = size;
        if( target.___rwtStyle__backgroundImage ) {
          this._updateBackground( target );
        }
      }
    },

    /**
     * Sets the given color as a background for the target element/widget.
     * The color is rendered in any case, but always below gradient and image.
     */
    setBackgroundColor : function( target, color ) {
      var value = color === "transparent" ? null : color;
      if( target.___rwtStyle__backgroundColor !== value ) {
        target.___rwtStyle__backgroundColor = value;
        this._updateBackground( target );
      }
    },

    /**
     * Returns the color that was previously set by setBackgroundColor
     */
    getBackgroundColor : function( target ) {
      return target.___rwtStyle__backgroundColor || "transparent";
    },

    setBoxShadow: function( target, shadowObject ) {
      var property;
      if( ( Client.isWebkit() || Client.isBlink() ) && !Client.isMobileChrome() ) {
        property = this.VENDOR_PREFIX_VALUE + "box-shadow";
      } else {
        property = "boxShadow";
      }
      if( shadowObject ) {
        // NOTE: older webkit dont accept spread, therefor only use parameters 1-3
        var string = shadowObject[ 0 ] ? "inset " : "";
        string += shadowObject.slice( 1, 4 ).join( "px " ) + "px";
        var rgba = rwt.util.Colors.stringToRgb( shadowObject[ 5 ] );
        rgba.push( shadowObject[ 6 ] );
        string += " rgba(" + rgba.join() + ")";
        this.setStyleProperty( target, property, string );
      } else {
        this.removeStyleProperty( target, property );
      }
    },

    setTextShadow : function( target, shadowObject ) {
      var property = "textShadow";
      if( shadowObject ) {
        var string = shadowObject.slice( 1, 4 ).join( "px " ) + "px";
        var rgba = rwt.util.Colors.stringToRgb( shadowObject[ 5 ] );
        rgba.push( shadowObject[ 6 ] );
        string += " rgba(" + rgba.join() + ")";
        this.setStyleProperty( target, property, string );
      } else {
        this.removeStyleProperty( target, property );
      }
    },

    setPointerEvents : function( target, value ) {
      var version = Client.getVersion();
      var ffSupport = Client.getEngine() === "gecko" && version >= 1.9;
      // TODO: check if all supported browser support pointerEvents now
      // NOTE: chrome does not support pointerEvents, but not on svg-nodes
      var webKitSupport = Client.getBrowser() === "safari" && version >= 530;
      if( ffSupport || webKitSupport ) {
        this.setStyleProperty( target, "pointerEvents", value );
        target.setAttribute( "pointerEvents", value );
      } else {
        this._passEventsThrough( target, value );
      }
    },

    setUserSelect : function( target, value ) {
      this.setStyleProperty( target, this._prefixProperty( "userSelect" ), value );
    },

    getUserSelect : function( target ) {
      return this.getOwnProperty( target, this._prefixProperty( "userSelect" ) );
    },

    setTransition : function( target, value ) {
      if( !this._transitionProperty ) {
        // TODO [tb] : Find a more general solution for transitions and/or style support tests
        this._transitionProperty = "transition";
        var dummy = document.createElement( "div" );
        if( !( "transition" in dummy.style ) ) {
          if( "MozTransition" in dummy.style ) {
            this._transitionProperty = "MozTransition";
          } else if( "webkitTransition" in dummy.style  ) {
            this._transitionProperty = "webkitTransition";
          }
        }
      }
      this.setStyleProperty( target, this._transitionProperty, value );
    },

    setStyleProperty : function( target, property, value ) {
      if( target.setStyleProperty ) {
        target.setStyleProperty( property, value );
      } else {
        target.style[ property ] = value;
      }
    },

    removeStyleProperty : function( target, property ) {
      if( target instanceof rwt.widgets.base.Widget ) {
        target.removeStyleProperty( property );
      } else {
        target.style[ property ] = "";
      }
    },

    getOwnProperty : function( target, property ) {
      if( target.getStyleProperty ) {
        target.getStyleProperty( property );
      } else {
        return target.style[ property ];
      }
    },

    //////////
    // Private

    _prefixProperty : function( property ) {
      if( this.VENDOR_PREFIX_PROPERTY ) {
        return this.VENDOR_PREFIX_PROPERTY + rwt.util.Strings.toFirstUp( property );
      }
      return property;
    },

    _updateBackground : function( target ) {
      var background = [];
      this._pushBackgroundImage( target, background );
      this._pushBackgroundGradient( target, background );
      this._pushBackgroundColor( target, background );
      if( background.length > 0 ) {
        this.setStyleProperty( target, "background", background.join( ", " ) );
        // Set background size as separate backgroundSize property for Firefox compatibility
        // http://stackoverflow.com/questions/7864448/background-size-in-shorthand-background-property-css3
        if( target.___rwtStyle__backgroundImage && target.___rwtStyle__backgroundSize ) {
          this.setStyleProperty( target, "backgroundSize", target.___rwtStyle__backgroundSize );
        }
      } else {
        this._clearCssBackground( target );
      }
    },

    _pushBackgroundImage : function( target, backgroundArray ) {
      var value = target.___rwtStyle__backgroundImage;
      if( value ) {
        var repeat = target.___rwtStyle__backgroundRepeat;
        var position = target.___rwtStyle__backgroundPosition;
        backgroundArray.push( this._getImageString( value, repeat, position ) );
      }
    },

    _pushBackgroundGradient : function( target, backgroundArray ) {
      var value = target.___rwtStyle__backgroundGradient;
      if( value && !target.___rwtStyle__backgroundImage ) {
        backgroundArray.push( this._getGradientString( value ) );
      }
    },

    _pushBackgroundColor : function( target, backgroundArray ) {
      var value = target.___rwtStyle__backgroundColor;
      if( value ) {
        if( ( Client.isWebkit() || Client.isBlink() ) && !target.___rwtStyle__backgroundGradient ) {
          backgroundArray.push( this._getGradientString( [ [ 0, value ], [ 1, value ] ] ) );
        }
        backgroundArray.push( value );
      }
    },

    _getGradientString : rwt.util.Variant.select( "qx.client", {
      // TODO [tb] : Webkit and Gecko now support the default syntax, but will continue to support
      //             their old syntax if prefexied. RAP should use new syntax if possible to be
      //             future proof.
      "webkit|blink" : function( gradientObject ) {
        var args = [ "linear", "left top" ];
        if( gradientObject.horizontal === true ) {
          args.push( "right top" );
        }  else {
          args.push( "left bottom" );
        }
        for( var i = 0; i < gradientObject.length; i++ ) {
          var position = gradientObject[ i ][ 0 ];
          var color = gradientObject[ i ][ 1 ];
          args.push( "color-stop(" + position + "," + color + ")" );
        }
        return this.VENDOR_PREFIX_VALUE + "gradient( " + args.join() + ")";
      },
      "gecko" : function( gradientObject ) {
        var args = [ gradientObject.horizontal === true ? "0deg" : "-90deg" ];
        for( var i = 0; i < gradientObject.length; i++ ) {
          var position = ( gradientObject[ i ][ 0 ] * 100 ) + "%";
          var color = gradientObject[ i ][ 1 ];
          args.push( color + " " + position );
        }
        return this.VENDOR_PREFIX_VALUE + "linear-gradient( " + args.join() + ")";
      },
      "trident" : function( gradientObject ) {
        if( rwt.client.Client.getMajor() === 9 ) {
          return this._getSvgGradientString( gradientObject );
        }
        return this._getDefaultGradientString( gradientObject );
      },
      "default" : function( gradientObject ) {
        return this._getDefaultGradientString( gradientObject );
      }
    } ),

    _getDefaultGradientString : function( gradientObject ) {
      var args = [ gradientObject.horizontal === true ? "90deg" : "180deg" ];
      for( var i = 0; i < gradientObject.length; i++ ) {
        var position = ( gradientObject[ i ][ 0 ] * 100 ) + "%";
        var color = gradientObject[ i ][ 1 ];
        args.push( color + " " + position );
      }
      return "linear-gradient( " + args.join() + ")";
    },

    _getSvgGradientString : function( gradientObject ) {
      var result = [ svgStrings.start ];
      result.push( gradientObject.horizontal ? svgStrings.horizontal : svgStrings.vertical );
      for( var i = 0; i < gradientObject.length; i++ ) {
        result.push( svgStrings.color( gradientObject[ i ] ) );
      }
      result.push( svgStrings.end );
      return result.join( "" );
    },

    _getImageString : function( value, repeat, position ) {
      return   "url(" + this._resolveResource( value ) + ")"
             + ( repeat ? " " + repeat : "" )
             + ( position ? " " + position : "" );
    },

    _clearCssBackground : function( target ) {
      if( Client.isTrident() ) {
        this.setStyleProperty( target, "background", "rgba(0, 0, 0, 0)" );
      } else {
        this.removeStyleProperty( target, "background" );
      }
    },

    /////////
    // Helper

    _passEventsThrough : function( target, value ) {
      // TODO [tb] : This is a very limited implementation that allowes
      // to click "through" the elmement, but won't handle hover and cursor.
      var types = rwt.event.EventHandler._mouseEventTypes;
      var handler = this._passEventThroughHandler;
      if( value === "none" ) {
        this.setStyleProperty( target, "cursor", "default" );
        for( var i = 0; i < types.length; i++ ) {
          target.addEventListener( types[ i ], handler, false );
        }
      } else {
        // TODO
      }
    },

    _passEventThroughHandler : function( domEvent ) {
      var EventHandlerUtil = rwt.event.EventHandlerUtil;
      var domTarget = EventHandlerUtil.getDomTarget( domEvent );
      var type = domEvent.type;
      domTarget.style.display = "none";
      var newTarget
        = document.elementFromPoint( domEvent.clientX, domEvent.clientY );
      domEvent.cancelBubble = true;
      EventHandlerUtil.stopDomEvent( domEvent );
      if(    newTarget
          && type !== "mousemove"
          && type !== "mouseover"
          && type !== "mouseout" )
      {
        if( type === "mousedown" ) {
          rwt.html.Style._refireEvent( newTarget, "mouseover", domEvent );
        }
        rwt.html.Style._refireEvent( newTarget, type, domEvent );
        if( type === "mouseup" ) {
          rwt.html.Style._refireEvent( newTarget, "mouseout", domEvent );
        }
      }
      domTarget.style.display = "";
    },

    _refireEvent : function( target, type, originalEvent ) {
      var newEvent = document.createEvent( "MouseEvents" );
      newEvent.initMouseEvent( type,
                               true, /* can bubble */
                               true, /* cancelable */
                               originalEvent.view,
                               originalEvent.detail,
                               originalEvent.screenX,
                               originalEvent.screenY,
                               originalEvent.clientX,
                               originalEvent.clientY,
                               originalEvent.ctrlKey,
                               originalEvent.altKey,
                               originalEvent.shiftKey,
                               originalEvent.metaKey,
                               originalEvent.button,
                               originalEvent.relatedTarget);
      target.dispatchEvent( newEvent );
    },

    _resolveResource : function( url ) {
      return url;
    }

  }

} );

var svgStrings = {
  "start" :   "url(\"data:image/svg+xml;charset=utf-8,"
            + encodeURIComponent( "<svg xmlns='http://www.w3.org/2000/svg'>" ),
  "vertical" : encodeURIComponent( "<linearGradient id='g' x2='0' y2='1'>" ),
  "horizontal" : encodeURIComponent( "<linearGradient id='g'>" ),
  "color" : function( stopColor ) {
    return encodeURIComponent(   "<stop offset='"
                               + ( stopColor[ 0 ] * 100 )
                               +"%' stop-color='"
                               + stopColor[ 1 ]
                               + "'/>" );
  },
  "end" :   encodeURIComponent( "</linearGradient><rect fill='url(#g)' " )
          + encodeURIComponent( "width='100%' height='100%'/></svg>" )
          + "\")"
};

}() );

/*******************************************************************************
 * Copyright (c) 2004, 2014 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

rwt.qx.Class.define("rwt.html.Scroll",
{
  /*
  *****************************************************************************
     STATICS
  *****************************************************************************
  */

  statics :
  {

    /**
     * Disables browser-native scrolling
     *
     * @type static
     * @param el {Element} html-element
     * @return {void}
     */
    disableScrolling : function( el ) {
      this.enableScrolling( el );
      el.scrollLeft = 0;
      el.scrollTop = 0;
      el.addEventListener( "scroll", this._onscroll, false );
    },


    /**
     * Re-enables browser-native scrolling
     *
     * @type static
     * @param el {Element} html-element
     * @return {void}
     */
    enableScrolling : function( el ) {
      el.removeEventListener( "scroll", this._onscroll, false );
    },


    /**
     * Handler for the scroll-event
     *
     * @type static
     * @param ev {event} scroll-event
     * @return {void}
     */
    _onscroll : function(ev)
    {
      // RAP [if] Fix for bug 288737: Scroll bars are broken in Opera 10
      // https://bugs.eclipse.org/bugs/show_bug.cgi?id=288737
      var el = null;
      if(ev.target) {
        el = (ev.target == ev.currentTarget) ? ev.target : null;
      } else if(ev.srcElement){
        el = ev.srcElement;
      }
      if( el && ( ev.scrollLeft !== 0 || ev.scrollTop !== 0 ) ) {
        el.scrollLeft = 0;
        el.scrollTop = 0;
      }
    }
  }
});

/*******************************************************************************
 * Copyright (c) 2004, 2014 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

rwt.qx.Class.define( "rwt.html.StyleSheet", {

  statics : {

    /**
     * Creates a new Stylesheet node and append it to the document.
     */
    createElement : document.createStyleSheet ?
      // ie4+
      function( vCssText ) {
        var vSheet = document.createStyleSheet();
        if( vCssText ) {
          vSheet.cssText = vCssText;
        }
        return vSheet;
      } :
      // other
      function( vCssText ) {
        var vElement = document.createElement("style");
        vElement.type = "text/css";
        // Safari 2.0 doesn't like empty stylesheets
        vElement.appendChild(document.createTextNode(vCssText || "body {}"));
        document.getElementsByTagName("head")[0].appendChild(vElement);
        if( vElement.sheet ) {
          return vElement.sheet;
        } else {
          // Safari 2.0 doesn't support element.sheet so we neet a workaround
          var styles = document.styleSheets;
          for( var i=styles.length-1; i>=0; i-- ) {
            if( styles[i].ownerNode == vElement ) {
              return styles[i];
            }
          }
        }
        throw "Error: Could not get a reference to the sheet object";
      },

    /**
     * Inserts a new CSS rule into a given Stylesheet.
     */
    addRule : document.createStyleSheet ?
      // ie4+
      function( vSheet, vSelector, vStyle ) {
        vSheet.addRule( vSelector, vStyle );
      } :
      // other
      function( vSheet, vSelector, vStyle ) {
        vSheet.insertRule(vSelector + "{" + vStyle + "}", vSheet.cssRules.length);
      },

    /**
     * Removes a CSS rule from a stylesheet.
     */
    removeRule : document.createStyleSheet ?
      // ie4+
      function( vSheet, vSelector ) {
        var vRules = vSheet.rules;
        var vLength = vRules.length;
        for( var i = vLength - 1 ; i >= 0; i-- ) {
          if( vRules[i].selectorText == vSelector ) {
            vSheet.removeRule( i );
          }
        }
      } :
      // other
      function( vSheet, vSelector ) {
        var vRules = vSheet.cssRules;
        var vLength = vRules.length;
        for( var i = vLength - 1; i >= 0; i-- ) {
          if( vRules[i].selectorText == vSelector ) {
            vSheet.deleteRule( i );
          }
        }
      },

    /**
     * Removes all CSS rules from a stylesheet.
     */
    removeAllRules : document.createStyleSheet ?
      // ie4+
      function( vSheet ) {
        var vRules = vSheet.rules;
        var vLength = vRules.length;
        for( var i = vLength-1; i >= 0; i-- ) {
          vSheet.removeRule( i );
        }
      } :
      // other
      function( vSheet ) {
        var vRules = vSheet.cssRules;
        var vLength = vRules.length;
        for( var i = vLength - 1; i >= 0; i-- ) {
          vSheet.deleteRule( i );
        }
      }

  }

});

/*******************************************************************************
 * Copyright (c) 2014, 2015 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

namespace( "rwt.util" );

(function(){

  var Style = rwt.html.Style;
  var WidgetUtil = rwt.widgets.util.WidgetUtil;

/**
 * @private
 * @class An JQuery-like object which allows manipulation of HTML elements.
 * @exports rwt.util.RWTQuery as $
 * @description The constructor is not public. Instances can currently only be obtained from
 * {@link Widget#$el}.
 * @since 2.3
 */
rwt.util.RWTQuery = function( target ) {
  return new rwt.util.RWTQuery.fn.init( target );
};

rwt.util._RWTQuery = function( target ) {
  // TODO: If more methods are going to be made public almost all will also need restrictions
  return new rwt.util.RWTQuery.fn.init( target, true );
};

var $ = rwt.util.RWTQuery;

rwt.util._RWTQuery.prototype = $.prototype = {

  init : function( target, privileged ) {
    if( typeof target === "string" ) {
      target = parseHTML( target );
    }
    this.__access = function( args, callbackWidget, callbackElement ) {
      if( WidgetUtil.isWidget( target ) ) {
        if( typeof callbackWidget === "function" ) {
          return callbackWidget.apply( this, [ target, args, privileged ] );
        } else if( typeof callbackWidget === "string" ) {
          var element = asElement( target, callbackWidget );
          return callbackElement.apply( this, [ element, args, privileged ] );
        }
      }
      return callbackElement.apply( this, [ target, args, privileged ] );
    };
  },

  /**
   * @description A method to either set or get the value of an HTML-attribute.
   * Note that the attributes "id" and "class" can not be set this way.
   * @param {string|Object} attribute The name of the attribute to return or modify. Alternatively
   * a plain object with key-value pairs to set.
   * @param {string} [value] The value to set the attribute to.
   * @return {string|$} The value of the given attribute, if the function is called with a
   * string only. Otherwise a reference to this object.
   */
  attr : function() {
    return this.__access( arguments, attr_widget, attr_element );
  },

  removeAttr : function() {
    return this.__access( arguments, removeAttr_widget, removeAttr_element );
  },

  prop : function() { // TODO: widget could use inner outer outer depending on property
    return this.__access( arguments, "getElement", prop_element );
  },

  removeProp : function() {
    return this.__access( arguments, "getElement", removeProp_element );
  },

  append : function() {
    return this.__access( arguments, "_getTargetNode", append_element );
  },

  prepend : function() {
    return this.__access( arguments, "_getTargetNode", prepend_element );
  },

  detach : function() {
    return this.__access( arguments, null, detach_element );
  },

  appendTo : function() {
    return this.__access( arguments, null, appendTo_element );
  },

  insertAfter : function() {
    return this.__access( arguments, null, insertAfter_element );
  },

  insertBefore : function() {
    return this.__access( arguments, null, insertBefore_element );
  },

  /**
   * @description A method to either set or get the value of a CSS property. Note that RAP may overwrite any changes
   * made to a widget's style properties, and that the changes are not applied to the Java-side widget instance.
   * Modifying properties not used by RAP is safe. Supports only elements of control widgets.
   * @param {string|Object} property The name of the property to return or modify. Alternatively
   * a plain object with key-value pairs to set.
   * @param {string} [value] The value to set the property to.
   * @return {string|$} The value of the given property, if the function is called with a
   * string only. Otherwise a reference to this object.
   * @since 3.0
   */
  css : function() {
    return this.__access( arguments, css_widget, css_element );
  },

  outerHeight : function() {
    return this.__access( arguments, "getElement", outerHeight_element );
  },

  outerWidth : function() {
    return this.__access( arguments, "getElement", outerWidth_element );
  },

  text : function() {
    return this.__access( arguments, "_getTargetNode", text_element );
  },

  html : function() {
    return this.__access( arguments, "_getTargetNode", html_element );
  },

  empty : function() {
    return this.__access( arguments, "_getTargetNode", empty_element );
  },

  clone : function() {
    return this.__access( arguments, "getElement", clone_element );
  },

  /**
   * @name get
   * @methodOf $#
   * @description Retrieve the DOM element represented by this object. Supports only elements of control widgets.
   * @return {[HTMLElement]} Array with exactly one HTML element.
   * @since 3.0
   */
  "get" : function() {
    return this.__access( arguments, "getElement", get_element );
  },

  is : function() {
    return this.__access( arguments, null, is_element );
  },

  offset: function() {
    return this.__access( arguments, null, offset_element );
  }

};

$.fn = $.prototype; // for extendability
$.fn.init.prototype = $.prototype; // for creation without "new"

// TODO: these hooks are for element only, widgets would need separate ones
$.cssHooks = {
  "backgroundColor" : {
    "set" : function( element, value ) {
      rwt.html.Style.setBackgroundColor( element, value );
    },
    "get" : function( element ) {
      return rwt.html.Style.getBackgroundColor( element );
    }
  },
  "userSelect" : {
    "set" : function( element, value ) {
      rwt.html.Style.setUserSelect( element, value );
    },
    "get" : function( element ) {
      return rwt.html.Style.getUserSelect( element );
    }
  },
  "backgroundImage" : {
    "set" : function( element, value ) {
      rwt.html.Style.setBackgroundImage( element, fixBackgroundImage( value ) );
    },
    "get" : function( element ) {
      return rwt.html.Style.getBackgroundImage( element );
    }
  },
  "backgroundRepeat" : {
    "set" : function( element, value ) {
      rwt.html.Style.setBackgroundRepeat( element, value );
    },
    "get" : function( element ) {
      return rwt.html.Style.getBackgroundRepeat( element );
    }
  },
  "backgroundPosition" : {
    "set" : function( element, value ) {
      rwt.html.Style.setBackgroundPosition( element, value );
    },
    "get" : function( element ) {
      return rwt.html.Style.getBackgroundPosition( element );
    }
  },
  "backgroundGradient" : {
    "set" : function( element, value ) {
      rwt.html.Style.setBackgroundGradient( element, fixBackgroundGradient( value ) );
    },
    "get" : function( element ) {
      return rwt.html.Style.getBackgroundGradient( element );
    }
  },
  "textShadow" : {
    "set" : function( element, value ) {
      if( value instanceof Array ) {
        rwt.html.Style.setTextShadow( element, value );
      } else {
        element.style.textShadow = value;
      }
    }
  },
  "boxShadow" : {
    "set" : function( element, value ) {
      if( value instanceof Array ) {
        rwt.html.Style.setBoxShadow( element, value );
      } else {
        element.style.boxShadow = value;
      }
    }
  },
  "border" : {
    "set" : function( element, value ) {
      if( value && typeof value === "object" && value.renderElement ) {
        value.renderElement( element );
      } else {
        element.style.border = value;
      }
    }
  },
  "font" : {
    "set" : function( element, value ) {
      if( value && typeof value === "object" && value.renderElement ) {
        value.renderElement( element );
      } else {
        element.style.font = value;
      }
    }
  }
};

// NOTE: this list is still incomplete, extend as needed
$.widgetCssHooks = {
  "font": "font",
  "border": "border",
  "backgroundColor": "backgroundColor",
  "textShadow": "textShadow",
  "boxShadow": "shadow",
  "color": "textColor",
  "left": "left",
  "top": "top",
  "width": "width",
  "height": "height",
  "bottom": "bottom",
  "right": "right",
  "opacity": "opacity",
  "overflow": "overflow",
  "userSelect": "selectable",
  "backgroundImage": {
    "set" : function( widget, value ) {
      widget.set( "backgroundImage", fixBackgroundImage( value ) );
    }
  },
  "backgroundGradient" : {
    "set" : function( widget, value ) {
      widget.set( "backgroundGradient", fixBackgroundGradient( value ) );
    }
  }
};

$.cssNumber = {
  "columnCount" : true,
  "fillOpacity" : true,
  "fontWeight" : true,
  "lineHeight" : true,
  "opacity" : true,
  "zIndex" : true,
  "zoom" : true
};

var unwrapSetterArgsFor = function( originalSetter ) {
  return function( target, args, privileged ) {
    if( args.length === 1 && ( typeof args[ 0 ] === "object" ) ) {
      var map = args[ 0 ];
      for( var key in map ) {
        originalSetter.apply( this, [ target, [ key, map[ key ] ], privileged ] );
      }
      return this;
    }
    return originalSetter.apply( this, [ target, args, privileged ] );
  };
};

var unwrapStringListFor = function( originalHandler ) {
  return function( target, args, privileged ) {
    var arr = args[ 0 ].trim().split( " " );
    for( var i = 0; i < arr.length; i++ ) {
      if( arr[ i ] || arr[ i ].length > 0 ) {
        originalHandler.apply( this, [ target, arr[ i ], privileged ] );
      }
    }
    return this;
  };
};

var attr_widget = unwrapSetterArgsFor( function( widget, args, privileged ) {
  if( args.length === 1 ) {
    return widget.getHtmlAttributes()[ args[ 0 ] ];
  } else if( privileged || !restrictedAttributes[ args[ 0 ] ] ) {
    widget.setHtmlAttribute( args[ 0 ], args[ 1 ] );
  }
  return this;
} );

var attr_element = unwrapSetterArgsFor( function( element, args, privileged ) {
  if( args.length === 1 ) {
    return element.getAttribute( args[ 0 ] ) || undefined;
  } else if( privileged || !restrictedAttributes[ args[ 0 ] ] ) {
    element.setAttribute( args[ 0 ], args[ 1 ] );
  }
  return this;
} );

var removeAttr_widget = unwrapStringListFor( function( widget, arg ) {
  widget.setHtmlAttribute( arg, null );
} );

var removeAttr_element = unwrapStringListFor( function( element, arg ) {
  element.removeAttribute( arg );
} );

var prop_element = unwrapSetterArgsFor( function( element, args ) {
  if( args.length === 1 ) {
    return element[ args[ 0 ] ];
  } else {
    element[ args[ 0 ] ] = args[ 1 ];
  }
  return this;
} );

var removeProp_element = unwrapSetterArgsFor( function( element, args ) {
  try {
    element[ args[ 0 ] ] = "";
    delete element[ args[ 0 ] ];
  } catch( ex ) {
    // some properties can not be deleted
  }
  return this;
} );

var css_widget = unwrapSetterArgsFor( function( widget, args ) {
  var hook = $.widgetCssHooks[ args[ 0 ] ];
  if( args.length === 1 ) {
    if( hook && ( typeof hook === "string" || hook.get ) ) {
      if( typeof hook === "string" ) {
        var getter = "get" + hook.slice( 0, 1 ).toUpperCase() +  hook.slice( 1 );
        return widget[ getter ]();
      } else {
        return hook.get( widget );
      }
    }
    return widget.getStyleProperties()[ args[ 0 ] ];
  }
  if( hook && ( typeof hook === "string" || hook.set ) ) {
    if( typeof hook === "string"  ) {
      widget.set( hook, args[ 1 ] );
    } else {
      hook.set( widget, args[ 1 ] );
    }
  } else {
    widget.setStyleProperty( args[ 0 ], args[ 1 ] );
  }
  return this;
} );

var css_element = unwrapSetterArgsFor( function( element, args ) {
  var hook = $.cssHooks[ args[ 0 ] ];
  if( args.length === 1 ) {
    if( hook && hook.get ) {
      return hook.get( element );
    }
    return Style.get( element, args[ 0 ] );
  }
  if( hook && hook.set ) {
    hook.set( element, args[ 1 ] );
  } else {
    element.style[ args[ 0 ] ] = parseCssValue( args );
  }
  return this;
} );

var outerHeight_element = function( element ) {
  return element.offsetHeight;
};

var outerWidth_element = function( element ) {
  return element.offsetWidth;
};

var append_element = function( element, args ) {
  element.appendChild( asElement( args[ 0 ] ) );
  return this;
};

var prepend_element = function( element, args ) {
  element.insertBefore( asElement( args[ 0 ] ), element.firstChild );
  return this;
};

var insertAfter_element = function( element, args ) {
  var reference = asElement( args[ 0 ] );
  reference.parentNode.insertBefore( element, reference.nextSibling );
  return this;
};

var insertBefore_element = function( element, args ) {
  var reference = asElement( args[ 0 ] );
  reference.parentNode.insertBefore( element, reference );
  return this;
};

var appendTo_element = function( element, args ) {
  asElement( args[ 0 ], "_getTargetNode" ).appendChild( element );
  return this;
};

var detach_element = function( element ) {
  element.parentNode.removeChild( element );
  return this;
};

var get_element = function( element, args ) {
  var result = [ element ];
  return args.length > 0 ? result[ args[ 0 ] ] : result;
};

var is_element = function( element, args ) {
  return element === asElement( args[ 0 ] );
};

var offset_element = function( element ) {
  var location = rwt.html.Location.get( element );
  return {left: location.left, top: location.top};
};

var text_element = function( element, args ) {
  if( args.length === 0 )  {
    return element.textContent;
  }
  element.textContent = args[ 0 ];
  return this;
};

var html_element = function( element, args ) {
  if( args.length === 0 )  {
    return element.innerHTML;
  }
  element.innerHTML = args[ 0 ];
  return this;
};

var empty_element = function( element ) {
  while( element.firstChild ) {
    element.removeChild( element.firstChild );
  }
  return this;
};

var clone_element = function( element ) {
  var clone = element.cloneNode( true );
  for( var i = 0; i < cloneableProperties.length; i++ ) {
    var property = cloneableProperties[ i ];
    if( element[ property ] ) {
      clone[ property ] = element[ property ];
    }
  }
  return $( clone );
};

var restrictedAttributes = {
  "id" : true, // RAP renders IDs. While it does not rely on them, addons and future versions may.
  "class" : true, // May be used by RAP in the future, separate API could allow access
  "style" : true // Would destroy layout, separate API could allow (limited) access
};

var parseCssValue = function( args ) {
  if( typeof args[ 1 ] === "number" && !$.cssNumber[ args[ 0 ] ] ) {
    return args[ 1 ] + "px";
  }
  return args[ 1 ];
};

var parseHTML = function( str ) {
  var parsed = rsingleTag.exec( str );
  if( parsed ) {
    return document.createElement( parsed[ 1 ] );
  }
  throw new Error( "Invalid or unsupported HTML string" );
};

var fixBackgroundImage = function( value ) {
  if( value && value.trim().toLowerCase().indexOf( "url(" ) === 0 ) {
    return getCssFunctionParams( "url", value )[ 0 ];
  }
  return value;
};

var fixBackgroundGradient = function( value ) {
  if( value && typeof value === "string" ) {
    var params = getCssFunctionParams("linear-gradient", value);
    var horizontal = params[ 0 ] === "to right";
    cssCheck(horizontal || params[ 0 ] === "to bottom");
    var gradient = [];
    gradient.horizontal = horizontal;
    cssCheck(params.length > 2);
    for(var i = 1; i < params.length; i++) {
      var stop = trimAll(params[ i ].split(" ").reverse());
      stop[ 0 ] = parseInt(stop[ 0 ], 10) / 100;
      cssCheck(!isNaN(stop[ 0 ]));
      gradient.push(stop);
    }
    return gradient;
  }
  return value;
};

var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);

var getCssFunctionParams = function( fnName, cssValue ) {
  var trimmed = cssValue.trim().toLowerCase();
  var start = fnName + "(";
  if( trimmed.indexOf( start ) === 0 && trimmed.lastIndexOf( ")" ) === ( trimmed.length - 1 ) ) {
    return trimAll( trimmed.slice( start.length, -1 ).trim().split( "," ) );
  }
  cssCheck( false );
};

var trimAll = function( arr ) {
  return arr.map( function( str ){ return str.trim(); } );
};

var cssCheck = function( passed ) {
  if( !passed ) {
    throw new Error( "Invalid or unsupported css value" );
  }
};

var ensureWidgetElement = function( widget ) {
  if( !widget.getElement() ) {
    rwt.widgets.base.Widget.removeFromGlobalElementQueue( widget );
    widget._createElementImpl();
  }
};

var asElement = function( target, widgetElementGetter ) {
  if( WidgetUtil.isWidget( target ) ) {
    ensureWidgetElement( target );
    return target[ ( widgetElementGetter || "getElement" ) ]();
  }
  return target instanceof $ ? target.get( 0 ) : target;
};

var cloneableProperties = [
  "___rwtStyle__backgroundPosition",
  "___rwtStyle__backgroundGradient",
  "___rwtStyle__backgroundImage",
  "___rwtStyle__backgroundRepeat",
  "___rwtStyle__backgroundColor"
];

}());

/*******************************************************************************
 * Copyright (c) 2004, 2015 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource, and others.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/


/**
 * This is the main widget, all visible objects in the application extend this.
 *
 * @appearance widget
 * @state selected Set by {@link rwt.widgets.util.SelectionManager#renderItemSelectionState}
 * @state anchor Set by {@link rwt.widgets.util.SelectionManager#renderItemAnchorState}
 * @state lead Set by {@link rwt.widgets.util.SelectionManager#renderItemLeadState}
 *
 * @state disabled Set by {@link rwt.qx.Object#enabled}
 * @state focused Set by {@link #focused}
 */

/*jshint boss: true */
rwt.qx.Class.define( "rwt.widgets.base.Widget", {

  extend : rwt.qx.Target,
  include : rwt.widgets.util.HtmlAttributesMixin,

  construct : function() {
    this.base( arguments );
    this._layoutChanges = {};
    this._outerFrame = [ 0, 0 ];
  },

  statics : {

    //////////////////////
    // Global Widget Flush

    _globalWidgetQueue : [],
    _globalElementQueue : [],
    _globalStateQueue : [],
    _globalJobQueue : [],
    _globalLayoutQueue : [],
    _fastGlobalDisplayQueue : [],
    _lazyGlobalDisplayQueues : {},
    _globalDisposeQueue : [],

    _autoFlushTimeout : null,
    _flushGlobalQueuesPhase : 0,
    _renderHtmlIds : false,

    _FLUSH_PHASE_IDLE : 0,
    _FLUSH_PHASE_WIDGET : 1,
    _FLUSH_PHASE_STATE : 2,
    _FLUSH_PHASE_ELEMENT : 3,
    _FLUSH_PHASE_JOB : 4,
    _FLUSH_PHASE_LAYOUT : 5,
    _FLUSH_PHASE_DISPLAY : 6,
    _FLUSH_PHASE_DISPOSE : 7,

    _initAutoFlush : function( phase ) {
      if( rwt.widgets.base.Widget._autoFlushTimeout == null ) {
        // RAP: Fix for bug 303162
        if(    !rwt.widgets.base.Widget._inFlushGlobalQueues
            || phase < rwt.widgets.base.Widget._flushGlobalQueuesPhase ) {
          rwt.widgets.base.Widget._autoFlushTimeout
            = window.setTimeout( rwt.widgets.base.Widget._autoFlushHelper, 0 );
        }
      }
    },

    _removeAutoFlush : function() {
      if( rwt.widgets.base.Widget._autoFlushTimeout != null ) {
        window.clearTimeout( rwt.widgets.base.Widget._autoFlushTimeout );
        rwt.widgets.base.Widget._autoFlushTimeout = null;
      }
    },

    _autoFlushHelper : function() {
      try {
        rwt.widgets.base.Widget._autoFlushTimeout = null;
        if( !rwt.qx.Object.inGlobalDispose() ) {
          rwt.widgets.base.Widget.flushGlobalQueues();
        }
      }catch( ex ) {
        rwt.runtime.ErrorHandler.processJavaScriptError( ex );
      }
    },

    flushGlobalQueues : function() {
      if( rwt.widgets.base.Widget._autoFlushTimeout != null ) {
        rwt.widgets.base.Widget._removeAutoFlush();
      }
      if( rwt.widgets.base.Widget._inFlushGlobalQueues ) {
        return;
      }
      if( !rwt.runtime.System.getInstance().getUiReady() ) {
        return;
      }
      rwt.widgets.base.Widget._inFlushGlobalQueues = true;
      rwt.widgets.base.Widget.flushGlobalWidgetQueue();
      rwt.widgets.base.Widget.flushGlobalStateQueue();
      rwt.widgets.base.Widget.flushGlobalElementQueue();
      rwt.widgets.base.Widget.flushGlobalJobQueue();
      rwt.widgets.base.Widget.flushGlobalLayoutQueue();
      rwt.widgets.base.Widget.flushGlobalDisplayQueue();
      rwt.widgets.base.Widget.flushGlobalDisposeQueue();
      rwt.widgets.base.Widget._flushGlobalQueuesPhase = rwt.widgets.base.Widget._FLUSH_PHASE_IDLE;
      delete rwt.widgets.base.Widget._inFlushGlobalQueues;
    },

    addToGlobalWidgetQueue : function(vWidget) {
      if (!vWidget._isInGlobalWidgetQueue && vWidget._isDisplayable) {
        if (rwt.widgets.base.Widget._autoFlushTimeout == null) {
          rwt.widgets.base.Widget._initAutoFlush( rwt.widgets.base.Widget._FLUSH_PHASE_WIDGET );
        }
        rwt.widgets.base.Widget._globalWidgetQueue.push(vWidget);
        vWidget._isInGlobalWidgetQueue = true;
      }
    },

    removeFromGlobalWidgetQueue : function(vWidget) {
      if (vWidget._isInGlobalWidgetQueue) {
        rwt.util.Arrays.remove(rwt.widgets.base.Widget._globalWidgetQueue, vWidget);
        delete vWidget._isInGlobalWidgetQueue;
      }
    },

    flushGlobalWidgetQueue : function() {
      rwt.widgets.base.Widget._flushGlobalQueuesPhase = rwt.widgets.base.Widget._FLUSH_PHASE_WIDGET;
      var vQueue = rwt.widgets.base.Widget._globalWidgetQueue, vLength, vWidget;
      while ((vLength = vQueue.length) > 0) {
        for (var i=0; i<vLength; i++) {
          vWidget = vQueue[i];
          vWidget.flushWidgetQueue();
          delete vWidget._isInGlobalWidgetQueue;
        }
        vQueue.splice(0, vLength);
      }
      rwt.widgets.base.Widget._globalWidgetQueue = [];
    },

    addToGlobalElementQueue : function(vWidget) {
      if (!vWidget._isInGlobalElementQueue && vWidget._isDisplayable) {
        if (rwt.widgets.base.Widget._autoFlushTimeout == null) {
          rwt.widgets.base.Widget._initAutoFlush( rwt.widgets.base.Widget._FLUSH_PHASE_ELEMENT );
        }
        rwt.widgets.base.Widget._globalElementQueue.push(vWidget);
        vWidget._isInGlobalElementQueue = true;
      }
    },

    removeFromGlobalElementQueue : function(vWidget) {
      if (vWidget._isInGlobalElementQueue) {
        rwt.util.Arrays.remove(rwt.widgets.base.Widget._globalElementQueue, vWidget);
        delete vWidget._isInGlobalElementQueue;
      }
    },

    flushGlobalElementQueue : function() {
      rwt.widgets.base.Widget._flushGlobalQueuesPhase = rwt.widgets.base.Widget._FLUSH_PHASE_ELEMENT;
      var vQueue = rwt.widgets.base.Widget._globalElementQueue, vLength, vWidget;
      while ((vLength = vQueue.length) > 0) {
        for (var i=0; i<vLength; i++) {
          vWidget = vQueue[i];
          vWidget._createElementImpl();
          delete vWidget._isInGlobalElementQueue;
        }
        vQueue.splice(0, vLength);
      }
      rwt.widgets.base.Widget._globalElementQueue = [];
    },

    addToGlobalStateQueue : function(vWidget) {
      if (!vWidget._isInGlobalStateQueue && vWidget._isDisplayable) {
        if (rwt.widgets.base.Widget._autoFlushTimeout == null) {
          rwt.widgets.base.Widget._initAutoFlush( rwt.widgets.base.Widget._FLUSH_PHASE_STATE );
        }
        rwt.widgets.base.Widget._globalStateQueue.push(vWidget);
        vWidget._isInGlobalStateQueue = true;
      }
    },

    removeFromGlobalStateQueue : function(vWidget) {
      if (vWidget._isInGlobalStateQueue) {
        rwt.util.Arrays.remove(rwt.widgets.base.Widget._globalStateQueue, vWidget);
        delete vWidget._isInGlobalStateQueue;
      }
    },

    flushGlobalStateQueue : function() {
      rwt.widgets.base.Widget._flushGlobalQueuesPhase = rwt.widgets.base.Widget._FLUSH_PHASE_STATE;
      var Widget = rwt.widgets.base.Widget;
      // the queue may change while doing the flush so we work on a copy of
      // the queue and loop while the queue has any entries.
      while(Widget._globalStateQueue.length > 0) {
        var queue = rwt.util.Arrays.copy(Widget._globalStateQueue);
        Widget._globalStateQueue = [];
        for (var i=0, l=queue.length; i<l; i++) {
          var widget = queue[i];
          if (widget._isInGlobalStateQueue) {
            widget._renderAppearance();
            delete widget._isInGlobalStateQueue;
          }
        }
      }
    },

    addToGlobalJobQueue : function(vWidget) {
      if (!vWidget._isInGlobalJobQueue && vWidget._isDisplayable) {
        if (rwt.widgets.base.Widget._autoFlushTimeout == null) {
          rwt.widgets.base.Widget._initAutoFlush( rwt.widgets.base.Widget._FLUSH_PHASE_JOB );
        }
        rwt.widgets.base.Widget._globalJobQueue.push(vWidget);
        vWidget._isInGlobalJobQueue = true;
      }
    },

    removeFromGlobalJobQueue : function(vWidget) {
      if (vWidget._isInGlobalJobQueue) {
        rwt.util.Arrays.remove(rwt.widgets.base.Widget._globalJobQueue, vWidget);
        delete vWidget._isInGlobalJobQueue;
      }
    },

    flushGlobalJobQueue : function() {
      rwt.widgets.base.Widget._flushGlobalQueuesPhase
        = rwt.widgets.base.Widget._FLUSH_PHASE_JOB;
      var vQueue = rwt.widgets.base.Widget._globalJobQueue, vLength, vWidget;
      while ((vLength = vQueue.length) > 0) {
        for (var i=0; i<vLength; i++) {
          vWidget = vQueue[i];
          vWidget._flushJobQueue(vWidget._jobQueue);
          delete vWidget._isInGlobalJobQueue;
        }
        vQueue.splice(0, vLength);
      }
      rwt.widgets.base.Widget._globalJobQueue = [];
    },

    addToGlobalLayoutQueue : function(vParent) {
      if (!vParent._isInGlobalLayoutQueue && vParent._isDisplayable) {
        if (rwt.widgets.base.Widget._autoFlushTimeout == null) {
          rwt.widgets.base.Widget._initAutoFlush( rwt.widgets.base.Widget._FLUSH_PHASE_LAYOUT );
        }
        rwt.widgets.base.Widget._globalLayoutQueue.push(vParent);
        vParent._isInGlobalLayoutQueue = true;
      }
    },

    removeFromGlobalLayoutQueue : function(vParent) {
      if (vParent._isInGlobalLayoutQueue) {
        rwt.util.Arrays.remove(rwt.widgets.base.Widget._globalLayoutQueue, vParent);
        delete vParent._isInGlobalLayoutQueue;
      }
    },

    flushGlobalLayoutQueue : function() {
      rwt.widgets.base.Widget._flushGlobalQueuesPhase = rwt.widgets.base.Widget._FLUSH_PHASE_LAYOUT;
      var vQueue = rwt.widgets.base.Widget._globalLayoutQueue, vLength, vParent;
      while ((vLength = vQueue.length) > 0) {
        for (var i=0; i<vLength; i++) {
          vParent = vQueue[i];
          vParent._flushChildrenQueue();
          delete vParent._isInGlobalLayoutQueue;
        }
        vQueue.splice(0, vLength);
      }
      rwt.widgets.base.Widget._globalLayoutQueue = [];
    },

    addToGlobalDisplayQueue : function(vWidget) {
      if (!vWidget._isInGlobalDisplayQueue && vWidget._isDisplayable) {
        if (rwt.widgets.base.Widget._autoFlushTimeout == null) {
          rwt.widgets.base.Widget._initAutoFlush( rwt.widgets.base.Widget._FLUSH_PHASE_DISPLAY );
        }
        var vParent = vWidget.getParent();
        if (vParent.isSeeable()) {
          var vKey = vParent.toHashCode();
          if (rwt.widgets.base.Widget._lazyGlobalDisplayQueues[vKey]) {
            rwt.widgets.base.Widget._lazyGlobalDisplayQueues[vKey].push(vWidget);
          } else {
            rwt.widgets.base.Widget._lazyGlobalDisplayQueues[vKey] = [ vWidget ];
          }
        } else {
          rwt.widgets.base.Widget._fastGlobalDisplayQueue.push(vWidget);
        }
        vWidget._isInGlobalDisplayQueue = true;
      }
    },

    removeFromGlobalDisplayQueue : function() {},

    flushGlobalDisplayQueue : function() {
      rwt.widgets.base.Widget._flushGlobalQueuesPhase = rwt.widgets.base.Widget._FLUSH_PHASE_DISPLAY;
      var vKey, vLazyQueue, vWidget, vFragment;
      var vFastQueue = rwt.widgets.base.Widget._fastGlobalDisplayQueue;
      var vLazyQueues = rwt.widgets.base.Widget._lazyGlobalDisplayQueues;
      // Work on fast queue
      for (var i=0, l=vFastQueue.length; i<l; i++) {
        vWidget = vFastQueue[i];
        vWidget.getParent()._getTargetNode().appendChild(vWidget.getElement());
      }
      // Work on lazy queues: Other widgets
      for (vKey in vLazyQueues) {
        vLazyQueue = vLazyQueues[vKey];
        // Speed enhancement: Choose a fairly small arbitrary value for the number
        // of elements that should be added to the parent individually.  If more
        // than this number of elements is to be added to the parent, we'll create
        // a document fragment, add the elements to the document fragment, and
        // then add the whole fragment to the parent en mass (assuming that
        // creation of a document fragment is supported by the browser).
        if (document.createDocumentFragment && vLazyQueue.length >= 3) {
          // creating new document fragment
          vFragment = document.createDocumentFragment();
          // appending all widget elements to fragment
          for (var i=0, l=vLazyQueue.length; i<l; i++) {
            vWidget = vLazyQueue[i];
            vFragment.appendChild(vWidget.getElement());
          }
          // append all fragment data at once to
          // the already visible parent widget element
          vLazyQueue[0].getParent()._getTargetNode().appendChild(vFragment);
          for (var i=0, l=vLazyQueue.length; i<l; i++) {
            vWidget = vLazyQueue[i];
            vWidget._afterInsertDom();
          }
        } else {
          // appending all widget elements (including previously added children)
          // to the already visible parent widget element
          for (var i=0, l=vLazyQueue.length; i<l; i++)
          {
            vWidget = vLazyQueue[i];
            vWidget.getParent()._getTargetNode().appendChild(vWidget.getElement());
            vWidget._afterInsertDom();
          }
        }
      }
      // Only need to do this with the lazy queues
      // because through the recursion from rwt.widgets.base.Parent
      // all others get also informed.
      for (vKey in vLazyQueues) { vLazyQueue = vLazyQueues[vKey];
        for (var i=0, l=vLazyQueue.length; i<l; i++) {
          vWidget = vLazyQueue[i];
          if (vWidget.getVisibility()) {
            vWidget._afterAppear();
          }
          // Reset display queue flag
          delete vWidget._isInGlobalDisplayQueue;
        }
        delete vLazyQueues[vKey];
      }
      // reset queue if it is empty. This frees some browser memory
      if (rwt.util.Objects.isEmpty(vLazyQueues)) {
        rwt.widgets.base.Widget._lazyGlobalDisplayQueues = {};
      }
      // Reset display queue flag for widgets in fastQueue
      for (var i=0, l=vFastQueue.length; i<l; i++) {
        delete vFastQueue[i]._isInGlobalDisplayQueue;
      }
      // Remove fast queue entries
      rwt.widgets.base.Widget._fastGlobalDisplayQueue = [];
    },

    addToGlobalDisposeQueue : function(vWidget) {
      if (!vWidget._isInGlobalDisposeQueue && !vWidget.isDisposed()) {
        if (rwt.widgets.base.Widget._autoFlushTimeout == null) {
          rwt.widgets.base.Widget._initAutoFlush( rwt.widgets.base.Widget._FLUSH_PHASE_DISPOSE );
        }
        rwt.widgets.base.Widget._globalDisposeQueue.push(vWidget);
        vWidget._markInDispose();
      }
    },

    flushGlobalDisposeQueue : function() {
      rwt.widgets.base.Widget._flushGlobalQueuesPhase
        = rwt.widgets.base.Widget._FLUSH_PHASE_DISPOSE;
      var vQueue = rwt.widgets.base.Widget._globalDisposeQueue, vLength, vWidget;
      while ((vLength = vQueue.length) > 0) {
        for (var i=0; i<vLength; i++) {
          vWidget = vQueue[i];
          vWidget.dispose();
          delete vWidget._isInGlobalDisposeQueue;
        }
        vQueue.splice(0, vLength);
      }
      rwt.widgets.base.Widget._globalDisposeQueue = [];
    },

    /////////////////
    // Global Helpers

    getActiveSiblingHelperIgnore : function(vIgnoreClasses, vInstance) {
      for (var j=0; j<vIgnoreClasses.length; j++) {
        if (vInstance instanceof vIgnoreClasses[j]) {
          return true;
        }
      }
      return false;
    },

    getActiveSiblingHelper : function(vObject, vParent, vCalc, vIgnoreClasses, vMode) {
      if (!vIgnoreClasses) {
        vIgnoreClasses = [];
      }
      var vChilds = vParent.getChildren();
      var vPosition = vMode == null ? vChilds.indexOf(vObject) + vCalc : vMode === "first" ? 0 : vChilds.length - 1;
      var vInstance = vChilds[vPosition];
      while (vInstance && (!vInstance.getEnabled() || rwt.widgets.base.Widget.getActiveSiblingHelperIgnore(vIgnoreClasses, vInstance))) {
        vPosition += vCalc;
        vInstance = vChilds[vPosition];
        if (!vInstance) {
          return null;
        }
      }
      return vInstance;
    },

    ///////////////////////
    //  APPLY LAYOUT STYLES

    TYPE_NULL : 0,
    TYPE_PIXEL : 1,
    TYPE_PERCENT : 2,
    TYPE_AUTO : 3,
    TYPE_FLEX : 4,

    __initApplyMethods : function(members) {
      var applyRuntime = "_renderRuntime";
      var resetRuntime = "_resetRuntime";
      var style = "this._style.";
      var cssValue = "=((v==null)?0:v)+'px'";
      var parameter = "v";
      var properties = [
        "left",
        "right",
        "top",
        "bottom",
        "width",
        "height",
        "minWidth",
        "maxWidth",
        "minHeight",
        "maxHeight"
      ];
      var propertiesUpper = [
        "Left",
        "Right",
        "Top",
        "Bottom",
        "Width",
        "Height",
        "MinWidth",
        "MaxWidth",
        "MinHeight",
        "MaxHeight"
      ];
      var applyMargin = applyRuntime + "Margin";
      var resetMargin = resetRuntime + "Margin";
      var styleMargin = style + "margin";
      for (var i=0; i<4; i++) {
        members[applyMargin + propertiesUpper[i]]
          = new Function(parameter, styleMargin + propertiesUpper[i] + cssValue);
        members[resetMargin + propertiesUpper[i]]
          = new Function(styleMargin + propertiesUpper[i] + "=''");
      }
      var applyPadding = applyRuntime + "Padding";
      var resetPadding = resetRuntime + "Padding";
      // need to use setStyleProperty to keep compatibility with enhanced cross browser borders
      for (var i=0; i<4; i++) {
        members[applyPadding + propertiesUpper[i]]
          = new Function(parameter, "this.setStyleProperty('padding" + propertiesUpper[i] + "', ((v==null)?0:v)+'px')");
        members[resetPadding + propertiesUpper[i]]
          = new Function("this.removeStyleProperty('padding" + propertiesUpper[i] + "')");
      }

      /*
        Use optimized method for internet explorer
        to omit string concat and directly setup
        the new layout property.
         We could not use this to reset the value however.
        It seems that is just doesn't work this way. And the
        left/top always get priority. Tried: "", null, "auto".
        Nothing helps.
         Now I've switched back to the conventional method
        to reset the value. This seems to work again.
      */
      for (var i=0; i<properties.length; i++) {
        members[applyRuntime + propertiesUpper[i]]
          = new Function(parameter, style + properties[i] + cssValue);
        members[resetRuntime + propertiesUpper[i]] = new Function(style + properties[i] + "=''");
      }
    },

    ///////////////////////////////////////
    //  LAYOUT TYPE AND VALUE KEY PRE-CACHE

    layoutPropertyTypes : {},

    __initLayoutProperties : function(statics) {
      var a = [
        "width",
        "height",
        "minWidth",
        "maxWidth",
        "minHeight",
        "maxHeight",
        "left",
        "right",
        "top",
        "bottom"
      ];
      for (var i=0, l=a.length, p, b, t; i<l; i++) {
        p = a[i];
        b = "_computed" + rwt.util.Strings.toFirstUp(p);
        t = b + "Type";
        statics.layoutPropertyTypes[p] = {
          dataType    : t,
          dataParsed  : b + "Parsed",
          dataValue   : b + "Value",
          typePixel   : t + "Pixel",
          typePercent : t + "Percent",
          typeAuto    : t + "Auto",
          typeFlex    : t + "Flex",
          typeNull    : t + "Null"
        };
      }
    },

    //////////////////
    //  SCROLL-BLOCKER

    disableScrolling : function( widget ) {
      var el = widget._getTargetNode();
      if( el ) {
        rwt.html.Scroll.disableScrolling(el);
      } else {
        widget.addEventListener( "appear", this._blockScrollingOnAppear, widget );
      }
    },

    enableScrolling : function( widget ) {
      var el = widget._getTargetNode();
      if( el ) {
        rwt.html.Scroll.enableScrolling( el );
      } else {
        widget.removeEventListener( "appear", this._blockScrollingOnAppear, widget );
      }
    },

    _blockScrollingOnAppear : function() {
      var func = rwt.widgets.base.Widget._blockScrollingOnAppear;
      this.removeEventListener( "appear", func, this );
      rwt.widgets.base.Widget.disableScrolling( this );
    }

  },

  properties : {
    enabled : {
      init : "inherit",
      check : "Boolean",
      inheritable : true,
      apply : "_applyEnabled",
      event : "changeEnabled"
    },

    /** The parent widget (the real object, no ID or something) */
    parent : {
      check : "rwt.widgets.base.Parent",
      nullable : true,
      event : "changeParent",
      apply : "_applyParent"
    },

    /** The element node (if the widget is created, otherwise null) */
    element : {
      check : "Element",
      nullable : true,
      apply : "_applyElement",
      event : "changeElement"
    },

    /**
     * Toggle the visibility of a widget.
     * Setting this property to false will hide the widget but will not remove
     * it from the layout flow, so other widgets will not be repositioned. This
     * is similar to the CSS property <code>visibility</code>.
     **/
    visibility : {
      check : "Boolean",
      init : true,
      apply : "_applyVisibility",
      event : "changeVisibility"
    },

    /**
     * Whether the widget should be displayed.
     * Use this property instead of visibility if the change of the visibility
     * should remove the widget from the layout flow and force a relayout of the
     * application. This is similar to the CSS property <code>display</code>.
     */
    display : {
      check : "Boolean",
      init : true,
      apply : "_applyDisplay",
      event : "changeDisplay"
    },

    /**
     * If you switch this to true, the widget doesn't handle
     *  events directly. It will redirect them to the parent
     *  widget.
     */
    anonymous : {
      check : "Boolean",
      init: false,
      event : "changeAnonymous"
    },

    /**
     * This is used by many layout managers to control the individual horizontal alignment of this widget inside this parent.
     *
     *  This should be used with caution since in some cases
     *  this might give unrespected results.
     */
    horizontalAlign : {
      check : [ "left", "center", "right" ],
      themeable : true,
      nullable : true
    },

    /**
     * This is used by many layout managers to control the individual vertical alignment of this widget inside this parent.
     *
     *  This should be used with caution since in some cases
     *  this might give unrespected results.
     */
    verticalAlign :  {
      check : [ "top", "middle", "bottom" ],
      themeable : true,
      nullable : true
    },

    /**
     * Should this widget be stretched on the x-axis if the layout handler will do this?
     *  Used by some layout handlers (rwt.widgets.base.BoxLayout, ...).
     */
    allowStretchX : {
      check : "Boolean",
      init : true
    },

    /**
     * Should this widget be stretched on the y-axis if the layout handler will do this?
     *  Used by some layout handlers (rwt.widgets.base.BoxLayout, ...).
     */
    allowStretchY : {
      check : "Boolean",
      init : true
    },

    /**
     * Mapping to native style property z-index.
     *
     *  This should be used with caution since in some cases
     *  this might give unrespected results.
     */
    zIndex : {
      check : "Number",
      apply : "_applyZIndex",
      event : "changeZIndex",
      themeable : true,
      nullable : true,
      init : null
    },

    /**
     * The backgroundColor style property of the rendered widget.
     */
    backgroundColor : {
      nullable : true,
      init : null,
      check : "Color",
      apply : "_applyBackgroundColor",
      event : "changeBackgroundColor",
      themeable : true
    },

    backgroundGradient : {
      check : "Array",
      nullable : true,
      init : null,
      apply : "_applyBackgroundGradient",
      event : "changeBackgroundGradient",
      themeable : true
    },

    /**
     * Syntax for shadow:
     * [
     *    inset, //boolean, currently not supported
     *    offsetX, // positive or negative number
     *    offsetY, // positive or negative number
     *    blurRadius, // positive number or zero
     *    spread, // positive or negative number
     *    color, // string
     *    opacity, // number between 0 and 1
     * ]
     */
    shadow : {
      check : "Array",
      nullable : true,
      init : null,
      apply : "_applyShadow",
      event : "changeShadow",
      themeable : true
    },

    textShadow : {
      check : "Array",
      nullable : true,
      init : null,
      apply : "_applyTextShadow",
      event : "changeTextShadow",
      themeable : true
   },

    /**
     * The color (textColor) style property of the rendered widget.
     */
    textColor : {
      nullable : true,
      init : "inherit",
      check : "Color",
      apply : "_applyTextColor",
      event : "changeTextColor",
      themeable : true,
      inheritable : true
    },

    /**
     * The border property describes how to paint the border on the widget.
     */
    border : {
      nullable : true,
      init : null,
      apply : "_applyBorder",
      event : "changeBorder",
      check : "Border",
      themeable : true
    },

    /** The font property describes how to paint the font on the widget. */
    font : {
      nullable : true,
      init : "inherit",
      apply : "_applyFont",
      check : "Font",
      event : "changeFont",
      themeable : true,
      inheritable : true
    },

    /**
     * Mapping to native style property opacity.
     *
     *  The uniform opacity setting to be applied across an entire object. Behaves like the new CSS-3 Property.
     *  Any values outside the range 0.0 (fully transparent) to 1.0 (fully opaque) will be clamped to this range.
     */
    opacity : {
      check : "Number",
      apply : "_applyOpacity",
      themeable : true,
      nullable : true,
      init : null
    },

    /**
     * Mapping to native style property cursor.
     *
     * The name of the cursor to show when the mouse pointer is over the widget.
     * This is any valid CSS2 cursor name defined by W3C.
     *
     * The following values are possible crossbrowser:
     * <ul><li>default</li>
     * <li>crosshair</li>
     * <li>pointer</li>
     * <li>move</li>
     * <li>n-resize</li>
     * <li>ne-resize</li>
     * <li>e-resize</li>
     * <li>se-resize</li>
     * <li>s-resize</li>
     * <li>sw-resize</li>
     * <li>w-resize</li>
     * <li>nw-resize</li>
     * <li>text</li>
     * <li>wait</li>
     * <li>help </li>
     * </ul>
     */
    cursor : {
      check : "String",
      apply : "_applyCursor",
      event : "changeCursor",
      themeable : true,
      nullable : true,
      init : null
    },

    /**
     * Mapping to native style property background-image.
     *
     *  The URI of the image file to use as background image.
     */
    backgroundImage : {
      check : "String",
      nullable : true,
      apply : "_applyBackgroundImage",
      themeable : true
    },

    /**
     * Mapping to native style property background-repeat.
     */
    backgroundRepeat : {
      check : [ "repeat", "repeat-x", "repeat-y", "no-repeat" ],
      nullable : true,
      apply : "_applyBackgroundRepeat",
      themeable : true
    },

    /**
     * Mapping to native style property background-position.
     */
    backgroundPosition : {
      check : [ "left top", "left center", "left bottom",
                "right top", "right center", "right bottom",
                "center top", "center center", "center bottom" ],
      nullable : true,
      apply : "_applyBackgroundPosition",
      themeable : true
    },

    /**
     * Describes how to handle content that is too large to fit inside the widget.
     *
     * Overflow modes:
     * <table>
     * <tr><th>hidden</th><td>The content is clipped</td></tr>
     * <tr><th>auto</th><td>Scroll bars are shown as needed</td></tr>
     * <tr><th>scroll</th><td>Scroll bars are always shown. Even if there is enough room for the content inside the widget.</td></tr>
     * <tr><th>scrollX</th><td>Scroll bars for the X-Axis are always shown. Even if there is enough room for the content inside the widget.</td></tr>
     * <tr><th>scrollY</th><td>Scroll bars for the Y-Axis are always shown. Even if there is enough room for the content inside the widget.</td></tr>
     * </table>
     */
    overflow : {
      check : ["hidden", "auto", "scroll" ,"scrollX", "scrollY"],
      nullable : true,
      apply : "_applyOverflow",
      event : "changeOverflow",
      themeable : true,
      init : null
    },

    /**
     * Enables/disables overflow on the outer element for enhanced borders.
     */
    containerOverflow : {
      check : "Boolean",
      nullable : false,
      apply : "_applyContainerOverflow",
      themeable : true,
      init : true
    },

    /** Clipping of the widget (left) */
    clipLeft : {
      check : "Integer",
      apply : "_applyClip",
      themeable : true,
      nullable : true
    },

    /** Clipping of the widget (top) */
    clipTop : {
      check : "Integer",
      apply : "_applyClip",
      themeable : true,
      nullable : true
    },

    /** Clipping of the widget (width) */
    clipWidth : {
      check : "Integer",
      apply : "_applyClip",
      themeable : true,
      nullable : true
    },

    /** Clipping of the widget (height) */
    clipHeight : {
      check : "Integer",
      apply : "_applyClip",
      themeable : true,
      nullable : true
    },

    /**
     * Set this to a positive value makes the widget able to get the focus.
     * It even is reachable through the usage of the tab-key.
     *
     * Widgets with the same tabIndex are handled through there position
     * in the document.
     *
     * Setting the tabIndex to -1 deactivate focus handling for the widget.
     */
    tabIndex : {
      check : "Integer",
      nullable : true,
      init : null,
      apply : "_applyTabIndex",
      event : "changeTabIndex"
    },

    /** If the focus outline should be hidden. */
    hideFocus : {
      check : "Boolean",
      init : true,
      themeable : true
    },

    /** Use DOM focussing (focus() and blur() methods of DOM nodes) */
    enableElementFocus : {
      check : "Boolean",
      init : true
    },

    /**
     * Handle focus state of this widget.
     *
     *  someWidget.setFocused(true) set the current focus to this widget.
     *  someWidget.setFocused(false) remove the current focus and leave it blank.
     *
     *  Normally you didn't need to set this directly.
     */
    focused : {
      check : "Boolean",
      init : false,
      apply : "_applyFocused",
      event : "changeFocused"
    },

    /** Toggle the possibility to select the element of this widget. */
    selectable : {
      check : "Boolean",
      init : null,
      nullable : true,
      apply : "_applySelectable"
    },

    /** Contains the tooltip object connected to the widget. */
    toolTipText : {
      nullable : true,
      event: "changeToolTipText"
    },

    /** Contains the context menu object connected to the widget. (Need real implementation) */
    // RAP : remove check, allow other menu implementation
    contextMenu : {
      nullable : true,
      event: "changeContextMenu"
    },

    /** Capture all events and map them to this widget */
    capture : {
      check : "Boolean",
      init : false,
      apply : "_applyCapture",
      event : "changeCapture"
    },

    /** Contains the support drop types for drag and drop support */
    dropDataTypes : {
      nullable : true,
      dispose : true
    },

    /** A command called if the widget should be excecuted (a placeholder for buttons, ...) */
    command : {
      check : "qx.client.Command",
      nullable : true,
      apply : "_applyCommand"
    },

    /** Appearance of the widget */
    appearance : {
      check : "String",
      init : "widget",
      apply : "_applyAppearance",
      event : "changeAppearance"
    },

    /*
     * The method which this.supportsDrop() calls to determine whether the
     * widget supports a particular drop operation.
     *
     * This is a property so that a mixin can modify it.  Otherwise, the mixin
     * would have to override the supportsDrop() method, requiring the mixin
     * to be applied with patch() instead of include().  All normal mixins
     * should be able to be simply include()ed, and not have to be patch()ed.
     *
     * If this property is null, then the default supportsDrop() action
     * defined herein shall be used.
     */
    supportsDropMethod : {
      check : "Function",
      nullable : true,
      init : null
    },

    /** Margin of the widget (top) */
    marginTop : {
      check : "Number",
      apply : "_applyMarginTop",
      nullable : true,
      themeable : true
    },

    /** Margin of the widget (right) */
    marginRight : {
      check : "Number",
      apply : "_applyMarginRight",
      nullable : true,
      themeable : true
    },

    /** Margin of the widget (bottom) */
    marginBottom : {
      check : "Number",
      apply : "_applyMarginBottom",
      nullable : true,
      themeable : true
    },

    /** Margin of the widget (left) */
    marginLeft : {
      check : "Number",
      apply : "_applyMarginLeft",
      nullable : true,
      themeable : true
    },

    /** Padding of the widget (top) */
    paddingTop : {
      check : "Number",
      apply : "_applyPaddingTop",
      nullable : true,
      themeable : true
    },

    /** Padding of the widget (right) */
    paddingRight : {
      check : "Number",
      apply : "_applyPaddingRight",
      nullable : true,
      themeable : true
    },

    /** Padding of the widget (bottom) */
    paddingBottom : {
      check : "Number",
      apply : "_applyPaddingBottom",
      nullable : true,
      themeable : true
    },

    /** Padding of the widget (left) */
    paddingLeft : {
      check : "Number",
      apply : "_applyPaddingLeft",
      nullable : true,
      themeable : true
    },

    /**
     * The distance from the outer left border to the parent left area edge.
     *
     *  You could only set two of the three horizonal dimension properties (boxLeft, boxRight, boxWidth)
     *  at the same time. This will be omitted during the setup of the new third value. To reset a value
     *  you didn't want anymore, set it to null.
     */
    left : {
      apply : "_applyLeft",
      event : "changeLeft",
      nullable : true,
      themeable : true,
      init : null
    },

    /**
     * The distance from the outer right border to the parent right area edge.
     *
     *  You could only set two of the three horizonal dimension properties (boxLeft, boxRight, boxWidth)
     *  at the same time. This will be omitted during the setup of the new third value. To reset a value
     *  you didn't want anymore, set it to null.
     */
    right : {
      apply : "_applyRight",
      event : "changeRight",
      nullable : true,
      themeable : true,
      init : null
    },

    /**
     * The width of the box (including padding and border).
     *
     *  You could only set two of the three horizonal dimension properties (boxLeft, boxRight, boxWidth)
     *  at the same time. This will be omitted during the setup of the new third value. To reset a value
     *  you didn't want anymore, set it to null.
     */
    width : {
      apply : "_applyWidth",
      event : "changeWidth",
      nullable : true,
      themeable : true,
      init : null
    },

    /**
     * The minimum width of the box (including padding and border).
     *
     *  Set this to omit the shrinking of the box width under this value.
     */
    minWidth : {
      apply : "_applyMinWidth",
      event : "changeMinWidth",
      nullable : true,
      themeable : true,
      init : null
    },

    /**
     * The maximum width of the box (including padding and border).
     *
     *  Set this to omit the expanding of the box width above this value.
     */
    maxWidth : {
      apply : "_applyMaxWidth",
      event : "changeMaxWidth",
      nullable : true,
      themeable : true,
      init : null
    },

    /**
     * The distance from the outer top border to the parent top area edge.
     *
     *  You could only set two of the three vertical dimension properties (boxTop, boxBottom, boxHeight)
     *  at the same time. This will be omitted during the setup of the new third value. To reset a value
     *  you didn't want anymore, set it to null.
     */
    top : {
      apply : "_applyTop",
      event : "changeTop",
      nullable : true,
      themeable : true,
      init : null
    },

    /**
     * The distance from the outer bottom border to the parent bottom area edge.
     *
     *  You could only set two of the three vertical dimension properties (boxTop, boxBottom, boxHeight)
     *  at the same time. This will be omitted during the setup of the new third value. To reset a value
     *  you didn't want anymore, set it to null.
     */
    bottom : {
      apply : "_applyBottom",
      event : "changeBottom",
      nullable : true,
      themeable : true,
      init : null
    },

    /**
     * The height of the box (including padding and border).
     *
     *  You could only set two of the three vertical dimension properties (boxTop, boxBottom, boxHeight)
     *  at the same time. This will be omitted during the setup of the new third value. To reset a value
     *  you didn't want anymore, set it to null.
     */
    height : {
      apply : "_applyHeight",
      event : "changeHeight",
      nullable : true,
      themeable : true,
      init : null
    },

    /**
     * The minimum height of the box (including padding and border).
     *
     *  Set this to omit the shrinking of the box height under this value.
     */
    minHeight : {
      apply : "_applyMinHeight",
      event : "changeMinHeight",
      nullable : true,
      themeable : true,
      init : null
    },

    /**
     * The maximum height of the box (including padding and border).
     *
     *  Set this to omit the expanding of the box height above this value.
     */
    maxHeight : {
      apply : "_applyMaxHeight",
      event : "changeMaxHeight",
      nullable : true,
      themeable : true,
      init : null
    },

    location : { group : [ "left", "top" ], themeable : true },
    dimension : { group : [ "width", "height" ], themeable : true },
    space : { group : [ "left", "width", "top", "height" ], themeable : true },

    edge : {
      group : [ "top", "right", "bottom", "left" ],
      themeable : true,
      mode  : "shorthand"
    },

    padding : {
      group : [ "paddingTop", "paddingRight", "paddingBottom", "paddingLeft" ],
      mode  : "shorthand",
      themeable : true
    },

    /**
     * The 'margin' property is a shorthand property for setting 'marginTop',
     * 'marginRight', 'marginBottom' and 'marginLeft' at the same time.
     *
     * If four length values are specified they apply to top, right, bottom and
     * left respectively. If there is only one value, it applies to all sides,
     * if there are two or three, the missing values are taken from the opposite side.
     */
    margin : {
      group : [ "marginTop", "marginRight", "marginBottom", "marginLeft" ],
      mode  : "shorthand",
      themeable : true
    },

    heights : { group : [ "minHeight", "height", "maxHeight" ], themeable : true },
    widths : { group : [ "minWidth", "width", "maxWidth" ], themeable : true },

    /**
     * The 'align' property is a shorthand property for setting 'horizontalAlign',
     * and 'verticalAlign' at the same time.
     */
    align : { group : [ "horizontalAlign", "verticalAlign" ], themeable : true },
    clipLocation : { group : [ "clipLeft", "clipTop" ] },
    clipDimension : { group : [ "clipWidth", "clipHeight" ] },
    clip : { group : [ "clipLeft", "clipTop", "clipWidth", "clipHeight" ] },

    innerWidth : {
      _cached      : true,
      defaultValue : null
    },

    innerHeight : {
      _cached      : true,
      defaultValue : null
    },

    boxWidth : {
      _cached      : true,
      defaultValue : null
    },

    boxHeight : {
      _cached      : true,
      defaultValue : null
    },

    outerWidth : {
      _cached      : true,
      defaultValue : null
    },

    outerHeight : {
      _cached      : true,
      defaultValue : null
    },

    frameWidth : {
      _cached           : true,
      defaultValue      : null,
      addToQueueRuntime : true
    },

    frameHeight : {
      _cached           : true,
      defaultValue      : null,
      addToQueueRuntime : true
    },

    preferredInnerWidth : {
      _cached           : true,
      defaultValue      : null,
      addToQueueRuntime : true
    },

    preferredInnerHeight : {
      _cached           : true,
      defaultValue      : null,
      addToQueueRuntime : true
    },

    preferredBoxWidth : {
      _cached      : true,
      defaultValue : null
    },

    preferredBoxHeight : {
      _cached      : true,
      defaultValue : null
    },

    hasPercentX : {
      _cached      : true,
      defaultValue : false
    },

    hasPercentY : {
      _cached      : true,
      defaultValue : false
    },

    hasAutoX : {
      _cached      : true,
      defaultValue : false
    },

    hasAutoY : {
      _cached      : true,
      defaultValue : false
    },

    hasFlexX : {
      _cached      : true,
      defaultValue : false
    },

    hasFlexY : {
      _cached      : true,
      defaultValue : false
    }
  },

  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members : {
    _computedLeftValue : null,
    _computedLeftParsed : null,
    _computedLeftType : null,
    _computedLeftTypeNull : true,
    _computedLeftTypePixel : false,
    _computedLeftTypePercent : false,
    _computedLeftTypeAuto : false,
    _computedLeftTypeFlex : false,
    _computedRightValue : null,
    _computedRightParsed : null,
    _computedRightType : null,
    _computedRightTypeNull : true,
    _computedRightTypePixel : false,
    _computedRightTypePercent : false,
    _computedRightTypeAuto : false,
    _computedRightTypeFlex : false,
    _computedTopValue : null,
    _computedTopParsed : null,
    _computedTopType : null,
    _computedTopTypeNull : true,
    _computedTopTypePixel : false,
    _computedTopTypePercent : false,
    _computedTopTypeAuto : false,
    _computedTopTypeFlex : false,
    _computedBottomValue : null,
    _computedBottomParsed : null,
    _computedBottomType : null,
    _computedBottomTypeNull : true,
    _computedBottomTypePixel : false,
    _computedBottomTypePercent : false,
    _computedBottomTypeAuto : false,
    _computedBottomTypeFlex : false,
    _computedWidthValue : null,
    _computedWidthParsed : null,
    _computedWidthType : null,
    _computedWidthTypeNull : true,
    _computedWidthTypePixel : false,
    _computedWidthTypePercent : false,
    _computedWidthTypeAuto : false,
    _computedWidthTypeFlex : false,
    _computedMinWidthValue : null,
    _computedMinWidthParsed : null,
    _computedMinWidthType : null,
    _computedMinWidthTypeNull : true,
    _computedMinWidthTypePixel : false,
    _computedMinWidthTypePercent : false,
    _computedMinWidthTypeAuto : false,
    _computedMinWidthTypeFlex : false,
    _computedMaxWidthValue : null,
    _computedMaxWidthParsed : null,
    _computedMaxWidthType : null,
    _computedMaxWidthTypeNull : true,
    _computedMaxWidthTypePixel : false,
    _computedMaxWidthTypePercent : false,
    _computedMaxWidthTypeAuto : false,
    _computedMaxWidthTypeFlex : false,
    _computedHeightValue : null,
    _computedHeightParsed : null,
    _computedHeightType : null,
    _computedHeightTypeNull : true,
    _computedHeightTypePixel : false,
    _computedHeightTypePercent : false,
    _computedHeightTypeAuto : false,
    _computedHeightTypeFlex : false,
    _computedMinHeightValue : null,
    _computedMinHeightParsed : null,
    _computedMinHeightType : null,
    _computedMinHeightTypeNull : true,
    _computedMinHeightTypePixel : false,
    _computedMinHeightTypePercent : false,
    _computedMinHeightTypeAuto : false,
    _computedMinHeightTypeFlex : false,
    _computedMaxHeightValue : null,
    _computedMaxHeightParsed : null,
    _computedMaxHeightType : null,
    _computedMaxHeightTypeNull : true,
    _computedMaxHeightTypePixel : false,
    _computedMaxHeightTypePercent : false,
    _computedMaxHeightTypeAuto : false,
    _computedMaxHeightTypeFlex : false,
    _customVariant : null,

    ///////////////
    // apply layout

    _applyLeft : function(value) {
      this._unitDetectionPixelPercent("left", value);
      this.addToQueue("left");
    },

    _applyRight : function(value) {
      this._unitDetectionPixelPercent("right", value);
      this.addToQueue("right");
    },

    _applyTop : function(value) {
      this._unitDetectionPixelPercent("top", value);
      this.addToQueue("top");
    },

    _applyBottom : function(value) {
      this._unitDetectionPixelPercent("bottom", value);
      this.addToQueue("bottom");
    },

    _applyWidth : function(value) {
      this._unitDetectionPixelPercentAutoFlex("width", value);
      this.addToQueue("width");
    },

    _applyMinWidth : function(value) {
      this._unitDetectionPixelPercentAuto("minWidth", value);
      this.addToQueue("minWidth");
    },

    _applyMaxWidth : function(value) {
      this._unitDetectionPixelPercentAuto("maxWidth", value);
      this.addToQueue("maxWidth");
    },

    _applyHeight : function(value) {
      this._unitDetectionPixelPercentAutoFlex("height", value);
      this.addToQueue("height");
    },

    _applyMinHeight : function(value) {
      this._unitDetectionPixelPercentAuto("minHeight", value);
      this.addToQueue("minHeight");
    },

    _applyMaxHeight : function(value) {
      this._unitDetectionPixelPercentAuto("maxHeight", value);
      this.addToQueue("maxHeight");
    },

    ////////////////////
    // CHILDREN HANDLING

    // NOTE: Implemented in Parent.js
    getChildren : rwt.util.Functions.returnNull,
    getChildrenLength : rwt.util.Functions.returnZero,
    hasChildren : rwt.util.Functions.returnFalse,
    isEmpty : rwt.util.Functions.returnTrue,
    indexOf : function() { return -1; },
    contains : rwt.util.Functions.returnFalse,
    getVisibleChildren : rwt.util.Functions.returnNull,
    getVisibleChildrenLength : rwt.util.Functions.returnZero,
    hasVisibleChildren : rwt.util.Functions.returnFalse,
    isVisibleEmpty : rwt.util.Functions.returnTrue,

    /////////////////
    //  CORE MODIFIER

    _hasParent : false,
    _isDisplayable : false,

    isDisplayable : function() {
      return this._isDisplayable;
    },

    _checkParent : function(value) {
      if (this.contains(value)) {
        throw new Error("Could not insert myself into a child " + value + "!");
      }

      return value;
    },

    _applyParent : function(value, old) {
      if (old) {
        var vOldIndex = old.getChildren().indexOf(this);
        // Reset cached dimension and location values
        this._computedWidthValue = null;
        this._computedMinWidthValue = null;
        this._computedMaxWidthValue = null;
        this._computedLeftValue = null;
        this._computedRightValue = null;
        this._computedHeightValue = null;
        this._computedMinHeightValue = null;
        this._computedMaxHeightValue = null;
        this._computedTopValue = null;
        this._computedBottomValue = null;
        this._cachedBoxWidth = null;
        this._cachedInnerWidth = null;
        this._cachedOuterWidth = null;
        this._cachedBoxHeight = null;
        this._cachedInnerHeight = null;
        this._cachedOuterHeight = null;
        // Finally remove from children array
        rwt.util.Arrays.removeAt(old.getChildren(), vOldIndex);
        // Invalidate visible children cache
        old._invalidateVisibleChildren();
        // Remove child from old parent's children queue
        old._removeChildFromChildrenQueue(this);
        // The layouter adds some layout jobs
        old.getLayoutImpl().updateChildrenOnRemoveChild(this, vOldIndex);
        // Inform job queue
        old.addToJobQueue("removeChild");
        // Invalidate inner preferred dimensions
        old._invalidatePreferredInnerDimensions();
        // Store old parent (needed later by _handleDisplayable)
        this._oldParent = old;
      }
      if (value) {
        this._hasParent = true;
        if (typeof this._insertIndex == "number") {
          rwt.util.Arrays.insertAt(value.getChildren(), this, this._insertIndex);
          delete this._insertIndex;
        } else {
          value.getChildren().push(this);
        }
      } else {
        this._hasParent = false;
      }
      rwt.qx.Property.refresh(this);
      return this._handleDisplayable("parent");
    },

    _applyDisplay : function() {
      return this._handleDisplayable("display");
    },

    //////////////////////
    // DISPLAYBLE HANDLING

    _handleDisplayable : function( vHint ) {
      var vDisplayable = this._computeDisplayable();
      if(    this._isDisplayable == vDisplayable
          && !( vDisplayable && vHint == "parent" ) )
      {
        return true;
      }
      this._isDisplayable = vDisplayable;
      var vParent = this.getParent();
      if( vParent ) {
        vParent._invalidateVisibleChildren();
        vParent._invalidatePreferredInnerDimensions();
      }
      // Remove old parent's elements from DOM and delete old parent
      if( vHint && this._oldParent && this._oldParent._initialLayoutDone ) {
        var elem = this.getElement();
        if( elem ) {
          if( this.getVisibility() ) {
            this._beforeDisappear();
          }
          try {
            this._oldParent._getTargetNode().removeChild( elem );
          } catch( ex ) {
            // ignore exception
          }
          this._afterRemoveDom();
          if ( this.getVisibility() ) {
            this._afterDisappear();
          }
        }
        delete this._oldParent;
      } // old parent end
      if( vDisplayable ) {
        // The layouter added some layout jobs
        if( vParent._initialLayoutDone ) {
          var index = vParent.getChildren().indexOf( this );
          vParent.getLayoutImpl().updateChildrenOnAddChild( this, index );
          vParent.addToJobQueue( "addChild" );
        }
        // Add to parents children queue
        // (indirectly with a new layout request)
        this.addToLayoutChanges( "initial" );
        // Add to custom queues
        this.addToCustomQueues( vHint );
        if( this.getVisibility() ) {
          this._beforeAppear();
        }
        if( !this._isCreated ) {
          rwt.widgets.base.Widget.addToGlobalElementQueue(this);
        }
        rwt.widgets.base.Widget.addToGlobalStateQueue( this );
        if(!rwt.util.Objects.isEmpty(this._jobQueue ) ) {
          rwt.widgets.base.Widget.addToGlobalJobQueue( this );
        }
        if( !rwt.util.Objects.isEmpty( this._childrenQueue ) ) {
          rwt.widgets.base.Widget.addToGlobalLayoutQueue( this );
        }
        // displayable end
      } else {
        rwt.widgets.base.Widget.removeFromGlobalElementQueue( this );
        rwt.widgets.base.Widget.removeFromGlobalStateQueue( this );
        rwt.widgets.base.Widget.removeFromGlobalJobQueue( this );
        rwt.widgets.base.Widget.removeFromGlobalLayoutQueue( this );
        this.removeFromCustomQueues( vHint );
        // only remove when itself want to be removed
        // through a property change - not a parent signal
        if( vParent && vHint ) {
          if( this.getVisibility() ) {
            this._beforeDisappear();
          }
          if( vParent._initialLayoutDone && this._initialLayoutDone ) {
            var index = vParent.getChildren().indexOf( this );
            vParent.getLayoutImpl().updateChildrenOnRemoveChild( this, index );
            vParent.addToJobQueue( "removeChild" );
            var parentNode = this.getElement().parentNode;
            if( parentNode ){
              parentNode.removeChild( this.getElement() );
              this._afterRemoveDom();
            }
          }
          vParent._removeChildFromChildrenQueue( this );
          if( this.getVisibility() ) {
            this._afterDisappear();
          }
        }
      } // not displayable end
      this._handleDisplayableCustom( vDisplayable, vParent, vHint );
      return true;
    },

    addToCustomQueues : rwt.util.Functions.returnTrue,
    removeFromCustomQueues : rwt.util.Functions.returnTrue,
    _handleDisplayableCustom : rwt.util.Functions.returnTrue,

    _computeDisplayable : function() {
      return this.getDisplay() && this.getParent() && this.getParent()._isDisplayable ? true : false;
    },

    _beforeAppear : function() {
      this.dispatchSimpleEvent( "beforeAppear" );
    },

    _afterAppear : function() {
      this._isSeeable = true;
      this.dispatchSimpleEvent( "appear" );
    },

    _beforeDisappear : function() {
      // Remove any hover/pressed styles
      this.removeState("over");
      this.removeState("pressed");
      this.removeState("abandoned");
      this.dispatchSimpleEvent( "beforeDisappear" );
    },

    _afterDisappear : function() {
      this._isSeeable = false;
      this.dispatchSimpleEvent("disappear");
    },

    _isSeeable : false,
    _isInDom : false,

    /**
     * If the widget is currently seeable which means that it:
     *
     * * has a also seeable parent
     * * visibility is true
     * * display is true
     *
     * @type member
     * @return {boolean} TODOC
     */
    isSeeable : function() {
      return this._isSeeable;
    },

    isInDom : function() {
      return this._isInDom;
    },

    isAppearRelevant : function() {
      return this.getVisibility() && this._isDisplayable;
    },

    _afterInsertDom : function() {
      this._isInDom = true;
      this.dispatchSimpleEvent( "insertDom" );
    },

    _afterRemoveDom : function() {
      this._isInDom = false;
    },

    //////////////////////
    // VISIBILITY HANDLING

    _applyVisibility : function(value) {
      if (value) {
        if ( this._isDisplayable && ( this._isCreated || this._isInGlobalElementQueue ) ) {
          this._beforeAppear();
        }
        this.removeStyleProperty("display");
        if ( this._isDisplayable && this._isCreated ) {
          this._afterAppear();
        }
      } else {
        if ( this._isDisplayable && this._isCreated ) {
          this._beforeDisappear();
        }
        this.setStyleProperty("display", "none");
        if ( this._isDisplayable && this._isCreated ) {
          this._afterDisappear();
        }
      }
    },

    show : function() {
      this.setVisibility(true);
      this.setDisplay(true);
    },

    hide : function() {
      this.setVisibility(false);
    },

    destroy : function () {
      if( this.getParent() === null || !this.getParent()._isInGlobalDisposeQueue ) {
        if( this.dispatchSimpleEvent( "destroy" ) ) {
          this.setParent( null );
          rwt.widgets.base.Widget.addToGlobalDisposeQueue( this );
        }
      }
    },

    _markInDispose : function() {
      this._isInGlobalDisposeQueue = true;
    },

    ///////////////////////
    // DOM ELEMENT HANDLING

    _isCreated : false,
    _element : null,
    _targetNode : null,
    _style : null,
    _innerStyle : null,

    _getTargetNode : function() {
      return this._targetNode || this._element;
    },

    addToDocument : function() {
      rwt.widgets.base.ClientDocument.getInstance().add(this);
    },

    enableEnhancedBorder : function() {
      this._targetNodeEnabled = true;
      if( this._element ) {
        this.prepareEnhancedBorder();
      }
    },

    /**
     * Check if the element is already available.
     */
    isCreated : function() {
      return this._isCreated;
    },

    _createElementImpl : function() {
      this.setElement( document.createElement( "div" ) );
    },

    _applyElement : function(value, old) {
      this._isCreated = value != null;
      if (old) {
        // reset reference to widget instance
        old.rwtWidget = null;
      }
      if (value) {
        // add reference to widget instance
        value.rwtWidget = this;
        // make absolute
        value.style.position = "absolute";
        // link element and style reference
        this._element = value;
        this._style = value.style;
        if( this._targetNodeEnabled ) {
          this.prepareEnhancedBorder( true );
        }
        this.initBackgroundColor();
        this._applyStyleProperties(value);
        this._applyHtmlProperties(value);
        this._applyHtmlAttributes(value);
        this._applyElementData(value);
        // send out create event
        this.dispatchSimpleEvent( "create" );
        // add created instances to state queue
        this.addToStateQueue();
      } else {
        this._element = this._style = null;
      }
    },

    ////////////
    // JOB QUEUE

    addToJobQueue : function(p){
      if (this._hasParent) {
        rwt.widgets.base.Widget.addToGlobalJobQueue(this);
      }
      if (!this._jobQueue) {
        this._jobQueue = {};
      }
      this._jobQueue[p] = true;
      return true;
    },

    _flushJobQueue : function() {
      // 1. Pre checks
      var vQueue = this._jobQueue;
      var vParent = this.getParent();
      if (!vParent || rwt.util.Objects.isEmpty(vQueue)) {
        return;
      }
      var vLayoutImpl = this instanceof rwt.widgets.base.Parent ? this.getLayoutImpl() : null;
      if (vLayoutImpl) {
        vLayoutImpl.updateSelfOnJobQueueFlush(vQueue);
      }
      // 2. Recompute dimensions
      var vFlushParentJobQueue = false;
      var vRecomputeOuterWidth = vQueue.marginLeft || vQueue.marginRight;
      var vRecomputeOuterHeight = vQueue.marginTop || vQueue.marginBottom;
      var vRecomputeInnerWidth = vQueue.frameWidth;
      var vRecomputeInnerHeight = vQueue.frameHeight;
      var vRecomputeParentPreferredInnerWidth
        = (vQueue.frameWidth || vQueue.preferredInnerWidth) && this._recomputePreferredBoxWidth();
      var vRecomputeParentPreferredInnerHeight
        = (vQueue.frameHeight || vQueue.preferredInnerHeight) && this._recomputePreferredBoxHeight();
      if (vRecomputeParentPreferredInnerWidth) {
        var vPref = this.getPreferredBoxWidth();
        if (this._computedWidthTypeAuto) {
          this._computedWidthValue = vPref;
          vQueue.width = true;
        }
        if (this._computedMinWidthTypeAuto) {
          this._computedMinWidthValue = vPref;
          vQueue.minWidth = true;
        }
        if (this._computedMaxWidthTypeAuto) {
          this._computedMaxWidthValue = vPref;
          vQueue.maxWidth = true;
        }
      }
      if (vRecomputeParentPreferredInnerHeight) {
        var vPref = this.getPreferredBoxHeight();
        if (this._computedHeightTypeAuto) {
          this._computedHeightValue = vPref;
          vQueue.height = true;
        }
        if (this._computedMinHeightTypeAuto) {
          this._computedMinHeightValue = vPref;
          vQueue.minHeight = true;
        }
        if (this._computedMaxHeightTypeAuto) {
          this._computedMaxHeightValue = vPref;
          vQueue.maxHeight = true;
        }
      }
      if ((vQueue.width || vQueue.minWidth || vQueue.maxWidth || vQueue.left || vQueue.right) && this._recomputeBoxWidth()) {
        vRecomputeOuterWidth = vRecomputeInnerWidth = true;
      }
      if ((vQueue.height || vQueue.minHeight || vQueue.maxHeight || vQueue.top || vQueue.bottom) && this._recomputeBoxHeight()) {
        vRecomputeOuterHeight = vRecomputeInnerHeight = true;
      }
      // 3. Signals to parent widgets
      if ((vRecomputeOuterWidth && this._recomputeOuterWidth()) || vRecomputeParentPreferredInnerWidth) {
        vParent._invalidatePreferredInnerWidth();
        vParent.getLayoutImpl().updateSelfOnChildOuterWidthChange(this);
        vFlushParentJobQueue = true;
      }
      if ((vRecomputeOuterHeight && this._recomputeOuterHeight()) || vRecomputeParentPreferredInnerHeight) {
        vParent._invalidatePreferredInnerHeight();
        vParent.getLayoutImpl().updateSelfOnChildOuterHeightChange(this);
        vFlushParentJobQueue = true;
      }
      if (vFlushParentJobQueue) {
        vParent._flushJobQueue();
      }
      //  4. Add layout jobs
      // add to layout queue
      vParent._addChildToChildrenQueue(this);
      // convert jobs to layout jobs
      for (var i in vQueue) {
        this._layoutChanges[i] = true;
      }
      // 5. Signals to children
      // inform children about padding change
      if (this instanceof rwt.widgets.base.Parent && (vQueue.paddingLeft || vQueue.paddingRight || vQueue.paddingTop || vQueue.paddingBottom)) {
        var ch = this.getChildren(), chl = ch.length;
        if (vQueue.paddingLeft) {
          for (var i=0; i<chl; i++) {
            ch[i].addToLayoutChanges("parentPaddingLeft");
          }
        }
        if (vQueue.paddingRight) {
          for (var i=0; i<chl; i++) {
            ch[i].addToLayoutChanges("parentPaddingRight");
          }
        }
        if (vQueue.paddingTop) {
          for (var i=0; i<chl; i++) {
            ch[i].addToLayoutChanges("parentPaddingTop");
          }
        }
        if (vQueue.paddingBottom) {
          for (var i=0; i<chl; i++) {
            ch[i].addToLayoutChanges("parentPaddingBottom");
          }
        }
      }
      if (vRecomputeInnerWidth) {
        this._recomputeInnerWidth();
      }
      if (vRecomputeInnerHeight) {
        this._recomputeInnerHeight();
      }
      if (this._initialLayoutDone) {
        if (vLayoutImpl) {
          vLayoutImpl.updateChildrenOnJobQueueFlush(vQueue);
        }
      }
      // 5. Cleanup
      delete this._jobQueue;
    },

    ////////////////////////////////////////////
    // METHODS TO GIVE THE LAYOUTERS INFORMATION

    _isWidthEssential : rwt.util.Functions.returnTrue,
    _isHeightEssential : rwt.util.Functions.returnTrue,

    _computeBoxWidthFallback : function() {
      return 0;
    },

    _computeBoxHeightFallback : function() {
      return 0;
    },

    _computeBoxWidth : function() {
      var vLayoutImpl = this.getParent().getLayoutImpl();
      return Math.max(0, rwt.util.Numbers.limit(vLayoutImpl.computeChildBoxWidth(this), this.getMinWidthValue(), this.getMaxWidthValue()));
    },

    _computeBoxHeight : function() {
      var vLayoutImpl = this.getParent().getLayoutImpl();
      return Math.max(0, rwt.util.Numbers.limit(vLayoutImpl.computeChildBoxHeight(this), this.getMinHeightValue(), this.getMaxHeightValue()));
    },

    _computeOuterWidth : function() {
      return Math.max(0, (this.getMarginLeft() + this.getBoxWidth() + this.getMarginRight()));
    },

    _computeOuterHeight : function() {
      return Math.max(0, (this.getMarginTop() + this.getBoxHeight() + this.getMarginBottom()));
    },

    _computeInnerWidth : function() {
      return Math.max(0, this.getBoxWidth() - this.getFrameWidth());
    },

    _computeInnerHeight : function() {
      return Math.max(0, this.getBoxHeight() - this.getFrameHeight());
    },

    getNeededWidth : function() {
      var vLayoutImpl = this.getParent().getLayoutImpl();
      return Math.max(0, vLayoutImpl.computeChildNeededWidth(this));
    },

    getNeededHeight : function() {
      var vLayoutImpl = this.getParent().getLayoutImpl();
      return Math.max(0, vLayoutImpl.computeChildNeededHeight(this));
    },

    /////////////////////////
    //  RECOMPUTE FLEX VALUES

    _recomputeFlexX : function() {
      if (!this.getHasFlexX()) {
        return false;
      }
      if (this._computedWidthTypeFlex) {
        this._computedWidthValue = null;
        this.addToLayoutChanges("width");
      }
      return true;
    },

    _recomputeFlexY : function() {
      if (!this.getHasFlexY()) {
        return false;
      }
      if (this._computedHeightTypeFlex) {
        this._computedHeightValue = null;
        this.addToLayoutChanges("height");
      }
      return true;
    },

    /////////////////////
    // RECOMPUTE PERCENTS

    _recomputePercentX : function() {
      if (!this.getHasPercentX()) {
        return false;
      }
      if (this._computedWidthTypePercent) {
        this._computedWidthValue = null;
        this.addToLayoutChanges("width");
      }
      if (this._computedMinWidthTypePercent) {
        this._computedMinWidthValue = null;
        this.addToLayoutChanges("minWidth");
      }
      if (this._computedMaxWidthTypePercent) {
        this._computedMaxWidthValue = null;
        this.addToLayoutChanges("maxWidth");
      }
      if (this._computedLeftTypePercent) {
        this._computedLeftValue = null;
        this.addToLayoutChanges("left");
      }
      if (this._computedRightTypePercent) {
        this._computedRightValue = null;
        this.addToLayoutChanges("right");
      }
      return true;
    },

    _recomputePercentY : function() {
      if (!this.getHasPercentY()) {
        return false;
      }
      if (this._computedHeightTypePercent) {
        this._computedHeightValue = null;
        this.addToLayoutChanges("height");
      }
      if (this._computedMinHeightTypePercent) {
        this._computedMinHeightValue = null;
        this.addToLayoutChanges("minHeight");
      }
      if (this._computedMaxHeightTypePercent) {
        this._computedMaxHeightValue = null;
        this.addToLayoutChanges("maxHeight");
      }
      if (this._computedTopTypePercent) {
        this._computedTopValue = null;
        this.addToLayoutChanges("top");
      }
      if (this._computedBottomTypePercent) {
        this._computedBottomValue = null;
        this.addToLayoutChanges("bottom");
      }
      return true;
    },

    ///////////////////
    // RECOMPUTE RANGES

    _recomputeRangeX : rwt.util.Variant.select("qx.client", {
      "trident|webkit|blink" : function() {
        if (this._computedLeftTypeNull || this._computedRightTypeNull) {
          return false;
        }
        this.addToLayoutChanges("width");
        return true;
      },
      "default" : function() {
        return !(this._computedLeftTypeNull || this._computedRightTypeNull);
      }
    } ),

    _recomputeRangeY : rwt.util.Variant.select("qx.client", {
      "trident|webkit|blink" : function() {
        if (this._computedTopTypeNull || this._computedBottomTypeNull) {
          return false;
        }
        this.addToLayoutChanges("height");
        return true;
      },
      "default" : function() {
        return !(this._computedTopTypeNull || this._computedBottomTypeNull);
      }
    } ),

    ///////////////////////
    // RECOMPUTE STRETCHING

    _recomputeStretchingX : rwt.util.Variant.select("qx.client", {
      "trident|webkit|blink" : function() {
        if (this.getAllowStretchX() && this._computedWidthTypeNull) {
          this._computedWidthValue = null;
          this.addToLayoutChanges("width");
          return true;
        }
        return false;
      },
      "default" : function() {
        if (this.getAllowStretchX() && this._computedWidthTypeNull) {
          return true;
        }
        return false;
      }
    } ),

    _recomputeStretchingY : rwt.util.Variant.select("qx.client", {
      "trident|webkit|blink" : function() {
        if (this.getAllowStretchY() && this._computedHeightTypeNull) {
          this._computedHeightValue = null;
          this.addToLayoutChanges("height");
          return true;
        }
        return false;
      },
      "default" : function() {
        if (this.getAllowStretchY() && this._computedHeightTypeNull) {
          return true;
        }
        return false;
      }
    } ),

    /////////////////////////////////////////////////
    //  INTELLIGENT GETTERS FOR STANDALONE DIMENSIONS

    _computeValuePixel : function(v) {
      return Math.round(v);
    },

    _computeValuePixelLimit : function(v) {
      return Math.max(0, this._computeValuePixel(v));
    },

    _computeValuePercentX : function(v) {
      return Math.round(this.getParent().getInnerWidthForChild(this) * v * 0.01);
    },

    _computeValuePercentXLimit : function(v) {
      return Math.max(0, this._computeValuePercentX(v));
    },

    _computeValuePercentY : function(v) {
      return Math.round(this.getParent().getInnerHeightForChild(this) * v * 0.01);
    },

    _computeValuePercentYLimit : function(v) {
      return Math.max(0, this._computeValuePercentY(v));
    },

    getWidthValue : function() {
      if (this._computedWidthValue != null) {
        return this._computedWidthValue;
      }
      switch(this._computedWidthType) {
        case rwt.widgets.base.Widget.TYPE_PIXEL:
          return this._computedWidthValue = this._computeValuePixelLimit(this._computedWidthParsed);
        case rwt.widgets.base.Widget.TYPE_PERCENT:
          return this._computedWidthValue = this._computeValuePercentXLimit(this._computedWidthParsed);
        case rwt.widgets.base.Widget.TYPE_AUTO:
          return this._computedWidthValue = this.getPreferredBoxWidth();
        case rwt.widgets.base.Widget.TYPE_FLEX:
          if (this.getParent().getLayoutImpl().computeChildrenFlexWidth === undefined) {
            throw new Error("Widget " + this + ": having horizontal flex size (width=" + this.getWidth() + ") but parent layout " + this.getParent() + " does not support it");
          }
          this.getParent().getLayoutImpl().computeChildrenFlexWidth();
          return this._computedWidthValue = this._computedWidthFlexValue;
      }
      return null;
    },

    getMinWidthValue : function() {
      if (this._computedMinWidthValue != null) {
        return this._computedMinWidthValue;
      }
      switch(this._computedMinWidthType) {
        case rwt.widgets.base.Widget.TYPE_PIXEL:
          return this._computedWidthValue = this._computeValuePixelLimit(this._computedMinWidthParsed);
        case rwt.widgets.base.Widget.TYPE_PERCENT:
          return this._computedWidthValue = this._computeValuePercentXLimit(this._computedMinWidthParsed);
        case rwt.widgets.base.Widget.TYPE_AUTO:
          return this._computedMinWidthValue = this.getPreferredBoxWidth();
      }
      return null;
    },

    getMaxWidthValue : function() {
      if (this._computedMaxWidthValue != null) {
        return this._computedMaxWidthValue;
      }
      switch(this._computedMaxWidthType) {
        case rwt.widgets.base.Widget.TYPE_PIXEL:
          return this._computedWidthValue = this._computeValuePixelLimit(this._computedMaxWidthParsed);
        case rwt.widgets.base.Widget.TYPE_PERCENT:
          return this._computedWidthValue = this._computeValuePercentXLimit(this._computedMaxWidthParsed);
        case rwt.widgets.base.Widget.TYPE_AUTO:
          return this._computedMaxWidthValue = this.getPreferredBoxWidth();
      }
      return null;
    },

    getLeftValue : function() {
      if (this._computedLeftValue != null) {
        return this._computedLeftValue;
      }
      switch(this._computedLeftType) {
        case rwt.widgets.base.Widget.TYPE_PIXEL:
          return this._computedLeftValue = this._computeValuePixel(this._computedLeftParsed);
        case rwt.widgets.base.Widget.TYPE_PERCENT:
          return this._computedLeftValue = this._computeValuePercentX(this._computedLeftParsed);
      }
      return null;
    },

    getRightValue : function() {
      if (this._computedRightValue != null) {
        return this._computedRightValue;
      }
      switch(this._computedRightType) {
        case rwt.widgets.base.Widget.TYPE_PIXEL:
          return this._computedRightValue = this._computeValuePixel(this._computedRightParsed);
        case rwt.widgets.base.Widget.TYPE_PERCENT:
          return this._computedRightValue = this._computeValuePercentX(this._computedRightParsed);
      }
      return null;
    },

    getHeightValue : function() {
      if (this._computedHeightValue != null) {
        return this._computedHeightValue;
      }
      switch(this._computedHeightType) {
        case rwt.widgets.base.Widget.TYPE_PIXEL:
          return this._computedHeightValue = this._computeValuePixelLimit(this._computedHeightParsed);
        case rwt.widgets.base.Widget.TYPE_PERCENT:
          return this._computedHeightValue = this._computeValuePercentYLimit(this._computedHeightParsed);
        case rwt.widgets.base.Widget.TYPE_AUTO:
          return this._computedHeightValue = this.getPreferredBoxHeight();
        case rwt.widgets.base.Widget.TYPE_FLEX:
          if (this.getParent().getLayoutImpl().computeChildrenFlexHeight === undefined) {
            throw new Error("Widget " + this + ": having vertical flex size (height=" + this.getHeight() + ") but parent layout " + this.getParent() + " does not support it");
          }
          this.getParent().getLayoutImpl().computeChildrenFlexHeight();
          return this._computedHeightValue = this._computedHeightFlexValue;
      }
      return null;
    },

    getMinHeightValue : function() {
      if (this._computedMinHeightValue != null) {
        return this._computedMinHeightValue;
      }
      switch(this._computedMinHeightType) {
        case rwt.widgets.base.Widget.TYPE_PIXEL:
          return this._computedMinHeightValue = this._computeValuePixelLimit(this._computedMinHeightParsed);
        case rwt.widgets.base.Widget.TYPE_PERCENT:
          return this._computedMinHeightValue = this._computeValuePercentYLimit(this._computedMinHeightParsed);
        case rwt.widgets.base.Widget.TYPE_AUTO:
          return this._computedMinHeightValue = this.getPreferredBoxHeight();
      }
      return null;
    },

    getMaxHeightValue : function() {
      if (this._computedMaxHeightValue != null) {
        return this._computedMaxHeightValue;
      }
      switch(this._computedMaxHeightType) {
        case rwt.widgets.base.Widget.TYPE_PIXEL:
          return this._computedMaxHeightValue = this._computeValuePixelLimit(this._computedMaxHeightParsed);
        case rwt.widgets.base.Widget.TYPE_PERCENT:
          return this._computedMaxHeightValue = this._computeValuePercentYLimit(this._computedMaxHeightParsed);
        case rwt.widgets.base.Widget.TYPE_AUTO:
          return this._computedMaxHeightValue = this.getPreferredBoxHeight();
      }
      return null;
    },

    getTopValue : function() {
      if (this._computedTopValue != null) {
        return this._computedTopValue;
      }
      switch(this._computedTopType) {
        case rwt.widgets.base.Widget.TYPE_PIXEL:
          return this._computedTopValue = this._computeValuePixel(this._computedTopParsed);
        case rwt.widgets.base.Widget.TYPE_PERCENT:
          return this._computedTopValue = this._computeValuePercentY(this._computedTopParsed);
      }
      return null;
    },

    getBottomValue : function() {
      if (this._computedBottomValue != null) {
        return this._computedBottomValue;
      }
      switch(this._computedBottomType) {
        case rwt.widgets.base.Widget.TYPE_PIXEL:
          return this._computedBottomValue = this._computeValuePixel(this._computedBottomParsed);
        case rwt.widgets.base.Widget.TYPE_PERCENT:
          return this._computedBottomValue = this._computeValuePercentY(this._computedBottomParsed);
      }
      return null;
    },

    _computeFrameWidth : function() {
      return this._cachedBorderLeft + this.getPaddingLeft() + this.getPaddingRight() + this._cachedBorderRight;
    },

    _computeFrameHeight : function() {
      return this._cachedBorderTop + this.getPaddingTop() + this.getPaddingBottom() + this._cachedBorderBottom;
    },

    _invalidateFrameDimensions : function() {
      this._invalidateFrameWidth();
      this._invalidateFrameHeight();
    },

    _invalidatePreferredInnerDimensions : function() {
      this._invalidatePreferredInnerWidth();
      this._invalidatePreferredInnerHeight();
    },

    _computePreferredBoxWidth : function() {
      return Math.max(0, this.getPreferredInnerWidth() + this.getFrameWidth());
    },

    _computePreferredBoxHeight : function() {
      return Math.max(0, this.getPreferredInnerHeight() + this.getFrameHeight());
    },

    ///////////////
    // LAYOUT QUEUE

    _initialLayoutDone : false,

    addToLayoutChanges : function(p) {
      if (this._isDisplayable) {
        this.getParent()._addChildToChildrenQueue(this);
      }
      return this._layoutChanges[p] = true;
    },

    addToQueue : function(p) {
      if( this._initialLayoutDone ) {
        this.addToJobQueue( p );
      } else {
        this.addToLayoutChanges( p );
      }
    },

    addToQueueRuntime : function(p) {
      return !this._initialLayoutDone || this.addToJobQueue(p);
    },

    /////////////////////
    // LAYOUTER INTERNALS

    _computeHasPercentX : function() {
      return (this._computedLeftTypePercent || this._computedWidthTypePercent || this._computedMinWidthTypePercent || this._computedMaxWidthTypePercent || this._computedRightTypePercent);
    },

    _computeHasPercentY : function() {
      return (this._computedTopTypePercent || this._computedHeightTypePercent || this._computedMinHeightTypePercent || this._computedMaxHeightTypePercent || this._computedBottomTypePercent);
    },

    _computeHasAutoX : function() {
      return (this._computedWidthTypeAuto || this._computedMinWidthTypeAuto || this._computedMaxWidthTypeAuto);
    },

    _computeHasAutoY : function() {
      return (this._computedHeightTypeAuto || this._computedMinHeightTypeAuto || this._computedMaxHeightTypeAuto);
    },

    _computeHasFlexX : function() {
      return this._computedWidthTypeFlex;
    },

    _computeHasFlexY : function() {
      return this._computedHeightTypeFlex;
    },

    _evalUnitsPixelPercentAutoFlex : function(value) {
      switch(value) {
        case "auto":
          return rwt.widgets.base.Widget.TYPE_AUTO;
        case Infinity:
        case -Infinity:
          return rwt.widgets.base.Widget.TYPE_NULL;
      }
      switch(typeof value) {
        case "number":
          return isNaN(value) ? rwt.widgets.base.Widget.TYPE_NULL : rwt.widgets.base.Widget.TYPE_PIXEL;

        case "string":
          return value.indexOf("%") != -1 ? rwt.widgets.base.Widget.TYPE_PERCENT : value.indexOf("*") != -1 ? rwt.widgets.base.Widget.TYPE_FLEX : rwt.widgets.base.Widget.TYPE_NULL;
      }
      return rwt.widgets.base.Widget.TYPE_NULL;
    },

    _evalUnitsPixelPercentAuto : function(value) {
      switch(value) {
        case "auto":
          return rwt.widgets.base.Widget.TYPE_AUTO;
        case Infinity:
        case -Infinity:
          return rwt.widgets.base.Widget.TYPE_NULL;
      }
      switch(typeof value) {
        case "number":
          return isNaN(value) ? rwt.widgets.base.Widget.TYPE_NULL : rwt.widgets.base.Widget.TYPE_PIXEL;
        case "string":
          return value.indexOf("%") != -1 ? rwt.widgets.base.Widget.TYPE_PERCENT : rwt.widgets.base.Widget.TYPE_NULL;
      }
      return rwt.widgets.base.Widget.TYPE_NULL;
    },

    _evalUnitsPixelPercent : function(value) {
      switch(value) {
        case Infinity:
        case -Infinity:
          return rwt.widgets.base.Widget.TYPE_NULL;
      }
      switch(typeof value) {
        case "number":
          return isNaN(value) ? rwt.widgets.base.Widget.TYPE_NULL : rwt.widgets.base.Widget.TYPE_PIXEL;
        case "string":
          return value.indexOf("%") != -1 ? rwt.widgets.base.Widget.TYPE_PERCENT : rwt.widgets.base.Widget.TYPE_NULL;
      }
      return rwt.widgets.base.Widget.TYPE_NULL;
    },

    ///////////////////////////////////
    // UNIT DETECTION FOR LAYOUT SYSTEM

    _unitDetectionPixelPercentAutoFlex : function(name, value) {
      var r = rwt.widgets.base.Widget.layoutPropertyTypes[name];
      var s = r.dataType;
      var p = r.dataParsed;
      var v = r.dataValue;
      var s1 = r.typePixel;
      var s2 = r.typePercent;
      var s3 = r.typeAuto;
      var s4 = r.typeFlex;
      var s5 = r.typeNull;
      var wasPercent = this[s2];
      var wasAuto = this[s3];
      var wasFlex = this[s4];
      this[ s ] = this._evalUnitsPixelPercentAutoFlex( value );
      switch( this[ s ] ) {
        case rwt.widgets.base.Widget.TYPE_PIXEL:
          this[s1] = true;
          this[s2] = this[s3] = this[s4] = this[s5] = false;
          this[p] = this[v] = Math.round(value);
        break;
        case rwt.widgets.base.Widget.TYPE_PERCENT:
          this[s2] = true;
          this[s1] = this[s3] = this[s4] = this[s5] = false;
          this[p] = parseFloat(value);
          this[v] = null;
        break;
        case rwt.widgets.base.Widget.TYPE_AUTO:
          this[s3] = true;
          this[s1] = this[s2] = this[s4] = this[s5] = false;
          this[p] = this[v] = null;
        break;
        case rwt.widgets.base.Widget.TYPE_FLEX:
          this[s4] = true;
          this[s1] = this[s2] = this[s3] = this[s5] = false;
          this[p] = parseFloat(value);
          this[v] = null;
        break;
        default:
          this[s5] = true;
          this[s1] = this[s2] = this[s3] = this[s4] = false;
          this[p] = this[v] = null;
        break;
      }
      if (wasPercent != this[s2]) {
        switch(name) {
          case "minWidth":
          case "maxWidth":
          case "width":
          case "left":
          case "right":
            this._invalidateHasPercentX();
          break;
          case "maxHeight":
          case "minHeight":
          case "height":
          case "top":
          case "bottom":
            this._invalidateHasPercentY();
          break;
        }
      }
      // No ELSE because you can also switch from percent to auto
      if (wasAuto != this[s3]) {
        switch(name) {
          case "minWidth":
          case "maxWidth":
          case "width":
            this._invalidateHasAutoX();
          break;
          case "minHeight":
          case "maxHeight":
          case "height":
            this._invalidateHasAutoY();
          break;
        }
      }
      // No ELSE because you can also switch from percent to auto
      if (wasFlex != this[s4]) {
        switch(name) {
          case "width":
            this._invalidateHasFlexX();
          break;
          case "height":
            this._invalidateHasFlexY();
          break;
        }
      }
    },

    _unitDetectionPixelPercentAuto : function(name, value) {
      var r = rwt.widgets.base.Widget.layoutPropertyTypes[name];
      var s = r.dataType;
      var p = r.dataParsed;
      var v = r.dataValue;
      var s1 = r.typePixel;
      var s2 = r.typePercent;
      var s3 = r.typeAuto;
      var s4 = r.typeNull;
      var wasPercent = this[s2];
      var wasAuto = this[s3];
      this[ s ] = this._evalUnitsPixelPercentAuto( value );
      switch( this[ s ] ) {
        case rwt.widgets.base.Widget.TYPE_PIXEL:
          this[s1] = true;
          this[s2] = this[s3] = this[s4] = false;
          this[p] = this[v] = Math.round(value);
        break;
        case rwt.widgets.base.Widget.TYPE_PERCENT:
          this[s2] = true;
          this[s1] = this[s3] = this[s4] = false;
          this[p] = parseFloat(value);
          this[v] = null;
        break;
        case rwt.widgets.base.Widget.TYPE_AUTO:
          this[s3] = true;
          this[s1] = this[s2] = this[s4] = false;
          this[p] = this[v] = null;
        break;
        default:
          this[s4] = true;
          this[s1] = this[s2] = this[s3] = false;
          this[p] = this[v] = null;
          break;
      }
      if (wasPercent != this[s2]) {
        switch(name) {
          case "minWidth":
          case "maxWidth":
          case "width":
          case "left":
          case "right":
            this._invalidateHasPercentX();
          break;
          case "minHeight":
          case "maxHeight":
          case "height":
          case "top":
          case "bottom":
            this._invalidateHasPercentY();
            break;
        }
      }
      // No ELSE because you can also switch from percent to auto
      if (wasAuto != this[s3]) {
        switch(name) {
          case "minWidth":
          case "maxWidth":
          case "width":
            this._invalidateHasAutoX();
          break;
          case "minHeight":
          case "maxHeight":
          case "height":
            this._invalidateHasAutoY();
          break;
        }
      }
    },

    _unitDetectionPixelPercent : function(name, value) {
      var r = rwt.widgets.base.Widget.layoutPropertyTypes[name];
      var s = r.dataType;
      var p = r.dataParsed;
      var v = r.dataValue;
      var s1 = r.typePixel;
      var s2 = r.typePercent;
      var s3 = r.typeNull;
      var wasPercent = this[s2];
      this[ s ] = this._evalUnitsPixelPercent( value );
      switch( this[ s ] ) {
        case rwt.widgets.base.Widget.TYPE_PIXEL:
          this[s1] = true;
          this[s2] = this[s3] = false;
          this[p] = this[v] = Math.round(value);
        break;
        case rwt.widgets.base.Widget.TYPE_PERCENT:
          this[s2] = true;
          this[s1] = this[s3] = false;
          this[p] = parseFloat(value);
          this[v] = null;
        break;
        default:
          this[s3] = true;
          this[s1] = this[s2] = false;
          this[p] = this[v] = null;
        break;
      }
      if (wasPercent != this[s2]) {
        switch(name) {
          case "minWidth":
          case "maxWidth":
          case "width":
          case "left":
          case "right":
            this._invalidateHasPercentX();
          break;
          case "minHeight":
          case "maxHeight":
          case "height":
          case "top":
          case "bottom":
            this._invalidateHasPercentY();
          break;
        }
      }
    },

    /////////////////////
    // CHILDREN MANAGMENT

    /**
     * The widget which is at the top level,
     *  which contains all others (normally a
     *  instance of rwt.widgets.base.ClientDocument).
     */
    getTopLevelWidget : function() {
      return this._hasParent ? this.getParent().getTopLevelWidget() : null;
    },

    moveSelfToBegin : function() {
      this.getParent().addAtBegin(this);
    },

    moveSelfToEnd : function() {
      this.getParent().addAtEnd(this);
    },

    getPreviousSibling : function() {
      var p = this.getParent();
      if (p == null) {
        return null;
      }
      var cs = p.getChildren();
      return cs[cs.indexOf(this) - 1];
    },

    getNextSibling : function() {
      var p = this.getParent();
      if (p == null) {
        return null;
      }
      var cs = p.getChildren();
      return cs[cs.indexOf(this) + 1];
    },

    getPreviousVisibleSibling : function() {
      if (!this._hasParent) {
        return null;
      }
      var vChildren = this.getParent().getVisibleChildren();
      return vChildren[vChildren.indexOf(this) - 1];
    },

    getPreviousActiveSibling : function(vIgnoreClasses) {
      var vPrev = rwt.widgets.base.Widget.getActiveSiblingHelper(this, this.getParent(), -1, vIgnoreClasses, null);
      return vPrev ? vPrev : this.getParent().getLastActiveChild();
    },

    getNextActiveSibling : function(vIgnoreClasses) {
      var vNext = rwt.widgets.base.Widget.getActiveSiblingHelper(this, this.getParent(), 1, vIgnoreClasses, null);
      return vNext ? vNext : this.getParent().getFirstActiveChild();
    },

    isFirstVisibleChild : function() {
      return this._hasParent && this.getParent().getFirstVisibleChild() == this;
    },

    isLastVisibleChild : function() {
      return this._hasParent && this.getParent().getLastVisibleChild() == this;
    },

    /////////////////
    // STATE HANDLING

    setCustomVariant : function( value ) {
      if( this._customVariant !== null ) {
        this.removeState( this._customVariant );
      }
      this._customVariant = value;
      if( this._customVariant !== null ) {
        this.addState( this._customVariant );
      }
      var subWidgets = this._getSubWidgets ? this._getSubWidgets() : [];
      for( var i = 0; i < subWidgets.length; i++ ) {
        subWidgets[ i ].setCustomVariant( this._customVariant );
      }
    },

    hasState : function( state ) {
      return this.__states && this.__states[ state ] ? true : false;
    },

    toggleState : function( state, add ) {
      if( add ) {
        this.addState( state );
      } else {
        this.removeState( state );
      }
    },

    addState : function( state ) {
      if( !this.__states ) {
        this.__states = {};
      }
      if( !this.__states[ state ] ) {
        this.__states[ state ] = true;
        if( this._hasParent ) {
          rwt.widgets.base.Widget.addToGlobalStateQueue( this );
        }
      }
    },

    removeState : function( state ) {
      if( this.__states && this.__states[ state ] ) {
        delete this.__states[ state ];
        if( this._hasParent ) {
          rwt.widgets.base.Widget.addToGlobalStateQueue( this );
        }
      }
    },

    /////////////////////
    // APPEARANCE SUPPORT

    /**
     * Style multiple properties at once by using a property list
     *
     * @type member
     * @param data {Map} a map of property values. The key is the name of the property.
     * @return {Object} this instance.
     * @throws an error if the incoming data field is not a map.
     */
    _styleFromMap : function( data ) {
      var styler = rwt.qx.Property.$$method.style;
      var unstyler = rwt.qx.Property.$$method.unstyle;
      var value;
      for( var prop in data ) {
        value = data[prop];
        if( value === "undefined" ) {
          this[ unstyler[ prop ] ]();
        } else {
          this[ styler[ prop ] ]( value );
        }
      }
    },

    _unstyleFromArray : function(data) {
      var unstyler = rwt.qx.Property.$$method.unstyle;
      for (var i=0, l=data.length; i<l; i++) {
        this[unstyler[data[i]]]();
      }
    },

    _renderAppearance : function() {
      if (!this.__states) {
        this.__states = {};
      }
      // HACK: Is there a cleaner way to implement this?
      // Maybe not use the appearance for this, but a simple property and event handler combination?
      this._applyStateStyleFocus(this.__states);
      var vAppearance = this.getAppearance();
      if (vAppearance) {
          var r = rwt.theme.AppearanceManager.getInstance().styleFrom(vAppearance, this.__states);
          if (r) {
            this._styleFromMap(r);
          }
      }
    },

    _resetAppearanceThemeWrapper : function(vNewAppearanceTheme, vOldAppearanceTheme) {
      var vAppearance = this.getAppearance();
      if (vAppearance) {
        var vAppearanceManager = rwt.theme.AppearanceManager.getInstance();
        var vOldAppearanceProperties
          = vAppearanceManager.styleFromTheme(vOldAppearanceTheme, vAppearance, this.__states);
        var vNewAppearanceProperties
          = vAppearanceManager.styleFromTheme(vNewAppearanceTheme, vAppearance, this.__states);
        var vUnstyleList = [];
        for (var prop in vOldAppearanceProperties) {
          if (vNewAppearanceProperties[prop] === undefined) {
            vUnstyleList.push(prop);
          }
        }
        this._unstyleFromArray(vUnstyleList);
        this._styleFromMap(vNewAppearanceProperties);
      }
    },

    _applyStateStyleFocus : function( vStates ) {
      if (vStates.focused) {
        if (!rwt.widgets.util.FocusHandler.mouseFocus && !this.getHideFocus()) {
          this.setStyleProperty("outline", "1px dotted");
        }
      } else {
        this.setStyleProperty("outline", "none");
      }
    },

    addToStateQueue : function() {
      rwt.widgets.base.Widget.addToGlobalStateQueue(this);
    },

    recursiveAddToStateQueue : function() {
      this.addToStateQueue();
    },

    _applyAppearance : function(value, old) {
      if (!this.__states) {
        this.__states = {};
      }
      var vAppearanceManager = rwt.theme.AppearanceManager.getInstance();
      if (value) {
        var vNewAppearanceProperties = vAppearanceManager.styleFrom(value, this.__states) || {};
      }
      if (old) {
        var vOldAppearanceProperties = vAppearanceManager.styleFrom(old, this.__states) || {};
        var vUnstyleList = [];
        for (var prop in vOldAppearanceProperties) {
          if (!vNewAppearanceProperties || !(prop in vNewAppearanceProperties)) {
            vUnstyleList.push(prop);
          }
        }
      }
      if (vUnstyleList) {
        this._unstyleFromArray(vUnstyleList);
      }
      if (vNewAppearanceProperties) {
        this._styleFromMap(vNewAppearanceProperties);
      }
    },

    _recursiveAppearanceThemeUpdate : function(vNewAppearanceTheme, vOldAppearanceTheme) {
      this._resetAppearanceThemeWrapper(vNewAppearanceTheme, vOldAppearanceTheme);
    },

    ///////////////
    // ELEMENT DATA

    _applyElementData : function() {},

    //////////////////
    // HTML PROPERTIES

    // TODO : can be removed if IE8 is no longer supported
    setHtmlProperty : function(propName, value) {
      if (!this._htmlProperties) {
        this._htmlProperties = {};
      }
      this._htmlProperties[propName] = value;
      if (this._isCreated && this.getElement()[propName] != value) {
        this.getElement()[propName] = value;
      }
      return true;
    },

    _applyHtmlProperties : function(elem) {
      var vProperties = this._htmlProperties;
      if (vProperties) {
        var propName;
        for (propName in vProperties) {
          elem[propName] = vProperties[propName];
        }
      }
    },

    _applyHtmlAttributes : function( element ) {
      if( this._htmlAttributes ) {
        for( var property in this._htmlAttributes ) {
          element.setAttribute( property, this._htmlAttributes[ property ] );
        }
      }
    },

    ///////////////////
    // STYLE PROPERTIES

    getStyleProperty : function(propName) {
      if (!this._styleProperties) {
        return "";
      }
      return this._styleProperties[propName] || "";
    },

    getStyleProperties : function() {
      return this._styleProperties || {};
    },

    //Some properties should always be applied on the outer element node:
    __outerElementStyleProperties : {
      cursor : true,
      zIndex : true,
      filter : true,
      display : true,
      visibility : true,
      outline : true,
      boxShadow : true,
      opacity : true,
      MozOpacity : true
    },

    setStyleProperty : function(propName, value) {
      if (!this._styleProperties) {
        this._styleProperties = {};
      }
      this._styleProperties[propName] = value;
      if (this._isCreated) {
        var elem = this.__outerElementStyleProperties[propName] ? this.getElement() : this._getTargetNode();
        if (elem) {
          elem.style[propName] = (value == null) ? "" : value;
        }
      }
    },

    removeStyleProperty : function(propName) {
      if (!this._styleProperties) {
        return;
      }
      delete this._styleProperties[propName];
      if (this._isCreated) {
        var elem = this.__outerElementStyleProperties[propName] ? this.getElement() : this._getTargetNode();
        if (elem) {
          elem.style[propName] = "";
        }
      }
    },

    _applyStyleProperties : function(elem) {
      var vProperties = this._styleProperties;
      if (!vProperties) {
        return;
      }
      var propName;
      var vBaseElement = elem;
      var vTargetElement = this._getTargetNode();
      var elem;
      var value;
      for (propName in vProperties) {
        elem = this.__outerElementStyleProperties[propName] ? vBaseElement : vTargetElement;
        value = vProperties[propName];
        elem.style[propName] = (value == null) ? "" : value;
      }
    },

    /////////////////////////
    // ENABLE/DISABLE SUPPORT

    _applyEnabled : function( value ) {
      this.toggleState( "disabled", value === false );
      if( value === false) {
        // Also reset some states to be sure a pressed/hovered button gets reset
        this.removeState( "over" );
        this.removeState( "abandoned" );
        this.removeState( "pressed" );
        if( this.getFocused() ) {
          this.setFocused( false );
        }
      }
    },

    /////////////////
    // FOCUS HANDLING

    isFocusable : function() {
      return this.getEnabled() && this.isSeeable() && this.getTabIndex() != null;
    },

    isFocusRoot : function() {
      return false;
    },

    getFocusRoot : function() {
      if (this._hasParent) {
        return this.getParent().getFocusRoot();
      }
      return null;
    },

    getActiveChild : function() {
      var vRoot = this.getFocusRoot();
      if (vRoot) {
        return vRoot.getActiveChild();
      }
      return null;
    },

    _ontabfocus : rwt.util.Functions.returnTrue,

    _applyFocused : function(value) {
      if (!this.isCreated()) {
        return;
      }
      var vFocusRoot = this.getFocusRoot();
      if (vFocusRoot) {
        // may be undefined if this widget has been removed
        if (value) {
          vFocusRoot.setFocusedChild(this);
          this._visualizeFocus();
          this.scrollIntoView();
        } else {
          if (vFocusRoot.getFocusedChild() == this) {
            vFocusRoot.setFocusedChild(null);
          }
          this._visualizeBlur();
        }
      }
    },

    _visualizeBlur : function() {
      // Force blur, even if mouseFocus is not active because we
      // need to be sure that the previous focus rect gets removed.
      // But this only needs to be done, if there is no new focused element.
      if (this.getEnableElementFocus() && (!this.getFocusRoot().getFocusedChild() || (this.getFocusRoot().getFocusedChild() && this.getFocusRoot().getFocusedChild().getEnableElementFocus()))) {
        try {
          this.getElement().blur();
        } catch(ex) {}
      }
      this.removeState("focused");
    },

    _visualizeFocus : function() {
      var FocusHandler = rwt.widgets.util.FocusHandler;
      if (!FocusHandler.mouseFocus && !FocusHandler.blockFocus && this.getEnableElementFocus()) {
        try {
          this.getElement().focus();
        } catch(ex) {}
      }
      this.addState("focused");
    },

    focus : function() {
      delete rwt.widgets.util.FocusHandler.mouseFocus;
      this.setFocused(true);
    },

    blur : function() {
      delete rwt.widgets.util.FocusHandler.mouseFocus;
      this.setFocused(false);
    },

    ////////////////////
    // CAPTURING SUPPORT

    _applyCapture : function(value, old) {
      var vMgr = rwt.event.EventHandler;
      if (old) {
        vMgr.setCaptureWidget(null);
      }
      if (value) {
        vMgr.setCaptureWidget(this);
      }
    },

    /////////////////
    // ZINDEX SUPPORT

    _applyZIndex : function(value) {
      if (value == null) {
        this.removeStyleProperty("zIndex");
      } else {
        this.setStyleProperty("zIndex", value);
      }
    },

    ////////////////////
    // TAB INDEX SUPPORT

    _applyTabIndex : function( value ) {
      // CSS 3 draft userFocus property
      this.setStyleProperty("userFocus", (value < 0 ? "ignore" : "normal"));
      // Legacy tabIndex property
      this.setHtmlProperty("tabIndex", value < 0 ? -1 : 1);
    },

    /////////////////////
    // SELECTABLE SUPPORT

    _applySelectable : function( value ) {
      rwt.html.Style.setUserSelect( this, value ?  "" : "none" );
    },

    //////////////////
    // OPACITY SUPPORT

    /**
     * Sets the opacity for the widget. Any child widget inside the widget will also
     * become (semi-)transparent. The value should be a number between 0 and 1
     * inclusive, where 1 means totally opaque and 0 invisible.
     */
    _applyOpacity : function( value ) {
      this.setStyleProperty( "opacity", value );
    },

    /////////////////
    // CURSOR SUPPORT

    // TODO: maybe we could use cursor:url() for not suppoted cursors.
    __cursorMap : {
      "default" : "default",
      "wait" : "wait",
      "crosshair" : "crosshair",
      "help" : "help",
      "move" : "move",
      "text" : "text",
      "pointer" : "pointer",
      "e-resize" : "e-resize",
      "n-resize" : "n-resize",
      "w-resize" : "w-resize",
      "s-resize" : "s-resize",
      "ne-resize" : "ne-resize",
      "se-resize" : "se-resize",
      "nw-resize" : "nw-resize",
      "sw-resize" : "sw-resize",
      "col-resize" : "col-resize",
      "row-resize" : "row-resize",
      "progress" : "progress",
      "not-allowed" : "not-allowed",
      "no-drop" : "no-drop"
    },

    _applyCursor : function(value) {
      if (value) {
        var url = "url( " + value + " ), default";
        this.setStyleProperty("cursor", this.__cursorMap[value] || url);
      } else {
        this.removeStyleProperty("cursor");
      }
    },

    //////////////////
    // COMMAND SUPPORT

    // TODO [tb] : used only in listitem - remove
    _applyCommand : function() {
      // place holder
    },

    ///////////////////////////
    // BACKGROUND IMAGE SUPPORT

    _applyBackgroundImage : function(value, old) {
      var imageMgr = rwt.html.ImageManager.getInstance();
      if (old) {
        imageMgr.hide(old);
      }
      if (value) {
        imageMgr.show(value);
      }
      this._styleBackgroundImage( value );
    },

    _styleBackgroundImage : function( value ) {
      rwt.html.Style.setBackgroundImage( this, value );
    },

    _applyBackgroundRepeat : function( value ) {
      rwt.html.Style.setBackgroundRepeat( this, value );
    },

    _applyBackgroundPosition : function( value ) {
      rwt.html.Style.setBackgroundPosition( this, value );
    },

    ///////////////////
    // CLIPPING SUPPORT

    _applyClip : function() {
      return this._compileClipString();
    },

    _compileClipString : function() {
      var vLeft = this.getClipLeft();
      var vTop = this.getClipTop();
      var vWidth = this.getClipWidth();
      var vHeight = this.getClipHeight();
      var vRight, vBottom;
      if (vLeft == null) {
        vRight = (vWidth == null ? "auto" : vWidth + "px");
        vLeft = "auto";
      } else {
        vRight = (vWidth == null ? "auto" : vLeft + vWidth + "px");
        vLeft = vLeft + "px";
      }
      if (vTop == null) {
        vBottom = (vHeight == null ? "auto" : vHeight + "px");
        vTop = "auto";
      } else {
        vBottom = (vHeight == null ? "auto" : vTop + vHeight + "px");
        vTop = vTop + "px";
      }
      return this.setStyleProperty("clip", ("rect(" + vTop + "," + vRight + "," + vBottom + "," + vLeft + ")"));
    },

    _applyOverflow : function( value ) {
      this.setStyleProperty( "overflow", value || "");
      this._invalidateFrameWidth();
      this._invalidateFrameHeight();
      this.addToQueue( "overflow" );
    },

    _applyContainerOverflow : function( value ) {
      if( this._innerStyle ) {
        this._style.overflow = value ? "" : "hidden";
      }
    },

    /////////////////////////
    // FONT AND COLOR SUPPORT

    _applyBackgroundColor : function( value ) {
      this._styleBackgroundColor( value );
    },

    _applyBackgroundGradient : function( value ) {
      rwt.html.Style.setBackgroundGradient( this, value );
    },

    _applyShadow : function( value ) {
      rwt.html.Style.setBoxShadow( this, value );
    },

    _applyTextShadow : function( value ) {
      rwt.html.Style.setTextShadow( this, value );
    },

    _styleBackgroundColor : function( value ) {
      rwt.html.Style.setBackgroundColor( this, value );
    },

    _applyTextColor : function() {
      // place holder
    },

    _applyFont : function() {
      // place holder
    },

    /////////////////
    // BORDER SUPPORT

    _cachedBorderTop : 0,
    _cachedBorderRight : 0,
    _cachedBorderBottom : 0,
    _cachedBorderLeft : 0,
    _targetNodeEnabled : false,

    _applyBorder : function( value ) {
      this._queueBorder( value );
    },

    _queueBorder : function( value ) {
      this.addToQueue( "border" );
      this.__reflowBorderX( value );
      this.__reflowBorderY( value );
      this.__borderObject = value;
    },

    /**
     * Invalidates the cached frame on y-axis when border changes occour
     */
    __reflowBorderX : function( value ) {
      var oldLeftWidth = this._cachedBorderLeft;
      var oldRightWidth = this._cachedBorderRight;
      this._cachedBorderLeft = value ? value.getWidthLeft() : 0;
      this._cachedBorderRight = value ? value.getWidthRight() : 0;
      if ((oldLeftWidth + oldRightWidth) != (this._cachedBorderLeft + this._cachedBorderRight)) {
        this._invalidateFrameWidth();
      }
    },

    /**
     * Invalidates the cached frame on y-axis when border changes occour
     */
    __reflowBorderY : function(value) {
      var oldTopWidth = this._cachedBorderTop;
      var oldBottomWidth = this._cachedBorderBottom;
      this._cachedBorderTop = value ? value.getWidthTop() : 0;
      this._cachedBorderBottom = value ? value.getWidthBottom() : 0;
      if ((oldTopWidth + oldBottomWidth) != (this._cachedBorderTop + this._cachedBorderBottom)) {
        this._invalidateFrameHeight();
      }
    },

    /**
     * Renders border object to widget.
     * Callback from layout queue
     */
    renderBorder : function() {
      var value = this.__borderObject;
      if( value ) {
        value.renderWidget( this );
      } else {
        rwt.html.Border.resetWidget( this );
      }
      // RAP: Fix for Bug 301709, 380878
      this._outerFrame = this._computeOuterFrame();
    },

    _computeOuterFrame : function() {
      var result = [ 0, 0 ];
      if( this._innerStyle && this.__borderObject ) {
        var widths = this.__borderObject.getWidths();
        if( this.__borderObject.getStyle() === "complex" && widths[ 0 ] === 2 ) {
          // NOTE: RAP only supports complex borders with identical widths.
          result = [ 2, 2 ];
        } else {
          result = [ widths[ 1 ] + widths[ 3 ], widths[ 0 ] + widths[ 2 ] ];
        }
      }
      return result;
    },

    prepareEnhancedBorder : function( newElement ) {
      if( !this._innerStyle ) {
        this._targetNode = document.createElement( "div" );
        this._innerStyle = this._targetNode.style;
        this._targetNodeEnabled = true;
        this._innerStyle.width = "100%";
        this._innerStyle.height = "100%";
        this._innerStyle.position = "absolute";
        if( !newElement ) {
          for( var i in this._styleProperties ) {
            switch( i ) {
              case "zIndex":
              case "filter":
              case "opacity":
              case "MozOpacity":
              case "display":
              case "cursor":
              case "boxShadow":
              break;
              default:
                this._innerStyle[i] = this._styleProperties[i];
                this._style[i] = "";
            }
          }
        }
        // [if] Fix for bug 279800: Some focused widgets look strange in webkit
        this._style.outline = "none";
        this._applyContainerOverflow( this.getContainerOverflow() );
        if( !newElement ) {
          for( var name in this._htmlProperties ) {
            if( name === "unselectable" ) {
              this._targetNode.unselectable = this._htmlProperties[ name ];
            }
          }
        }
        while( this._element.firstChild ) {
          this._targetNode.appendChild( this._element.firstChild );
        }
        this._element.appendChild( this._targetNode );
        if( this.isInDom() ) {
          // TODO [tb] : check if this works for ProgressBar
          this._afterRemoveDom();
          this._afterInsertDom();
        }
      }
    },

    //////////////////
    // PADDING SUPPORT

    _applyPaddingTop : function() {
      this.addToQueue("paddingTop");
      this._invalidateFrameHeight();
    },

    _applyPaddingRight : function() {
      this.addToQueue("paddingRight");
      this._invalidateFrameWidth();
    },

    _applyPaddingBottom : function() {
      this.addToQueue("paddingBottom");
      this._invalidateFrameHeight();
    },

    _applyPaddingLeft : function() {
      this.addToQueue("paddingLeft");
      this._invalidateFrameWidth();
    },

    /**
     * Renders padding to widget
     * Callback from layout queue
     */
    renderPadding : function() {
      // empty
    },

    /////////////////
    // MARGIN SUPPORT

    _applyMarginLeft : function() {
      this.addToQueue("marginLeft");
    },

    _applyMarginRight : function() {
      this.addToQueue("marginRight");
    },

    _applyMarginTop : function() {
      this.addToQueue("marginTop");
    },

    _applyMarginBottom : function() {
      this.addToQueue("marginBottom");
    },

    //////////////////
    // COMMAND SUPPORT

    execute : function() {
      var cmd = this.getCommand();
      if (cmd) {
        cmd.execute(this);
      }
      this.createDispatchEvent( "execute" );
    },

    ///////////////////////////////
    // DOM: OFFSET & SCROLL SUPPORT

    _visualPropertyCheck : function() {
      if (!this.isCreated()) {
        throw new Error(this.classname + ": Element must be created previously!");
      }
    },

    setScrollLeft : function(nScrollLeft) {
      this._visualPropertyCheck();
      this._getTargetNode().scrollLeft = nScrollLeft;
    },

    setScrollTop : function(nScrollTop) {
      this._visualPropertyCheck();
      this._getTargetNode().scrollTop = nScrollTop;
    },

    getOffsetLeft : function() {
      this._visualPropertyCheck();
      return rwt.html.Offset.getLeft(this.getElement());
    },

    getOffsetTop : function() {
      this._visualPropertyCheck();
      return rwt.html.Offset.getTop(this.getElement());
    },

    getScrollLeft : function() {
      this._visualPropertyCheck();
      return this._getTargetNode().scrollLeft;
    },

    getScrollTop : function() {
      this._visualPropertyCheck();
      return this._getTargetNode().scrollTop;
    },

    getClientWidth : function() {
      this._visualPropertyCheck();
      return this._getTargetNode().clientWidth;
    },

    getClientHeight : function() {
      this._visualPropertyCheck();
      return this._getTargetNode().clientHeight;
    },

    getOffsetWidth : function() {
      this._visualPropertyCheck();
      return this.getElement().offsetWidth;
    },

    getOffsetHeight : function() {
      this._visualPropertyCheck();
      return this.getElement().offsetHeight;
    },

    getScrollWidth : function() {
      this._visualPropertyCheck();
      return this._getTargetNode().scrollWidth;
    },

    getScrollHeight : function() {
      this._visualPropertyCheck();
      return this._getTargetNode().scrollHeight;
    },

    ////////////////////////////////
    // DOM: SCROLL INTO VIEW SUPPORT

    /**
     * Scroll the widget into the view.
     *
     * This function works on DOM level and needs the widget to be already rendered.
     * This is true for example in the "appear" event handler of a widget.
     *
     * @type member
     * @param alignTopLeft {Boolean} Set the alignment. "True" means top left align, "False" means bottom right.
     */
    scrollIntoView : function(alignTopLeft) {
      this.scrollIntoViewX(alignTopLeft);
      this.scrollIntoViewY(alignTopLeft);
    },

    scrollIntoViewX : function(alignLeft) {
      if (!this._isCreated || !this._isDisplayable) {
        return false;
      }
      return rwt.html.ScrollIntoView.scrollX(this.getElement(), alignLeft);
    },

    scrollIntoViewY : function(alignTop) {
      if (!this._isCreated || !this._isDisplayable) {
        return false;
      }
      return rwt.html.ScrollIntoView.scrollY(this.getElement(), alignTop);
    },

    ////////////////////////
    // DRAG AND DROP SUPPORT

    supportsDrop : function(dragCache) {
      // Is there a user-supplied supportsDropMethod?
      var supportsDropMethod = this.getSupportsDropMethod();
      if (supportsDropMethod !== null) {
        // Yup.  Let it determine whether a drop is allowed.
        return supportsDropMethod.call(this, dragCache);
      }
      // Default behavior is to allow drop only if not dropping onto self
      return (this != dragCache.sourceWidget);
    },

    //////////////////
    // Adapter Support

    getAdapter : function( Clazz ) {
      /*jshint nonew: false */
      if( this._adapters === undefined ) {
        this._adapters = {};
      }
      var key = Clazz.classname;
      var result = this._adapters[ key ];
      if( result == null ) {
        new Clazz( this );
        result = this._adapters[ key ];
      }
      return result;
    }

  },

  ////////
  // DEFER

  defer : function(statics, members) {
    statics.__initApplyMethods(members);
    statics.__initLayoutProperties(statics);
  },

  /////////////
  // DESTRUCTOR

  destruct : function() {
    this.dispatchSimpleEvent( "dispose", { target : this } );
    var elem = this.getElement();
    if (elem) {
      elem.rwtWidget = null;
      try {
        if( elem.parentNode ) {
          elem.parentNode.removeChild( elem );
        }
      } catch( ex ) {
        //ignore exception
      }
      try {
        if( this._targetNode && this._targetNode.parentNode ) {
          this._targetNode.parentNode.removeChild( this._targetNode );
        }
      } catch( ex ) {
        //ignore exception
      }
    }
    this._disposeObjectDeep( "_adapters", 1 );
    this._disposeFields(
      "_isCreated",
      "_inlineEvents",
      "_element",
      "_style",
      "_targetNode",
      "_innerStyle",
      "_oldParent",
      "_styleProperties",
      "_htmlProperties",
      "_htmlAttributes",
      "__states",
      "_jobQueue",
      "_layoutChanges",
      "__borderObject",
      "_outerFrame"
    );
  }
} );

/*******************************************************************************
 * Copyright (c) 2011, 2012 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.qx.Class.define( "rwt.widgets.util.WidgetRenderAdapter", {

  extend : rwt.qx.Target,

  construct : function( widget ) {
    // Widget is responsible for the dispose:
    this._autoDispose = false;
    this.base( arguments );
    this._widget = widget;
    var key = this.classname;
    if( widget._adapters[ key ] != null ) {
      throw new Error( "Never create WidgetRenderAdapter directly!" );
    }
    widget._adapters[ key ] = this;
  },

  destruct : function() {
    // NOTE: disposing the adapter before the widget is not used or tested.
    this._widget = null;
  },

  events: {
    "visibility" : "rwt.event.DataEvent",
    "height" : "rwt.event.DataEvent",
    "top" : "rwt.event.DataEvent",
    "left" : "rwt.event.DataEvent",
    "opacity" : "rwt.event.DataEvent",
    "backgroundColor" : "rwt.event.DataEvent",
    "backgroundGradient" : "rwt.event.DataEvent"
  },

  members : {

    addRenderListener : function( type, listener, context ) {
      var rendererName = this._renderFunctionNames[ type ];
      if( !this.hasEventListeners( type ) ) {
        var that = this;
        this._widget[ rendererName ] = function() {
          var render = that.dispatchSimpleEvent( type, arguments, false );
          if( render ) {
            this.constructor.prototype[ rendererName ].apply( this, arguments );
          }
        };
      }
      this.addEventListener( type, listener, context );
    },

    removeRenderListener : function( type, listener, context ) {
      this.removeEventListener( type, listener, context );
      if( !this.hasEventListeners( type ) ) {
        var rendererName = this._renderFunctionNames[ type ];
        delete this._widget[ rendererName ];
      }
    },

    forceRender : function( type, value ) {
      this.getOriginalRenderer( type ).call( this._widget, value );
    },

    getOriginalRenderer : function( type ) {
      var rendererName = this._renderFunctionNames[ type ];
      var proto = this._widget.constructor.prototype;
      return proto[ rendererName ];
    },

    // TODO [tb]: AnimationRenderer#getValueFromWidget would also fit here

    _renderFunctionNames :  {
      "visibility" : "_applyVisibility",
      "height" : "_renderRuntimeHeight",
      "top" : "_renderRuntimeTop",
      "left" : "_renderRuntimeLeft",
      "opacity" : "_applyOpacity",
      "backgroundColor" : "_styleBackgroundColor",
      "backgroundGradient" : "_applyBackgroundGradient"
    }

  }

} );

/*******************************************************************************
 * Copyright (c) 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

(function(){

  var $ = rwt.util.RWTQuery;
  var BADGE_ELEMENT = "rwt.widgets.util.Badges.BADGE_ELEMENT";
  var BADGE = "Widget-Badge";

  rwt.define( "rwt.widgets.util.Badges", {

    setBadge : function( widget, text ) {
      if( text ) {
        var badge = this._getBadgeElement( widget );
        var element = $( widget ).get( 0 ); // add to OUTER element, do not use append diretly
        $( element ).append( badge );
        $( badge ).text( text );
        widget.addEventListener( "appear", this._renderBadgePosition, widget );
        widget.addEventListener( "flush", this._renderBadgePosition, widget );
        this._renderBadgePosition.apply( widget );
      } else {
        this._removeBadge( widget );
      }
    },

    _getBadgeElement : function( widget ) {
      if( widget.getUserData( BADGE_ELEMENT ) == null ) {
        var themeValues = new rwt.theme.ThemeValues( {} );
        widget.enableEnhancedBorder();
        var vPadding = 1;
        var lineHeightFactor = 1.1;
        var badge = document.createElement( "div" );
        $( badge ).css( {
          "position" : "absolute",
          "textAlign" : "center",
          "lineHeight" : lineHeightFactor,
          "color" : themeValues.getCssColor( BADGE, "color" ),
          "backgroundColor" : themeValues.getCssColor( BADGE, "background-color" ),
          "border" : themeValues.getCssBorder( BADGE, "border" ),
          "font" : themeValues.getCssFont( BADGE, "font" )
        } );
        var height = parseInt( badge.style.fontSize, 10 ) * lineHeightFactor + 2 * vPadding;
        $( badge ).css( {
          "minWidth" : height,
          "paddingLeft" : Math.floor( height * 0.3 ),
          "paddingRight" : Math.floor( height * 0.3 ),
          "paddingTop" : vPadding,
          "paddingBottom" : vPadding
        } );
        widget.setUserData( BADGE_ELEMENT, badge );
      }
      return widget.getUserData( BADGE_ELEMENT );
    },

    _removeBadge : function( widget ) {
      if( widget.getUserData( BADGE_ELEMENT ) != null ) {
        $( widget.getUserData( BADGE_ELEMENT ) ).detach();
      }
    },

    _renderBadgePosition : function( event ) {
      var widget = this;
      var updateNeeded = event && event.getData ? event.getData().updateBadgePosition : true;
      var badge = widget.getUserData( BADGE_ELEMENT );
      if(    updateNeeded
          && widget.isSeeable()
          && badge
          && badge.parentNode
          && widget.computeBadgePosition )
      {
        var size = [ badge.offsetWidth, badge.offsetHeight ];
        var position = widget.computeBadgePosition( size );
        // NOTE: 2 of these values should be "auto", but we don't enforce it here
        $( badge ).css( {
          "top" : position[ 0 ],
          "right" : position[ 1 ],
          "bottom" : position[ 2 ],
          "left" : position[ 3 ]
        } );
      }
    }

  } );

}());

/*******************************************************************************
 * Copyright (c) 2010, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.qx.Class.define( "rwt.animation.AnimationRenderer", {

  extend : rwt.qx.Object,

  construct : function( animation ) {
    // Animation is responsible for the dispose:
    this._autoDispose = false;
    this.base( arguments );
    this._animation = animation;
    this._animation._addRenderer( this );
    // Simple use:
    this._converterFunction = null;
    this._renderFunction = null;
    this._context = null;
    this._startValue = null;
    this._endValue = null;
    this._lastValue = null;
    this._setupFunction = null;
    this._cloneFrom = null;
    this._active = true;
    this._activeOnce = false;
    // Widget integration:
    this._invisibilityGetter = rwt.util.Functions.returnZero;
    this._fullVisibilityValue = null;
    this._autoStartEnabled = true;
    this._renderType = null;
    this._renderAdapter = null;
    this._animationType = 0;
    this._autoCheck = true;
  },

  destruct : function() {
    this.clearAnimation();
    this._animation._removeRenderer( this );
    this._animation = null;
    this._startValue = null;
    this._endValue = null;
    this._invisibilityGetter = null;
    this._lastValue = null;
    this._setupFunction = null;
    this._converterFunction = null;
    this._renderFunction = null;
    this._context = null;
    this._cloneFrom = null;
  },

  members : {

    //////////////////////////
    // Public API - simple use

    // Converts transitionValue (usually between 0 and 1) to the render-value.
    setConverter : function( type ) {
      if( typeof type == "string" ) {
        this._converterFunction = rwt.animation.AnimationRenderer.converter[ type ];
      } else {
        this._converterFunction = type;
      }
    },

    // Sets the function that is called with the value to render.
    setRenderFunction : function( func, context ) {
      if( this._renderType == null ) {
        this._renderFunction = func;
        this._context = context;
      }
    },

    renderValue : function( value ) {
      this._renderFunction.call( this._context, value );
      this._lastValue = value;
    },

    setStartValue : function( value ) {
      this._startValue = value;
    },

    setEndValue : function( value ) {
      this._endValue = value;
    },

    // The setup-function is called (if set) directly before the first frame of
    // an Animation is rendered. It is the last chance to set startValue,
    // endValue, renderFunction and converter before they are used.
    // The first parameter is the "config" value from Animation.start().
    // The second paramter will be the animationRenderer.
    setSetupFunction : function( func ) {
      this._setupFunction = func;
    },

    // Use lastValue from this renderer as transition-value.
    setCloneFrom : function( renderer ) {
      this._cloneFrom = renderer;
    },

    getAnimation : function() {
      return this._animation;
    },

    getContext : function() {
      return this._context;
    },

    getStartValue : function() {
      return this._startValue;
    },

    getEndValue : function() {
      return this._endValue;
    },

    // Returns the value that was last rendered.
    getLastValue : function() {
      return this._lastValue;
    },

    // Set to false to disable calls to setupFunction and renderFunction.
    // Also disables widget-integration.
    setActive : function( value ) {
      if( this._active !== value ) {
        if( this._animation.isRunning() ) {
          throw "AnimationRenderer: Can not change \"active\" while running!";
        }
        this._active = value;
        if( this._renderType !== null ) {
          this._handleAnimationType();
        }
      }
    },

    isActive : function() {
      return this._active;
    },

    // Sets active to false as soon as animation is finished
    activateOnce : function() {
      if( !this._activeOnce ) {
        this.setActive( true );
        this._activeOnce = true;
      }
    },

    cancelActivateOnce : function() {
      if( this._activeOnce ) {
        this._activeOnce = false;
        this.setActive( false );
      }
    },

    //////////////////////////////////
    // internals - called by Animation

    _setup : function( config ) {
      if( this._active ) {
        if( this._context instanceof rwt.widgets.base.Widget && this._context._isCreated !== true ) {
          if( this._context._isInGlobalElementQueue ) {
            rwt.widgets.base.Widget.flushGlobalQueues();
          } else {
            throw new Error( "AnimationRenderer setup failed: Widget not ready." );
          }
        }
        if( this._setupFunction != null ) {
          this._setupFunction.call( this._context, config, this );
        }
        this._startValue = this._prepareValue( this._startValue );
        this._endValue = this._prepareValue( this._endValue );
        if( this._renderFunction == null || this._converterFunction == null ) {
          throw new Error( "renderFunction or converterFunction missing" );
        }
      }
    },

    _render : function( transitionValue ) {
      if( this._active ) {
        var convertValue = this._cloneFrom != null
                           ? this._cloneFrom.getLastValue()
                           : transitionValue;
        try {
          var value = this._converterFunction( convertValue, this._startValue, this._endValue );
          this.renderValue( value );
        } catch( e ) {
          throw "AnimationRenderer failed: " + ( e.message ? e.message : e );
        }
      }
    },

    _finish : function( config ) {
      if( this._active && config == "disappear" ) {
        this._updateWidgetVisibility();
        this._forceWidgetRenderer();
      }
      this.cancelActivateOnce();
    },

    _prepareValue : function( value ) {
      var result = value;
      switch( this._renderType ) {
        case "backgroundColor":
          if( typeof value == "string" ) {
            if( value == "transparent" || value === "" || value.slice( 0, 4 ) === "rgba" ) {
              result = null;
            } else {
              result = rwt.util.Colors.stringToRgb( value );
            }
          }
        break;
        case "backgroundGradient":
          if( value ) {
            var result = [];
            for( var i = 0; i < value.length; i++ ) {
              result[ i ] = [
                value[ i ][ 0 ],
                rwt.util.Colors.stringToRgb( value[ i ][ 1 ] )
              ];
            }
          }
        break;
        case "opacity":
          result = ( value == null || value > 1 || value < 0 ) ? 1 : value;
        break;
        default:
          result = value != null ? value : 0;
        break;
      }
      return result;
    },

    ///////////////////////////
    // API - Widget integration

    // The RenderType can currently be:  "height", "opacity", "backgroundColor",
    // "backgroundGradient". The AnimationTypes are defined in the statics.
    animate : function( widget, renderType, animationType ) {
      if(    this._context != widget
          || this._renderType != renderType
          || this._animationType != animationType )
      {
        this.clearAnimation();
        this._context = widget;
        this._renderAdapter = widget.getAdapter( rwt.widgets.util.WidgetRenderAdapter );
        this._renderType = renderType;
        this._animationType = animationType;
        this._renderFunction = this._renderAdapter.getOriginalRenderer( this._renderType );
        var map = rwt.animation.AnimationRenderer.converterByRenderType;
        this.setConverter( map[ this._renderType ] );
        this._handleAnimationType();
      }
    },

    clearAnimation : function() {
      if( this._renderType !== null ) {
        this._animationType = 0;
        this._handleAnimationType();
        this._renderType = null;
        this.setRenderFunction( null, null );
        this._renderAdapter = null;
      }
    },

    isAnimated : function( type ) {
      var result = false;
      if( this._animationType > 0 && this._active ) {
        var animated = type & this._animationType;
        if( typeof type === "undefined" || animated !== 0 ) {
          result = true;
        }
      }
      return result;
    },

    setInvisibilityGetter : function( value ) {
      this._invisibilityGetter = value;
    },

    // default is true
    setAutoStart : function( value ) {
      this._autoStartEnabled = value;
    },

    // Prevent autoStart if startValue/endValue are invalid. If set to false,
    // the values can be set before or in the setupFunction is called.
    // Default is true.
    setAutoCheck : function( value ) {
      this._autoCheck = value;
    },

    // Return the actual, planned or last known value from the widget.
    getValueFromWidget : function() {
      var result = null;
      switch( this._renderType ) {
        case "opacity":
          result = this._context.getOpacity();
        break;
        case "height":
          if( this._context.isCreated() && this._context._style.height ) {
            result = parseInt( this._context._style.height, 10 );
          } else {
            result = this._context.getHeightValue();
            this._context._computedHeightValue = null;
            this._context._invalidatePreferredInnerHeight();
            this._context._invalidatePreferredBoxHeight();
          }
        break;
        case "top":
          if( this._context.isCreated() && this._context._style.top ) {
            result = parseInt( this._context._style.top, 10 );
          } else {
            result = this._context.getTopValue();
          }
        break;
        case "left":
          if( this._context.isCreated() && this._context._style.left ) {
            result = parseInt( this._context._style.left, 10 );
          } else {
            result = this._context.getLeftValue();
          }
        break;
        case "backgroundColor":
          var bg = "backgroundColor";
          var context = this._context;
          if( context.getGfxProperty && context.getGfxProperty( bg ) ) {
            result = context.getGfxProperty( bg );
          } else {
            result = rwt.html.Style.getBackgroundColor( context );
          }
        break;
        case "backgroundGradient":
          var context = this._context;
          // NOTE : this is not necessarily the actually last rendered value, but converting from
          //        css3-syntax to rwt-gradient would be overkill. It shouldn't matter.
          result = context.getBackgroundGradient();
        break;
        default:
          throw "getValueFromWidget: " + this._renderType + " not supported!";
      }
      return result;
    },

    // Are current values valid for animation (after using prepareValue)
    // Assumes that the given values ARE valid as a property of the renderType.
    checkValues : function() {
      var result;
      switch( this._renderType ) {
        case "backgroundGradient":
        case "backgroundColor":
          result = this._startValue != null && this._endValue != null;
        break;
        default:
          result = true;
        break;
      }
      // NOTE: Does not compare objects, i.e. gradients:
      return result && this._startValue != this._endValue;
    },

    //////////////////////////////////
    // Widget integration - internals

    _handleAnimationType : function() {
      if( this._animation.isRunning() ) {
        throw "AnimationRenderer: Can not change animation while running!";
      }
      // Note: Conventional event-handler would not be able to prevent the
      // actual rendering, therefore the functions are overwritten instead.
      if( this.isAnimated() ) {
        this._attachToApplyVisibility( true );
        this._attachToWidgetRenderer( true );
      } else {
        this._attachToApplyVisibility( false );
        this._attachToWidgetRenderer( false );
      }
    },

    _attachToApplyVisibility : function( value ) {
      if( value ) {
        this._renderAdapter.addRenderListener( "visibility", this._onVisibilityChange, this );
        this._context.addEventListener( "create", this._onCreate, this );
      } else {
        this._renderAdapter.removeRenderListener( "visibility", this._onVisibilityChange, this );
        this._context.removeEventListener( "create", this._onCreate, this );
      }
    },

    _attachToWidgetRenderer : function( value ) {
      if( value ) {
        this._renderAdapter.addRenderListener( this._renderType, this._onOriginalRenderer, this );
      } else {
        this._renderAdapter.removeRenderListener( this._renderType, this._onOriginalRenderer, this );
      }

    },

    //////////////////////////////////////
    // Widget integration - event handlers

    _onVisibilityChange : function( originalArgs ) {
      var value = originalArgs[ 0 ];
      var allow = false;
      if( value ) {
        allow = this._onBeforeAppear();
      } else {
        if( !this._context.isCreated() ) {
          this._animation.cancel(); // scheduled appear animation
        }
        if( this._context.isSeeable() ) {
          allow = this._onBeforeDisappear();
        } else {
          allow = true;
        }
      }
      return allow;
    },


    _onCreate : function() {
      if( this._context.isDisplayable() ) {
       this._onBeforeAppear();
      }
    },

    _onBeforeAppear : function() {
      if( this._context.isCreated() ) {
        this._animation.skip();
      } else {
        this._animation.cancel();
      }
      var typeAppear = rwt.animation.AnimationRenderer.ANIMATION_APPEAR;
      if( this._context.isCreated() && this.isAnimated( typeAppear ) ) {
        this.setEndValue( this.getValueFromWidget() );
        if( this._invisibilityGetter != null ) {
          this.setStartValue( this._invisibilityGetter( this._context ) );
          this._render( 0 );
        }
        this._autoStart( typeAppear );
      }
      return true;
    },

    _onBeforeDisappear : function() {
      this._animation.skip();
      var typeDisappear = rwt.animation.AnimationRenderer.ANIMATION_DISAPPEAR;
      var result = !this.isAnimated( typeDisappear );
      if( !result ) {
        if( this._invisibilityGetter !== null ) {
          this.setEndValue( this._invisibilityGetter( this._context ) );
        }
        this.setStartValue( this.getValueFromWidget() );
        this._autoStart( typeDisappear );
      }
      return result;
    },

    _onOriginalRenderer : function( originalArgs ) {
      var value = originalArgs[ 0 ];
      var oldValue = originalArgs[ 1 ];
      var result = false;
      if( this._animation.isStarted() ) {
        var config = this._animation.getConfig();
        var endValue = this._endValue;
        if( config == "change" || config == "appear" ) {
          this.setEndValue( value );
        }
        if( endValue != this._endValue ) {
          if( this._animation.isRunning() ) {
            this.setStartValue( this.getLastValue() );
          }
          if( !this.checkValues() || !this._animation.restart() ) {
            this._animation.cancel();
            this.cancelActivateOnce();
            result = true;
          }
        }
      } else {
        var typeChange = rwt.animation.AnimationRenderer.ANIMATION_CHANGE;
        if( this.isAnimated( typeChange ) && this._context.isSeeable() ) {
          this.setStartValue(   typeof oldValue !== "undefined"
                              ? oldValue
                              : this.getValueFromWidget() );
          this.setEndValue( value );
          if( !this._autoStart( typeChange ) && this._autoStartEnabled ) {
            result = true;
          }
        } else {
          result = true;
        }
      }
      return result;
    },

    //////////////////////////////
    // Widget integration - helper

    // Forces the widget to call the renderer, may be asynchronous due to flush.
    _forceWidgetRenderer : function() {
      var applyName = rwt.animation.AnimationRenderer.applyFunctionNames[ this._renderType ];
      this._context[ applyName ]( this._context.get( this._renderType ) );
    },

    _autoStart : function( type ) {
      var result = false;
      if(    this._autoStartEnabled
          && this.isAnimated( type )
          && ( this._autoCheck ? this.checkValues() : true ) )
      {
        result = this._animation.start( this._typeToConfig( type ) );
      } else {
        this.cancelActivateOnce();
      }
      return result;
    },

    _typeToConfig : function( type ) {
      var result = null;
      switch( type ) {
        case rwt.animation.AnimationRenderer.ANIMATION_APPEAR:
          result = "appear";
        break;
        case rwt.animation.AnimationRenderer.ANIMATION_DISAPPEAR:
          result = "disappear";
        break;
        case rwt.animation.AnimationRenderer.ANIMATION_CHANGE:
          result = "change";
        break;
      }
      return result;
    },

    // calls the original "_applyVisibility".
    _updateWidgetVisibility : function() {
      var value = this._context.getVisibility();
      this._renderAdapter.forceRender( "visibility", value );
    }

  },

  statics : {

    ANIMATION_APPEAR : 1,
    ANIMATION_DISAPPEAR : 2,
    ANIMATION_CHANGE : 4,

    applyFunctionNames : {
      "height" : "_applyHeight",
      "opacity" : "_applyOpacity",
      "backgroundColor" : "_applyBackgroundColor",
      "backgroundGradient" : "_applyBackgroundGradient",
      "top" : "_applyTop",
      "left" : "_applyLeft"
    },

    converterByRenderType : {
      "height" : "numericPositiveRound",
      "top" : "numericRound",
      "left" : "numericRound",
      "opacity" : "factor",
      "backgroundColor" : "color",
      "backgroundGradient" : "gradient"
    },

    converter : {

      // Converter working without startValue/EndValue

      none : function( value ) {
        return value;
      },

      round : Math.round,

      positive : function( value ) {
        return Math.max( 0, value );
      },

      // Converter needing valid startValue/EndValue

      numeric : function( value, startValue, endValue ) {
        return startValue + ( endValue - startValue ) * value;
      },

      numericRound : function( value, startValue, endValue ) {
        var result = startValue + ( endValue - startValue ) * value;
        return Math.round( result );
      },

      numericPositive : function( value, startValue, endValue ) {
        var diff = endValue - startValue;
        return Math.max( 0, startValue + diff * value );
      },

      numericPositiveRound : function( value, startValue, endValue ) {
        var diff = endValue - startValue;
        var result = Math.max( 0, startValue + diff * value );
        return Math.round( result );
      },

      factor : function( value, startValue, endValue ) {
        var result = startValue + ( endValue - startValue ) * value;
        return Math.max( 0, Math.min( result, 1) );
      },

      color : function( value, startValue, endValue ) {
        var result = [];
        var part;
        var partDiff;
        for( var i = 0; i < 3; i++ ) {
          partDiff = endValue[ i ] - startValue[ i ];
          part = Math.round( startValue[ i ] + partDiff * value );
          result[ i ] = Math.max( 0, Math.min( part, 255 ) );
        }
        return rwt.util.Colors.rgbToRgbString( result );
      },

      // Assumes that the number of colors are identical
      gradient : function( value, startValue, endValue ) {
        var convertColor = rwt.animation.AnimationRenderer.converter.color;
        var convertFactor = rwt.animation.AnimationRenderer.converter.factor;
        var result = [];
        var length = Math.min( endValue.length, startValue.length );
        for( var i = 0; i < length; i++ ) {
          result[ i ] = [
            convertFactor( value, startValue[ i ][ 0 ], endValue[ i ][ 0 ] ),
            convertColor( value, startValue[ i ][ 1 ], endValue[ i ][ 1 ] )
          ];
        }
        return result;
      }

    }//converter

  }

} );

/*******************************************************************************
 * Copyright (c) 2010, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.qx.Class.define( "rwt.animation.Animation", {

  extend : rwt.qx.Target,

  construct : function() {
    this.base( arguments );
    this._renderer = [];
    // properties:
    this._duration = 1000;
    this._transitionFunction = rwt.animation.Animation.transitions.linear;
    // setup:
    this._startOn = null;
    this._finishOn = null;
    this._totalTime = null;
    this._config = null;
    this._defaultRenderer = null;
    // state info:
    this._isRunning = false;
    this._inQueue = false;
  },

  destruct : function() {
    if( this.isRunning() ) {
      this.skip();
    } else {
      this.cancel();
    }
    try {
      for( var i = 0; i < this._renderer.length; i++ ) {
        this._renderer[ i ].dispose();
      }
    } catch( ex ) {
      throw "Could not Dispose AnimationRenderer: " + ex;
    }
    this._renderer = null;
  },

  events: {
    "init" : "rwt.event.DataEvent",
    "finish" : "rwt.event.DataEvent",
    "cancel" : "rwt.event.DataEvent"
  },

  members : {

    /////////////
    // Public API

    // Time in milliseconds
    setDuration : function( value ) {
      this._duration = value;
    },

    getDuration : function() {
      return this._duration;
    },

    setTransition : function( type ) {
      this._transitionFunction = rwt.animation.Animation.transitions[ type ];
    },

    setProperties : function( properties ) {
      this.setDuration( properties[ 0 ] );
      this.setTransition( properties[ 1 ] );
    },

    getRenderer : function( number ) {
      return this._renderer[ number ];
    },

    getDefaultRenderer : function( active ) {
      if( this._defaultRenderer == null || this._defaultRenderer.isDisposed() ) {
        this._defaultRenderer = new rwt.animation.AnimationRenderer( this );
      }
      if( typeof active != "undefined" ) {
        this._defaultRenderer.setActive( active );
      }
      return this._defaultRenderer;
    },

    getRendererLength : function() {
      return this._renderer.length;
    },

    getRendererIndex : function( renderer ) {
      return this._renderer.indexOf( renderer );
    },

    getConfig : function() {
      return this._config;
    },

    // config can by any value, but "appear", "disappear" and "change" are
    // used by AnimationRenderer when autoStart is enabled. When using
    // the widget-integration of AnimationRenderer, those should be used
    // in the appropriate scenarios. A config is valid between start and cancel,
    // then its set to null. Its given in the setup-function and all events.
    start : function( config ) {
      if ( !this.isStarted() ) {
        rwt.animation.Animation._addToQueue( this );
        this._inQueue = true;
        this._config = config;
        this._init();
      }
      return this.isStarted();
    },

    restart : function() {
      var result = false;
      if( this.isStarted() ) {
        var config = this._config;
        this.cancel();
        result = this.start( config );
      }
      return result;
    },

    cancel : function() {
      if( this.isStarted() ) {
        this._inQueue = false;
        this._isRunning = false;
        this.createDispatchDataEvent( "cancel", this._config );
        this._config = null;
        rwt.animation.Animation._removeFromLoop( this );
      }
    },

    // Unlike "cancel", this properly finishs the animation in any case by
    // simply skipping over the remaining frames (If there are any).
    skip : function() {
      if( this.isStarted() ) {
        if( !this.isRunning() ) {
          this._render( 0 );
        }
        this._finish();
      }
    },

    setRendererActive : function( value ) {
      for( var i = 0; i < this._renderer.length; i++ ) {
        this._renderer[ i ].setActive( value );
      }
    },

    activateRendererOnce : function() {
      for( var i = 0; i < this._renderer.length; i++ ) {
        this._renderer[ i ].activateOnce();
      }
    },

    isStarted : function() {
      return this._inQueue;
    },

    isRunning : function() {
      return this._isRunning;
    },

    ////////////
    // internals

    _addRenderer : function( renderer ) {
      this._renderer.push( renderer );
    },

    _removeRenderer : function( renderer ) {
      if( this.isStarted() ) {
        throw "Cannot remove AnimationRenderer: Animation already started!";
      }
      rwt.util.Arrays.remove( this._renderer, renderer );
    },

    _init : function() {
      this.createDispatchDataEvent( "init", this._config );
      this._startOn = null;
      this._numberRenderer = this._renderer.length;
    },

    _loop : function( time ) {
      if( this._startOn === null ) {
        this._startOn = new Date().getTime();
        this._finishOn = this._startOn + ( this._duration );
        this._totalTime = this._duration;
      }
      if ( time >= this._finishOn ) {
        this._finish();
      } else {
        var position = ( time - this._startOn ) / this._totalTime;
        this._render( position );
      }
    },

    _render : function( position ) {
      if( !this._isRunning ) {
        for( var i = 0; i < this._numberRenderer; i++ ) {
          this._renderer[ i ]._setup( this._config );
        }
        this._isRunning = true;
      }
      var transitionValue = this._transitionFunction( position );
      for( var i = 0; i < this._numberRenderer; i++ ) {
        this._renderer[ i ]._render( transitionValue );
      }
    },

    _finish : function() {
      this._render( 1 );
      var config = this._config;
      this.cancel();
      for( var i = 0; i < this._numberRenderer; i++ ) {
        this._renderer[ i ]._finish( config );
      }
      this.createDispatchDataEvent( "finish", config );
    }

  },

  statics : {

    ///////////////
    // Global Queue

    FPS : 60,
    _queue : [],
    _interval : null,

    _addToQueue : function( animation ) {
      this._queue.push( animation );
      if ( this._interval == null ) {
        this._startLoop();
      }
    },

    _removeFromLoop : function( animation ) {
      rwt.util.Arrays.remove( this._queue, animation );
      if( this._queue.length === 0 ) {
        this._stopLoop();
      }
    },

    _startLoop : function() {
      this._interval = setInterval( this._mainLoop, Math.round( 1000 / this.FPS ) );
    },

    _stopLoop : function() {
      window.clearInterval( this._interval );
      this._interval = null;
    },

    _mainLoop : function() {
      try {
        if( !rwt.remote.EventUtil.getSuspended() ) {
          var time = new Date().getTime();
          var Animation = rwt.animation.Animation;
          try {
            for( var i=0, len = Animation._queue.length; i < len; i++ ) {
              if( Animation._queue[ i ] ) {
                Animation._queue[ i ]._loop( time );
              }
            }
          } catch( e ) {
            // prevent endless error-messages:
            rwt.animation.Animation._stopLoop();
            throw "Animation aborted: " + e;
          }
        }
      } catch( ex ) {
        rwt.runtime.ErrorHandler.processJavaScriptError( ex );
      }
    },

    ////////
    // Util

    blockGlobalFlushs : function( value ) {
      rwt.widgets.base.Widget._inFlushGlobalQueues = value;
      if( !value ) {
        rwt.widgets.base.Widget._initAutoFlush( 0 );
      }
    },

    //////////////
    // Transitions

    transitions : {

      linear : function( position ) {
        return position;
      },

      ease : function ( position ) {
        var easeOut = -Math.pow( position - 1 , 2 ) + 1;
        return ( -Math.cos( easeOut *  Math.PI ) / 2 ) + 0.5;
      },

      easeIn : function ( position ) {
        return Math.pow( position, 2 );
      },

      easeOut : function ( position ) {
        return -Math.pow( position - 1 , 2 ) + 1;
      },

      easeInOut : function( position ) {
        return ( -Math.cos( position * Math.PI ) / 2 ) + 0.5;
      }

    }

  }

} );

/*******************************************************************************
 * Copyright (c) 2012 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

(function(){

var AnimationRenderer = rwt.animation.AnimationRenderer;
var Animation = rwt.animation.Animation;

rwt.animation.AnimationUtil = {

  snapTo : function( widget, time, left, top, hide ) {
    var animation = this._createAnimation( widget, time, "easeOut" );
    var rendererX = this._createRenderer( animation, widget, "left" );
    var rendererY = this._createRenderer( animation, widget, "top" );
    var startLeft = parseInt( widget.getLeft(), 10 );
    var startTop = parseInt( widget.getTop(), 10 );
    rendererX.setStartValue( isNaN( startLeft ) ? 0 : startLeft );
    rendererY.setStartValue( isNaN( startTop ) ? 0 : startTop );
    rendererX.setEndValue( left );
    rendererY.setEndValue( top );
    animation.addEventListener( "finish", function() {
      widget.setLeft( left );
      widget.setTop( top );
      if( hide ) {
        widget.setDisplay( false );
      }
    } );
    animation.start();
  },

  _createAnimation : function( widget, time, transition ) {
    var result = new Animation();
    result.setDuration( time );
    result.setTransition( transition );
    var abort = function() {
      result.cancel();
      result.dispose();
    };
    widget.addEventListener( "cancelAnimations", abort );
    widget.addEventListener( "dispose", abort );
    result.addEventListener( "cancel", function() {
      widget.removeEventListener( "dispose", abort );
      widget.removeEventListener( "cancelAnimations", abort );
      // animation may still need to dispatch "finish", dispose later
      rwt.client.Timer.once( result.dispose, result, 0 );
    } );
    return result;
  },

  _createRenderer : function( animation, widget, property ) {
    var converter = AnimationRenderer.converterByRenderType;
    var adapter = widget.getAdapter( rwt.widgets.util.WidgetRenderAdapter );
    var result = new AnimationRenderer( animation );
    result.setRenderFunction( adapter.getOriginalRenderer( property ), widget );
    result.setConverter( converter[ property ] );
    return result;
  }

};

}());

/*******************************************************************************
 * Copyright (c) 2010, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

( function() {

var Animation = rwt.animation.Animation;
var AnimationRenderer = rwt.animation.AnimationRenderer;
var EventHandlerUtil = rwt.event.EventHandlerUtil;

rwt.qx.Mixin.define( "rwt.animation.VisibilityAnimationMixin", {

  properties : {

    animation : {
      check : "Object",
      nullable : false,
      init : null,
      apply : "_applyAnimation",
      themeable : true
    }

  },

  construct : function() {
    this.hide(); // forces _applyVisibility to be called on show() - not a good practice
    this.addEventListener( "changeVisibility", this._blockUserEvents, this );
    this.addEventListener( "destroy", this._onDestroyAnim, this );
    if( this instanceof rwt.widgets.Composite ) {
      this.show();
    }
  },

  destruct : function() {
    if( this._appearAnimation != null ) {
      this._appearAnimation.dispose();
    }
    this._appearAnimation = null;
    if( this._disappearAnimation != null ) {
      this._disappearAnimation.dispose();
    }
    this._disappearAnimation = null;
  },

  members : {
    _appearAnimation : null, // Declaration in constructor would be too late (mixin)
    _disappearAnimation : null,
    _animateDestroy : false,

    _applyAnimation : function( newValue ) {
      this._configureAppearAnimation( newValue );
      this._configureDisappearAnimation( newValue );
    },

    ////////////////////
    // Appear animations

    _configureAppearAnimation : function( config ) {
      if( this._appearAnimation !== null ) {
        this._appearAnimation.getDefaultRenderer().setActive( false );
      }
      for( var type in config ) {
        switch( type ) {
          case "fadeIn":
            this._configureFadeIn( config[ type ] );
          break;
          case "slideIn":
            this._configureSlideIn( config[ type ] );
          break;
          case "flyInTop":
          case "flyInLeft":
          case "flyInRight":
          case "flyInBottom":
            this._configureFlyIn( config[ type ], type );
          break;
        }
      }
    },

    _configureFadeIn : function( props ) {
      var animation = this._getAppearAnimation();
      animation.setProperties( props );
      animation.getDefaultRenderer().animate( this, "opacity", AnimationRenderer.ANIMATION_APPEAR );
    },

    _configureSlideIn : function( props ) {
      var animation = this._getAppearAnimation();
      animation.setProperties( props );
      var renderer = animation.getDefaultRenderer();
      var animationType = AnimationRenderer.ANIMATION_APPEAR | AnimationRenderer.ANIMATION_CHANGE;
      renderer.animate( this, "height", animationType );
      animation.addEventListener( "init", this._initSlideAnimation, this );
      animation.addEventListener( "cancel", this._finishSlideAnimation, this );
    },

    _configureFlyIn : function( props, type ) {
      var animation = this._getAppearAnimation();
      animation.setProperties( props );
      var renderer = animation.getDefaultRenderer();
      var animationType = AnimationRenderer.ANIMATION_APPEAR;
      switch( type ) {
        case "flyInTop":
          renderer.animate( this, "top", animationType );
          renderer.setInvisibilityGetter( rwt.animation.VisibilityAnimationMixin.hideTop );
        break;
        case "flyInBottom":
          renderer.animate( this, "top", animationType );
          renderer.setInvisibilityGetter( rwt.animation.VisibilityAnimationMixin.hideBottom );
        break;
        case "flyInLeft":
          renderer.animate( this, "left", animationType );
          renderer.setInvisibilityGetter( rwt.animation.VisibilityAnimationMixin.hideLeft );
        break;
        case "flyInRight":
          renderer.animate( this, "left", animationType );
          renderer.setInvisibilityGetter( rwt.animation.VisibilityAnimationMixin.hideRight );
        break;
      }
    },

    _getAppearAnimation : function() {
      if( this._appearAnimation === null ) {
        this._appearAnimation = new Animation();
      }
      this._appearAnimation.getDefaultRenderer().setActive( true );
      return this._appearAnimation;
    },

    ///////////////////////
    // Disappear Animations

    _onDestroyAnim : function() {
      var result = true;
      if( this._animateDestroy ) {
        this._markInDispose();
        this.hide();
        if( this._disappearAnimation.isStarted() ) {
          result = false;
          this._disappearAnimation.addEventListener( "cancel", this._finishDestroyAnimation, this );
        } else {
          this._animateDestroy = false;
          delete this._isInGlobalDisposeQueue;
        }
      }
      return result;
    },

    _finishDestroyAnimation : function() {
      this._animateDestroy = false;
      delete this._isInGlobalDisposeQueue;
      this.destroy();
    },

    _configureDisappearAnimation : function( config ) {
      if( this._disappearAnimation !== null ) {
        this._disappearAnimation.getDefaultRenderer().setActive( false );
        this._animateDestroy = false;
      }
      for( var type in config ) {
        switch( type ) {
          case "fadeOut":
            this._configureFadeOut( config[ type ] );
          break;
          case "slideOut":
            this._configureSlideOut( config[ type ] );
          break;
          case "flyOutTop":
          case "flyOutLeft":
          case "flyOutRight":
          case "flyOutBottom":
            this._configureFlyOut( config[ type ], type );
          break;
        }
      }
    },

    _configureFadeOut : function( props ) {
      var animation = this._getDisappearAnimation();
      var renderer = animation.getDefaultRenderer();
      renderer.animate( this, "opacity", AnimationRenderer.ANIMATION_DISAPPEAR );
      animation.setProperties( props );
    },

    _configureSlideOut : function( props ) {
      var animation = this._getDisappearAnimation();
      var renderer = animation.getDefaultRenderer();
      renderer.animate( this, "height", AnimationRenderer.ANIMATION_DISAPPEAR );
      animation.addEventListener( "init", this._initSlideAnimation, this );
      animation.addEventListener( "cancel", this._finishSlideAnimation, this );
      animation.setProperties( props );
    },

    _configureFlyOut : function( props, type ) {
      var animation = this._getDisappearAnimation();
      animation.setProperties( props );
      var renderer = animation.getDefaultRenderer();
      var animationType = AnimationRenderer.ANIMATION_DISAPPEAR;
      switch( type ) {
        case "flyOutTop":
          renderer.animate( this, "top", animationType );
          renderer.setInvisibilityGetter( rwt.animation.VisibilityAnimationMixin.hideTop );
        break;
        case "flyOutBottom":
          renderer.animate( this, "top", animationType );
          renderer.setInvisibilityGetter( rwt.animation.VisibilityAnimationMixin.hideBottom );
        break;
        case "flyOutLeft":
          renderer.animate( this, "left", animationType );
          renderer.setInvisibilityGetter( rwt.animation.VisibilityAnimationMixin.hideLeft );
        break;
        case "flyOutRight":
          renderer.animate( this, "left", animationType );
          renderer.setInvisibilityGetter( rwt.animation.VisibilityAnimationMixin.hideRight );
        break;
      }
    },

    _getDisappearAnimation : function() {
      if( this._disappearAnimation === null ) {
        this._disappearAnimation = new Animation();
        if( this instanceof rwt.widgets.Shell ) {
          this._disappearAnimation.addEventListener( "init", this._lockActiveState, this );
          this._disappearAnimation.addEventListener( "cancel", this._unlockActiveState, this );
        }
      }
      this._disappearAnimation.getDefaultRenderer().setActive( true );
      this._animateDestroy = true;
      return this._disappearAnimation;
    },

    /////////
    // helper

    _initSlideAnimation : function() {
      this.setContainerOverflow( false );
    },

    _finishSlideAnimation : function() {
      // TODO : could container overflow just be generally false, or use _applyHeight instead?
      this.setContainerOverflow( true );
    },

    _blockUserEvents : function( changeEvent ) {
      var element = this.getElement();
      if( element ) {
        EventHandlerUtil.blockUserDomEvents( element, !changeEvent.getValue() );
      }
    },

    _lockActiveState : function() {
      //this._setActiveState = rwt.util.Functions.returnNull;
      this.getWindowManager().blockActiveState = true;
    },

    _unlockActiveState : function() {
      var manager = rwt.widgets.base.Window.getDefaultWindowManager();
      manager.blockActiveState = false;
      if( !this.isDisposed() && !this._isInGlobalDisposeQueue ) {
        //delete this._setActiveState;
        this._setActiveState( this.getActive() );
      }
      var active = manager.getActiveWindow();
      if( active && active !== this ) {
        active._setActiveState( true );
      }
    }

 },

 statics : {

   hideTop : function( widget ) {
     return parseInt( widget.getHeightValue(), 10 ) * -1;
   },

   hideBottom : function( widget ) {
     return widget.getParent().getInnerHeight();
   },

   hideLeft : function( widget ) {
     return parseInt( widget.getWidthValue(), 10 ) * -1;
   },

   hideRight : function( widget ) {
     return widget.getParent().getInnerWidth();
   }

 }

} );

}());

/*******************************************************************************
 * Copyright (c) 2004, 2015 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

/**
 * Abstract base class for all widget which have child widgets (e.g. layout manager)
 *
 * Don't instantiate this class directly.
 */
rwt.qx.Class.define("rwt.widgets.base.Parent",
{
  extend : rwt.widgets.base.Widget,




  /*
  *****************************************************************************
     CONSTRUCTOR
  *****************************************************************************
  */

  construct : function()
  {
    this.base(arguments);

    // Contains all children
    this._children = [];

    // Create instanceof layout implementation
    this._layoutImpl = this._createLayoutImpl();
  },




  /*
  *****************************************************************************
     PROPERTIES
  *****************************************************************************
  */

  properties :
  {
    /** Individual focus handler for all child elements. */
    focusHandler :
    {
      check : "rwt.widgets.util.FocusHandler",
      apply : "_applyFocusHandler",
      nullable : true
    },

    /** The current active child. */
    activeChild :
    {
      check : "rwt.widgets.base.Widget",
      event : "changeActiveChild",
      nullable : true
    },

    /** The current focused child. */
    focusedChild :
    {
      check : "rwt.widgets.base.Widget",
      apply : "_applyFocusedChild",
      event : "changeFocusedChild",
      nullable : true
    },

    /** all visible child widgets */
    visibleChildren :
    {
      _cached      : true,
      defaultValue : null
    }
  },




  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {
    /*
    ---------------------------------------------------------------------------
      FOCUS HANDLING
    ---------------------------------------------------------------------------
    */

    /**
     * Wether the widget has its own focus handler or uses one of its parent's
     * focus handler.
     *
     * @type member
     * @return {Boolean} whether the widget has its own focus handler
     */
    isFocusRoot : function() {
      return this.getFocusHandler() != null;
    },


    /**
     * Return the responsible focus handler
     *
     * @type member
     * @return {rwt.widgets.util.FocusHandler} TODOC
     */
    getFocusRoot : function()
    {
      if (this.isFocusRoot()) {
        return this;
      }

      if (this._hasParent) {
        return this.getParent().getFocusRoot();
      }

      return null;
    },


    /**
     * Let the widget use its own focus handler
     *
     * @type member
     * @return {void}
     */
    activateFocusRoot : function()
    {
      if (this._focusHandler) {
        return;
      }

      this._focusHandler = new rwt.widgets.util.FocusHandler(this);
      this.setFocusHandler(this._focusHandler);
    },


    /**
     * Delegate keyevent to the focus handler
     *
     * @type member
     * @param e {Event} TODOC
     * @return {void}
     */
    _onfocuskeyevent : function(e) {
      this.getFocusHandler()._onkeyevent(this, e);
    },


    /**
     * TODOC
     *
     * @type member
     * @param value {var} Current value
     * @param old {var} Previous value
     */
    _applyFocusHandler : function(value)
    {
      if (value)
      {
        // Add Key Handler
        this.addEventListener("keypress", this._onfocuskeyevent);

        // Activate focus handling (but keep already configured tabIndex)
        if (this.getTabIndex() < 1) {
          this.setTabIndex(1);
        }

        // But hide the focus outline
        this.setHideFocus(true);

        // Make myself the default
        this.setActiveChild(this);
      }
      else
      {
        // Remove Key Handler
        this.removeEventListener("keydown", this._onfocuskeyevent);
        this.removeEventListener("keypress", this._onfocuskeyevent);

        // Deactivate focus handling
        this.setTabIndex(null);

        // Don't hide focus outline
        this.setHideFocus(false);
      }
    },

    /**
     * TODOC
     *
     * @type member
     * @param value {var} Current value
     * @param old {var} Previous value
     */
    _applyFocusedChild : function(value, old)
    {
      var vFocusValid = value != null;
      var vBlurValid = old != null;

      if (rwt.qx.Class.isDefined("rwt.widgets.util.PopupManager") && vFocusValid)
      {
        var vMgr = rwt.widgets.util.PopupManager.getInstance();

        if (vMgr) {
          vMgr.update(value);
        }
      }

      if (vBlurValid)
      {
        // Dispatch FocusOut
        if (old.hasEventListeners("focusout"))
        {
          var vEventObject = new rwt.event.FocusEvent("focusout", old);

          if (vFocusValid) {
            vEventObject.setRelatedTarget(value);
          }

          old.dispatchEvent(vEventObject);
          vEventObject.dispose();
        }
      }

      if (vFocusValid)
      {
        if (value.hasEventListeners("focusin"))
        {
          // Dispatch FocusIn
          var vEventObject = new rwt.event.FocusEvent("focusin", value);

          if (vBlurValid) {
            vEventObject.setRelatedTarget(old);
          }

          value.dispatchEvent(vEventObject);
          vEventObject.dispose();
        }
      }

      if (vBlurValid)
      {
        if (this.getActiveChild() == old && !vFocusValid) {
          this.setActiveChild(null);
        }

        old.setFocused(false);

        // Dispatch Blur
        var vEventObject = new rwt.event.FocusEvent("blur", old);

        if (vFocusValid) {
          vEventObject.setRelatedTarget(value);
        }

        old.dispatchEvent(vEventObject);

        var vMgr = rwt.widgets.util.ToolTipManager.getInstance();

        if (vMgr) {
          vMgr.handleBlur(vEventObject);
        }

        vEventObject.dispose();
      }

      if (vFocusValid)
      {
        this.setActiveChild(value);
        value.setFocused(true);
        rwt.event.EventHandler.setFocusRoot(this);

        // Dispatch Focus
        var vEventObject = new rwt.event.FocusEvent("focus", value);

        if (vBlurValid) {
          vEventObject.setRelatedTarget(old);
        }

        value.dispatchEvent(vEventObject);

        var vMgr = rwt.widgets.util.ToolTipManager.getInstance();

        if (vMgr) {
          vMgr.handleFocus(vEventObject);
        }

        vEventObject.dispose();
      }
    },




    /*
    ---------------------------------------------------------------------------
      LAYOUT IMPLEMENTATION
    ---------------------------------------------------------------------------
    */

    _layoutImpl : null,


    /**
     * abstract method. Create layout implementation.
     *
     * This method must be overwritten by all subclasses
     *
     * return
     *
     * @type member
     * @return {rwt.widgets.base.BoxLayout} TODOC
     */
    _createLayoutImpl : function() {
      return new rwt.widgets.util.CanvasLayoutImpl( this);
    },


    /**
     * Return the layout implementation.
     *
     * return {rwt.widgets.util.LayoutImpl}
     *
     * @type member
     * @return {var} TODOC
     */
    getLayoutImpl : function() {
      return this._layoutImpl;
    },




    /*
    ---------------------------------------------------------------------------
      CHILDREN MANAGMENT: MANAGE ALL
    ---------------------------------------------------------------------------
    */

    /**
     * Return the array of all children
     *
     * @type member
     * @return {rwt.widgets.base.Widget[]} all children
     */
    getChildren : function() {
      return this._children;
    },


    /**
     * Get number of children
     *
     * @type member
     * @return {Integer} number of children
     */
    getChildrenLength : function() {
      return this.getChildren().length;
    },


    /**
     * Check if the widget has children
     *
     * @type member
     * @return {Boolean} whether the widget has children
     */
    hasChildren : function() {
      return this.getChildrenLength() > 0;
    },


    /**
     * Check if there are any children inside
     *
     * @type member
     * @return {Boolean} whether the number of children is 0
     */
    isEmpty : function() {
      return this.getChildrenLength() === 0;
    },


    /**
     * Get the index of a child widget.
     *
     * @type member
     * @param vChild {rwt.widgets.base.Widget} Child widget to get the index for
     * @return {Integer} index of the child widget
     */
    indexOf : function(vChild) {
      return this.getChildren().indexOf(vChild);
    },


    /**
     * Check if the given widget is a child
     *
     * @type member
     * @param vWidget {rwt.widgets.base.Widget} The widget which should be checked.
     * @return {Boolean | var} TODOC
     */
    contains : function(vWidget)
    {
      switch(vWidget)
      {
        case null:
          return false;

        case this:
          return true;

        default:
          // try the next parent of the widget (recursive until found)
          return this.contains(vWidget.getParent());
      }
    },




    /*
    ---------------------------------------------------------------------------
      CHILDREN MANAGMENT: MANAGE VISIBLE ONES

      uses a cached private property
    ---------------------------------------------------------------------------
    */

    /**
     * Return the array of all visible children
     * (which are configured as visible=true)
     *
     * @type member
     * @return {rwt.widgets.base.Widget[]} all visible children
     */
    _computeVisibleChildren : function()
    {
      var vVisible = [];
      var vChildren = this.getChildren();

      if (! vChildren)
      {
        return 0;
      }

      var vLength = vChildren.length;

      for (var i=0; i<vLength; i++)
      {
        var vChild = vChildren[i];

        if (vChild._isDisplayable ) {
          vVisible.push(vChild);
        }
      }

      return vVisible;
    },


    /**
     * Get number of visible children
     *
     * @type member
     * @return {Integer} number of visible children
     */
    getVisibleChildrenLength : function() {
      return this.getVisibleChildren().length;
    },


    /**
     * Check if the widget has any visible children
     *
     * @type member
     * @return {Boolean} whether the widget has any visible children
     */
    hasVisibleChildren : function() {
      return this.getVisibleChildrenLength() > 0;
    },


    /**
     * Check whether there are any visible children inside
     *
     * @type member
     * @return {Boolean} whether there are any visible children inside
     */
    isVisibleEmpty : function() {
      return this.getVisibleChildrenLength() === 0;
    },




    /*
    ---------------------------------------------------------------------------
      CHILDREN MANAGMENT: ADD
    ---------------------------------------------------------------------------
    */

    /**
     * Add/Append another widget. Allows to add multiple at
     *  one, a parameter could be a widget.
     *
     * @type member
     * @param varargs {rwt.widgets.base.Widget} variable number of widgets to add
     * @return {Parent} This widget.
     * @throws TODOC
     */
    add : function()
    {
      var vWidget;

      for (var i=0, l=arguments.length; i<l; i++)
      {
        vWidget = arguments[i];
        vWidget.setParent( this );
      }

      return this;
    },


    /**
     * Add a child widget at the specified index
     *
     * @type member
     * @param vChild {widget} widget to add
     * @param vIndex {Integer} Index, at which the widget will be inserted
     */
    addAt : function(vChild, vIndex)
    {
      if (vIndex == null || vIndex < 0) {
        throw new Error("Not a valid index for addAt(): " + vIndex);
      }

      if (vChild.getParent() == this)
      {
        var vChildren = this.getChildren();
        var vOldIndex = vChildren.indexOf(vChild);

        if (vOldIndex != vIndex)
        {
          if (vOldIndex != -1) {
            rwt.util.Arrays.removeAt(vChildren, vOldIndex);
          }

          rwt.util.Arrays.insertAt(vChildren, vChild, vIndex);

          if (this._initialLayoutDone)
          {
            this._invalidateVisibleChildren();
            this.getLayoutImpl().updateChildrenOnMoveChild(vChild, vIndex, vOldIndex);
          }
        }
      }
      else
      {
        vChild._insertIndex = vIndex;
        vChild.setParent(this);
      }
    },


    /**
     * Add a child widget as the first widget
     *
     * @type member
     * @param vChild {widget} widget to add
     */
    addAtBegin : function(vChild) {
      return this.addAt(vChild, 0);
    },


    /**
     * Add a child widget as the last widget
     *
     * @type member
     * @param vChild {widget} widget to add
     */
    addAtEnd : function(vChild)
    {
      // we need to fix here, when the child is already inside myself, but
      // want to change its position
      var vLength = this.getChildrenLength();
      return this.addAt(vChild, vChild.getParent() == this ? vLength - 1 : vLength);
    },


    /**
     * Add a widget before another already inserted widget
     *
     * @type member
     * @param vChild {var} widget to add
     * @param vBefore {var} widget before the new widget will be inserted.
     */
    addBefore : function(vChild, vBefore)
    {
      var vChildren = this.getChildren();
      var vTargetIndex = vChildren.indexOf(vBefore);

      if (vTargetIndex == -1) {
        throw new Error("Child to add before: " + vBefore + " is not inside this parent.");
      }

      var vSourceIndex = vChildren.indexOf(vChild);

      if (vSourceIndex == -1 || vSourceIndex > vTargetIndex) {
        vTargetIndex++;
      }

      return this.addAt(vChild, Math.max(0, vTargetIndex - 1));
    },


    /**
     * Add a widget after another already inserted widget
     *
     * @type member
     * @param vChild {var} widget to add
     * @param vAfter {var} widgert, after which the new widget will be inserted
     */
    addAfter : function(vChild, vAfter)
    {
      var vChildren = this.getChildren();
      var vTargetIndex = vChildren.indexOf(vAfter);

      if (vTargetIndex == -1) {
        throw new Error("Child to add after: " + vAfter + " is not inside this parent.");
      }

      var vSourceIndex = vChildren.indexOf(vChild);

      if (vSourceIndex != -1 && vSourceIndex < vTargetIndex) {
        vTargetIndex--;
      }

      return this.addAt(vChild, Math.min(vChildren.length, vTargetIndex + 1));
    },




    /*
    ---------------------------------------------------------------------------
      CHILDREN MANAGMENT: REMOVE
    ---------------------------------------------------------------------------
    */

    /**
     * Remove one or multiple childrens.
     *
     * @type member
     * @param varargs {rwt.widgets.base.Widget} variable number of widgets to remove
     */
    remove : function( /*children*/ )
    {
      var vWidget;

      for (var i=0, l=arguments.length; i<l; i++)
      {
        vWidget = arguments[i];

        if (!(vWidget instanceof rwt.widgets.base.Parent) && !(vWidget instanceof rwt.widgets.base.Terminator)) {
          throw new Error("Invalid Widget: " + vWidget);
        } else if (vWidget.getParent() == this) {
          vWidget.setParent(null);
        }
      }
    },


    /**
     * Remove the widget at the specified index.
     *
     * @type member
     * @param vIndex {Integer} Index of the widget to remove.
     */
    removeAt : function(vIndex)
    {
      var vChild = this.getChildren()[vIndex];

      if (vChild)
      {
        delete vChild._insertIndex;

        vChild.setParent(null);
      }
    },


    /**
     * Remove all children.
     *
     * @type member
     */
    removeAll : function()
    {
      var cs = this.getChildren();
      var co = cs[0];

      while (co)
      {
        this.remove(co);
        co = cs[0];
      }
    },




    /*
    ---------------------------------------------------------------------------
      CHILDREN MANAGMENT: FIRST CHILD
    ---------------------------------------------------------------------------
    */

    /**
     * Get the first child
     *
     * @type member
     * @return {Widget|null} First child widget (null if this widget does not have any children)
     */
    getFirstChild : function() {
      return rwt.util.Arrays.getFirst(this.getChildren()) || null;
    },


    /**
     * Get the first visible child
     *
     * @type member
     * @return {Widget|null} First visible child widget (null if this widget does
     *     not have any visible children)
     */
    getFirstVisibleChild : function() {
      return rwt.util.Arrays.getFirst(this.getVisibleChildren()) || null;
    },


    /**
     * Get the first active child
     *
     * @type member
     * @param vIgnoreClasses {Class[]} array of classes which should be ignored
     * @return {Widget|null} First active child widget (null if this widget does
     *     not have any active children)
     */
    getFirstActiveChild : function(vIgnoreClasses) {
      return rwt.widgets.base.Widget.getActiveSiblingHelper(null, this, 1, vIgnoreClasses, "first") || null;
    },




    /*
    ---------------------------------------------------------------------------
      CHILDREN MANAGMENT: LAST CHILD
    ---------------------------------------------------------------------------
    */

    /**
     * Get the last child
     *
     * @type member
     * @return {Widget|null} Last child widget (null if this widget does
     *     not have any children)
     */
    getLastChild : function() {
      return rwt.util.Arrays.getLast(this.getChildren()) || null;
    },


    /**
     * Get the last visible child
     *
     * @type member
     * @return {Widget|null} Last visible child widget (null if this widget does
     *     not have any visible children)
     */
    getLastVisibleChild : function() {
      return rwt.util.Arrays.getLast(this.getVisibleChildren()) || null;
    },


    /**
     * Get the last active child
     *
     * @type member
     * @param vIgnoreClasses {Class[]} array of classes which should be ignored
     * @return {Widget|null} Last active child widget (null if this widget does
     *     not have any active children)
     */
    getLastActiveChild : function(vIgnoreClasses) {
      return rwt.widgets.base.Widget.getActiveSiblingHelper(null, this, -1, vIgnoreClasses, "last") || null;
    },




    /*
    ---------------------------------------------------------------------------
      CHILDREN MANAGMENT: LOOP UTILS
    ---------------------------------------------------------------------------
    */

    /**
     * Call a callbach function for each child widget. The callback has the following signature:
     * <code>function(childWidget, widgetIndex)</code>. The first parameter is the child widget
     * and the second the index of the child widget in its parent.
     *
     * @type member
     * @param vFunc {Function} callback function. Signature: <code>function(childWidget, widgetIndex)</code>
     */
    forEachChild : function(vFunc)
    {
      var ch = this.getChildren(), chc, i = -1;

      if (! ch) {
        return;
      }

      chc = ch[++i];
      while( chc ) {
        vFunc.call(chc, i);
        chc = ch[++i];
      }
    },


    /**
     * Call a callbach function for each visible child widget. The callback has the following signature:
     * <code>function(childWidget, widgetIndex)</code>. The first parameter is the child widget
     * and the second the index of the child widget in its parent.
     *
     * @type member
     * @param vFunc {Function} callback function. Signature: <code>function(childWidget, widgetIndex)</code>
     */
    forEachVisibleChild : function(vFunc)
    {
      var ch = this.getVisibleChildren(), chc, i = -1;

      if (! ch) {
        return;
      }

      chc = ch[++i];
      while( chc ) {
        vFunc.call(chc, i);
        chc = ch[++i];
      }
    },

    _markInDispose : function() {
      this._isInGlobalDisposeQueue = true;
      if( this.forEachChild ) {
        this.forEachChild( arguments.callee );
      }
    },

    /*
    ---------------------------------------------------------------------------
      APPEAR/DISAPPEAR MESSAGES FOR CHILDREN
    ---------------------------------------------------------------------------
    */

    // overridden
    _beforeAppear : function()
    {
      this.base(arguments);

      this.forEachVisibleChild(function()
      {
        if (this.isAppearRelevant()) {
          this._beforeAppear();
        }
      });
    },


    // overridden
    _afterAppear : function()
    {
      this.base(arguments);

      this.forEachVisibleChild(function()
      {
        if (this.isAppearRelevant()) {
          this._afterAppear();
        }
      });
    },

    // overridden
    _beforeDisappear : function()
    {
      this.base(arguments);

      this.forEachVisibleChild(function()
      {
        if (this.isAppearRelevant()) {
          this._beforeDisappear();
        }
      });
    },


    // overridden
    _afterDisappear : function()
    {
      this.base(arguments);

      this.forEachVisibleChild(function()
      {
        if (this.isAppearRelevant()) {
          this._afterDisappear();
        }
      });
    },


    // overridden
    _afterInsertDom : function() {
      this.base( arguments );
      // NOTE: a "visible" Child is actually every "displayable" child here
      this.forEachVisibleChild( function() {
        // Check if the nodes are actually connected - See Bug 359665
        if(    this.getElement()
            && this.getElement().parentNode === this.getParent()._getTargetNode() )
        {
          this._afterInsertDom();
        }
      } );
    },



    // overridden
    _afterRemoveDom : function() {
      this.base( arguments );
      this.forEachVisibleChild( function() {
        if( this.isInDom() ) {
          this._afterRemoveDom();
        }
      } );
    },



    /*
    ---------------------------------------------------------------------------
      DISPLAYBLE HANDLING
    ---------------------------------------------------------------------------
    */

    /**
     * TODOC
     *
     * @type member
     * @param vDisplayable {var} TODOC
     * @param vParent {var} TODOC
     * @param vHint {var} TODOC
     * @return {void}
     */
    _handleDisplayableCustom : function()
    {
      this.forEachChild(function() {
        this._handleDisplayable();
      });
    },




    /*
    ---------------------------------------------------------------------------
      STATE QUEUE
    ---------------------------------------------------------------------------
    */

    /**
     * TODOC
     *
     * @type member
     * @return {void}
     */
    _addChildrenToStateQueue : function()
    {
      this.forEachVisibleChild(function() {
        this.addToStateQueue();
      });
    },


    // overridden
    recursiveAddToStateQueue : function()
    {
      this.addToStateQueue();

      this.forEachVisibleChild(function() {
        this.recursiveAddToStateQueue();
      });
    },


    // overridden
    _recursiveAppearanceThemeUpdate : function(vNewAppearanceTheme, vOldAppearanceTheme)
    {
      this.base(arguments, vNewAppearanceTheme, vOldAppearanceTheme);

      this.forEachVisibleChild(function() {
        this._recursiveAppearanceThemeUpdate(vNewAppearanceTheme, vOldAppearanceTheme);
      });
    },




    /*
    ---------------------------------------------------------------------------
      CHILDREN QUEUE
    ---------------------------------------------------------------------------
    */

    /**
     * TODOC
     *
     * @type member
     * @param vChild {var} TODOC
     * @return {void}
     */
    _addChildToChildrenQueue : function(vChild)
    {
      if (!vChild._isInParentChildrenQueue && vChild._isDisplayable)
      {
        rwt.widgets.base.Widget.addToGlobalLayoutQueue(this);

        if (!this._childrenQueue) {
          this._childrenQueue = {};
        }

        this._childrenQueue[vChild.toHashCode()] = vChild;
      }
    },


    /**
     * TODOC
     *
     * @type member
     * @param vChild {var} TODOC
     * @return {void}
     */
    _removeChildFromChildrenQueue : function(vChild)
    {
      if (this._childrenQueue && vChild._isInParentChildrenQueue)
      {
        delete this._childrenQueue[vChild.toHashCode()];

        if (rwt.util.Objects.isEmpty(this._childrenQueue))
        {
          this._childrenQueue = {};
          rwt.widgets.base.Widget.removeFromGlobalLayoutQueue(this);
        }
      }
    },


    /**
     * TODOC
     *
     * @type member
     * @return {void}
     */
    _flushChildrenQueue : function()
    {
      if (!rwt.util.Objects.isEmpty(this._childrenQueue))
      {
        this.getLayoutImpl().flushChildrenQueue(this._childrenQueue);
        delete this._childrenQueue;
      }
    },




    /*
    ---------------------------------------------------------------------------
      LAYOUT QUEUE
    ---------------------------------------------------------------------------
    */

    /**
     * TODOC
     *
     * @type member
     * @param p {var} TODOC
     * @return {void}
     */
    _addChildrenToLayoutQueue : function(p)
    {
      this.forEachChild(function() {
        this.addToLayoutChanges(p);
      });
    },


    /**
     * TODOC
     *
     * @type member
     * @param vChild {var} TODOC
     * @return {void}
     */
    _layoutChild : function(vChild)
    {
      if (!vChild._isDisplayable)
      {
        // this.warn("Want to render an invisible child: " + vChild + " -> omitting!");
        return;
      }

      // APPLY LAYOUT
      var vChanges = vChild._layoutChanges;

      if (vChild.renderBorder && vChanges.border ) {
        vChild.renderBorder( vChanges );
      }

      if (vChild.renderPadding)
      {
        if (vChanges.paddingLeft || vChanges.paddingRight || vChanges.paddingTop || vChanges.paddingBottom) {
          vChild.renderPadding(vChanges);
        }
      }

      // WRAP TO LAYOUT ENGINE
      this.getLayoutImpl().layoutChild(vChild, vChanges);

      // POST LAYOUT
      vChild._layoutPost(vChanges);

      // DISPLAY DOM NODE
      // insert dom node (if initial flag enabled)
      if (vChanges.initial)
      {
        vChild._initialLayoutDone = true;
        rwt.widgets.base.Widget.addToGlobalDisplayQueue(vChild);
      }

      // CLEANUP
      vChild._layoutChanges = {};

      delete vChild._isInParentLayoutQueue;
      delete this._childrenQueue[vChild.toHashCode()];
    },

    _layoutPost : function( changes ) {
      this.createDispatchDataEvent( "flush", changes );
    },



    /*
    ---------------------------------------------------------------------------
      DIMENSION CACHE
    ---------------------------------------------------------------------------
    */

    /**
     * TODOC
     *
     * @type member
     * @return {var} TODOC
     */
    _computePreferredInnerWidth : function() {
      return this.getLayoutImpl().computeChildrenNeededWidth();
    },


    /**
     * TODOC
     *
     * @type member
     * @return {var} TODOC
     */
    _computePreferredInnerHeight : function() {
      return this.getLayoutImpl().computeChildrenNeededHeight();
    },


    /**
     * TODOC
     *
     * @type member
     * @param vNew {var} TODOC
     * @param vOld {var} TODOC
     * @return {void}
     */
    _changeInnerWidth : function()
    {
      var vLayout = this.getLayoutImpl();

      if (vLayout.invalidateChildrenFlexWidth) {
        vLayout.invalidateChildrenFlexWidth();
      }

      this.forEachVisibleChild(function()
      {
        if (vLayout.updateChildOnInnerWidthChange(this) && this._recomputeBoxWidth())
        {
          this._recomputeOuterWidth();
          this._recomputeInnerWidth();
        }
      });
    },


    /**
     * TODOC
     *
     * @type member
     * @param vNew {var} TODOC
     * @param vOld {var} TODOC
     * @return {void}
     */
    _changeInnerHeight : function()
    {
      var vLayout = this.getLayoutImpl();

      if (vLayout.invalidateChildrenFlexHeight) {
        vLayout.invalidateChildrenFlexHeight();
      }

      this.forEachVisibleChild(function()
      {
        if (vLayout.updateChildOnInnerHeightChange(this) && this._recomputeBoxHeight())
        {
          this._recomputeOuterHeight();
          this._recomputeInnerHeight();
        }
      });
    },


    /**
     * TODOC
     *
     * @type member
     * @param vChild {var} TODOC
     * @return {var} TODOC
     */
    getInnerWidthForChild : function() {
      return this.getInnerWidth();
    },


    /**
     * TODOC
     *
     * @type member
     * @param vChild {var} TODOC
     * @return {var} TODOC
     */
    getInnerHeightForChild : function() {
      return this.getInnerHeight();
    },






    /*
    ---------------------------------------------------------------------------
      REMAPPING
    ---------------------------------------------------------------------------
    */

    _remappingChildTable : [ "add", "remove", "addAt", "addAtBegin", "addAtEnd", "removeAt", "addBefore", "addAfter", "removeAll" ],

    _remapStart : "return this._remappingChildTarget.",
    _remapStop : ".apply(this._remappingChildTarget, arguments)",


    /**
     * TODOC
     *
     * @type member
     * @param vTarget {var} TODOC
     * @return {void}
     */
    remapChildrenHandlingTo : function(vTarget)
    {
      var t = this._remappingChildTable;

      this._remappingChildTarget = vTarget;

      for (var i=0, l=t.length, s; i<l; i++)
      {
        s = t[i];
        this[s] = new Function(rwt.widgets.base.Parent.prototype._remapStart + s + rwt.widgets.base.Parent.prototype._remapStop);
      }
    }
  },




  /*
  *****************************************************************************
     DESTRUCTOR
  *****************************************************************************
  */

  destruct : function()
  {
    this._disposeObjectDeep("_children", 1);
    this._disposeObjects("_layoutImpl", "_focusHandler");
    this._disposeFields("_childrenQueue", "_childrenQueue", "_remappingChildTable",
      "_remappingChildTarget", "_cachedVisibleChildren");
  }
});

/*******************************************************************************
 * Copyright (c) 2004, 2013 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

/**
 * This event handles all focus events.
 *
 *  The four supported types are:
 *  1+2: focus and blur also propagate the target object
 *  3+4: focusout and focusin are bubbling to the parent objects
 */
rwt.qx.Class.define("rwt.event.FocusEvent",
{
  extend : rwt.event.Event,

  construct : function(type, target)
  {
    this.base(arguments, type);

    this.setTarget(target);

    switch(type)
    {
      case "focusin":
      case "focusout":
        this.setBubbles(true);
        this.setPropagationStopped(false);
    }
  }
});

/*******************************************************************************
 * Copyright (c) 2004, 2014 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource, and others.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

namespace( "rwt.event" );


rwt.event.EventHandler = {

  _filter : {},
  _allowContextMenu : rwt.util.Functions.returnFalse,
  _captureWidget : null,
  _focusRoot : null,
  // state storage:
  _focused : false,
  _blockKeyEvents : false,

  ///////////////////
  // Public functions

  init : function() {
    var functionUtil = rwt.util.Functions;
    this.__onmouseevent = functionUtil.bind( this._onmouseevent, this );
    this.__ondragevent = functionUtil.bind( this._ondragevent, this );
    this.__onselectevent = functionUtil.bind( this._onselectevent, this );
    this.__onwindowblur = functionUtil.bind( this._onwindowblur, this );
    this.__onwindowfocus = functionUtil.bind( this._onwindowfocus, this );
    this.__onwindowresize = functionUtil.bind( this._onwindowresize, this );
    this.__onKeyEvent = rwt.util.Functions.bind( this._onKeyEvent, this );
    rwt.event.EventHandlerUtil.applyBrowserFixes();
  },

  cleanUp : function() {
    delete this.__onmouseevent;
    delete this.__ondragevent;
    delete this.__onselectevent;
    delete this.__onwindowblur;
    delete this.__onwindowfocus;
    delete this.__onwindowresize;
    delete this.__onKeyEvent;
    delete this._lastMouseDownDomTarget;
    delete this._lastMouseDownDispatchTarget;
    rwt.event.EventHandlerUtil.cleanUp();
  },

  attachEvents : function() {
    this.attachEventTypes( this._mouseEventTypes, this.__onmouseevent );
    this.attachEventTypes( this._dragEventTypes, this.__ondragevent );
    this.attachEventTypes( this._keyEventTypes, this.__onKeyEvent );
    window.addEventListener( "blur", this.__onwindowblur, false );
    window.addEventListener( "focus", this.__onwindowfocus, false  );
    window.addEventListener( "resize", this.__onwindowresize, false  );
    document.body.onselect = this.__onselectevent;
    document.onselectstart = this.__onselectevent;
    document.onselectionchange = this.__onselectevent;
  },

  detachEvents : function() {
    this.detachEventTypes( this._mouseEventTypes, this.__onmouseevent);
    this.detachEventTypes( this._dragEventTypes, this.__ondragevent);
    this.detachEventTypes( this._keyEventTypes, this.__onKeyEvent );
    window.removeEventListener( "blur", this.__onwindowblur, false );
    window.removeEventListener( "focus", this.__onwindowfocus, false );
    window.removeEventListener( "resize", this.__onwindowresize, false );
    document.body.onselect = null;
    document.onselectstart = null;
    document.onselectionchange = null;
  },

  setCaptureWidget : function( widget ) {
    if( this._captureWidget !== widget ) {
      if( this._captureWidget !== null ) {
        this._captureWidget.setCapture( false );
      }
      this._captureWidget = widget;
      if( widget != null ) {
        widget.setCapture( true );
      }
    }
  },

  getCaptureWidget : function() {
    return this._captureWidget && this._captureWidget.getEnabled() ? this._captureWidget : null;
  },

  setFocusRoot : function( widget ) {
    if( widget !== this._focusRoot ) {
      if( this._focusRoot !== null ) {
        this._focusRoot.setFocusedChild( null );
      }
      this._focusRoot = widget;
      if( widget !== null && widget.getFocusedChild() === null ) {
        widget.setFocusedChild( widget );
      }
    }
  },

  getFocusRoot : function() {
    return this._focusRoot;
  },

  /**
   * Sets a callback-function to decide if the native context-
   * menu is displayed. It will be called on DOM-events of the type
   * "contextmenu". The target-Widget of the event will be given as
   * the first argument, the dom-target as the second.
   * It must return a boolean. Null is not allowed.
   *
   */
  setAllowContextMenu : function( func ) {
    this._allowContextMenu = func;
  },

  setBlockKeyEvents : function( value ) {
    this._blockKeyEvents = value;
  },

  getBlockKeyEvents : function() {
    return this._blockKeyEvents;
  },

  getMenuManager : function() {
    return rwt.widgets.util.MenuManager.getInstance();
  },

  setMouseEventFilter : function( filter, context ) {
    if( filter ) {
      this._filter[ "mouseevent" ] = [ filter, context ];
    } else {
      delete this._filter[ "mouseevent" ];
    }
  },

  getMouseEventFilter : function() {
    return this._filter[ "mouseevent" ];
  },

  setMouseDomEventFilter : function( filter, context ) {
    this._filter[ "dommouseevent" ] = [ filter, context ];
  },

  setKeyEventFilter : function( filter, context ) {
    // TODO [tb] : Unify behavior and API for EventFilter, only use event
    // create API for order of filter
    this._filter[ "keyevent" ] = [ filter, context ];
  },

  setKeyDomEventFilter : function( filter, context ) {
    this._filter[ "domkeyevent" ] = [ filter, context ];
  },

  //////////////
  // KEY EVENTS:

  _onKeyEvent : function( event ) {
    try {
      var EventHandlerUtil = rwt.event.EventHandlerUtil;
      var keyCode = EventHandlerUtil.getKeyCode( event );
      var charCode = EventHandlerUtil.getCharCode( event );
      if( this._blockKeyEvents ) {
        if( EventHandlerUtil.shouldBlock( event.type, keyCode, charCode, event ) ) {
          EventHandlerUtil.stopDomEvent( event );
        }
        return;
      }
      if( typeof this._filter[ "domkeyevent" ] !== "undefined" ) {
        var context = this._filter[ "domkeyevent" ][ 1 ];
        var func = this._filter[ "domkeyevent" ][ 0 ];
        func.call( context, event.type, keyCode, charCode, event );
      }
      var pseudoTypes = EventHandlerUtil.getEventPseudoTypes( event, keyCode, charCode );
      var keyUpCodes =  EventHandlerUtil.mustRestoreKeyup( keyCode, pseudoTypes );
      for( var i = 0; i < keyUpCodes.length; i++ ) {
        this._onkeyevent_post( event, "keyup", keyUpCodes[ i ], 0 );
        EventHandlerUtil.clearStuckKey( keyUpCodes[ i ] );
      }
      for( var i = 0; i < pseudoTypes.length; i++ ) {
        this._onkeyevent_post( event, pseudoTypes[ i ], keyCode, charCode );
      }
      if( EventHandlerUtil.mustRestoreKeypress( event, pseudoTypes ) ) {
        this._onkeyevent_post( event, "keypress", keyCode, charCode );
      }
      EventHandlerUtil.saveData( event, keyCode, charCode );
    } catch( ex ) {
      rwt.runtime.ErrorHandler.processJavaScriptError( ex );
    }
  },

  _onkeyevent_post : function( vDomEvent, vType, vKeyCode, vCharCode ) {
    var process = true;
    if( typeof this._filter[ "keyevent" ] !== "undefined" ) {
      var context = this._filter[ "keyevent" ][ 1 ];
      var func = this._filter[ "keyevent" ][ 0 ];
      process = func.call( context, vType, vKeyCode, vCharCode, vDomEvent );
    }
    if( process ) {
      this._processKeyEvent( vDomEvent, vType, vKeyCode, vCharCode );
    }
  },

  _processKeyEvent : function( vDomEvent, vType, vKeyCode, vCharCode ) {
    var EventHandlerUtil = rwt.event.EventHandlerUtil;
    var keyIdentifier;
    if( !isNaN( vKeyCode ) && vKeyCode !== 0 ) {
      keyIdentifier = EventHandlerUtil.keyCodeToIdentifier( vKeyCode );
    } else {
      keyIdentifier = EventHandlerUtil.charCodeToIdentifier( vCharCode );
    }
    var vDomTarget = EventHandlerUtil.getDomTarget( vDomEvent );
    var vTarget = this._getKeyEventTarget();
    var vKeyEventObject = new rwt.event.KeyEvent( vType,
                                                      vDomEvent,
                                                      vDomTarget,
                                                      vTarget,
                                                      null,
                                                      vKeyCode,
                                                      vCharCode,
                                                      keyIdentifier );
    if( vTarget != null && vTarget.getEnabled() ) {
      switch( keyIdentifier ) {
        case "Escape":
        case "Tab":
          this.getMenuManager().update(vTarget, vType);
        break;
      }
      if( vDomEvent.ctrlKey && keyIdentifier == "A" ) {
        switch( vDomTarget.tagName.toLowerCase() ) {
          case "input":
          case "textarea":
          case "iframe":
            // selection allowed
          break;
          default:
           EventHandlerUtil.stopDomEvent(vDomEvent);
          break;
        }
      }
      vTarget.dispatchEvent( vKeyEventObject );
      if( rwt.qx.Class.isDefined("rwt.event.DragAndDropHandler") ) {
        rwt.event.DragAndDropHandler.getInstance().handleKeyEvent( vKeyEventObject );
      }
      rwt.widgets.util.ToolTipManager.getInstance().handleKeyEvent( vKeyEventObject );
    }
    vKeyEventObject.dispose();
  },

  ///////////////
  // MOUSE EVENTS

  _onmouseevent : function( event ) {
    try {
      var process = true;
      if( typeof this._filter[ "dommouseevent" ] !== "undefined" ) {
        var context = this._filter[ "dommouseevent" ][ 1 ];
        process = this._filter[ "dommouseevent" ][ 0 ].call( context, event );
      }
      if( process ) {
        this._processMouseEvent( event );
      }
    } catch( ex ) {
      rwt.runtime.ErrorHandler.processJavaScriptError( ex );
    }
  },

  // TODO [tb] : refactor to work like _onKeyEvent
  _processMouseEvent : function( vDomEvent ) {
    var EventHandlerUtil = rwt.event.EventHandlerUtil;
    var vDomTarget = EventHandlerUtil.getDomTarget( vDomEvent );
    var vType = vDomEvent.type;
    switch(vType) {
      case "DOMMouseScroll":
        vType = "mousewheel";
      break;
      case "click":
      case "dblclick":
        // ignore click or dblclick events with other then the left mouse button
        if( vDomEvent.which !== 1 ) {
          return;
        }
    }
    this._onmouseevent_post( vDomEvent, vType, vDomTarget );
  },

  _onmouseevent_post : function( vDomEvent, vType, vDomTarget ) {
    var eventConsumed = false;
    var EventHandlerUtil = rwt.event.EventHandlerUtil;
    var vCaptureTarget = this.getCaptureWidget();
    var vOriginalTarget = EventHandlerUtil.getOriginalTargetObject( vDomTarget );
    var vTarget = EventHandlerUtil.getTargetObject( null, vOriginalTarget, true );
    if( !vTarget ) {
      return;
    }
    var vDispatchTarget = vCaptureTarget ? vCaptureTarget : vTarget;
    var vFixClick = this._onmouseevent_click_fix( vDomTarget, vType, vDispatchTarget );
    if( vType == "contextmenu" ) {
      if( this._allowContextMenu( vOriginalTarget, vDomTarget ) ) {
        eventConsumed = true;
      } else {
        EventHandlerUtil.stopDomEvent( vDomEvent );
      }
    }
    if( vType == "mousedown" ) {
      EventHandlerUtil.handleFocusedChild( vDispatchTarget );
    }
    // handle related target object
    if( vType == "mouseover" || vType == "mouseout" ) {
      var vRelatedTarget = EventHandlerUtil.getRelatedTargetObjectFromEvent( vDomEvent );
      var elementEventType = vType == "mouseover" ? "elementOver" : "elementOut";
      this._fireElementHoverEvents( elementEventType,
                                    vDomEvent,
                                    vDomTarget,
                                    vTarget,
                                    vOriginalTarget,
                                    vRelatedTarget,
                                    vDispatchTarget );
      // Ignore events where the related target and
      // the real target are equal - from our sight
      if( vRelatedTarget == vTarget ) {
        return;
      }
    }
    var vEventObject = new rwt.event.MouseEvent( vType,
                                                     vDomEvent,
                                                     vDomTarget,
                                                     vTarget,
                                                     vOriginalTarget,
                                                     vRelatedTarget );
    // Store last Event in MouseEvent Constructor. Needed for Tooltips, ...
    if( vType !== "contextmenu" ) {
      rwt.event.MouseEvent.storeEventState( vEventObject );
    }
    if( !eventConsumed ) {
      this._dispatchMouseEvent( vDispatchTarget, vEventObject );
      if( vDispatchTarget.getEnabled() ) {
        this._onmouseevent_special_post( vType,
                                         vTarget,
                                         vOriginalTarget,
                                         vDispatchTarget,
                                         vEventObject,
                                         vDomEvent );
      }
    } else if( vType == "mouseover" ) {
      var toolTipManager = rwt.widgets.util.ToolTipManager.getInstance();
      toolTipManager.handleMouseEvent( vEventObject );
    }
    vEventObject.dispose();
    rwt.widgets.base.Widget.flushGlobalQueues();
    // Fix Click (Gecko Bug, see above)
    if( vFixClick ) {
      this._onmouseevent_post( vDomEvent, "click", this._lastMouseDownDomTarget );
      this._lastMouseDownDomTarget = null;
      this._lastMouseDownDispatchTarget = null;
    }
  },

  _fireElementHoverEvents : function( type,
                                      domEvent,
                                      domTarget,
                                      target,
                                      originalTarget,
                                      relatedTarget,
                                      dispatchTarget )
  {
    if( dispatchTarget.getEnabled() ) {
      var eventObject = new rwt.event.MouseEvent( type,
                                                  domEvent,
                                                  domTarget,
                                                  target,
                                                  originalTarget,
                                                  relatedTarget );
      this._dispatchMouseEvent( dispatchTarget, eventObject );
    }
  },

  _dispatchMouseEvent : function( target, event ) {
    var process = true;
    if( typeof this._filter[ "mouseevent" ] !== "undefined" ) {
      var context = this._filter[ "mouseevent" ][ 1 ];
      process = this._filter[ "mouseevent" ][ 0 ].call( context, event );
    }
    if( process ) {
      target.dispatchEvent( event );
    }
  },

  _onmouseevent_special_post : function( vType,
                                         vTarget,
                                         vOriginalTarget,
                                         vDispatchTarget,
                                         vEventObject )
  {
    switch( vType ) {
      case "mousedown":
        rwt.widgets.util.PopupManager.getInstance().update( vTarget );
        this.getMenuManager().update( vTarget, vType );
        rwt.widgets.util.IframeManager.getInstance().handleMouseDown( vEventObject );
      break;
      case "mouseup":
        // Mouseup event should always hide, independed of target,
        //  so don't send a target
        this.getMenuManager().update( vTarget, vType );
        if( rwt.qx.Class.isDefined("rwt.widgets.util.IframeManager" ) ) {
          rwt.widgets.util.IframeManager.getInstance().handleMouseUp( vEventObject );
        }
      break;
    }
    rwt.widgets.util.ToolTipManager.getInstance().handleMouseEvent( vEventObject );
    this._ignoreWindowBlur = vType === "mousedown";
    if( rwt.qx.Class.isDefined( "rwt.event.DragAndDropHandler" ) && vTarget ) {
      rwt.event.DragAndDropHandler.getInstance().handleMouseEvent( vEventObject );
    }
  },

  _ondragevent : function( event ) {
    try {
      if( !event ) {
        event = window.event;
      }
      if( event.type === "dragstart" || event.type === "dragover" || event.type === "drop" ) {
        rwt.event.EventHandlerUtil.stopDomEvent( event );
      }
      if( ( event.type === "dragover" || event.type === "dragenter" ) && event.dataTransfer ) {
        event.dataTransfer.dropEffect = "none";  // has no effect in IE
      }
    } catch( ex ) {
      rwt.runtime.ErrorHandler.processJavaScriptError( ex );
    }
  },

  ////////////////
  // SELECT EVENTS

  _onselectevent : function( event ) {
    try {
      var EventHandlerUtil = rwt.event.EventHandlerUtil;
      var target = EventHandlerUtil.getOriginalTargetObjectFromEvent( event );
      while( target ) {
        if( target.getSelectable() != null ) {
          if( !target.getSelectable() ) {
            EventHandlerUtil.stopDomEvent( event );
          }
          break;
        }
        target = target.getParent();
      }
    } catch( ex ) {
      rwt.runtime.ErrorHandler.processJavaScriptError( ex );
    }
  },

  _onwindowblur : function( e ) {
    try {
      if( !this._focused || this._ignoreWindowBlur || e.originalTarget != window ) {
        return;
      }
      this._focused = false;
      this.setCaptureWidget( null );
      if( rwt.qx.Class.isDefined( "rwt.widgets.util.PopupManager" ) ) {
        rwt.widgets.util.PopupManager.getInstance().update();
      }
      this.getMenuManager().update();
      if( rwt.qx.Class.isDefined( "rwt.event.DragAndDropHandler" ) ) {
        rwt.event.DragAndDropHandler.getInstance().globalCancelDrag();
      }
      rwt.widgets.base.ClientDocument.getInstance().createDispatchEvent( "windowblur" );
    } catch( ex ) {
      rwt.runtime.ErrorHandler.processJavaScriptError( ex );
    }
  },

  _onwindowfocus : function() {
    try {
      if( this._focused ) {
        return;
      }
      this._focused = true;
      rwt.widgets.base.ClientDocument.getInstance().createDispatchEvent( "windowfocus" );
    } catch( ex ) {
      rwt.runtime.ErrorHandler.processJavaScriptError( ex );
    }
  },

  _onwindowresize : function() {
    try {
      var clientDocument = rwt.widgets.base.ClientDocument.getInstance();
      // Catch redundant resize events, fired for example by iPad:
      var oldWidth = clientDocument.getInnerWidth();
      var oldHeight = clientDocument.getInnerHeight();
      var width = clientDocument._computeInnerWidth();
      var height = clientDocument._computeInnerHeight();
      if( width !== oldWidth || height !== oldHeight ) {
        rwt.widgets.base.ClientDocument.getInstance().createDispatchEvent( "windowresize" );
      }
    } catch( ex ) {
      rwt.runtime.ErrorHandler.processJavaScriptError( ex );
    }
  },

  ///////////////
  // Helper-maps:

  _mouseEventTypes : [
    "mouseover",
    "mousemove",
    "mouseout",
    "mousedown",
    "mouseup",
    "click",
    "dblclick",
    "contextmenu",
    rwt.client.Client.isGecko() ? "DOMMouseScroll" : "mousewheel"
  ],

  _keyEventTypes : [ "keydown", "keypress", "keyup" ],

  _dragEventTypes : [ "dragstart", "drop", "dragover", "dragleave", "dragenter" ],

  ////////////////////
  // Helper-functions:

  _getKeyEventTarget : function() {
    var vFocusRoot = this.getFocusRoot();
    return this.getCaptureWidget() || ( vFocusRoot == null ? null : vFocusRoot.getActiveChild() );
  },

  attachEventTypes : function( vEventTypes, vFunctionPointer ) {
    try {
      // Gecko is a bit buggy to handle key events on document if
      // not previously focused. Internet Explorer has problems to use
      // 'window', so there we use the 'body' element
      var el = rwt.client.Client.isGecko() ? window : document.body;
      for( var i=0, l=vEventTypes.length; i<l; i++ ) {
        el.addEventListener( vEventTypes[ i ], vFunctionPointer, false );
      }
    }
    catch( ex ) {
      throw new Error( "EventHandler: Failed to attach window event types: " + vEventTypes + ": " + ex );
    }
  },

  detachEventTypes : function( vEventTypes, vFunctionPointer ) {
    try {
      var el = rwt.client.Client.isGecko() ? window : document.body;
      for(var i=0, l=vEventTypes.length; i<l; i++) {
        el.removeEventListener( vEventTypes[ i ], vFunctionPointer, false );
      }
    } catch( ex ) {
      throw new Error( "EventHandler: Failed to detach window event types: " + vEventTypes + ": " + ex );
    }
  },

  /**
   * Fixes browser quirks with 'click' detection
   *
   * Firefox: The DOM-targets are different. The click event only fires,
   * if the target of the mousedown is the same than with the mouseup.
   * If the content moved away, the click isn't fired.
   */
  _onmouseevent_click_fix : rwt.util.Variant.select( "qx.client", {
    "gecko" : function( vDomTarget, vType, vDispatchTarget ) {
      var vReturn = false;
      switch( vType ) {
        case "mousedown":
          this._lastMouseDownDomTarget = vDomTarget;
          this._lastMouseDownDispatchTarget = vDispatchTarget;
        break;
        case "mouseup":
          if(    this._lastMouseDownDispatchTarget === vDispatchTarget
              && vDomTarget !== this._lastMouseDownDomTarget) {
            vReturn = true;
          } else {
            this._lastMouseDownDomTarget = null;
            this._lastMouseDownDispatchTarget = null;
          }
        break;
      }
      return vReturn;
    },

    "default" : function() {
      return false;
    }
  } )

};

/*******************************************************************************
 * Copyright (c) 2004, 2014 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

/**
 * Basic node creation and type detection
 */
rwt.qx.Class.define("rwt.html.Nodes",
{
  /*
  *****************************************************************************
     STATICS
  *****************************************************************************
  */

  statics :
  {
    /*
    ---------------------------------------------------------------------------
      NODE TYPES
    ---------------------------------------------------------------------------
    */

    /**
     * {Map} Node type:
     *
     * * ELEMENT
     * * ATTRIBUTE
     * * TEXT
     * * CDATA_SECTION
     * * ENTITY_REFERENCE
     * * ENTITY
     * * PROCESSING_INSTRUCTION
     * * COMMENT
     * * DOCUMENT
     * * DOCUMENT_TYPE
     * * DOCUMENT_FRAGMENT
     * * NOTATION
     */
    ELEMENT                : 1,
    ATTRIBUTE              : 2,
    TEXT                   : 3,
    CDATA_SECTION          : 4,
    ENTITY_REFERENCE       : 5,
    ENTITY                 : 6,
    PROCESSING_INSTRUCTION : 7,
    COMMENT                : 8,
    DOCUMENT               : 9,
    DOCUMENT_TYPE          : 10,
    DOCUMENT_FRAGMENT      : 11,
    NOTATION               : 12,



    /**
     * Whether the given node is a DOM document node
     *
     * @type static
     * @param node {Node} the node which should be tested
     * @return {Boolean} true when the node is a document
     */
    isDocument : function(node) {
      return !!(node && node.nodeType === rwt.html.Nodes.DOCUMENT);
    },


    /*
    ---------------------------------------------------------------------------
      DOCUMENT ACCESS
    ---------------------------------------------------------------------------
    */

    /**
     * Returns the owner document of the given node
     *
     * @type static
     * @param node {Node} the node which should be tested
     * @return {Document | null} The document of the given DOM node
     */
    getDocument : function(node)
    {
      if (this.isDocument(node)) {
        return node;
      }

      return node.ownerDocument || node.document || null;
    },


    /**
     * Returns the DOM2 <code>defaultView</code> (window).
     *
     * @type static
     * @signature function(node)
     * @param node {Node} node to inspect
     * @return {Window} the <code>defaultView</code> of the given node
     */
    getWindow : function( node ) {
      return this.getDocument(node).defaultView;
    }

  }
});

/*******************************************************************************
 * Copyright (c) 2004, 2014 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

rwt.qx.Class.define( "rwt.event.DomEvent", {

  extend : rwt.event.Event,

  construct : function( vType, vDomEvent, vDomTarget, vTarget, vOriginalTarget ) {
    this.base( arguments, vType );

    this.setDomEvent( vDomEvent );
    this.setDomTarget( vDomTarget );

    this.setTarget( vTarget );
    this.setOriginalTarget( vOriginalTarget );
  },

  statics : {

    /** {int} The modifier mask for the shift key. */
    SHIFT_MASK : 1,

    /** {int} The modifier mask for the control key. */
    CTRL_MASK  : 2,

    /** {int} The modifier mask for the alt key. */
    ALT_MASK   : 4,

    /** {int} The modifier mask for the meta key (e.g. apple key on Macs). */
    META_MASK  : 8

  },

  properties : {

    bubbles : {
      _fast        : true,
      defaultValue : true,
      noCompute    : true
    },

    propagationStopped : {
      _fast        : true,
      defaultValue : false,
      noCompute    : true
    },

    domEvent : {
      _fast       : true,
      setOnlyOnce : true,
      noCompute   : true
    },

    domTarget : {
      _fast       : true,
      setOnlyOnce : true,
      noCompute   : true
    },

    /**
     * The modifiers. A mask of the pressed modifier keys. This is an OR-combination of
     * {@link #SHIFT_MASK}, {@link #CTRL_MASK}, {@link #ALT_MASK} and {@link #META_MASK}.
     */
    modifiers : {
      _cached      : true,
      defaultValue : null
    }

  },

  members : {

    setDomEvent : function( domEvent ) {
      this.base( arguments, domEvent );
      rwt.remote.EventUtil._shiftKey = domEvent.shiftKey;
      rwt.remote.EventUtil._ctrlKey = domEvent.ctrlKey;
      rwt.remote.EventUtil._altKey = domEvent.altKey;
      rwt.remote.EventUtil._metaKey = domEvent.metaKey;
      rwt.remote.EventUtil._button = rwt.event.MouseEvent.C_BUTTON_NONE;
    },

    /**
     * property computer
     *
     * @type member
     * @return {var} TODOC
     */
    _computeModifiers : function() {
      var mask = 0;
      var evt = this.getDomEvent();
      if( evt.shiftKey ) {
        mask |= rwt.event.DomEvent.SHIFT_MASK;
      }
      if( evt.ctrlKey ) {
        mask |= rwt.event.DomEvent.CTRL_MASK;
      }
      if( evt.altKey ) {
        mask |= rwt.event.DomEvent.ALT_MASK;
      }
      if( evt.metaKey ) {
        mask |= rwt.event.DomEvent.META_MASK;
      }
      return mask;
    },

    /**
     * Returns whether the the ctrl key is pressed.
     *
     * @type member
     * @return {Boolean} whether the the ctrl key is pressed.
     */
    isCtrlPressed : function() {
      return this.getDomEvent().ctrlKey;
    },

    /**
     * Returns whether the the shift key is pressed.
     *
     * @type member
     * @return {Boolean} whether the the shift key is pressed.
     */
    isShiftPressed : function() {
      return this.getDomEvent().shiftKey;
    },

    /**
     * Returns whether the the alt key is pressed.
     *
     * @type member
     * @return {Boolean} whether the the alt key is pressed.
     */
    isAltPressed : function() {
      return this.getDomEvent().altKey;
    },

    /**
     * Returns whether the the meta key is pressed.
     *
     * @type member
     * @return {Boolean} whether the the meta key is pressed.
     */
    isMetaPressed : function() {
      return this.getDomEvent().metaKey;
    },

    /**
     * TODOC
     *
     * @type member
     * @param vValue {var} TODOC
     * @return {var} TODOC
     * @signature function(vValue)
     */
    setDefaultPrevented : function( vValue ) {
      if( !vValue ) {
        throw new Error( "It is not possible to set preventDefault to false if it was true before!" );
      }
      rwt.event.EventHandlerUtil.stopDomEvent( this.getDomEvent() );
      this.base( arguments, vValue );
    }

  },

  destruct : function() {
    this._disposeFields( "_valueDomEvent", "_valueDomTarget" );
  }

} );

/*******************************************************************************
 * Copyright (c) 2004, 2013 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

/**
 * A key event instance contains all data for each occured key event
 */
rwt.qx.Class.define("rwt.event.KeyEvent",
{
  extend : rwt.event.DomEvent,

  /**
   * @param vType {String} event type (keydown, keypress, keyup)
   * @param vDomEvent {Element} DOM event object
   * @param vDomTarget {Element} target element of the DOM event
   * @param vTarget
   * @param vOriginalTarget
   * @param vKeyCode {Integer} emulated key code for compatibility with older qoodoo applications
   * @param vCharCode {Integer} char code from the "keypress" event
   * @param vKeyIdentifier {String} the key identifier
   */
  construct : function(vType, vDomEvent, vDomTarget, vTarget, vOriginalTarget, vKeyCode, vCharCode, vKeyIdentifier)
  {
    this.base(arguments, vType, vDomEvent, vDomTarget, vTarget, vOriginalTarget);

    this._keyCode = vKeyCode;
    this.setCharCode(vCharCode);
    this.setKeyIdentifier(vKeyIdentifier);
  },




  /*
  *****************************************************************************
     STATICS
  *****************************************************************************
  */

  statics :
  {
    /**
     * Mapping of the old key identifiers to the key codes
     * @deprecated
     */
    keys :
    {
      esc             : 27,
      enter           : 13,
      tab             : 9,
      space           : 32,
      up              : 38,
      down            : 40,
      left            : 37,
      right           : 39,
      shift           : 16,
      ctrl            : 17,
      alt             : 18,
      f1              : 112,
      f2              : 113,
      f3              : 114,
      f4              : 115,
      f5              : 116,
      f6              : 117,
      f7              : 118,
      f8              : 119,
      f9              : 120,
      f10             : 121,
      f11             : 122,
      f12             : 123,
      print           : 124,
      del             : 46,
      backspace       : 8,
      insert          : 45,
      home            : 36,
      end             : 35,
      pageup          : 33,
      pagedown        : 34,
      numlock         : 144,
      numpad_0        : 96,
      numpad_1        : 97,
      numpad_2        : 98,
      numpad_3        : 99,
      numpad_4        : 100,
      numpad_5        : 101,
      numpad_6        : 102,
      numpad_7        : 103,
      numpad_8        : 104,
      numpad_9        : 105,
      numpad_divide   : 111,
      numpad_multiply : 106,
      numpad_minus    : 109,
      numpad_plus     : 107
    },

    /**
     * Mapping of the key codes to the key identifiers
     */
    codes : {}
  },




  /*
  *****************************************************************************
     PROPERTIES
  *****************************************************************************
  */

  properties :
  {

    /**
     * Unicode number of the pressed character.
     */
    charCode :
    {
      _fast       : true,
      setOnlyOnce : true,
      noCompute   : true
    },


    /**
     * Identifier of the pressed key. This property is modeled after the <em>KeyboardEvent.keyIdentifier</em> property
     * of the W3C DOM 3 event specification (http://www.w3.org/TR/2003/NOTE-DOM-Level-3-Events-20031107/events.html#Events-KeyboardEvent-keyIdentifier).
     *
     * Printable keys are represented by a unicode string, non-printable keys have one of the following
     * values:
     * <br>
     * <table>
     * <tr><th>Backspace</th><td>The Backspace (Back) key.</td></tr>
     * <tr><th>Tab</th><td>The Horizontal Tabulation (Tab) key.</td></tr>
     * <tr><th>Space</th><td>The Space (Spacebar) key.</td></tr>
     * <tr><th>Enter</th><td>The Enter key. Note: This key identifier is also used for the Return (Macintosh numpad) key.</td></tr>
     * <tr><th>Shift</th><td>The Shift key.</td></tr>
     * <tr><th>Control</th><td>The Control (Ctrl) key.</td></tr>
     * <tr><th>Alt</th><td>The Alt (Menu) key.</td></tr>
     * <tr><th>CapsLock</th><td>The CapsLock key</td></tr>
     * <tr><th>Meta</th><td>The Meta key. (Apple Meta and Windows key)</td></tr>
     * <tr><th>Escape</th><td>The Escape (Esc) key.</td></tr>
     * <tr><th>Left</th><td>The Left Arrow key.</td></tr>
     * <tr><th>Up</th><td>The Up Arrow key.</td></tr>
     * <tr><th>Right</th><td>The Right Arrow key.</td></tr>
     * <tr><th>Down</th><td>The Down Arrow key.</td></tr>
     * <tr><th>PageUp</th><td>The Page Up key.</td></tr>
     * <tr><th>PageDown</th><td>The Page Down (Next) key.</td></tr>
     * <tr><th>End</th><td>The End key.</td></tr>
     * <tr><th>Home</th><td>The Home key.</td></tr>
     * <tr><th>Insert</th><td>The Insert (Ins) key. (Does not fire in Opera/Win)</td></tr>
     * <tr><th>Delete</th><td>The Delete (Del) Key.</td></tr>
     * <tr><th>F1</th><td>The F1 key.</td></tr>
     * <tr><th>F2</th><td>The F2 key.</td></tr>
     * <tr><th>F3</th><td>The F3 key.</td></tr>
     * <tr><th>F4</th><td>The F4 key.</td></tr>
     * <tr><th>F5</th><td>The F5 key.</td></tr>
     * <tr><th>F6</th><td>The F6 key.</td></tr>
     * <tr><th>F7</th><td>The F7 key.</td></tr>
     * <tr><th>F8</th><td>The F8 key.</td></tr>
     * <tr><th>F9</th><td>The F9 key.</td></tr>
     * <tr><th>F10</th><td>The F10 key.</td></tr>
     * <tr><th>F11</th><td>The F11 key.</td></tr>
     * <tr><th>F12</th><td>The F12 key.</td></tr>
     * <tr><th>NumLock</th><td>The Num Lock key.</td></tr>
     * <tr><th>PrintScreen</th><td>The Print Screen (PrintScrn, SnapShot) key.</td></tr>
     * <tr><th>Scroll</th><td>The scroll lock key</td></tr>
     * <tr><th>Pause</th><td>The pause/break key</td></tr>
     * <tr><th>Win</th><td>The Windows Logo key</td></tr>
     * <tr><th>Apps</th><td>The Application key (Windows Context Menu)</td></tr>
     * </table>
     */
    keyIdentifier :
    {
      _fast       : true,
      setOnlyOnce : true,
      noCompute   : true
    }
  },




  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {
    /**
     * Legacy keycode
     * @deprecated Will be removed with qooxdoo 0.7
     */
    getKeyCode : function() {
      return this._keyCode;
    }
  },



  /*
  *****************************************************************************
     DEFER
  *****************************************************************************
  */

  defer : function(statics)
  {
    // create dynamic codes copy
    for (var i in statics.keys) {
      statics.codes[statics.keys[i]] = i;
    }
  }
});

/*******************************************************************************
 *  Copyright: 2004, 2014 1&1 Internet AG, Germany, http://www.1und1.de,
 *                        and EclipseSource
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v1.0 which accompanies this
 * distribution, and is available at http://www.eclipse.org/legal/epl-v10.html
 *
 *  Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/


/** A mouse event instance contains all data for each occured mouse event */
rwt.qx.Class.define("rwt.event.MouseEvent",
{
  extend : rwt.event.DomEvent,




  /*
  *****************************************************************************
     CONSTRUCTOR
  *****************************************************************************
  */

  construct : function(vType, vDomEvent, vDomTarget, vTarget, vOriginalTarget, vRelatedTarget)
  {
    this.base(arguments, vType, vDomEvent, vDomTarget, vTarget, vOriginalTarget);

    if (vRelatedTarget) {
      this.setRelatedTarget(vRelatedTarget);
    }
    this._storeButton( vType );
  },




  /*
  *****************************************************************************
     STATICS
  *****************************************************************************
  */

  statics :
  {
    C_BUTTON_LEFT : "left",
    C_BUTTON_MIDDLE : "middle",
    C_BUTTON_RIGHT : "right",
    C_BUTTON_NONE : "none",

    _screenX : 0,
    _screenY : 0,
    _clientX : 0,
    _clientY : 0,
    _pageX : 0,
    _pageY : 0,
    _button : null,

    buttons : {
      left   : 0,
      right  : 2,
      middle : 1
    },

    /**
     * TODOC
     *
     * @type static
     * @param e {Event} TODOC
     * @return {void}
     */
    storeEventState : function(e)
    {
      this._screenX = e.getScreenX();
      this._screenY = e.getScreenY();
      this._clientX = e.getClientX();
      this._clientY = e.getClientY();
      this._pageX = e.getPageX();
      this._pageY = e.getPageY();
      this._button = e.getButton();
    },


    /**
     * TODOC
     *
     * @type static
     * @return {var} TODOC
     */
    getScreenX : function() {
      return this._screenX;
    },


    /**
     * TODOC
     *
     * @type static
     * @return {var} TODOC
     */
    getScreenY : function() {
      return this._screenY;
    },


    /**
     * TODOC
     *
     * @type static
     * @return {var} TODOC
     */
    getClientX : function() {
      return this._clientX;
    },


    /**
     * TODOC
     *
     * @type static
     * @return {var} TODOC
     */
    getClientY : function() {
      return this._clientY;
    },


    /**
     * TODOC
     *
     * @type static
     * @return {var} TODOC
     */
    getPageX : function() {
      return this._pageX;
    },


    /**
     * TODOC
     *
     * @type static
     * @return {var} TODOC
     */
    getPageY : function() {
      return this._pageY;
    },


    /**
     * TODOC
     *
     * @type static
     * @return {var} TODOC
     */
    getButton : function() {
      return this._button;
    }
  },




  /*
  *****************************************************************************
     PROPERTIES
  *****************************************************************************
  */

  properties :
  {
    button :
    {
      _fast    : true,
      readOnly : true
    },

    wheelDelta :
    {
      _fast    : true,
      readOnly : true
    }
  },




  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {
    /*
    ---------------------------------------------------------------------------
      PAGE COORDINATES SUPPORT
    ---------------------------------------------------------------------------
    */

    getPageX : function() {
      return Math.round( this.getDomEvent().pageX );
    },

    getPageY : function() {
      return Math.round( this.getDomEvent().pageY );
    },

    /*
    ---------------------------------------------------------------------------
      CLIENT COORDINATES SUPPORT
    ---------------------------------------------------------------------------
    */

    getClientX : function() {
      return this.getDomEvent().clientX;
    },

    getClientY : function() {
      return this.getDomEvent().clientY;
    },



    /*
    ---------------------------------------------------------------------------
      SCREEN COORDINATES SUPPORT
    ---------------------------------------------------------------------------
    */

    /**
     * TODOC
     *
     * @type member
     * @return {var} TODOC
     */
    getScreenX : function() {
      return this.getDomEvent().screenX;
    },


    /**
     * TODOC
     *
     * @type member
     * @return {var} TODOC
     */
    getScreenY : function() {
      return this.getDomEvent().screenY;
    },




    /*
    ---------------------------------------------------------------------------
      BUTTON SUPPORT
    ---------------------------------------------------------------------------
    */

    isLeftButtonPressed : function() {
      return this.getButton() === rwt.event.MouseEvent.C_BUTTON_LEFT;
    },

    isMiddleButtonPressed : function() {
      return this.getButton() === rwt.event.MouseEvent.C_BUTTON_MIDDLE;
    },

    isRightButtonPressed : function() {
      return this.getButton() === rwt.event.MouseEvent.C_BUTTON_RIGHT;
    },

    __buttons : {
      0 : "left",
      2 : "right",
      1 : "middle"
    },

    /**
     * During mouse events caused by the depression or release of a mouse button,
     * this method can be used to check which mouse button changed state.
     *
     * @type member
     * @return {String} One of "left", "right", "middle" or "none"
     */
    _computeButton : function()
    {
      switch(this.getDomEvent().type)
      {
        case "click":
        case "dblclick":
          return "left";

        case "contextmenu":
          return "right";

        default:
          return this.__buttons[this.getDomEvent().button] || "none";
      }
    },

    _storeButton : function( eventType ) {
      switch( eventType ) {
        case "mousedown":
        case "mouseup":
        case "click":
        case "dblclick":
        case "contextmenu":
          rwt.remote.EventUtil._button = this.getButton();
          break;
        default:
          rwt.remote.EventUtil._button = rwt.event.MouseEvent.C_BUTTON_NONE;
      }
    },

    /*
    ---------------------------------------------------------------------------
      WHEEL SUPPORT
    ---------------------------------------------------------------------------
    */

    /**
     * TODOC
     *
     * @type member
     * @return {var} TODOC
     * @signature function()
     */
    _computeWheelDelta : rwt.util.Variant.select("qx.client",
    {
      "default" : function() {
        return this.getDomEvent().wheelDelta / 120;
      },

      "gecko" : function() {
        return -(this.getDomEvent().detail / 3);
      }
    })
  }
});

/*******************************************************************************
 * Copyright (c) 2004, 2014 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

/** This class allows basic managment of assigned objects. */
rwt.qx.Class.define("rwt.util.ObjectManager",
{
  extend : rwt.qx.Target,




  /*
  *****************************************************************************
     CONSTRUCTOR
  *****************************************************************************
  */

  construct : function()
  {
    this.base(arguments);

    this._objects = {};
  },




  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {
    /*
    ---------------------------------------------------------------------------
      USER API
    ---------------------------------------------------------------------------
    */

    /**
     * TODOC
     *
     * @type member
     * @param vObject {var} TODOC
     * @return {void | Boolean} TODOC
     */
    add : function(vObject)
    {
      if (this.getDisposed()) {
        return;
      }

      this._objects[vObject.toHashCode()] = vObject;
    },


    /**
     * TODOC
     *
     * @type member
     * @param vObject {var} TODOC
     * @return {void | Boolean} TODOC
     */
    remove : function(vObject)
    {
      if (this.getDisposed()) {
        return false;
      }

      delete this._objects[vObject.toHashCode()];
    },


    /**
     * TODOC
     *
     * @type member
     * @param vObject {var} TODOC
     * @return {var} TODOC
     */
    has : function(vObject) {
      return this._objects[vObject.toHashCode()] != null;
    },


    /**
     * TODOC
     *
     * @type member
     * @param vObject {var} TODOC
     * @return {var} TODOC
     */
    get : function(vObject) {
      return this._objects[vObject.toHashCode()];
    },


    /**
     * TODOC
     *
     * @type member
     * @return {var} TODOC
     */
    getAll : function() {
      return this._objects;
    }

  },




  /*
  *****************************************************************************
     DESTRUCTOR
  *****************************************************************************
  */

  destruct : function() {
    this._disposeObjectDeep("_objects");
  }
});

/*******************************************************************************
 * Copyright (c) 2004, 2014 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

/**
 * This singleton manages multiple instances of rwt.widgets.base.Iframe.
 * <p>
 * The problem: When dragging over an iframe then all mouse events will be
 * passed to the document of the iframe, not the main document.
 * <p>
 * The solution: In order to be able to track mouse events over iframes, this
 * manager will block all iframes during a drag with a glasspane.
 */
rwt.qx.Class.define( "rwt.widgets.util.IframeManager", {

  extend : rwt.util.ObjectManager,

  statics : {

    getInstance : function() {
      return rwt.runtime.Singletons.get( rwt.widgets.util.IframeManager );
    }

  },

  /*
  *****************************************************************************
     CONSTRUCTOR
  *****************************************************************************
  */

  construct : function() {
    this.base(arguments);

    this._blocked = {};
  },




  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {
    /*
    ---------------------------------------------------------------------------
      METHODS
    ---------------------------------------------------------------------------
    */

    /**
     * TODOC
     *
     * @type member
     * @param evt {Event} TODOC
     * @return {void}
     */
    handleMouseDown : function()
    {
      var iframeMap = this._blockData = rwt.util.Objects.copy(this.getAll());
      for (var key in iframeMap) {
        iframeMap[key].block();
      }
    },


    /**
     * TODOC
     *
     * @type member
     * @param evt {Event} TODOC
     * @return {void}
     */
    handleMouseUp : function()
    {
      var iframeMap = this._blockData;
      for (var key in iframeMap) {
        iframeMap[key].release();
      }
    }
  },


  /*
    ---------------------------------------------------------------------------
      DESTRUCTOR
    ---------------------------------------------------------------------------
  */
  destruct : function()
  {
    this._disposeFields("_blocked", "_blockData");
  }
});

/*******************************************************************************
 * Copyright (c) 2011, 2012 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.qx.Class.define( "rwt.widgets.CoolBar", {
  extend : rwt.widgets.base.Parent,

  construct : function() {
    this.base( arguments );
    this._locked = false;
  },

  members : {

    setLocked : function( value ) {
      this._locked = value;
      var children = this.getChildren();
      var CoolItem = rwt.widgets.CoolItem;
      for( var i = 0; i < children.length; i++ ) {
        if( children[ i ] instanceof CoolItem ) {
          children[ i ].setLocked( value );
        }
      }
    },

    getLocked : function() {
      return this._locked;
    }

  }

} );

/*******************************************************************************
 * Copyright (c) 2011, 2012 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.remote.HandlerRegistry.add( "rwt.widgets.CoolBar", {

  factory : function( properties ) {
    var result = new rwt.widgets.CoolBar();
    rwt.remote.HandlerUtil.addStatesForStyles( result, properties.style );
    result.setUserData( "isControl", true );
    rwt.remote.HandlerUtil.setParent( result, properties.parent );
    result.setOverflow( "hidden" );
    result.setAppearance( "coolbar" );
    return result;
  },

  destructor : rwt.remote.HandlerUtil.getControlDestructor(),

  getDestroyableChildren : rwt.remote.HandlerUtil.getDestroyableChildrenFinder(),

  properties : rwt.remote.HandlerUtil.extendControlProperties( [ "locked"] ),

  propertyHandler : rwt.remote.HandlerUtil.extendControlPropertyHandler( {} ),

  listeners : rwt.remote.HandlerUtil.extendControlListeners( [] ),

  listenerHandler : rwt.remote.HandlerUtil.extendControlListenerHandler( {} )

} );

/*******************************************************************************
 * Copyright (c) 2004, 2014 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

/**
 * Abstact base class of all layout implementations
 *
 * @param vWidget {rwt.widgets.base.Parent} reference to the associated widget
 */
rwt.qx.Class.define("rwt.widgets.util.LayoutImpl",
{
  extend : rwt.qx.Object,




  /*
  *****************************************************************************
     CONSTRUCTOR
  *****************************************************************************
  */

  construct : function(vWidget)
  {
    this.base(arguments);

    this._widget = vWidget;
  },




  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {
    /**
     * Returns the associated widget
     *
     * @type member
     * @return {rwt.widgets.base.Parent} reference to the associated widget
     */
    getWidget : function() {
      return this._widget;
    },

    /*
      Global Structure:
      [01] COMPUTE BOX DIMENSIONS FOR AN INDIVIDUAL CHILD
      [02] COMPUTE NEEDED DIMENSIONS FOR AN INDIVIDUAL CHILD
      [03] COMPUTE NEEDED DIMENSIONS FOR ALL CHILDREN
      [04] UPDATE LAYOUT WHEN A CHILD CHANGES ITS OUTER DIMENSIONS
      [05] UPDATE CHILD ON INNER DIMENSION CHANGES OF LAYOUT
      [06] UPDATE LAYOUT ON JOB QUEUE FLUSH
      [07] UPDATE CHILDREN ON JOB QUEUE FLUSH
      [08] CHILDREN ADD/REMOVE/MOVE HANDLING
      [09] FLUSH LAYOUT QUEUES OF CHILDREN
      [10] LAYOUT CHILD
    */

    /*
    ---------------------------------------------------------------------------
      [01] COMPUTE BOX DIMENSIONS FOR AN INDIVIDUAL CHILD
    ---------------------------------------------------------------------------
    */

    /**
     * Compute and return the box width of the given child
     *
     * @type member
     * @param vChild {rwt.widgets.base.Widget} TODOC
     * @return {Integer} box width of the given child
     */
    computeChildBoxWidth : function(vChild) {
      return vChild.getWidthValue() || vChild._computeBoxWidthFallback();
    },


    /**
     * Compute and return the box height of the given child
     *
     * @type member
     * @param vChild {rwt.widgets.base.Widget} TODOC
     * @return {Integer} box height of the given child
     */
    computeChildBoxHeight : function(vChild) {
      return vChild.getHeightValue() || vChild._computeBoxHeightFallback();
    },




    /*
    ---------------------------------------------------------------------------
      [02] COMPUTE NEEDED DIMENSIONS FOR AN INDIVIDUAL CHILD
    ---------------------------------------------------------------------------
    */

    /**
     * Compute and return the needed width of the given child
     *
     * @type member
     * @param vChild {rwt.widgets.base.Widget} TODOC
     * @return {Integer} needed width
     */
    computeChildNeededWidth : function(vChild)
    {
      // omit ultra long lines, these two variables only needed once
      // here, but this enhance the readability of the code :)
      var vMinBox = vChild._computedMinWidthTypePercent ? null : vChild.getMinWidthValue();
      var vMaxBox = vChild._computedMaxWidthTypePercent ? null : vChild.getMaxWidthValue();

      var vBox = (vChild._computedWidthTypePercent || vChild._computedWidthTypeFlex ? null : vChild.getWidthValue()) || vChild.getPreferredBoxWidth() || 0;

      return rwt.util.Numbers.limit(vBox, vMinBox, vMaxBox) + vChild.getMarginLeft() + vChild.getMarginRight();
    },


    /**
     * Compute and return the needed height of the given child
     *
     * @type member
     * @param vChild {rwt.widgets.base.Widget} TODOC
     * @return {Integer} needed height
     */
    computeChildNeededHeight : function(vChild)
    {
      // omit ultra long lines, these two variables only needed once
      // here, but this enhance the readability of the code :)
      var vMinBox = vChild._computedMinHeightTypePercent ? null : vChild.getMinHeightValue();
      var vMaxBox = vChild._computedMaxHeightTypePercent ? null : vChild.getMaxHeightValue();

      var vBox = (vChild._computedHeightTypePercent || vChild._computedHeightTypeFlex ? null : vChild.getHeightValue()) || vChild.getPreferredBoxHeight() || 0;

      return rwt.util.Numbers.limit(vBox, vMinBox, vMaxBox) + vChild.getMarginTop() + vChild.getMarginBottom();
    },




    /*
    ---------------------------------------------------------------------------
      [03] COMPUTE NEEDED DIMENSIONS FOR ALL CHILDREN
    ---------------------------------------------------------------------------
    */

    /**
     * Calculate the maximum needed width of all children
     *
     * @type member
     * @return {Integer} maximum needed width of all children
     */
    computeChildrenNeededWidth_max : function()
    {
      for (var i=0, ch=this.getWidget().getVisibleChildren(), chl=ch.length, maxv=0; i<chl; i++) {
        maxv = Math.max(maxv, ch[i].getNeededWidth());
      }

      return maxv;
    },


    /**
     * Calculate the maximum needed height of all children
     *
     * @type member
     * @return {Integer} maximum needed height of all children
     */
    computeChildrenNeededHeight_max : function()
    {
      for (var i=0, ch=this.getWidget().getVisibleChildren(), chl=ch.length, maxv=0; i<chl; i++) {
        maxv = Math.max(maxv, ch[i].getNeededHeight());
      }

      return maxv;
    },


    /**
     * Compute and return the width needed by all children of this widget
     *
     * @type member
     * @return {Integer} TODOC
     */
    computeChildrenNeededWidth_sum : function()
    {
      for (var i=0, ch=this.getWidget().getVisibleChildren(), chl=ch.length, sumv=0; i<chl; i++) {
        sumv += ch[i].getNeededWidth();
      }

      return sumv;
    },


    /**
     * Compute and return the height needed by all children of this widget
     *
     * @type member
     * @return {Integer} height needed by all children of this widget
     */
    computeChildrenNeededHeight_sum : function()
    {
      for (var i=0, ch=this.getWidget().getVisibleChildren(), chl=ch.length, sumv=0; i<chl; i++) {
        sumv += ch[i].getNeededHeight();
      }

      return sumv;
    },


    /**
     * Compute and return the width needed by all children of this widget
     *
     * @return {Integer} width needed by all children of this widget
     */
    computeChildrenNeededWidth : null,  // alias set in defer


    /**
     * Compute and return the height needed by all children of this widget
     *
     * @return {Integer} height needed by all children of this widget
     */
    computeChildrenNeededHeight : null,  // alias set in defer




    /*
    ---------------------------------------------------------------------------
      [04] UPDATE LAYOUT WHEN A CHILD CHANGES ITS OUTER DIMENSIONS
    ---------------------------------------------------------------------------
    */

    /**
     * Things to do and layout when any of the childs changes its outer width.
     * Needed by layouts where the children depend on each other, like flow or box layouts.
     *
     * Subclasses might implement this method
     *
     * @type member
     * @param vChild {rwt.widgets.base.Widget} changed child widget
     * @return {void}
     */
    updateSelfOnChildOuterWidthChange : function() {},


    /**
     * Things to do and layout when any of the childs changes its outer height.
     * Needed by layouts where the children depend on each other, like flow or box layouts.
     *
     * Subclasses might implement this method
     *
     * @type member
     * @param vChild {rwt.widgets.base.Widget} changed child widget
     * @return {void}
     */
    updateSelfOnChildOuterHeightChange : function() {},




    /*
    ---------------------------------------------------------------------------
      [05] UPDATE CHILD ON INNER DIMENSION CHANGES OF LAYOUT
    ---------------------------------------------------------------------------
    */

    /**
     * Actions that should be done if the inner width of the layout widget has changed.
     * Normally this includes updates to percent values and ranges.
     *
     * Subclasses might implement this method
     *
     * @type member
     * @param vChild {rwt.widgets.base.Widget} changed child widget
     * @return {boolean}
     */
    updateChildOnInnerWidthChange : function() {},


    /**
     * Actions that should be done if the inner height of the layout widget has changed.
     * Normally this includes updates to percent values and ranges.
     *
     * Subclasses might implement this method
     *
     * @type member
     * @param vChild {rwt.widgets.base.Widget} changed child widget
     * @return {void}
     */
    updateChildOnInnerHeightChange : function() {},




    /*
    ---------------------------------------------------------------------------
      [06] UPDATE LAYOUT ON JOB QUEUE FLUSH
    ---------------------------------------------------------------------------
    */

    /**
     * Invalidate and recompute cached data according to job queue.
     * This is executed at the beginning of the job queue handling.
     *
     * Subclasses might implement this method
     *
     * @type member
     * @param vJobQueue {Object} TODOC
     * @return {void}
     */
    updateSelfOnJobQueueFlush : function() {},




    /*
    ---------------------------------------------------------------------------
      [07] UPDATE CHILDREN ON JOB QUEUE FLUSH
    ---------------------------------------------------------------------------
    */

    /**
     * Updates children on job queue flush.
     * This is executed at the end of the job queue handling.
     *
     * Subclasses might implement this method
     *
     * @type member
     * @param vJobQueue {Object} TODOC
     * @return {boolean}
     */
    updateChildrenOnJobQueueFlush : function() {},




    /*
    ---------------------------------------------------------------------------
      [08] CHILDREN ADD/REMOVE/MOVE HANDLING
    ---------------------------------------------------------------------------
    */

    /**
     * Add child to current layout. Rarely needed by some layout implementations.
     *
     * Subclasses might implement this method
     *
     * @type member
     * @param vChild {rwt.widgets.base.Widget} newly added child
     * @param vIndex {Integer} index of the child
     * @return {void}
     */
    updateChildrenOnAddChild : function() {},


    /**
     * Remove child from current layout.
     *  Needed by layouts where the children depend on each other, like flow or box layouts.
     *
     *  Subclasses might implement this method
     *
     * @type member
     * @param vChild {rwt.widgets.base.Widget} newly added child
     * @param vIndex {Integer} index of the child
     * @return {void}
     */
    updateChildrenOnRemoveChild : function() {},


    /**
     * Move child within its parent to a new position.
     *  Needed by layouts where the children depend on each other, like flow or box layouts.
     *
     * Subclasses might implement this method
     *
     * @type member
     * @param vChild {rwt.widgets.base.Widget} newly added child
     * @param vIndex {Integer} new index of the child
     * @param vOldIndex {Integer} old index of the child
     * @return {void}
     */
    updateChildrenOnMoveChild : function() {},




    /*
    ---------------------------------------------------------------------------
      [09] FLUSH LAYOUT QUEUES OF CHILDREN
    ---------------------------------------------------------------------------
    */

    /**
     * Has full control of the order in which the registered
     * (or non-registered) children should be layouted.
     *
     * @type member
     * @param vChildrenQueue {Object} TODOC
     * @return {void}
     */
    flushChildrenQueue : function(vChildrenQueue)
    {
      var vWidget = this.getWidget();

      for (var vHashCode in vChildrenQueue) {
        vWidget._layoutChild(vChildrenQueue[vHashCode]);
      }
    },




    /*
    ---------------------------------------------------------------------------
      [10] LAYOUT CHILD
    ---------------------------------------------------------------------------
    */

    /**
     * Called from rwt.widgets.base.Parent. Its task is to apply the layout
     * (excluding border and padding) to the child.
     *
     * @type member
     * @param vChild {rwt.widgets.base.Widget} child to layout
     * @param vJobs {Set} layout changes to perform
     * @return {void}
     */
    layoutChild : function() {},


    /**
     * Apply min-/max-width to the child. Direct usage of stylesheet properties.
     * This is only possible in modern capable clients (i.e. excluding all current
     *  versions of Internet Explorer)
     *
     * @type member
     * @param vChild {rwt.widgets.base.Widget} child to layout
     * @param vJobs {Set} layout changes to perform
     * @return {void}
     * @signature function(vChild, vJobs)
     */
    layoutChild_sizeLimitX : function( vChild, vJobs ) {
      if( vJobs.minWidth ) {
        if( vChild._computedMinWidthTypeNull ) {
          vChild._resetRuntimeMinWidth();
        } else {
          vChild._renderRuntimeMinWidth( vChild.getMinWidthValue() );
        }
      } else if( vJobs.initial && !vChild._computedMinWidthTypeNull ) {
        vChild._renderRuntimeMinWidth( vChild.getMinWidthValue() );
      }
      if( vJobs.maxWidth ) {
        if( vChild._computedMaxWidthTypeNull ) {
          vChild._resetRuntimeMaxWidth();
        } else {
          vChild._renderRuntimeMaxWidth( vChild.getMaxWidthValue() );
        }
      } else if( vJobs.initial && !vChild._computedMaxWidthTypeNull ) {
        vChild._renderRuntimeMaxWidth( vChild.getMaxWidthValue() );
      }
    },


    /**
     * Apply min-/max-height to the child. Direct usage of stylesheet properties.
     * This is only possible in modern capable clients (i.e. excluding all current
     *  versions of Internet Explorer)
     *
     * @type member
     * @param vChild {rwt.widgets.base.Widget} child to layout
     * @param vJobs {Set} layout changes to perform
     * @return {void}
     * @signature function(vChild, vJobs)
     */
    layoutChild_sizeLimitY : function( vChild, vJobs ) {
      if( vJobs.minHeight ) {
        if( vChild._computedMinHeightTypeNull ) {
          vChild._resetRuntimeMinHeight();
        } else {
          vChild._renderRuntimeMinHeight( vChild.getMinHeightValue() );
        }
      } else if( vJobs.initial && !vChild._computedMinHeightTypeNull ) {
        vChild._renderRuntimeMinHeight( vChild.getMinHeightValue() );
      }
      if( vJobs.maxHeight ) {
        if( vChild._computedMaxHeightTypeNull ) {
          vChild._resetRuntimeMaxHeight();
        } else {
          vChild._renderRuntimeMaxHeight( vChild.getMaxHeightValue() );
        }
      } else if( vJobs.initial && !vChild._computedMaxHeightTypeNull ) {
        vChild._renderRuntimeMaxHeight( vChild.getMaxHeightValue() );
      }
    },

    /**
     * Apply the X margin values as pure stylesheet equivalent.
     *
     * @type member
     * @param vChild {rwt.widgets.base.Widget} child to layout
     * @param vJobs {Set} layout changes to perform
     * @return {void}
     */
    layoutChild_marginX : function( vChild, vJobs ) {
      if( vJobs.marginLeft || vJobs.initial ) {
        var vValueLeft = vChild.getMarginLeft();
        if( vValueLeft != null ) {
          vChild._renderRuntimeMarginLeft( vValueLeft );
        } else {
          vChild._resetRuntimeMarginLeft();
        }
      }
      if( vJobs.marginRight || vJobs.initial ) {
        var vValueRight = vChild.getMarginRight();
        if( vValueRight != null ) {
          vChild._renderRuntimeMarginRight( vValueRight );
        } else {
          vChild._resetRuntimeMarginRight();
        }
      }
    },


    /**
     * Apply the Y margin values as pure stylesheet equivalent.
     *
     * @type member
     * @param vChild {rwt.widgets.base.Widget} child to layout
     * @param vJobs {Set} layout changes to perform
     * @return {void}
     */
    layoutChild_marginY : function( vChild, vJobs ) {
      if( vJobs.marginTop || vJobs.initial ) {
        var vValueTop = vChild.getMarginTop();
        if( vValueTop != null ) {
          vChild._renderRuntimeMarginTop( vValueTop );
        } else {
          vChild._resetRuntimeMarginTop();
        }
      }
      if( vJobs.marginBottom || vJobs.initial ) {
        var vValueBottom = vChild.getMarginBottom();
        if( vValueBottom != null ) {
          vChild._renderRuntimeMarginBottom( vValueBottom );
        } else {
          vChild._resetRuntimeMarginBottom();
        }
      }
    },


    /**
     * TODOC
     *
     * @type member
     * @param vChild {var} TODOC
     * @param vJobs {var} TODOC
     * @return {var} TODOC
     */
    layoutChild_sizeX_essentialWrapper : function(vChild, vJobs) {
      return vChild._isWidthEssential() ? this.layoutChild_sizeX(vChild, vJobs) : vChild._resetRuntimeWidth();
    },


    /**
     * TODOC
     *
     * @type member
     * @param vChild {var} TODOC
     * @param vJobs {var} TODOC
     * @return {var} TODOC
     */
    layoutChild_sizeY_essentialWrapper : function(vChild, vJobs) {
      return vChild._isHeightEssential() ? this.layoutChild_sizeY(vChild, vJobs) : vChild._resetRuntimeHeight();
    }
  },




  /*
  *****************************************************************************
     DEFER
  *****************************************************************************
  */

  defer : function(statics, members)
  {
    members.computeChildrenNeededWidth = members.computeChildrenNeededWidth_max;
    members.computeChildrenNeededHeight = members.computeChildrenNeededHeight_max;
  },




  /*
  *****************************************************************************
     DESTRUCTOR
  *****************************************************************************
  */

  destruct : function() {
    this._disposeFields("_widget");
  }
});

/*******************************************************************************
 * Copyright: 2004, 2015 1&1 Internet AG, Germany, http://www.1und1.de,
 *                       and EclipseSource
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v1.0 which accompanies this
 * distribution, and is available at http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

rwt.qx.Class.define("rwt.widgets.util.CanvasLayoutImpl",
{
  extend : rwt.widgets.util.LayoutImpl,




  /*
  *****************************************************************************
     CONSTRUCTOR
  *****************************************************************************
  */

  construct : function(vWidget) {
    this.base(arguments, vWidget);
  },




  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {
    /*
    ---------------------------------------------------------------------------
      [01] COMPUTE BOX DIMENSIONS FOR AN INDIVIDUAL CHILD
    ---------------------------------------------------------------------------
    */

    /** Compute and return the box width of the given child */
    /**
     * Global Structure:
     *  [01] COMPUTE BOX DIMENSIONS FOR AN INDIVIDUAL CHILD
     *  [02] COMPUTE NEEDED DIMENSIONS FOR AN INDIVIDUAL CHILD
     *  [03] COMPUTE NEEDED DIMENSIONS FOR ALL CHILDREN
     *  [04] UPDATE LAYOUT WHEN A CHILD CHANGES ITS OUTER DIMENSIONS
     *  [05] UPDATE CHILD ON INNER DIMENSION CHANGES OF LAYOUT
     *  [06] UPDATE LAYOUT ON JOB QUEUE FLUSH
     *  [07] UPDATE CHILDREN ON JOB QUEUE FLUSH
     *  [08] CHILDREN ADD/REMOVE/MOVE HANDLING
     *  [09] FLUSH LAYOUT QUEUES OF CHILDREN
     *  [10] LAYOUT CHILD
     *
     *  Inherits from rwt.widgets.util.LayoutImpl:
     *  [03] COMPUTE NEEDED DIMENSIONS FOR ALL CHILDREN
     *  [04] UPDATE LAYOUT WHEN A CHILD CHANGES ITS OUTER DIMENSIONS
     *  [06] UPDATE LAYOUT ON JOB QUEUE FLUSH
     *  [07] UPDATE CHILDREN ON JOB QUEUE FLUSH
     *  [08] CHILDREN ADD/REMOVE/MOVE HANDLING
     *  [09] FLUSH LAYOUT QUEUES OF CHILDREN
     *
     * @type member
     * @param vChild {var} TODOC
     * @return {var} TODOC
     */
    computeChildBoxWidth : function(vChild)
    {
      var vValue = null;

      if (vChild._computedLeftTypeNull || vChild._computedRightTypeNull) {
        vValue = vChild.getWidthValue();
      } else if (vChild._hasParent) {
        vValue = this.getWidget().getInnerWidth() - vChild.getLeftValue() - vChild.getRightValue();
      }

      return vValue !== null ? vValue : vChild._computeBoxWidthFallback();
    },


    /**
     * Compute and return the box height of the given child
     *
     * @type member
     * @param vChild {var} TODOC
     * @return {var} TODOC
     */
    computeChildBoxHeight : function(vChild)
    {
      var vValue = null;

      if (vChild._computedTopTypeNull || vChild._computedBottomTypeNull) {
        vValue = vChild.getHeightValue();
      } else if (vChild._hasParent) {
        vValue = this.getWidget().getInnerHeight() - vChild.getTopValue() - vChild.getBottomValue();
      }

      return vValue !== null ? vValue : vChild._computeBoxWidthFallback();
    },




    /*
    ---------------------------------------------------------------------------
      [02] COMPUTE NEEDED DIMENSIONS FOR AN INDIVIDUAL CHILD
    ---------------------------------------------------------------------------
    */

    /**
     * Compute and return the needed width of the given child
     *
     * @type member
     * @param vChild {var} TODOC
     * @return {var} TODOC
     */
    computeChildNeededWidth : function(vChild)
    {
      var vLeft = vChild._computedLeftTypePercent ? null : vChild.getLeftValue();
      var vRight = vChild._computedRightTypePercent ? null : vChild.getRightValue();
      var vMinBox = vChild._computedMinWidthTypePercent ? null : vChild.getMinWidthValue();
      var vMaxBox = vChild._computedMaxWidthTypePercent ? null : vChild.getMaxWidthValue();

      if (vLeft != null && vRight != null) {
        var vBox = vChild.getPreferredBoxWidth() || 0;
      } else {
        var vBox = (vChild._computedWidthTypePercent ? null : vChild.getWidthValue()) || vChild.getPreferredBoxWidth() || 0;
      }

      return rwt.util.Numbers.limit(vBox, vMinBox, vMaxBox) + vLeft + vRight + vChild.getMarginLeft() + vChild.getMarginRight();
    },


    /**
     * Compute and return the needed height of the given child
     *
     * @type member
     * @param vChild {var} TODOC
     * @return {var} TODOC
     */
    computeChildNeededHeight : function(vChild)
    {
      var vTop = vChild._computedTopTypePercent ? null : vChild.getTopValue();
      var vBottom = vChild._computedBottomTypePercent ? null : vChild.getBottomValue();
      var vMinBox = vChild._computedMinHeightTypePercent ? null : vChild.getMinHeightValue();
      var vMaxBox = vChild._computedMaxHeightTypePercent ? null : vChild.getMaxHeightValue();

      if (vTop != null && vBottom != null) {
        var vBox = vChild.getPreferredBoxHeight() || 0;
      } else {
        var vBox = (vChild._computedHeightTypePercent ? null : vChild.getHeightValue()) || vChild.getPreferredBoxHeight() || 0;
      }

      return rwt.util.Numbers.limit(vBox, vMinBox, vMaxBox) + vTop + vBottom + vChild.getMarginTop() + vChild.getMarginBottom();
    },




    /*
    ---------------------------------------------------------------------------
      [05] UPDATE CHILD ON INNER DIMENSION CHANGES OF LAYOUT
    ---------------------------------------------------------------------------
    */

    /**
     * Actions that should be done if the inner width of the widget was changed.
     *  Normally this includes update to percent values and ranges.
     *
     * @type member
     * @param vChild {var} TODOC
     * @return {var} TODOC
     */
    updateChildOnInnerWidthChange : function(vChild)
    {
      // this makes sure that both functions get executed before return
      var vUpdatePercent = vChild._recomputePercentX();
      var vUpdateRange = vChild._recomputeRangeX();

      return vUpdatePercent || vUpdateRange;
    },


    /**
     * Actions that should be done if the inner height of the widget was changed.
     *  Normally this includes update to percent values and ranges.
     *
     * @type member
     * @param vChild {var} TODOC
     * @return {var} TODOC
     */
    updateChildOnInnerHeightChange : function(vChild)
    {
      // this makes sure that both functions get executed before return
      var vUpdatePercent = vChild._recomputePercentY();
      var vUpdateRange = vChild._recomputeRangeY();

      return vUpdatePercent || vUpdateRange;
    },




    /*
    ---------------------------------------------------------------------------
      [10] LAYOUT CHILD
    ---------------------------------------------------------------------------
    */

    /**
     * This is called from rwt.widgets.base.Widget and  it's task is to apply the layout
     *  (excluding border and padding) to the child.
     *
     * @type member
     * @param vChild {var} TODOC
     * @param vJobs {var} TODOC
     * @return {void}
     */
    layoutChild : function(vChild, vJobs)
    {
      this.layoutChild_sizeX_essentialWrapper(vChild, vJobs);
      this.layoutChild_sizeY_essentialWrapper(vChild, vJobs);

      this.layoutChild_sizeLimitX(vChild, vJobs);
      this.layoutChild_sizeLimitY(vChild, vJobs);

      this.layoutChild_locationX(vChild, vJobs);
      this.layoutChild_locationY(vChild, vJobs);

      this.layoutChild_marginX(vChild, vJobs);
      this.layoutChild_marginY(vChild, vJobs);
    },


    /**
     * TODOC
     *
     * @type member
     * @param vChild {var} TODOC
     * @param vJobs {var} TODOC
     * @return {void}
     * @signature function(vChild, vJobs)
     */
    layoutChild_sizeX : rwt.util.Variant.select("qx.client",
    {
      "trident|webkit|blink" : function(vChild, vJobs)
      {
        if (vJobs.initial || vJobs.width || vJobs.minWidth || vJobs.maxWidth || vJobs.left || vJobs.right)
        {
          if (vChild._computedMinWidthTypeNull && vChild._computedWidthTypeNull && vChild._computedMaxWidthTypeNull && !(!vChild._computedLeftTypeNull && !vChild._computedRightTypeNull)) {
            vChild._resetRuntimeWidth();
          } else {
            vChild._renderRuntimeWidth(vChild.getBoxWidth());
          }
        }
      },

      "default" : function( vChild, vJobs ) {
        if( vJobs.initial || vJobs.width ) {
          if( vChild._computedWidthTypeNull ) {
            vChild._resetRuntimeWidth();
          } else  {
            vChild._renderRuntimeWidth( vChild.getWidthValue() );
          }
        }
      }
    }),


    /**
     * TODOC
     *
     * @type member
     * @param vChild {var} TODOC
     * @param vJobs {var} TODOC
     * @return {void}
     * @signature function(vChild, vJobs)
     */
    layoutChild_sizeY : rwt.util.Variant.select("qx.client",
    {
      "trident|webkit|blink" : function(vChild, vJobs)
      {
        if (vJobs.initial || vJobs.height || vJobs.minHeight || vJobs.maxHeight || vJobs.top || vJobs.bottom)
        {
          if (vChild._computedMinHeightTypeNull && vChild._computedHeightTypeNull && vChild._computedMaxHeightTypeNull && !(!vChild._computedTopTypeNull && !vChild._computedBottomTypeNull)) {
            vChild._resetRuntimeHeight();
          } else {
            vChild._renderRuntimeHeight(vChild.getBoxHeight());
          }
        }
      },

      "default" : function( vChild, vJobs ) {
        if( vJobs.initial || vJobs.height ) {
          if( vChild._computedHeightTypeNull ) {
            vChild._resetRuntimeHeight();
          } else  {
            vChild._renderRuntimeHeight( vChild.getHeightValue() );
          }
        }
      }
    }),


    /**
     * TODOC
     *
     * @type member
     * @param vChild {var} TODOC
     * @param vJobs {var} TODOC
     * @return {void}
     */
    layoutChild_locationX : function( vChild, vJobs ) {
      var vWidget = this.getWidget();
      if( vJobs.initial || vJobs.left || vJobs.parentPaddingLeft ) {
        if( vChild._computedLeftTypeNull ) {
          if( vChild._computedRightTypeNull && vWidget.getPaddingLeft() > 0 ) {
            vChild._renderRuntimeLeft( vWidget.getPaddingLeft() );
          } else {
            vChild._resetRuntimeLeft();
          }
        } else {
          vChild._renderRuntimeLeft( vChild.getLeftValue() + vWidget.getPaddingLeft() );
        }
      }
      if( vJobs.initial || vJobs.right || vJobs.parentPaddingRight ) {
        if( vChild._computedRightTypeNull ) {
          if( vChild._computedLeftTypeNull && vWidget.getPaddingRight() > 0 ) {
            vChild._renderRuntimeRight( vWidget.getPaddingRight() );
          } else {
            vChild._resetRuntimeRight();
          }
        } else {
          vChild._renderRuntimeRight( vChild.getRightValue() + vWidget.getPaddingRight() );
        }
      }
    },


    /**
     * TODOC
     *
     * @type member
     * @param vChild {var} TODOC
     * @param vJobs {var} TODOC
     * @return {void}
     */
    layoutChild_locationY : function( vChild, vJobs ) {
      var vWidget = this.getWidget();
      if( vJobs.initial || vJobs.top || vJobs.parentPaddingTop ) {
        if( vChild._computedTopTypeNull ) {
          if( vChild._computedBottomTypeNull && vWidget.getPaddingTop() > 0 ) {
            vChild._renderRuntimeTop( vWidget.getPaddingTop() );
          } else {
            vChild._resetRuntimeTop();
          }
        } else {
          vChild._renderRuntimeTop( vChild.getTopValue() + vWidget.getPaddingTop() );
        }
      }
      if( vJobs.initial || vJobs.bottom || vJobs.parentPaddingBottom ) {
        if( vChild._computedBottomTypeNull ) {
          if( vChild._computedTopTypeNull && vWidget.getPaddingBottom() > 0 ) {
            vChild._renderRuntimeBottom( vWidget.getPaddingBottom() );
          } else {
            vChild._resetRuntimeBottom();
          }
        } else {
          vChild._renderRuntimeBottom( vChild.getBottomValue() + vWidget.getPaddingBottom() );
        }
      }
    }

  }
} );

/*******************************************************************************
 * Copyright (c) 2004, 2014 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource, and others.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/


/**
 * This is the basic widget of all qooxdoo applications.
 *
 * rwt.widgets.base.ClientDocument is the parent of all children inside your application. It
 * also handles their resizing and focus navigation.
 *
 * @appearance client-document
 */
rwt.qx.Class.define( "rwt.widgets.base.ClientDocument", {

  extend : rwt.widgets.base.Parent,

  statics : {

    getInstance : function() {
      return rwt.runtime.Singletons.get( rwt.widgets.base.ClientDocument );
    }

  },

  construct : function() {
    this.base( arguments );
    this._window = window;
    this._document = window.document;
    // init element
    this.setElement( this._document.body );
    this.getElement().setAttribute( "spellcheck", "false" );
    // reset absolute position
    this._document.body.style.position = "";
    // cache current size
    this._cachedInnerWidth = this._document.body.offsetWidth;
    this._cachedInnerHeight = this._document.body.offsetHeight;
    // add resize handler
    this.addEventListener( "windowresize", this._onwindowresize );
    // dialog support
    this._modalWidgets = [];
    // enable as focus root behavior
    this.activateFocusRoot();
    // initialize properties
    this.initSelectable();
    // register as current focus root
    rwt.event.EventHandler.setFocusRoot( this );
    // Gecko-specific settings
    if( rwt.client.Client.isGecko() ) {
      // Fix for bug 193703:
      this.getElement().style.position = "absolute";
      this.setSelectable( true );
    }
    this._document.documentElement.onscroll = this._resetScrollPosition;
    this.getElement().onscroll = this._resetScrollPosition;
  },

  properties : {

    appearance : {
      refine : true,
      init : "client-document"
    },

    enableElementFocus : {
      refine : true,
      init : false
    },

    enabled : {
      refine : true,
      init : true
    },

    selectable : {
      refine : true,
      init : false
    },

    hideFocus : {
      refine : true,
      init : true
    },

    /**
     * Sets the global cursor style
     *
     * The name of the cursor to show when the mouse pointer is over the widget.
     * This is any valid CSS2 cursor name defined by W3C.
     *
     * The following values are possible:
     * - default
     * - crosshair
     * - pointer (hand is the ie name and will mapped to pointer in non-ie)
     * - move
     * - n-resize
     * - ne-resize
     * - e-resize
     * - se-resize
     * - s-resize
     * - sw-resize
     * - w-resize
     * - nw-resize
     * - text
     * - wait
     * - help
     * - url([file]) = self defined cursor, file should be an ANI- or CUR-type
     */
    globalCursor : {
      check : "String",
      nullable : true,
      themeable : true,
      apply : "_applyGlobalCursor",
      event : "changeGlobalCursor"
    }
  },

  members : {

    // ------------------------------------------------------------------------
    // OVERWRITE WIDGET FUNCTIONS/PROPERTIES
    // ------------------------------------------------------------------------

    _applyParent : rwt.util.Functions.returnTrue,

    getTopLevelWidget : function() {
      return this;
    },

    getWindowElement : function() {
      return this._window;
    },

    getDocumentElement : function() {
      return this._document;
    },

    getParent : rwt.util.Functions.returnNull,

    getToolTip : rwt.util.Functions.returnNull,

    isSeeable : rwt.util.Functions.returnTrue,

    _isDisplayable : true,

    _hasParent : false,

    _initialLayoutDone : true,

    _isInDom : true,

    // ------------------------------------------------------------------------
    // BLOCKER AND DIALOG SUPPORT
    // ------------------------------------------------------------------------

    /**
     * Returns the blocker widget if already created; otherwise create it first
     *
     * @return {ClientDocumentBlocker} the blocker widget.
     */
    _getBlocker : function() {
      if( !this._blocker ) {
        // Create blocker instance
        this._blocker = new rwt.widgets.base.ClientDocumentBlocker();
        // Add blocker to client document
        this.add( this._blocker );
      }
      return this._blocker;
    },

    block : function( vActiveChild ) {
      this._getBlocker().show();
      if( rwt.qx.Class.isDefined( "rwt.widgets.base.Window" )
          && vActiveChild instanceof rwt.widgets.base.Window )
      {
        this._modalWidgets.push( vActiveChild );
        var vOrigIndex = vActiveChild.getZIndex();
        this._getBlocker().setZIndex( vOrigIndex );
        vActiveChild.setZIndex( vOrigIndex + 1 );
      }
    },

    release : function( vActiveChild ) {
      if( vActiveChild ) {
        rwt.util.Arrays.remove( this._modalWidgets, vActiveChild );
      }
      var l = this._modalWidgets.length;
      if( l === 0 ) {
        this._getBlocker().hide();
      } else {
        var oldActiveChild = this._modalWidgets[ l - 1 ];
        var old = oldActiveChild.getZIndex();
        this._getBlocker().setZIndex( old );
        oldActiveChild.setZIndex( old + 1 );
      }
    },

    _resetScrollPosition : function() {
      document.documentElement.scrollTop = 0;
      document.documentElement.scrollLeft = 0;
      document.body.scrollTop = 0;
      document.body.scrollLeft = 0;
    },

    // CSS API

    createStyleElement : function( vCssText ) {
      return rwt.html.StyleSheet.createElement( vCssText );
    },

    addCssRule : function( vSheet, vSelector, vStyle ) {
      return rwt.html.StyleSheet.addRule( vSheet, vSelector, vStyle );
    },

    removeCssRule : function( vSheet, vSelector ) {
      return rwt.html.StyleSheet.removeRule( vSheet, vSelector );
    },

    removeAllCssRules : function( vSheet ) {
      return rwt.html.StyleSheet.removeAllRules( vSheet );
    },

    // ------------------------------------------------------------------------
    // GLOBAL CURSOR SUPPORT
    // ------------------------------------------------------------------------

    _applyGlobalCursor : function( value ) {
      if( !this._globalCursorStyleSheet ) {
        this._globalCursorStyleSheet = this.createStyleElement();
      }
      this.removeCssRule( this._globalCursorStyleSheet, "*" );
      if( value ) {
        this.addCssRule( this._globalCursorStyleSheet, "*", "cursor:" + value + " !important" );
      }
    },

    // ------------------------------------------------------------------------
    // WINDOW RESIZE HANDLING
    // ------------------------------------------------------------------------

    _onwindowresize : function() {
      rwt.widgets.util.PopupManager.getInstance().update();
      this._recomputeInnerWidth();
      this._recomputeInnerHeight();
      rwt.widgets.base.Widget.flushGlobalQueues();
    },

    _computeInnerWidth : function() {
      return this._document.body.offsetWidth;
    },

    _computeInnerHeight : function() {
      return this._document.body.offsetHeight;
    }

  },

  defer : function() {
    // CSS fix
    var boxSizingAttr = rwt.client.Client.getEngineBoxSizingAttributes();
    var borderBoxCss = boxSizingAttr.join( ":border-box;" ) + ":border-box;";
    var contentBoxCss = boxSizingAttr.join( ":content-box;" ) + ":content-box;";
    rwt.html.StyleSheet.createElement(
      "html,body { margin:0;border:0;padding:0; } " +
      "html { border:0 none; } " +
      "*{" + borderBoxCss +"} " +
      "img{" + contentBoxCss + "}"
    );
    rwt.html.StyleSheet.createElement( "html,body{width:100%;height:100%;overflow:hidden;}" );
    rwt.widgets.base.ClientDocument.BOXSIZING = "border-box";
  },

  destruct : function() {
    this._disposeObjects( "_blocker" );
    this._disposeFields( "_window", "_document", "_modalWidgets", "_globalCursorStyleSheet" );
  }

} );

/*******************************************************************************
 * Copyright (c) 2004, 2014 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

/**
 * The Terminator is the base class for all widgets, which don't have child
 * widgets.
 *
 * If used directly it represents an rectangular area, which can be positioned
 * and sized using the layout managers.
 */
rwt.qx.Class.define( "rwt.widgets.base.Terminator", {

  extend : rwt.widgets.base.Widget,

  members : {

    _applyTextColor : function() {
      this._renderTextColor();
    },

    _renderAppearance : function() {
      this.base( arguments );
      this._renderTextColor();
    },

    _renderTextColor : function() {
      var color = this.getEnabled() ? this.getTextColor() : this._getDisabledColor();
      if( this.getStyleProperty( "color" ) !== color ) {
        if( color ) {
          this.setStyleProperty( "color", color );
        } else {
          this.removeStyleProperty( "color" );
        }
      }
    },

    _getDisabledColor : function() {
      var result = this.__theme$textColor;
      var parent = this.getParent();
      while( !result && parent !== null ) {
        result = parent.__theme$textColor;
        parent = parent.getParent();
      }
      return result;
    },

    renderPadding : function( changes ) {
      if( changes.paddingLeft ) {
        this._renderRuntimePaddingLeft( this.getPaddingLeft() );
      }

      if( changes.paddingRight ) {
        this._renderRuntimePaddingRight( this.getPaddingRight() );
      }

      if( changes.paddingTop ) {
        this._renderRuntimePaddingTop( this.getPaddingTop() );
      }

      if( changes.paddingBottom ) {
        this._renderRuntimePaddingBottom( this.getPaddingBottom() );
      }
    },

    _renderContent : function() {
      // Small optimization: Only add innerPreferred jobs
      // if we don't have a static width
      if( this._computedWidthTypePixel ) {
        this._cachedPreferredInnerWidth = null;
      } else {
        this._invalidatePreferredInnerWidth();
      }

      // Small optimization: Only add innerPreferred jobs
      // if we don't have a static height
      if( this._computedHeightTypePixel ) {
        this._cachedPreferredInnerHeight = null;
      } else {
        this._invalidatePreferredInnerHeight();
      }

      // add load job
      if( this._initialLayoutDone ) {
        this.addToJobQueue( "load" );
      }
    },

    _layoutPost : function( changes ) {
      if( changes.initial || changes.load || changes.width || changes.height ) {
        this._postApply();
      }
      this.createDispatchDataEvent( "flush", changes ); // TODO [tb] : use simple event
    },

    _postApply : rwt.util.Functions.returnTrue,

    _computeBoxWidthFallback : function() {
      return this.getPreferredBoxWidth();
    },

    _computeBoxHeightFallback : function() {
      return this.getPreferredBoxHeight();
    },

    /**
     * Returns the preferred inner width of the widget. This value is used
     * by the layout managers to calculate the actual size of the widget.
     *
     * @return {Integer} the preffered inner width.
     * @signature function()
     */
    _computePreferredInnerWidth : rwt.util.Functions.returnZero,

    /**
     * Returns the preferred inner height of the widget. This value is used
     * by the layout managers to calculate the actual size of the widget.
     *
     * @return {Integer} the preffered inner height.
     * @signature function()
     */
    _computePreferredInnerHeight : rwt.util.Functions.returnZero,

    _isWidthEssential : function() {
      if( !this._computedLeftTypeNull && !this._computedRightTypeNull ) {
        return true;
      }

      if( !this._computedWidthTypeNull && !this._computedWidthTypeAuto ) {
        return true;
      }

      if( !this._computedMinWidthTypeNull && !this._computedMinWidthTypeAuto ) {
        return true;
      }

      if( !this._computedMaxWidthTypeNull && !this._computedMaxWidthTypeAuto ) {
        return true;
      }

      if( this._targetNode ) {
        return true;
      }

      return false;
    },

    _isHeightEssential : function() {
      if( !this._computedTopTypeNull && !this._computedBottomTypeNull ) {
        return true;
      }

      if( !this._computedHeightTypeNull && !this._computedHeightTypeAuto ) {
        return true;
      }

      if( !this._computedMinHeightTypeNull && !this._computedMinHeightTypeAuto ) {
        return true;
      }

      if( !this._computedMaxHeightTypeNull && !this._computedMaxHeightTypeAuto ) {
        return true;
      }

      if( this._targetNode ) {
        return true;
      }

      return false;
    }

  }

} );

/*******************************************************************************
 * Copyright (c) 2004, 2013 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

/**
 * rwt.widgets.base.ClientDocumentBlocker blocks the inputs from the user.
 * This will be used internally to allow better modal dialogs for example.
 *
 * @appearance blocker
 */
rwt.qx.Class.define("rwt.widgets.base.ClientDocumentBlocker",
{
  extend : rwt.widgets.base.Terminator,
  include : rwt.animation.VisibilityAnimationMixin,




  /*
  *****************************************************************************
     CONSTRUCTOR
  *****************************************************************************
  */

  construct : function()
  {
    this.base(arguments);

    this.initTop();
    this.initLeft();

    this.initWidth();
    this.initHeight();

    this.initZIndex();
  },




  /*
  *****************************************************************************
     PROPERTIES
  *****************************************************************************
  */

  properties :
  {
    appearance :
    {
      refine : true,
      init : "client-document-blocker"
    },

    zIndex :
    {
      refine : true,
      init : 1e8
    },

    top :
    {
      refine : true,
      init : 0
    },

    left :
    {
      refine : true,
      init : 0
    },

    width :
    {
      refine : true,
      init : "100%"
    },

    height :
    {
      refine : true,
      init : "100%"
    },

    display :
    {
      refine : true,
      init : false
    }
  },




  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {
    // We must omit that the focus root is changed to the client document
    // when processing a mouse down event on this widget.
    getFocusRoot : function() {
      return null;
    }
  }
});

/*******************************************************************************
 * Copyright (c) 2004, 2014 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

rwt.qx.Class.define( "rwt.theme.AppearanceManager", {

  extend : rwt.util.ObjectManager,

  statics : {

    getInstance : function() {
      return rwt.runtime.Singletons.get( rwt.theme.AppearanceManager );
    }

  },

  construct : function() {
    this.base( arguments );
    this.__cache = {};
    this.__stateMap = {};
    this.__stateMapLength = 1;
  },

  members : {

    setCurrentTheme : function( appearance ) {
      this._currentTheme = appearance;
      this.syncAppearanceTheme();
    },

    getCurrentTheme : function() {
      return this._currentTheme;
    },

    syncAppearanceTheme : function() {
      if( !this._currentTheme ) {
        return;
      }
      if( this._currentTheme ) {
        this.__cache[this._currentTheme.name] = {};
      }
      if( rwt.runtime.System.getInstance().getUiReady() ) {
        rwt.widgets.base.ClientDocument.getInstance()._recursiveAppearanceThemeUpdate( this._currentTheme );
      }
    },

    styleFrom : function( id, states ) {
      var theme = this.getCurrentTheme();
      if( !theme ) {
        return;
      }
      return this.styleFromTheme( theme, id, states );
    },

    styleFromTheme : function( theme, id, states ) {
      var entry = theme.appearances[id];
      if( !entry ) {
        if( rwt.util.Variant.isSet( "qx.debug", "on" ) ) {
          throw new Error( "Missing appearance entry: " + id );
        }
        return null;
      }

      // Fast fallback to super entry
      if( !entry.style ) {
        if( entry.include ) {
          return this.styleFromTheme( theme, entry.include, states );
        } else {
          return null;
        }
      }

      // Creating cache-able ID
      var map = this.__stateMap;
      var helper = [id];
      for( var state in states ) {
        if( !map[state] ) {
          map[state] = this.__stateMapLength++;
        }
        helper[map[state]] = true;
      }
      var unique = helper.join();
      // Using cache if available
      var cache = this.__cache[theme.name];
      if( cache && cache[unique] !== undefined ) {
        return cache[unique];
      }

      var result;

      // Otherwise "compile" the appearance
      // If a include or base is defined, too, we need to merge the entries
      if( entry.include || entry.base ) {
        // This process tries to insert the original data first, and
        // append the new data later, to higher priorise the local
        // data above the included/inherited data. This is especially needed
        // for property groups or properties which includences other
        // properties when modified.
        var local = entry.style(states);

        // Gather included data
        var incl;
        if( entry.include ) {
          incl = this.styleFromTheme(theme, entry.include, states);
        }

        // Create new map
        result = {};

        // Copy base data, but exclude overwritten local and included stuff
        if( entry.base ) {
          var base = this.styleFromTheme( entry.base, id, states );
          if( entry.include ) {
            for( var key in base ) {
              if( incl[key] === undefined && local[key] === undefined ) {
                result[key] = base[key];
              }
            }
          } else {
            for( var key in base ) {
              if( local[key] === undefined ) {
                result[key] = base[key];
              }
            }
          }
        }

        // Copy include data, but exclude overwritten local stuff
        if( entry.include ) {
          for( var key in incl ) {
            if( local[key] === undefined ) {
              result[key] = incl[key];
            }
          }
        }
        // Append local data
        for( var key in local ) {
          result[key] = local[key];
        }
      } else {
        result = entry.style( states );
      }
      // Cache new entry and return
      if( cache ) {
        cache[unique] = result || null;
      }
      return result || null;
    }
  },

  destruct : function() {
    this._disposeFields( "__cache", "__stateMap" );
  }

} );

/*******************************************************************************
 * Copyright (c) 2004, 2015 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

rwt.qx.Class.define( "rwt.html.Border", {

  extend : rwt.qx.Object,

  /**
   * All arguments can be either a single value, or an array of four values in the order of
   * [ top, right, bottom, left ]. The contructor does not recognize an array of four identical
   * values colors as one single value.
   *
   * @param width Integer. Multiple values can be given for rounded border but only the
   *        biggest and zero may be used. Null is allowed.
   * @param style String, either a browser-recognized border-style or "complex".
   *        The last two are not accepted as an array, only as a single string.
   * @param color String in any browser-recognized color-format. For rounded border only one
   *        color may be given.
   * @param colorsOrRadii String/number either innerColors(s) for "complex" or radius/radii
   *        for "rounded" border. Throws exception if its undefined for those or defiend for others.
   */
  construct : function( width, style, color, colorsOrRadii ) {
    this.base( arguments );
    this._colors = null;
    this._widths = null;
    this._styles = null;
    this._innerColors = [ null, null, null, null ];
    this._radii = [ 0, 0, 0, 0 ];
    this._singleColor = null;
    this._singleStyle = null;
    this._setWidth( width );
    this._setStyle( style ? style : "none" );
    this._setColor( color ? color : "" );
    if( style === "complex" ) {
      if( colorsOrRadii === undefined ) {
        throw new Error( "Missing innerColors" );
      }
      this._setInnerColor( colorsOrRadii );
    } else if( colorsOrRadii !== undefined ) {
      this._setRadii( colorsOrRadii );
    }
  },

  statics : {
    _EDGEWIDTH : [ "borderTopWidth", "borderRightWidth", "borderBottomWidth", "borderLeftWidth" ],
    _EDGECOLOR : [ "borderTopColor", "borderRightColor", "borderBottomColor", "borderLeftColor" ],
    _EDGESTYLE : [ "borderTopStyle", "borderRightStyle", "borderBottomStyle", "borderLeftStyle" ],
    _EDGEMOZCOLORS : [
      "MozBorderTopColors",
      "MozBorderRightColors",
      "MozBorderBottomColors",
      "MozBorderLeftColors"
    ],
    _BORDERRADII : rwt.util.Variant.select( "qx.client", {
      "webkit|blink" : [
        "-webkit-border-top-left-radius",
        "-webkit-border-top-right-radius",
        "-webkit-border-bottom-right-radius",
        "-webkit-border-bottom-left-radius"
      ],
      "gecko|trident" : [
        "borderTopLeftRadius",
        "borderTopRightRadius",
        "borderBottomRightRadius",
        "borderBottomLeftRadius"
      ],
      "default" : []
    } ),


    resetWidget : function( widget ) {
      widget._style.border = "";
      if( widget._innerStyle ) {
        widget._innerStyle.border = "";
      }
      this._resetRadii( widget );
      this._resetComplexBorder( widget );
    },

    _resetRadii : function( widget ) {
      try {
        for( var i = 0; i < 4; i++ ) {
          widget._style[ this._BORDERRADII[ i ] ] = "";
        }
      } catch( ex ) {
        // ignore for browser without radii support
      }
    },

    _resetComplexBorder : rwt.util.Variant.select("qx.client", {
      "gecko" : function( widget ) {
        var statics = rwt.html.Border;
        var style = widget._style;
        for( var i = 0; i < 4; i++ ) {
          style[ statics._EDGEMOZCOLORS[ i ] ] = "";
        }
      },
      "default" : function( widget ) {
        var statics = rwt.html.Border;
        var inner = widget._innerStyle;
        if( inner ) {
          for( var i = 0; i < 4; i++ ) {
            inner[ statics._EDGEWIDTH[ i ] ] = "";
            inner[ statics._EDGESTYLE[ i ] ] = "";
            inner[ statics._EDGECOLOR[ i ] ] = "";
          }
        }
      }
    } )

  },

  members : {

    _setColor : function( value ) {
      if( typeof value === "string" ) {
        this._singleColor = value;
      }
      this._colors = this._normalizeValue( value );
    },

    _setWidth : function( value ) {
      this._widths = this._normalizeValue( value );
    },

    _setStyle : function( value ) {
      if( typeof value === "string" ) {
        this._singleStyle = value;
      }
      this._styles = this._normalizeValue( value === "complex" ? "solid" : value );
    },

    _setInnerColor : function( value ) {
      this._innerColors = this._normalizeValue( value );
    },

    _setRadii : function( value ) {
      this._radii = this._normalizeValue( value );
    },

    getRadii : function() {
      return this._radii.concat();
    },

    getColor : function() {
      return this._singleColor;
    },

    getColors : function() {
      return this._colors.concat();
    },

    getColorTop : function() {
      return this._colors[ 0 ];
    },

    getColorRight : function() {
      return this._colors[ 1 ];
    },

    getColorBottom : function() {
      return this._colors[ 2 ];
    },

    getColorLeft : function() {
      return this._colors[ 3 ];
    },

    getInnerColors : function() {
      return this._innerColors.concat();
    },

    getColorInnerTop : function() {
      return this._innerColors[ 0 ];
    },

    getColorInnerRight : function() {
      return this._innerColors[ 1 ];
    },

    getColorInnerBottom : function() {
      return this._innerColors[ 2 ];
    },

    getColorInnerLeft : function() {
      return this._innerColors[ 3 ];
    },

    getStyle : function() {
      return this._singleStyle;
    },

    getStyles : function() {
      return this._styles.concat();
    },

    getStyleTop : function() {
      return this._styles[ 0 ];
    },

    getStyleRight : function() {
      return this._styles[ 1 ];
    },

    getStyleBottom : function() {
      return this._styles[ 2 ];
    },

    getStyleLeft : function() {
      return this._styles[ 3 ];
    },

    getWidths : function() {
      return this._widths.concat();
    },

    getWidthTop : function() {
      return this._widths[ 0 ];
    },

    getWidthRight : function() {
      return this._widths[ 1 ];
    },

    getWidthBottom : function() {
      return this._widths[ 2 ];
    },

    getWidthLeft : function() {
      return this._widths[ 3 ];
    },

    _normalizeValue : function( value ) {
      var result;
      if( value instanceof Array ) {
        result = value;
      } else {
        result = [ value, value, value, value ];
      }
      return result;
    },

    renderWidget : function( widget ) {
      if( this.getStyle() === "complex" ) {
        this._renderComplexBorder( widget );
      } else if( this._isRounded() ) {
        this._renderRoundedBorder( widget );
      } else {
        this._renderSimpleBorder( widget );
      }
    },

    renderElement : function( element ) {
      if( this.getStyle() === "complex" ) {
        throw new Error( "Rendering complex or rounded border on elements currently unsupported" );
      }
      this._renderSimpleBorderStyle( element.style );
      if( this._isRounded() ) {
        this._renderRadii( element.style );
      }
    },

    _renderSimpleBorder : function( widget ) {
      rwt.html.Border._resetComplexBorder( widget );
      rwt.html.Border._resetRadii( widget );
      this._renderSimpleBorderStyle( widget._style );
    },

    _renderSimpleBorderStyle : function( style ) {
      var statics = rwt.html.Border;
      for( var i = 0; i < 4; i++ ) {
        style[ statics._EDGEWIDTH[ i ] ] = ( this._widths[ i ] || 0 ) + "px";
        style[ statics._EDGESTYLE[ i ] ] = this._styles[ i ] || "none";
        style[ statics._EDGECOLOR[ i ] ] = this._colors[ i ] || "";
      }
    },

    _renderComplexBorder : rwt.util.Variant.select( "qx.client", {
      "gecko" : function( widget ) {
        var statics = rwt.html.Border;
        statics._resetRadii( widget );
        var style = widget._style;
        for( var i = 0; i < 4; i++ ) {
          style[ statics._EDGEWIDTH[ i ] ] = ( this._widths[ i ] || 0 ) + "px";
          style[ statics._EDGECOLOR[ i ] ] = this._colors[ i ] || "";
          if( this._widths[ i ] === 2 ) {
            style[ statics._EDGESTYLE[ i ] ] = "solid";
            style[ statics._EDGEMOZCOLORS[ i ] ] = this._colors[ i ] + " " + this._innerColors[ i ];
          } else {
            style[ statics._EDGESTYLE[ i ] ] = this._styles[ i ] || "none";
            style[ statics._EDGEMOZCOLORS[ i ] ] = "";
          }
        }
      },
      "default" : function( widget ) {
        var statics = rwt.html.Border;
        statics._resetRadii( widget );
        var outer = widget._style;
        var inner = widget._innerStyle;
        for( var i = 0; i < 4; i++ ) {
          if( this._widths[ i ] === 2 ) {
            if( !inner ) {
              widget.prepareEnhancedBorder();
              inner = widget._innerStyle;
            }
            outer[ statics._EDGEWIDTH[ i ] ] = "1px";
            outer[ statics._EDGESTYLE[ i ] ] = "solid";
            outer[ statics._EDGECOLOR[ i ] ] = this._colors[ i ] || "";
            inner[ statics._EDGEWIDTH[ i ] ] = "1px";
            inner[ statics._EDGESTYLE[ i ] ] = "solid";
            inner[ statics._EDGECOLOR[ i ] ] = this._innerColors[ i ];
          } else {
            outer[ statics._EDGEWIDTH[ i ] ] = ( this._widths[ i ] || 0 ) + "px";
            outer[ statics._EDGESTYLE[ i ] ] = this._styles[ i ] || "none";
            outer[ statics._EDGECOLOR[ i ] ] = this._colors[ i ] || "";
            if( inner ) {
              inner[ statics._EDGEWIDTH[ i ] ] = "";
              inner[ statics._EDGESTYLE[ i ] ] = "";
              inner[ statics._EDGECOLOR[ i ] ] = "";
            }
          }
        }
      }
    } ),

    _renderRoundedBorder : function( widget ) {
      this._renderSimpleBorder( widget );
      this._renderRadii( widget._style );
    },

    _renderRadii : function( style ) {
      var statics = rwt.html.Border;
      for( var i = 0; i < 4; i++ ) {
        style[ statics._BORDERRADII[ i ] ] = this._radii[ i ] + "px";
      }
    },

    _isRounded : function() {
      return this._radii.join( "" ) !== "0000";
    }

  }

} );

/*******************************************************************************
 * Copyright (c) 2004, 2013 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

/**
 * A wrapper for CSS font styles. Fond objects can be aplpied to widgets
 * or DOM elements.
 */
rwt.qx.Class.define( "rwt.html.Font", {

  extend : rwt.qx.Object,

  /**
   * @param size {String} The font size (Unit: pixel)
   * @param family {String[]} A sorted list of font families
   */
  construct : function( size, family ) {
    this.base( arguments );
    if( size !== undefined ) {
      this.setSize( size );
    }
    if( family !== undefined ) {
      this.setFamily( family );
    }
  },

  statics : {

    _fontPool : {},

    /**
     * Converts a typical CSS font definition string to an font object
     *
     * @type static
     * @param str {String} the CSS string
     * @return {rwt.html.Font} the created instance
     */
    fromString : function( str ) {
      var font = new rwt.html.Font();
      var parts = str.split( /\s+/ );
      var name = [];
      for( var i = 0; i < parts.length; i++ ) {
        var part = parts[ i ];
        switch( part ) {
          case "bold":
            font.setBold( true );
            break;
          case "italic":
            font.setItalic( true );
            break;
          case "underline":
            font.setDecoration( "underline" );
            break;
          default:
            var temp = parseInt( part, 10 );
            if( temp == part || rwt.util.Strings.contains( part, "px" ) ) {
              font.setSize(temp);
            } else {
              name.push(part);
            }
            break;
        }
      }
      if( name.length > 0 ) {
        font.setFamily( name );
      }
      return font;
    },

    fromArray : function( arr ) {
      var name = arr[ 0 ];
      var size = arr[ 1 ];
      var bold = arr[ 2 ];
      var italic = arr[ 3 ];
      var id = name + size + bold + italic;
      var font = this._fontPool[ id ]; // TODO [tb] : use pool for all static methods
      if( !font ) {
        font = new rwt.html.Font( size, name );
        font.setBold( bold );
        font.setItalic( italic );
        this._fontPool[ id ] = font;
      }
      return font;
    },

    /**
     * Converts a map property definition into a border object.
     *
     * @type static
     * @param config {Map} map of property values
     * @return {rwt.html.Font} the created instance
     */
    fromConfig : function( config ) {
      var font = new rwt.html.Font();
      font.set( config );
      return font;
    },

    /**
     * Removes all fond styles from this widget
     *
     * @param widget {rwt.widgets.base.Widget} widget to reset
     */
    reset : function( widget ) {
      widget.removeStyleProperty("fontFamily");
      widget.removeStyleProperty("fontSize");
      widget.removeStyleProperty("fontWeight");
      widget.removeStyleProperty("fontStyle");
      widget.removeStyleProperty("textDecoration");
    },

    /**
     * Removes all fond styles from this DOM element
     *
     * @param element {Element} DOM element to reset
     */
    resetElement : function( element ) {
      var style = element.style;
      style.fontFamily = "";
      style.fontSize = "";
      style.fontWeight = "";
      style.fontStyle = "";
      style.textDecoration = "";
    },

    /**
     * Reset a style map by setting the font attributes to empty.
     *
     * @param style {Map} The style map
     * @type static
     * @return {void}
     */
    resetStyle : function( style ) {
      style.fontFamily = "";
      style.fontSize = "";
      style.fontWeight = "";
      style.fontStyle = "";
      style.textDecoration = "";
    }
  },

  properties : {

    /** The font size (Unit: pixel) */
    size : {
      check : "Integer",
      nullable : true,
      apply : "_applySize"
    },

    /** A sorted list of font families */
    family : {
      check : "Array",
      nullable : true,
      apply : "_applyFamily"
    },

    /** Whether the font is bold */
    bold : {
      check : "Boolean",
      nullable : true,
      apply : "_applyBold"
    },

    /** Whether the font is italic */
    italic : {
      check : "Boolean",
      nullable : true,
      apply : "_applyItalic"
    },

    /** The text decoration for this font */
    decoration : {
      check : [ "underline", "line-through", "overline" ],
      nullable : true,
      apply : "_applyDecoration"
    }
  },

  members : {
    __size : null,
    __family : null,
    __bold : null,
    __italic : null,
    __decoration : null,

    _applySize : function(value) {
      this.__size = value === null ? null : value + "px";
    },

    _applyFamily : function( value ) {
      var family = "";
      for( var i = 0, l = value.length; i < l; i++ ) {
        if( value[ i ].indexOf( " " ) > 0 ) {
          family += '"' + value[ i ] + '"';
        } else {
          // in FireFox 2 and WebKit fonts like 'serif' or 'sans-serif' must
          // not be quoted!
          family += value[ i ];
        }
        if( i != l-1 ) {
          family += ",";
        }
      }
      this.__family = family;
    },

    _applyBold : function( value ) {
      this.__bold = value === null ? null : value ? "bold" : "normal";
    },

    _applyItalic : function( value ) {
      this.__italic = value === null ? null : value ? "italic" : "normal";
    },

    _applyDecoration : function( value ) {
      this.__decoration = value === null ? null : value;
    },

    /**
     * Apply the font to the given widget.
     *
     * @param widget {rwt.widgets.base.Widget} The widget to apply the font to
     */
    render : function( widget ) {
      widget.setStyleProperty( "fontFamily", this.__family );
      widget.setStyleProperty( "fontSize", this.__size );
      widget.setStyleProperty( "fontWeight", this.__bold );
      widget.setStyleProperty( "fontStyle", this.__italic );
      widget.setStyleProperty( "textDecoration", this.__decoration );
    },

    /**
     * Generate a style map with the current font attributes.
     *
     * @param style {Map} The style map
     * @type member
     * @return {void}
     */
    renderStyle : function( style ) {
      style.fontFamily = this.__family || "";
      style.fontSize = this.__size || "";
      style.fontWeight = this.__bold || "";
      style.fontStyle =  this.__italic || "";
      style.textDecoration = this.__decoration || "";
    },

    /**
     * Apply the font styles to the given DOM element.
     *
     * @param element {Element} The DOM element to apply the font to
     */
    renderElement : function( element ) {
      var style = element.style;
      style.fontFamily = this.__family || "";
      style.fontSize = this.__size || "";
      style.fontWeight = this.__bold || "";
      style.fontStyle =  this.__italic || "";
      style.textDecoration = this.__decoration || "";
    },

    toCss : function() {
      return ( this.getItalic() ? "italic " : "" ) +
             ( this.getBold() ? "bold " : "" ) +
             ( this.__size ? this.getSize() + "px " : "" ) +
             ( this.__family ? this.__family.replace(/\"/g, "'") : "" );
    }
  }
} );

/*******************************************************************************
 * Copyright (c) 2004, 2013 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

/**
 * Each focus root delegates the focus handling to instances of the FocusHandler.
 */
rwt.qx.Class.define("rwt.widgets.util.FocusHandler",
{
  extend : rwt.qx.Target,




  /*
  *****************************************************************************
     CONSTRUCTOR
  *****************************************************************************
  */

  construct : function(widget)
  {
    this.base(arguments);

    if (widget != null) {
      this._attachedWidget = widget;
    }
  },




  /*
  *****************************************************************************
     STATICS
  *****************************************************************************
  */

  statics : {
    mouseFocus : false,
    blockFocus : false
  },




  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {
    /*
    ---------------------------------------------------------------------------
      UTILITIES
    ---------------------------------------------------------------------------
    */

    /**
     * TODOC
     *
     * @type member
     * @return {var} TODOC
     */
    getAttachedWidget : function() {
      return this._attachedWidget;
    },


    /**
     * TODOC
     *
     * @type member
     * @param container {var} TODOC
     * @param ev {Event} TODOC
     * @return {void}
     */
    _onkeyevent : function(container, ev)
    {
      if (ev.getKeyIdentifier() != "Tab") {
        return;
      }

      // Stop all key-events with a TAB keycode
      ev.stopPropagation();
      ev.preventDefault();

      rwt.widgets.util.FocusHandler.mouseFocus = false;

      var vCurrent = this.getAttachedWidget().getFocusedChild();

      // Support shift key to reverse widget detection order
      if (!ev.isShiftPressed()) {
        var vNext = vCurrent ? this.getWidgetAfter(container, vCurrent) : this.getFirstWidget(container);
      } else {
        var vNext = vCurrent ? this.getWidgetBefore(container, vCurrent) : this.getLastWidget(container);
      }

      // If there was a widget found, focus it
      if (vNext)
      {
        vNext.setFocused(true);
        vNext._ontabfocus();
      }
    },


    /**
     * TODOC
     *
     * @type member
     * @param c1 {var} TODOC
     * @param c2 {var} TODOC
     * @return {int | var} TODOC
     */
    compareTabOrder : function(c1, c2)
    {
      // Sort-Check #1: Tab-Index
      if (c1 == c2) {
        return 0;
      }

      var t1 = c1.getTabIndex();
      var t2 = c2.getTabIndex();

      // The following are some ideas to handle focus after tabindex.
      // Sort-Check #2: Top-Position
      if (t1 != t2) {
        return t1 - t2;
      }

      var y1 = rwt.html.Location.getTop(c1.getElement());
      var y2 = rwt.html.Location.getTop(c2.getElement());

      if (y1 != y2) {
        return y1 - y2;
      }

      // Sort-Check #3: Left-Position
      var x1 = rwt.html.Location.getLeft(c1.getElement());
      var x2 = rwt.html.Location.getLeft(c2.getElement());

      if (x1 != x2) {
        return x1 - x2;
      }

      // Sort-Check #4: zIndex
      var z1 = c1.getZIndex();
      var z2 = c2.getZIndex();

      if (z1 != z2) {
        return z1 - z2;
      }

      return 0;
    },




    /*
    ---------------------------------------------------------------------------
      UTILITIES FOR TAB HANDLING
    ---------------------------------------------------------------------------
    */

    /**
     * TODOC
     *
     * @type member
     * @param parentContainer {var} TODOC
     * @return {var} TODOC
     */
    getFirstWidget : function(parentContainer) {
      return this._getFirst(parentContainer, null);
    },


    /**
     * TODOC
     *
     * @type member
     * @param parentContainer {var} TODOC
     * @return {var} TODOC
     */
    getLastWidget : function(parentContainer) {
      return this._getLast(parentContainer, null);
    },


    /**
     * TODOC
     *
     * @type member
     * @param parentContainer {var} TODOC
     * @param widget {var} TODOC
     * @return {var | Array} TODOC
     */
    getWidgetAfter : function(parentContainer, widget)
    {
      if (parentContainer == widget) {
        return this.getFirstWidget(parentContainer);
      }

      if (widget.getAnonymous()) {
        widget = widget.getParent();
      }

      if (widget == null) {
        return [];
      }

      var vAll = [];

      this._getAllAfter(parentContainer, widget, vAll);

      vAll.sort(this.compareTabOrder);

      return vAll.length > 0 ? vAll[0] : this.getFirstWidget(parentContainer);
    },


    /**
     * TODOC
     *
     * @type member
     * @param parentContainer {var} TODOC
     * @param widget {var} TODOC
     * @return {var | Array} TODOC
     */
    getWidgetBefore : function(parentContainer, widget)
    {
      if (parentContainer == widget) {
        return this.getLastWidget(parentContainer);
      }

      if (widget.getAnonymous()) {
        widget = widget.getParent();
      }

      if (widget == null) {
        return [];
      }

      var vAll = [];

      this._getAllBefore(parentContainer, widget, vAll);

      vAll.sort(this.compareTabOrder);

      var len = vAll.length;
      return len > 0 ? vAll[len - 1] : this.getLastWidget(parentContainer);
    },


    /**
     * TODOC
     *
     * @param parent {var} TODOC
     * @param widget {var} TODOC
     * @param arr {var} TODOC
     */
    _getAllAfter : function(parent, widget, arr)
    {
      var children = parent.getChildren();
      var child;
      var len = children.length || 0;

      for (var i=0; i<len; i++)
      {
        child = children[i];

        if (child.isDisposed() || !(child instanceof rwt.widgets.base.Parent) && !(child instanceof rwt.widgets.base.Terminator)) {
          continue;
        }

        if (child.isFocusable() && child.getTabIndex() > 0 && this.compareTabOrder(widget, child) < 0) {
          arr.push(children[i]);
        }

        if (!child.isFocusRoot() && child instanceof rwt.widgets.base.Parent) {
          this._getAllAfter(child, widget, arr);
        }
      }
    },


    /**
     * TODOC
     *
     * @type member
     * @param parent {var} TODOC
     * @param widget {var} TODOC
     * @param arr {var} TODOC
     * @return {void}
     */
    _getAllBefore : function(parent, widget, arr)
    {
      var children = parent.getChildren();
      var child;
      var len = children.length;

      for (var i=0; i<len; i++)
      {
        child = children[i];

        if (!(child instanceof rwt.widgets.base.Parent) && !(child instanceof rwt.widgets.base.Terminator)) {
          continue;
        }

        if (child.isFocusable() && child.getTabIndex() > 0 && this.compareTabOrder(widget, child) > 0) {
          arr.push(child);
        }

        if (!child.isFocusRoot() && child instanceof rwt.widgets.base.Parent) {
          this._getAllBefore(child, widget, arr);
        }
      }
    },


    /**
     * TODOC
     *
     * @type member
     * @param parent {var} TODOC
     * @param firstWidget {var} TODOC
     * @return {var} TODOC
     */
    _getFirst : function(parent, firstWidget)
    {
      var children = parent.getChildren();
      var child;
      var len = children.length;

      for (var i=0; i<len; i++)
      {
        child = children[i];

        if (!(child instanceof rwt.widgets.base.Parent) && !(child instanceof rwt.widgets.base.Terminator)) {
          continue;
        }

        if (child.isFocusable() && child.getTabIndex() > 0)
        {
          if (firstWidget == null || this.compareTabOrder(child, firstWidget) < 0) {
            firstWidget = child;
          }
        }

        if (!child.isFocusRoot() && child instanceof rwt.widgets.base.Parent) {
          firstWidget = this._getFirst(child, firstWidget);
        }
      }

      return firstWidget;
    },


    /**
     * TODOC
     *
     * @type member
     * @param parent {var} TODOC
     * @param lastWidget {var} TODOC
     * @return {var} TODOC
     */
    _getLast : function(parent, lastWidget)
    {
      var children = parent.getChildren();
      var child;
      var len = children.length;

      for (var i=0; i<len; i++)
      {
        child = children[i];

        if (!(child instanceof rwt.widgets.base.Parent) && !(child instanceof rwt.widgets.base.Terminator)) {
          continue;
        }

        if (child.isFocusable() && child.getTabIndex() > 0)
        {
          if (lastWidget == null || this.compareTabOrder(child, lastWidget) > 0) {
            lastWidget = child;
          }
        }

        if (!child.isFocusRoot() && child instanceof rwt.widgets.base.Parent) {
          lastWidget = this._getLast(child, lastWidget);
        }
      }

      return lastWidget;
    }
  },




  /*
  *****************************************************************************
     DESTRUCTOR
  *****************************************************************************
  */

  destruct : function() {
    this._disposeFields("_attachedWidget");
  }
});

/*******************************************************************************
 * Copyright: 2004, 2015 1&1 Internet AG, Germany, http://www.1und1.de,
 *                       and EclipseSource
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v1.0 which accompanies this
 * distribution, and is available at http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 *
 * This class contains code based on the following work:
 *
 *   * jQuery Dimension Plugin
 *       http://jquery.com/
 *       Version 1.1.3
 *
 *     Copyright:
 *       (c) 2007, Paul Bakaus & Brandon Aaron
 *
 *     License:
 *       MIT: http://www.opensource.org/licenses/mit-license.php
 *
 *     Authors:
 *       Paul Bakaus
 *       Brandon Aaron
 *
 ******************************************************************************/

/**
 * Query the location of an arbitrary DOM element in relation to its top
 * level body element. Works in all major browsers:
 *
 * * Mozilla 1.5 + 2.0
 * * Internet Explorer 6.0 + 7.0 (both standard & quirks mode)
 * * Opera 9.2
 * * Safari 3.0 beta
 */
rwt.qx.Class.define("rwt.html.Location",
{
  statics :
  {
    /**
     * Queries a style property for the given element
     *
     * @type static
     * @param elem {Element} DOM element to query
     * @param style {String} Style property
     * @return {String} Value of given style property
     */
    __style : function( elem, style ) {
      return rwt.html.Style.get( elem, style );
    },

    /**
     * Queries a style property for the given element and parses it to a integer value
     *
     * @type static
     * @param elem {Element} DOM element to query
     * @param style {String} Style property
     * @return {Integer} Value of given style property
     */
    __num : function(elem, style) {
      var value = rwt.html.Style.get( elem, style );
      var result = Math.round( parseFloat( value ,10 ) );
      return result || 0;
    },

    /**
     * Computes the scroll offset of the given element relative to the document
     * <code>body</code>.
     *
     * @type static
     * @param elem {Element} DOM element to query
     * @return {Map} Map which contains the <code>left</code> and <code>top</code> scroll offsets
     */
    __computeScroll : function( elem ) {
      var left = 0, top = 0;
      if( elem.getBoundingClientRect ) {
        var win = rwt.html.Nodes.getWindow( elem );
        // getBoundingClientRect works in relation to the viewport, not - as desired - the document
        left -= rwt.html.Viewport.getScrollLeft( win );
        top -= rwt.html.Viewport.getScrollTop( win );
      } else {
        var body = rwt.html.Nodes.getDocument( elem ).body;
        elem = elem.parentNode;
        while( elem && elem != body ) {
          left += elem.scrollLeft;
          top += elem.scrollTop;
          elem = elem.parentNode;
        }
      }
      return {
        left : Math.ceil( left ),
        top : Math.ceil( top )
      };
    },


    /**
     * Computes the offset of the given element relative to the document
     * <code>body</code>.
     *
     * @type static
     * @param elem {Element} DOM element to query
     * @return {Map} Map which contains the <code>left</code> and <code>top</code> offsets
     */
    __computeBody : rwt.util.Variant.select( "qx.client", {
      "webkit|blink" : function( elem ) {
        // Find body element
        var doc = rwt.html.Nodes.getDocument(elem);
        var body = doc.body;

        // Start with the offset
        var left = body.offsetLeft;
        var top = body.offsetTop;

        // Correct substracted border
        left += this.__num(body, "borderLeftWidth");
        top += this.__num(body, "borderTopWidth");

        // Add the margin when running in standard mode
        if (doc.compatMode === "CSS1Compat")
        {
          left += this.__num(body, "marginLeft");
          top += this.__num(body, "marginTop");
        }

        return {
          left : Math.ceil( left ),
          top : Math.ceil( top )
        };
      },
      "gecko" : function( elem ) {
        // Find body element
        var body = rwt.html.Nodes.getDocument(elem).body;

        // Start with the offset
        var left = body.offsetLeft;
        var top = body.offsetTop;

        // Correct substracted border (only in content-box mode)
        if (rwt.widgets.base.ClientDocument.BOXSIZING !== "border-box")
        {
          left += this.__num(body, "borderLeftWidth");
          top += this.__num(body, "borderTopWidth");

          // For some unknown reason we must add the border two times
          // when there is no absolute positioned element in the DOM tree

          // This is not neededd if the offset is computed using
          // <code>getBoundingClientRect</code>
          if (!elem.getBoundingClientRect)
          {
            var hasAbs;

            while (elem)
            {
              if (this.__style(elem, "position") === "absolute" || this.__style(elem, "position") === "fixed")
              {
                hasAbs = true;
                break;
              }

              elem = elem.offsetParent;
            }

            if (!hasAbs)
            {
              left += this.__num(body, "borderLeftWidth");
              top += this.__num(body, "borderTopWidth");
            }
          }
        }

        return {
          left : Math.ceil( left ),
          top : Math.ceil( top )
        };
      },
      // At the moment only correctly supported by Opera
      "default" : function( elem ) {
        // Find body element
        var body = rwt.html.Nodes.getDocument(elem).body;

        // Start with the offset
        var left = body.offsetLeft;
        var top = body.offsetTop;

        return {
          left : Math.ceil( left ),
          top : Math.ceil( top )
        };
      }
    } ),


    /**
     * Computes the sum of all offsets of the given element node.
     *
     * Traditionally this is a loop which goes up the whole parent tree
     * and sums up all found offsets.
     *
     * @type static
     * @signature function(elem)
     * @param elem {Element} DOM element to query
     * @return {Map} Map which contains the <code>left</code> and <code>top</code> offsets
     */
    __computeOffset : rwt.util.Variant.select( "qx.client", {
      "trident|webkit|blink" : function( elem ) {
        var doc = rwt.html.Nodes.getDocument(elem);

        // TODO: Check if all supported browser have getBoundingClientRect
        if (elem.getBoundingClientRect)
        {
          var rect = elem.getBoundingClientRect();

          var left = rect.left;
          var top = rect.top;
        }
        else
        {
          // Offset of the incoming element
          var left = elem.offsetLeft;
          var top = elem.offsetTop;

          // Start with the first offset parent
          elem = elem.offsetParent;

          // Stop at the body
          var body = doc.body;

          // Border correction is only needed for each parent
          // not for the incoming element itself
          while (elem && elem != body)
          {
            // Add node offsets
            left += elem.offsetLeft;
            top += elem.offsetTop;

            // Fix missing border
            left += this.__num(elem, "borderLeftWidth");
            top += this.__num(elem, "borderTopWidth");

            // One level up (offset hierarchy)
            elem = elem.offsetParent;
          }
        }

        return {
          left : Math.ceil( left ),
          top : Math.ceil( top )
        };
      },
      "gecko" : function( elem ) {
        // Use faster getBoundingClientRect() if available (gecko >= 1.9)
        if (elem.getBoundingClientRect)
        {
          var rect = elem.getBoundingClientRect();

          // Firefox 3.0 alpha 6 (gecko 1.9) returns floating point numbers
          // use Math.round() to round them to style compatible numbers
          var left = Math.round(rect.left);
          var top = Math.round(rect.top);
        }
        else
        {
          var left = 0;
          var top = 0;

          // Stop at the body
          var body = rwt.html.Nodes.getDocument(elem).body;
          var box = rwt.widgets.base.ClientDocument.BOXSIZING;

          if( box !== "border-box" ) {
            left -= this.__num(elem, "borderLeftWidth");
            top -= this.__num(elem, "borderTopWidth");
          }

          while (elem && elem !== body)
          {
            // Add node offsets
            left += elem.offsetLeft;
            top += elem.offsetTop;

            // Mozilla does not add the borders to the offset
            // when using box-sizing=content-box
            if( box !== "border-box" ) {
              left += this.__num(elem, "borderLeftWidth");
              top += this.__num(elem, "borderTopWidth");
            }

            // Mozilla does not add the border for a parent that has
            // overflow set to anything but visible
            if (elem.parentNode && this.__style(elem.parentNode, "overflow") != "visible")
            {
              left += this.__num(elem.parentNode, "borderLeftWidth");
              top += this.__num(elem.parentNode, "borderTopWidth");
            }

            // One level up (offset hierarchy)
            elem = elem.offsetParent;
          }
        }

        return {
          left : Math.ceil( left ),
          top : Math.ceil( top )
        };
      },
      // At the moment only correctly supported by Opera
      "default" : function( elem ) {
        var left = 0;
        var top = 0;

        // Stop at the body
        var body = rwt.html.Nodes.getDocument(elem).body;

        // Add all offsets of parent hierarchy, do not include
        // body element.
        while (elem && elem !== body)
        {
          // Add node offsets
          left += elem.offsetLeft;
          top += elem.offsetTop;

          // One level up (offset hierarchy)
          elem = elem.offsetParent;
        }

        return {
          left : Math.ceil( left ),
          top : Math.ceil( top )
        };
      }
    } ),


    /**
     * Computes the location of the given element in context of
     * the document dimensions.
     *
     * Supported modes:
     *
     * * <code>margin</code>: Calculate from the margin box of the element (bigger than the visual appearance: including margins of given element)
     * * <code>box</code>: Calculates the offset box of the element (default, uses the same size as visible)
     * * <code>border</code>: Calculate the border box (useful to align to border edges of two elements).
     * * <code>scroll</code>: Calculate the scroll box (relevant for absolute positioned content).
     * * <code>padding</code>: Calculate the padding box (relevant for static/relative positioned content).
     *
     * @type static
     * @param elem {Element} DOM element to query
     * @param mode {String} A supported option. See comment above.
     * @return {Map} Returns a map with <code>left</code>, <code>top</code>,
     *   <code>right</code> and <code>bottom</code> which contains the distance
     *   of the element relative to the document.
     */
    get : function(elem, mode)
    {
      var body = this.__computeBody(elem);

      if (elem.tagName == "BODY")
      {
        var left = body.left;
        var top = body.top;
      }
      else
      {
        var offset = this.__computeOffset(elem);
        var scroll = this.__computeScroll(elem);

        var left = offset.left + body.left - scroll.left;
        var top = offset.top + body.top - scroll.top;
      }

      var right = left + elem.offsetWidth;
      var bottom = top + elem.offsetHeight;

      if (mode)
      {
        // In this modes we want the size as seen from a child what means that we want the full width/height
        // which may be higher than the outer width/height when the element has scrollbars.
        if (mode == "padding" || mode == "scroll")
        {
          var overX = rwt.html.Overflow.getX(elem);
          if (overX == "scroll" || overX == "auto") {
            right += elem.scrollWidth - elem.offsetWidth + this.__num(elem, "borderLeftWidth") + this.__num(elem, "borderRightWidth");
          }

          var overY = rwt.html.Overflow.getY(elem);
          if (overY == "scroll" || overY == "auto") {
            bottom += elem.scrollHeight - elem.offsetHeight + this.__num(elem, "borderTopWidth") + this.__num(elem, "borderBottomWidth");
          }
        }

        if( mode === "padding" ) {
          left += this.__num(elem, "paddingLeft");
          top += this.__num(elem, "paddingTop");
          right -= this.__num(elem, "paddingRight");
          bottom -= this.__num(elem, "paddingBottom");
        }
        if( mode === "padding" || mode === "scroll" ) {
          left -= elem.scrollLeft;
          top -= elem.scrollTop;
          right -= elem.scrollLeft;
          bottom -= elem.scrollTop;
        }
        if( mode === "padding" || mode === "scroll" || mode === "border" ) {
          left += this.__num(elem, "borderLeftWidth");
          top += this.__num(elem, "borderTopWidth");
          right -= this.__num(elem, "borderRightWidth");
          bottom -= this.__num(elem, "borderBottomWidth");
        }
        if( mode === "margin" ) {
          left -= this.__num(elem, "marginLeft");
          top -= this.__num(elem, "marginTop");
          right += this.__num(elem, "marginRight");
          bottom += this.__num(elem, "marginBottom");
        }
      }

      return {
        left : left,
        top : top,
        right : right,
        bottom : bottom
      };
    },


    /**
     * Computes the location of the given element in context of
     * the document dimensions. For supported modes please
     * have a look at the {@link rwt.html.Location#get} method.
     *
     * @type static
     * @param elem {Element} DOM element to query
     * @param mode {String} A supported option. See comment above.
     * @return {Integer} The left distance
     *   of the element relative to the document.
     */
    getLeft : function(elem, mode) {
      return this.get(elem, mode).left;
    },


    /**
     * Computes the location of the given element in context of
     * the document dimensions.For supported modes please
     * have a look at the {@link rwt.html.Location#get} method.
     *
     * @type static
     * @param elem {Element} DOM element to query
     * @param mode {String} A supported option. See comment above.
     * @return {Integer} The top distance
     *   of the element relative to the document.
     */
    getTop : function(elem, mode) {
      return this.get(elem, mode).top;
    },


    /**
     * Computes the location of the given element in context of
     * the document dimenions.For supported modes please
     * have a look at the {@link rwt.html.Location#get} method.
     *
     * @type static
     * @param elem {Element} DOM element to query
     * @param mode {String} A supported option. See comment above.
     * @return {Integer} The right distance
     *   of the element relative to the document.
     */
    getRight : function(elem, mode) {
      return this.get(elem, mode).right;
    },


    /**
     * Computes the location of the given element in context of
     * the document dimenions.For supported modes please
     * have a look at the {@link rwt.html.Location#get} method.
     *
     * @type static
     * @param elem {Element} DOM element to query
     * @param mode {String} A supported option. See comment above.
     * @return {Integer} The bottom distance
     *   of the element relative to the document.
     */
    getBottom : function(elem, mode) {
      return this.get(elem, mode).bottom;
    },


    /**
     * Returns the distance between two DOM elements. For supported modes please
     * have a look at the {@link rwt.html.Location#get} method.
     *
     * @type static
     * @param elem1 {Element} First element
     * @param elem2 {Element} Second element
     * @param mode1 {String?null} Mode for first element
     * @param mode2 {String?null} Mode for second element
     * @return {Map} Returns a map with <code>left</code> and <code>top</code>
     *   which contains the distance of the elements from each other.
     */
    getRelative : function(elem1, elem2, mode1, mode2)
    {
      var loc1 = this.get(elem1, mode1);
      var loc2 = this.get(elem2, mode2);

      return {
        left : loc1.left - loc2.left,
        top : loc1.top - loc2.top,
        right : loc1.right - loc2.right,
        bottom : loc1.bottom - loc2.bottom
      };
    }
  }
});

/*******************************************************************************
 * Copyright: 2004, 2015 1&1 Internet AG, Germany, http://www.1und1.de,
 *                       and EclipseSource
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v1.0 which accompanies this
 * distribution, and is available at http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 *
 *   This class contains code based on the following work:
 *
 *   * Prototype JS
 *     http://www.prototypejs.org/
 *     Version 1.5
 *
 *     Copyright:
 *       (c) 2006-2007, Prototype Core Team
 *
 *     License:
 *       MIT: http://www.opensource.org/licenses/mit-license.php
 *
 *     Authors:
 *       * Prototype Core Team
 *
 ******************************************************************************/

(function() {

var Client = rwt.client.Client;

/**
 * Style querying and modification of HTML elements.
 *
 * Automatically normalizes cross-browser differences. Optimized for
 * performance.
 */
rwt.qx.Class.define( "rwt.html.Style", {

  statics : {

    VENDOR_PREFIX_VALUE : rwt.util.Variant.select( "qx.client", {
      "gecko" : "-moz-",
      "webkit|blink" : "-webkit-",
      "trident" : "-ms-",
      "default" : ""
    } ),

    VENDOR_PREFIX_PROPERTY : rwt.util.Variant.select( "qx.client", {
      "gecko" : "Moz",
      "webkit|blink" : "webkit",
      "trident" : "ms",
      "default" : ""
    } ),

    /**
     * Gets the value of a style property.
     *
     * *Computed*
     *
     * Returns the computed value of a style property. Compared to the cascaded style,
     * this one also interprets the values e.g. translates <code>em</code> units to
     * <code>px</code>.
     *
     * *Cascaded*
     *
     * Returns the cascaded value of a style property.
     *
     * *Local*
     *
     * Ignores inheritance cascade. Does not interpret values.
     *
     * @type static
     * @signature function(element, name)
     * @param element {Element} The DOM element to modify
     * @param name {String} Name of the style attribute (js variant e.g. marginTop, wordSpacing)
     * @return {var} The value of the property
     */
    get : function( element, name ) {
      // Opera, Mozilla and Safari 3+ also have a global getComputedStyle which is identical
      // to the one found under document.defaultView.

      // The problem with this is however that this does not work correctly
      // when working with frames and access an element of another frame.
      // Then we must use the <code>getComputedStyle</code> of the document
      // where the element is defined.
      var doc = rwt.html.Nodes.getDocument(element);
      var computed = doc.defaultView.getComputedStyle(element, null);

      // All relevant browsers expose the configured style properties to
      // the CSSStyleDeclaration objects
      return computed ? computed[name] : null;
    },

    /**
     * Gets the computed (CSS) style property of a given DOM element.
     */
    // TODO: check if all supported browser have document.defaultView.getComputedStyle
    getStyleProperty : ( document.defaultView && document.defaultView.getComputedStyle )
      ? function( el, prop ) {
        try {
          return el.ownerDocument.defaultView.getComputedStyle(el, "")[prop];
        } catch(ex) {
          throw new Error("Could not evaluate computed style: " + el + "[" + prop + "]: " + ex);
        }
      }
      : function( el, prop ) {
        try {
          return el.style[prop];
        } catch( ex ) {
          throw new Error( "Could not evaluate computed style: " + el + "[" + prop + "]" );
        }
      },

    /**
     * Get a (CSS) style property of a given DOM element and interpret the property as integer value
     *
     * @type static
     * @param vElement {Element} the DOM element
     * @param propertyName {String} the name of the style property. e.g. "paddingTop", "marginLeft", ...
     * @return {Integer} the (CSS) style property converted to an integer value
     */
    getStyleSize : function(vElement, propertyName) {
      return parseInt( rwt.html.Style.getStyleProperty( vElement, propertyName ), 10 ) || 0;
    },


    /**
     * Get the element's left margin.
     *
     * @type static
     * @param vElement {Element} the DOM element
     * @return {Integer} the element's left margin size
     */
    getMarginLeft : function(vElement) {
      return rwt.html.Style.getStyleSize(vElement, "marginLeft");
    },


    /**
     * Get the element's top margin.
     *
     * @type static
     * @param vElement {Element} the DOM element
     * @return {Integer} the element's top margin size
     */
    getMarginTop : function(vElement) {
      return rwt.html.Style.getStyleSize(vElement, "marginTop");
    },


    /**
     * Get the element's right margin.
     *
     * @type static
     * @param vElement {Element} the DOM element
     * @return {Integer} the element's right margin size
     */
    getMarginRight : function(vElement) {
      return rwt.html.Style.getStyleSize(vElement, "marginRight");
    },


    /**
     * Get the element's bottom margin.
     *
     * @type static
     * @param vElement {Element} the DOM element
     * @return {Integer} the element's bottom margin size
     */
    getMarginBottom : function(vElement) {
      return rwt.html.Style.getStyleSize(vElement, "marginBottom");
    },


    /**
     * Get the element's left padding.
     *
     * @type static
     * @param vElement {Element} the DOM element
     * @return {Integer} the element's left padding size
     */
    getPaddingLeft : function(vElement) {
      return rwt.html.Style.getStyleSize(vElement, "paddingLeft");
    },


    /**
     * Get the element's top padding.
     *
     * @type static
     * @param vElement {Element} the DOM element
     * @return {Integer} the element's top padding size
     */
    getPaddingTop : function(vElement) {
      return rwt.html.Style.getStyleSize(vElement, "paddingTop");
    },


    /**
     * Get the element's right padding.
     *
     * @type static
     * @param vElement {Element} the DOM element
     * @return {Integer} the element's right padding size
     */
    getPaddingRight : function(vElement) {
      return rwt.html.Style.getStyleSize(vElement, "paddingRight");
    },


    /**
     * Get the element's bottom padding.
     *
     * @type static
     * @param vElement {Element} the DOM element
     * @return {Integer} the element's bottom padding size
     */
    getPaddingBottom : function(vElement) {
      return rwt.html.Style.getStyleSize(vElement, "paddingBottom");
    },


    /**
     * Get the element's left border width.
     *
     * @type static
     * @param vElement {Element} the DOM element
     * @return {Integer} the element's left border width
     */
    getBorderLeft : function(vElement) {
      return rwt.html.Style.getStyleProperty(vElement, "borderLeftStyle") == "none" ? 0 : rwt.html.Style.getStyleSize(vElement, "borderLeftWidth");
    },


    /**
     * Get the element's top border width.
     *
     * @type static
     * @param vElement {Element} the DOM element
     * @return {Integer} the element's top border width
     */
    getBorderTop : function(vElement) {
      return rwt.html.Style.getStyleProperty(vElement, "borderTopStyle") == "none" ? 0 : rwt.html.Style.getStyleSize(vElement, "borderTopWidth");
    },


    /**
     * Get the element's right border width.
     *
     * @type static
     * @param vElement {Element} the DOM element
     * @return {Integer} the element's right border width
     */
    getBorderRight : function(vElement) {
      return rwt.html.Style.getStyleProperty(vElement, "borderRightStyle") == "none" ? 0 : rwt.html.Style.getStyleSize(vElement, "borderRightWidth");
    },

    /**
     * Get the element's bottom border width.
     *
     * @type static
     * @param vElement {Element} the DOM element
     * @return {Integer} the element's bottom border width
     */
    getBorderBottom : function(vElement) {
      return rwt.html.Style.getStyleProperty(vElement, "borderBottomStyle") == "none" ? 0 : rwt.html.Style.getStyleSize(vElement, "borderBottomWidth");
    },

    /**
     * Sets the given gradient as a background for the target element/widget.
     * The syntax is [ [ position, color ]* ], with position <= 1 and >= 0.
     * Color is any valid css string for colors.
     * The position has to increase from every previous position.
     * The gradient flows from top to bottom unless a "horizontal" flag is added as
     * a field to the gradient object, in which case it flows from left to right.
     *
     * If a background color is set, the gradient is rendered on top of it.
     * If a background image is set, the gradient is not rendered until it is removed.
     * If the browser does not support CSS3, the gradient is never rendered.
     */
    setBackgroundGradient : function( target, gradient ) {
      // Tests for identity, not equality, which is okay since this is just an optimization
      if( target.___rwtStyle__backgroundGradient !== gradient ) {
        target.___rwtStyle__backgroundGradient = gradient;
        if( !target.___rwtStyle__backgroundImage ) {
          this._updateBackground( target );
        }
      }
    },

    getBackgroundGradient : function( target ) {
      var gradient = target.___rwtStyle__backgroundGradient;
      if( !gradient ) {
        return undefined;
      }
      var args = [ gradient.horizontal === true ? "to right" : "to bottom" ];
      for( var i = 0; i < gradient.length; i++ ) {
        var position = ( gradient[ i ][ 0 ] * 100 ) + "%";
        var color = gradient[ i ][ 1 ];
        args.push( " " + color + " " + position );
      }
      return "linear-gradient( " + args.join() + " )";
    },

    /**
     * Sets the given image url as a background for the target element/widget.
     * If a background color is set, the image is rendered on top of it.
     * If a background gradient is set, only the image is rendered.
     * For background repeat/position to be respected, they have to be set by
     * setBackgroundPosition/Repeat, never directly.
     */
    setBackgroundImage : function( target, image ) {
      if( target.___rwtStyle__backgroundImage !== image ) {
        target.___rwtStyle__backgroundImage = image;
        this._updateBackground( target );
      }
    },

    getBackgroundImage : function( target ) {
      var image = target.___rwtStyle__backgroundImage;
      if( !image ) {
        return "none";
      }
      return "url(" + image + ")";
    },

    setBackgroundRepeat : function( target, repeat ) {
      if( target.___rwtStyle__backgroundRepeat !== repeat ) {
        target.___rwtStyle__backgroundRepeat = repeat;
        if( target.___rwtStyle__backgroundImage ) {
          this._updateBackground( target );
        }
      }
    },

    getBackgroundRepeat : function( target ) {
      return target.___rwtStyle__backgroundRepeat;
    },

    setBackgroundPosition : function( target, position ) {
      if( target.___rwtStyle__backgroundPosition !== position ) {
        target.___rwtStyle__backgroundPosition = position;
        if( target.___rwtStyle__backgroundImage ) {
          this._updateBackground( target );
        }
      }
    },

    getBackgroundPosition : function( target ) {
      return target.___rwtStyle__backgroundPosition;
    },

    setBackgroundSize : function( target, size ) {
      if( target.___rwtStyle__backgroundSize !== size ) {
        target.___rwtStyle__backgroundSize = size;
        if( target.___rwtStyle__backgroundImage ) {
          this._updateBackground( target );
        }
      }
    },

    /**
     * Sets the given color as a background for the target element/widget.
     * The color is rendered in any case, but always below gradient and image.
     */
    setBackgroundColor : function( target, color ) {
      var value = color === "transparent" ? null : color;
      if( target.___rwtStyle__backgroundColor !== value ) {
        target.___rwtStyle__backgroundColor = value;
        this._updateBackground( target );
      }
    },

    /**
     * Returns the color that was previously set by setBackgroundColor
     */
    getBackgroundColor : function( target ) {
      return target.___rwtStyle__backgroundColor || "transparent";
    },

    setBoxShadow: function( target, shadowObject ) {
      var property;
      if( ( Client.isWebkit() || Client.isBlink() ) && !Client.isMobileChrome() ) {
        property = this.VENDOR_PREFIX_VALUE + "box-shadow";
      } else {
        property = "boxShadow";
      }
      if( shadowObject ) {
        // NOTE: older webkit dont accept spread, therefor only use parameters 1-3
        var string = shadowObject[ 0 ] ? "inset " : "";
        string += shadowObject.slice( 1, 4 ).join( "px " ) + "px";
        var rgba = rwt.util.Colors.stringToRgb( shadowObject[ 5 ] );
        rgba.push( shadowObject[ 6 ] );
        string += " rgba(" + rgba.join() + ")";
        this.setStyleProperty( target, property, string );
      } else {
        this.removeStyleProperty( target, property );
      }
    },

    setTextShadow : function( target, shadowObject ) {
      var property = "textShadow";
      if( shadowObject ) {
        var string = shadowObject.slice( 1, 4 ).join( "px " ) + "px";
        var rgba = rwt.util.Colors.stringToRgb( shadowObject[ 5 ] );
        rgba.push( shadowObject[ 6 ] );
        string += " rgba(" + rgba.join() + ")";
        this.setStyleProperty( target, property, string );
      } else {
        this.removeStyleProperty( target, property );
      }
    },

    setPointerEvents : function( target, value ) {
      var version = Client.getVersion();
      var ffSupport = Client.getEngine() === "gecko" && version >= 1.9;
      // TODO: check if all supported browser support pointerEvents now
      // NOTE: chrome does not support pointerEvents, but not on svg-nodes
      var webKitSupport = Client.getBrowser() === "safari" && version >= 530;
      if( ffSupport || webKitSupport ) {
        this.setStyleProperty( target, "pointerEvents", value );
        target.setAttribute( "pointerEvents", value );
      } else {
        this._passEventsThrough( target, value );
      }
    },

    setUserSelect : function( target, value ) {
      this.setStyleProperty( target, this._prefixProperty( "userSelect" ), value );
    },

    getUserSelect : function( target ) {
      return this.getOwnProperty( target, this._prefixProperty( "userSelect" ) );
    },

    setTransition : function( target, value ) {
      if( !this._transitionProperty ) {
        // TODO [tb] : Find a more general solution for transitions and/or style support tests
        this._transitionProperty = "transition";
        var dummy = document.createElement( "div" );
        if( !( "transition" in dummy.style ) ) {
          if( "MozTransition" in dummy.style ) {
            this._transitionProperty = "MozTransition";
          } else if( "webkitTransition" in dummy.style  ) {
            this._transitionProperty = "webkitTransition";
          }
        }
      }
      this.setStyleProperty( target, this._transitionProperty, value );
    },

    setStyleProperty : function( target, property, value ) {
      if( target.setStyleProperty ) {
        target.setStyleProperty( property, value );
      } else {
        target.style[ property ] = value;
      }
    },

    removeStyleProperty : function( target, property ) {
      if( target instanceof rwt.widgets.base.Widget ) {
        target.removeStyleProperty( property );
      } else {
        target.style[ property ] = "";
      }
    },

    getOwnProperty : function( target, property ) {
      if( target.getStyleProperty ) {
        target.getStyleProperty( property );
      } else {
        return target.style[ property ];
      }
    },

    //////////
    // Private

    _prefixProperty : function( property ) {
      if( this.VENDOR_PREFIX_PROPERTY ) {
        return this.VENDOR_PREFIX_PROPERTY + rwt.util.Strings.toFirstUp( property );
      }
      return property;
    },

    _updateBackground : function( target ) {
      var background = [];
      this._pushBackgroundImage( target, background );
      this._pushBackgroundGradient( target, background );
      this._pushBackgroundColor( target, background );
      if( background.length > 0 ) {
        this.setStyleProperty( target, "background", background.join( ", " ) );
        // Set background size as separate backgroundSize property for Firefox compatibility
        // http://stackoverflow.com/questions/7864448/background-size-in-shorthand-background-property-css3
        if( target.___rwtStyle__backgroundImage && target.___rwtStyle__backgroundSize ) {
          this.setStyleProperty( target, "backgroundSize", target.___rwtStyle__backgroundSize );
        }
      } else {
        this._clearCssBackground( target );
      }
    },

    _pushBackgroundImage : function( target, backgroundArray ) {
      var value = target.___rwtStyle__backgroundImage;
      if( value ) {
        var repeat = target.___rwtStyle__backgroundRepeat;
        var position = target.___rwtStyle__backgroundPosition;
        backgroundArray.push( this._getImageString( value, repeat, position ) );
      }
    },

    _pushBackgroundGradient : function( target, backgroundArray ) {
      var value = target.___rwtStyle__backgroundGradient;
      if( value && !target.___rwtStyle__backgroundImage ) {
        backgroundArray.push( this._getGradientString( value ) );
      }
    },

    _pushBackgroundColor : function( target, backgroundArray ) {
      var value = target.___rwtStyle__backgroundColor;
      if( value ) {
        if( ( Client.isWebkit() || Client.isBlink() ) && !target.___rwtStyle__backgroundGradient ) {
          backgroundArray.push( this._getGradientString( [ [ 0, value ], [ 1, value ] ] ) );
        }
        backgroundArray.push( value );
      }
    },

    _getGradientString : rwt.util.Variant.select( "qx.client", {
      // TODO [tb] : Webkit and Gecko now support the default syntax, but will continue to support
      //             their old syntax if prefexied. RAP should use new syntax if possible to be
      //             future proof.
      "webkit|blink" : function( gradientObject ) {
        var args = [ "linear", "left top" ];
        if( gradientObject.horizontal === true ) {
          args.push( "right top" );
        }  else {
          args.push( "left bottom" );
        }
        for( var i = 0; i < gradientObject.length; i++ ) {
          var position = gradientObject[ i ][ 0 ];
          var color = gradientObject[ i ][ 1 ];
          args.push( "color-stop(" + position + "," + color + ")" );
        }
        return this.VENDOR_PREFIX_VALUE + "gradient( " + args.join() + ")";
      },
      "gecko" : function( gradientObject ) {
        var args = [ gradientObject.horizontal === true ? "0deg" : "-90deg" ];
        for( var i = 0; i < gradientObject.length; i++ ) {
          var position = ( gradientObject[ i ][ 0 ] * 100 ) + "%";
          var color = gradientObject[ i ][ 1 ];
          args.push( color + " " + position );
        }
        return this.VENDOR_PREFIX_VALUE + "linear-gradient( " + args.join() + ")";
      },
      "trident" : function( gradientObject ) {
        if( rwt.client.Client.getMajor() === 9 ) {
          return this._getSvgGradientString( gradientObject );
        }
        return this._getDefaultGradientString( gradientObject );
      },
      "default" : function( gradientObject ) {
        return this._getDefaultGradientString( gradientObject );
      }
    } ),

    _getDefaultGradientString : function( gradientObject ) {
      var args = [ gradientObject.horizontal === true ? "90deg" : "180deg" ];
      for( var i = 0; i < gradientObject.length; i++ ) {
        var position = ( gradientObject[ i ][ 0 ] * 100 ) + "%";
        var color = gradientObject[ i ][ 1 ];
        args.push( color + " " + position );
      }
      return "linear-gradient( " + args.join() + ")";
    },

    _getSvgGradientString : function( gradientObject ) {
      var result = [ svgStrings.start ];
      result.push( gradientObject.horizontal ? svgStrings.horizontal : svgStrings.vertical );
      for( var i = 0; i < gradientObject.length; i++ ) {
        result.push( svgStrings.color( gradientObject[ i ] ) );
      }
      result.push( svgStrings.end );
      return result.join( "" );
    },

    _getImageString : function( value, repeat, position ) {
      return   "url(" + this._resolveResource( value ) + ")"
             + ( repeat ? " " + repeat : "" )
             + ( position ? " " + position : "" );
    },

    _clearCssBackground : function( target ) {
      if( Client.isTrident() ) {
        this.setStyleProperty( target, "background", "rgba(0, 0, 0, 0)" );
      } else {
        this.removeStyleProperty( target, "background" );
      }
    },

    /////////
    // Helper

    _passEventsThrough : function( target, value ) {
      // TODO [tb] : This is a very limited implementation that allowes
      // to click "through" the elmement, but won't handle hover and cursor.
      var types = rwt.event.EventHandler._mouseEventTypes;
      var handler = this._passEventThroughHandler;
      if( value === "none" ) {
        this.setStyleProperty( target, "cursor", "default" );
        for( var i = 0; i < types.length; i++ ) {
          target.addEventListener( types[ i ], handler, false );
        }
      } else {
        // TODO
      }
    },

    _passEventThroughHandler : function( domEvent ) {
      var EventHandlerUtil = rwt.event.EventHandlerUtil;
      var domTarget = EventHandlerUtil.getDomTarget( domEvent );
      var type = domEvent.type;
      domTarget.style.display = "none";
      var newTarget
        = document.elementFromPoint( domEvent.clientX, domEvent.clientY );
      domEvent.cancelBubble = true;
      EventHandlerUtil.stopDomEvent( domEvent );
      if(    newTarget
          && type !== "mousemove"
          && type !== "mouseover"
          && type !== "mouseout" )
      {
        if( type === "mousedown" ) {
          rwt.html.Style._refireEvent( newTarget, "mouseover", domEvent );
        }
        rwt.html.Style._refireEvent( newTarget, type, domEvent );
        if( type === "mouseup" ) {
          rwt.html.Style._refireEvent( newTarget, "mouseout", domEvent );
        }
      }
      domTarget.style.display = "";
    },

    _refireEvent : function( target, type, originalEvent ) {
      var newEvent = document.createEvent( "MouseEvents" );
      newEvent.initMouseEvent( type,
                               true, /* can bubble */
                               true, /* cancelable */
                               originalEvent.view,
                               originalEvent.detail,
                               originalEvent.screenX,
                               originalEvent.screenY,
                               originalEvent.clientX,
                               originalEvent.clientY,
                               originalEvent.ctrlKey,
                               originalEvent.altKey,
                               originalEvent.shiftKey,
                               originalEvent.metaKey,
                               originalEvent.button,
                               originalEvent.relatedTarget);
      target.dispatchEvent( newEvent );
    },

    _resolveResource : function( url ) {
      return url;
    }

  }

} );

var svgStrings = {
  "start" :   "url(\"data:image/svg+xml;charset=utf-8,"
            + encodeURIComponent( "<svg xmlns='http://www.w3.org/2000/svg'>" ),
  "vertical" : encodeURIComponent( "<linearGradient id='g' x2='0' y2='1'>" ),
  "horizontal" : encodeURIComponent( "<linearGradient id='g'>" ),
  "color" : function( stopColor ) {
    return encodeURIComponent(   "<stop offset='"
                               + ( stopColor[ 0 ] * 100 )
                               +"%' stop-color='"
                               + stopColor[ 1 ]
                               + "'/>" );
  },
  "end" :   encodeURIComponent( "</linearGradient><rect fill='url(#g)' " )
          + encodeURIComponent( "width='100%' height='100%'/></svg>" )
          + "\")"
};

}() );

/*******************************************************************************
 * Copyright (c) 2004, 2015 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

/**
 * Contains methods to control and query the element's overflow properties.
 */
rwt.qx.Class.define("rwt.html.Overflow",
{
  /*
  *****************************************************************************
     STATICS
  *****************************************************************************
  */

  statics :
  {

    // Mozilla notes (http://developer.mozilla.org/en/docs/Mozilla_CSS_Extensions):
    // -moz-scrollbars-horizontal: Indicates that horizontal scrollbars should
    //    always appear and vertical scrollbars should never appear.
    // -moz-scrollbars-vertical: Indicates that vertical scrollbars should
    //    always appear and horizontal scrollbars should never appear.
    // -moz-scrollbars-none: Indicates that no scrollbars should appear but
    //    the element should be scrollable from script. (This is the same as
    //    hidden, and has been since Mozilla 1.6alpha.)
    //
    // Also a lot of interesting bugs:
    // * https://bugzilla.mozilla.org/show_bug.cgi?id=42676
    // * https://bugzilla.mozilla.org/show_bug.cgi?id=47710
    // * https://bugzilla.mozilla.org/show_bug.cgi?id=235524

    /**
     * Returns the computed value of the horizontal overflow
     *
     * @type static
     * @signature function(element, mode)
     * @param element {Element} DOM element to query
     * @param mode {Number} Choose one of the modes {@link rwt.html.Style#COMPUTED_MODE},
     *   {@link rwt.html.Style#CASCADED_MODE}, {@link rwt.html.Style#LOCAL_MODE}.
     *   The computed mode is the default one.
     * @return {String} computed overflow value
     */
    getX : rwt.util.Variant.select("qx.client",
    {
      // gecko support differs
      "gecko" : rwt.client.Client.getVersion() < 1.8 ?

      // older geckos do not support overflowX
      // it's also more safe to translate hidden to -moz-scrollbars-none
      // because of issues in older geckos
      function( element ) {
        var overflow = rwt.html.Style.get( element, "overflow" );

        if (overflow === "-moz-scrollbars-none") {
          overflow = "hidden";
        }

        return overflow;
      } :

      // gecko >= 1.8 supports overflowX, too
      function( element ) {
        return rwt.html.Style.get( element, "overflowX" );
      },

      // use native overflowX property
      "default" : function( element ) {
        return rwt.html.Style.get( element, "overflowX" );
      }
    }),




    /**
     * Returns the computed value of the vertical overflow
     *
     * @type static
     * @signature function(element, mode)
     * @param element {Element} DOM element to query
     * @param mode {Number} Choose one of the modes {@link rwt.html.Style#COMPUTED_MODE},
     *   {@link rwt.html.Style#CASCADED_MODE}, {@link rwt.html.Style#LOCAL_MODE}.
     *   The computed mode is the default one.
     * @return {String} computed overflow value
     */
    getY : rwt.util.Variant.select("qx.client",
    {
      // gecko support differs
      "gecko" : rwt.client.Client.getVersion() < 1.8 ?

      // older geckos do not support overflowY
      // it's also more safe to translate hidden to -moz-scrollbars-none
      // because of issues in older geckos
      function(element, mode)
      {
        var overflow = rwt.html.Style.get(element, "overflow", mode, false);

        if (overflow === "-moz-scrollbars-none") {
          overflow = "hidden";
        }

        return overflow;
      } :

      // gecko >= 1.8 supports overflowY, too
      function( element ) {
        return rwt.html.Style.get(element, "overflowY" );
      },

      // use native overflowY property
      "default" : function( element ) {
        return rwt.html.Style.get(element, "overflowY" );
      }
    })

  }
});

/*******************************************************************************
 * Copyright (c) 2004, 2014 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

/** This singleton manage stuff around image handling. */
rwt.qx.Class.define( "rwt.html.ImageManager", {

  extend : rwt.qx.Target,

  statics : {

    getInstance : function() {
      return rwt.runtime.Singletons.get( rwt.html.ImageManager );
    }

  },

  /*
  *****************************************************************************
     CONSTRUCTOR
  *****************************************************************************
  */

  construct : function()
  {
    this.base(arguments);

    this.__visible = {};
    this.__all = {};
  },





  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {
    /**
     * Register an image.
     * Gives the application the possibility to preload images.
     *
     * @type member
     * @param source {String} The incoming (unresolved) URL.
     * @return {void}
     */
    add : function(source)
    {
      var data = this.__all;

      if (data[source] === undefined) {
        data[source] = 1;
      } else {
        data[source]++;
      }
    },


    /**
     * Register an image.
     * Gives the application the possibility to preload images.
     *
     * @type member
     * @param source {String} The incoming (unresolved) URL.
     * @return {void}
     */
    remove : function(source)
    {
      var data = this.__all;

      if (data[source] !== undefined) {
        data[source]--;
      }

      if (data[source] <= 0) {
        delete data[source];
      }
    },


    /**
     * Register an visible image.
     * Gives the application the possibility to preload visible images.
     *
     * @type member
     * @param source {String} The incoming (unresolved) URL.
     * @return {void}
     */
    show : function(source)
    {
      var data = this.__visible;
      if (data[source] === undefined) {
        data[source] = 1;
      } else {
        data[source]++;
      }
    },


    /**
     * Register an image and reduce the visible counter
     * Warning: Only use after using show() before
     *
     * @type member
     * @param source {String} The incoming (unresolved) URL.
     * @return {void}
     */
    hide : function(source)
    {
      var data = this.__visible;

      if (data[source] !== undefined) {
        data[source]--;
      }

      if (data[source]<=0) {
        delete data[source];
      }
    },


    /**
     * Returns a map with the sources of all visible images
     *
     * @type member
     * @return {Map} Map with sources of all visible images
     */
    getVisibleImages : function()
    {
      var visible = this.__visible;
      var list = {};

      for (var source in visible)
      {
        if (visible[source] > 0) {
          list[source] = true;
        }
      }

      return list;
    },


    /**
     * Returns a map with the sources of all hidden images
     *
     * @type member
     * @return {Map} Map with sources of all hidden images
     */
    getHiddenImages : function()
    {
      var visible = this.__visible;
      var all = this.__all;
      var list = {};

      for (var source in all)
      {
        if (visible[source] === undefined) {
          list[source] = true;
        }
      }

      return list;
    }
  },





  /*
  *****************************************************************************
     DESTRUCTOR
  *****************************************************************************
  */

  destruct : function() {
    this._disposeFields("__all", "__visible");
  }
});

/*******************************************************************************
 * Copyright (c) 2004, 2013 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

rwt.qx.Class.define("rwt.html.Offset",
{
  /*
  *****************************************************************************
     STATICS
  *****************************************************************************
  */

  statics :
  {
    /*
    Mozilla seems to be a little buggy here.
    Mozilla/5.0 (Windows; U; Windows NT 5.1; de-DE; rv:1.7.5) Gecko/20041108 Firefox/1.0

    It calculates some borders and/or paddings to the offsetProperties.
    */

    /**
     * TODOC
     *
     * @type static
     * @param vElement {var} TODOC
     * @return {void}
     * @signature function(el)
     */
    getLeft : rwt.util.Variant.select("qx.client",
    {
      "gecko" : function(el)
      {
        var val = el.offsetLeft;
        var pa = el.parentNode;

        var pose = rwt.html.Style.getStyleProperty(el, "position");
        var posp = rwt.html.Style.getStyleProperty(pa, "position");

        // If element is positioned non-static: Substract the border of the element
        if (pose != "absolute" && pose != "fixed") {
          val -= rwt.html.Style.getBorderLeft(pa);
        }

        // If parent is positioned static: Substract the border of the first
        // parent element which is ab positioned non-static.
        if (posp != "absolute" && posp != "fixed")
        {
          while (pa)
          {
            pa = pa.parentNode;

            if (!pa || typeof pa.tagName !== "string") {
              break;
            }

            var posi = rwt.html.Style.getStyleProperty(pa, "position");

            if (posi == "absolute" || posi == "fixed")
            {
              val -= rwt.html.Style.getBorderLeft(pa) + rwt.html.Style.getPaddingLeft(pa);
              break;
            }
          }
        }

        return val;
      },

      "default" : function(el) {
        return el.offsetLeft;
      }
    }),


    /**
     * TODOC
     *
     * @type static
     * @param vElement {var} TODOC
     * @return {void}
     * @signature function(el)
     */
    getTop  : rwt.util.Variant.select("qx.client",
    {
      "gecko" : function(el)
      {
        var val = el.offsetTop;
        var pa = el.parentNode;

        var pose = rwt.html.Style.getStyleProperty(el, "position");
        var posp = rwt.html.Style.getStyleProperty(pa, "position");

        // If element is positioned non-static: Substract the border of the element
        if (pose != "absolute" && pose != "fixed") {
          val -= rwt.html.Style.getBorderTop(pa);
        }

        // If parent is positioned static: Substract the border of the first
        // parent element which is ab positioned non-static.
        if (posp != "absolute" && posp != "fixed")
        {
          while (pa)
          {
            pa = pa.parentNode;

            if (!pa || typeof pa.tagName !== "string") {
              break;
            }

            var posi = rwt.html.Style.getStyleProperty(pa, "position");

            if (posi == "absolute" || posi == "fixed")
            {
              val -= rwt.html.Style.getBorderTop(pa) + rwt.html.Style.getPaddingTop(pa);
              break;
            }
          }
        }

        return val;
      },

      "default" : function(el) {
        return el.offsetTop;
      }
    })
  }
});

/*******************************************************************************
 * Copyright (c) 2004, 2014 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

// Internet Explorer has invented scrollIntoView, but does not behave the same like in Mozilla (which would be better)
// Mozilla has a native well working method scrollIntoView
// Safari does not support scrollIntoView (but it can be found in Webkit since May 2005)
// Opera does not support scrollIntoView

namespace( "rwt.html" );

/**
 * Functions to scroll DOM elements into the visible area of the parent element
 */
rwt.html.ScrollIntoView = {

  /**
   * Scroll the parent DOM element so that the element's so that the x coordinate is inside
   * the visible area of the parent.
   *
   * @type static
   * @param vElement {Element} DOM node to be scrolled into view
   * @param vAlignLeft {Boolean?false} whether the element should be left aligned
   * @return {Boolean} Whether the element could be scrolled into the view
   */
  scrollX : function( vElement, vAlignLeft ) {
    var vHasScroll;
    var vParent = vElement.parentNode;
    var vOffset = vElement.offsetLeft;
    var vWidth = vElement.offsetWidth;
    while( vParent ) {
      switch( rwt.html.Style.getStyleProperty( vParent, "overflow" ) ) {
        case "scroll":
        case "auto":
        case "-moz-scrollbars-horizontal":
          vHasScroll = true;
          break;
        default:
          switch( rwt.html.Style.getStyleProperty( vParent, "overflowX" ) ) {
            case "scroll":
            case "auto":
              vHasScroll = true;
              break;
            default:
              vHasScroll = false;
          }
      }
      if( vHasScroll ) {
        var vParentWidth = vParent.clientWidth;
        var vParentScrollLeft = vParent.scrollLeft;
        var scrollable = vParent.rwtScrollable;
        var scrollBarWidth = scrollable ? scrollable.getVerticalBarWidth() : 0;
        if( vAlignLeft ) {
          vParent.scrollLeft = vOffset;
        } else if( vAlignLeft === false ) {
          vParent.scrollLeft = vOffset + vWidth - vParentWidth + scrollBarWidth;
        } else if( vWidth > vParentWidth || vOffset < vParentScrollLeft ) {
          vParent.scrollLeft = vOffset;
        } else if( vOffset + vWidth >= vParentScrollLeft + vParentWidth ) {
          vParent.scrollLeft = vOffset + vWidth - vParentWidth + scrollBarWidth;
        }
        vOffset = vParent.offsetLeft;
        vWidth = vParent.offsetWidth;
      } else {
        vOffset += vParent.offsetLeft;
      }
      if( vParent.tagName.toLowerCase() == "body" ) {
        break;
      }
      vParent = vParent.offsetParent;
    }
    return true;
  },

  /**
   * Scroll the parent DOM element so that the element's so that the y coordinate is inside
   * the visible area of the parent.
   *
   * @type static
   * @param vElement {Element} DOM node to be scrolled into view
   * @param vAlignTop {Boolean?false} whether the element should be top aligned
   * @return {Boolean} Whether the element could be scrolled into the view
   */
  scrollY : function( vElement, vAlignTop ) {
    var vHasScroll;
    var vParent = vElement.parentNode;
    var vOffset = vElement.offsetTop;
    var vHeight = vElement.offsetHeight;
    while( vParent ) {
      switch( rwt.html.Style.getStyleProperty( vParent, "overflow" ) ) {
        case "scroll":
        case "auto":
        case "-moz-scrollbars-vertical":
          vHasScroll = true;
          break;
        default:
          switch( rwt.html.Style.getStyleProperty( vParent, "overflowY" ) ) {
            case "scroll":
            case "auto":
              vHasScroll = true;
              break;
            default:
              vHasScroll = false;
          }
      }
      if( vHasScroll ) {
        var vParentHeight = vParent.clientHeight;
        var vParentScrollTop = vParent.scrollTop;
        var scrollable = vParent.rwtScrollable;
        var scrollBarHeight = scrollable ? scrollable.getHorizontalBarHeight() : 0;
        if( vAlignTop ) {
          vParent.scrollTop = vOffset;
        } else if( vAlignTop === false ) {
          vParent.scrollTop = vOffset + vHeight - vParentHeight + scrollBarHeight;
        } else if( vHeight > vParentHeight || vOffset < vParentScrollTop ) {
          vParent.scrollTop = vOffset;
        } else if( vOffset + vHeight >= vParentScrollTop + vParentHeight ) {
          vParent.scrollTop = vOffset + vHeight - vParentHeight + scrollBarHeight;
        }
        vOffset = vParent.offsetTop;
        vHeight = vParent.offsetHeight;
      } else {
        vOffset += vParent.offsetTop;
      }
      if( vParent.tagName.toLowerCase() == "body" ) {
        break;
      }
      vParent = vParent.offsetParent;
    }
    return true;
  }

};

/*******************************************************************************
 * Copyright (c) 2004, 2014 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

rwt.qx.Class.define("rwt.widgets.base.BoxLayout",
{
  extend : rwt.widgets.base.Parent,




  /*
  *****************************************************************************
     CONSTRUCTOR
  *****************************************************************************
  */

  /**
   * @param orientation {String} Initial value for {@link #orientation}.
   */
  construct : function(orientation)
  {
    this.base(arguments);

    // apply orientation
    if (orientation != null) {
      this.setOrientation(orientation);
    } else {
      this.initOrientation();
    }
  },




  /*
  *****************************************************************************
     STATICS
  *****************************************************************************
  */

  statics : {
    STR_REVERSED : "-reversed"
  },




  /*
  *****************************************************************************
     PROPERTIES
  *****************************************************************************
  */

  properties :
  {
    /** The orientation of the layout control. */
    orientation :
    {
      check : [ "horizontal", "vertical" ],
      init : "horizontal",
      apply : "_applyOrientation",
      event : "changeOrientation"
    },


    /** The spacing between childrens. Could be any positive integer value. */
    spacing :
    {
      check : "Integer",
      init : 0,
      themeable : true,
      apply : "_applySpacing",
      event : "changeSpacing"
    },


    /** The horizontal align of the children. Allowed values are: "left", "center" and "right" */
    horizontalChildrenAlign :
    {
      check : [ "left", "center", "right" ],
      init : "left",
      themeable : true,
      apply : "_applyHorizontalChildrenAlign"
    },


    /** The vertical align of the children. Allowed values are: "top", "middle" and "bottom" */
    verticalChildrenAlign :
    {
      check : [ "top", "middle", "bottom" ],
      init : "top",
      themeable : true,
      apply : "_applyVerticalChildrenAlign"
    },


    /** Should the children be layouted in reverse order? */
    reverseChildrenOrder :
    {
      check : "Boolean",
      init : false,
      apply : "_applyReverseChildrenOrder"
    },


    /**
     * Should the widgets be stretched to the available width (orientation==vertical) or height (orientation==horizontal)?
     *  This only applies if the child has not configured a own value for this axis.
     */
    stretchChildrenOrthogonalAxis :
    {
      check : "Boolean",
      init : true,
      apply : "_applyStretchChildrenOrthogonalAxis"
    },


    /**
     * If there are min/max values in combination with flex try to optimize placement.
     *  This is more complex and produces more time for the layouter but sometimes this feature is needed.
     */
    useAdvancedFlexAllocation :
    {
      check : "Boolean",
      init : false,
      apply : "_applyUseAdvancedFlexAllocation"
    },




    /*
    ---------------------------------------------------------------------------
      ACCUMULATED CHILDREN WIDTH/HEIGHT
    --------------------------------------------------------------------------------

      Needed for center/middle and right/bottom alignment

    ---------------------------------------------------------------------------
    */

    accumulatedChildrenOuterWidth :
    {
      _cached      : true,
      defaultValue : null
    },

    accumulatedChildrenOuterHeight :
    {
      _cached      : true,
      defaultValue : null
    }
  },




  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {
    /*
    ---------------------------------------------------------------------------
      INIT LAYOUT IMPL
    ---------------------------------------------------------------------------
    */

    /**
     * This creates an new instance of the layout impl this widget uses
     *
     * @type member
     * @return {rwt.widgets.base.BoxLayout} TODOC
     */
    _createLayoutImpl : function() {
      return this.getOrientation() == "vertical" ? new rwt.widgets.util.VerticalBoxLayoutImpl(this) : new rwt.widgets.util.HorizontalBoxLayoutImpl(this);
    },




    /*
    ---------------------------------------------------------------------------
      HELPERS
    ---------------------------------------------------------------------------
    */

    _layoutHorizontal : false,
    _layoutVertical : false,
    _layoutMode : "left",


    /**
     * TODOC
     *
     * @type member
     * @return {var} TODOC
     */
    isHorizontal : function() {
      return this._layoutHorizontal;
    },


    /**
     * TODOC
     *
     * @type member
     * @return {var} TODOC
     */
    isVertical : function() {
      return this._layoutVertical;
    },


    /**
     * TODOC
     *
     * @type member
     * @return {var} TODOC
     */
    getLayoutMode : function()
    {
      if (this._layoutMode == null) {
        this._updateLayoutMode();
      }

      return this._layoutMode;
    },


    /**
     * TODOC
     *
     * @type member
     * @return {void}
     */
    _updateLayoutMode : function()
    {
      this._layoutMode = this._layoutVertical ? this.getVerticalChildrenAlign() : this.getHorizontalChildrenAlign();

      if (this.getReverseChildrenOrder()) {
        this._layoutMode += rwt.widgets.base.BoxLayout.STR_REVERSED;
      }
    },


    /**
     * TODOC
     *
     * @type member
     * @return {void}
     */
    _invalidateLayoutMode : function() {
      this._layoutMode = null;
    },




    /*
    ---------------------------------------------------------------------------
      MODIFIERS
    ---------------------------------------------------------------------------
    */

    /**
     * TODOC
     *
     * @type member
     * @param value {var} Current value
     * @param old {var} Previous value
     * @return {var} TODOC
     */
    _applyOrientation : function(value, old)
    {
      // update fast access variables
      this._layoutHorizontal = value == "horizontal";
      this._layoutVertical = value == "vertical";

      // Layout Implementation
      if (this._layoutImpl)
      {
        this._layoutImpl.dispose();
        this._layoutImpl = null;
      }

      if (value) {
        this._layoutImpl = this._createLayoutImpl();
      }

      // call layout helper
      this._doLayoutOrder(value, old);

      this.addToQueueRuntime("orientation");
    },

    _applySpacing : function()
    {
      this._doLayout();
      this.addToQueueRuntime("spacing");
    },

    _applyHorizontalChildrenAlign : function()
    {
      this._doLayoutOrder();
      this.addToQueueRuntime("horizontalChildrenAlign");
    },

    _applyVerticalChildrenAlign : function()
    {
      this._doLayoutOrder();
      this.addToQueueRuntime("verticalChildrenAlign");
    },

    _applyReverseChildrenOrder : function()
    {
      this._doLayoutOrder();
      this.addToQueueRuntime("reverseChildrenOrder");
    },

    _applyStretchChildrenOrthogonalAxis : function() {
      this.addToQueueRuntime("stretchChildrenOrthogonalAxis");
    },

    _applyUseAdvancedFlexAllocation : function() {
      this.addToQueueRuntime("useAdvancedFlexAllocation");
    },



    /**
     * TODOC
     *
     * @type member
     * @param value {var} Current value
     * @param old {var} Previous value
     * @return {var} TODOC
     */
    _doLayoutOrder : function()
    {
      // update layout mode
      this._invalidateLayoutMode();

      // call doLayout
      this._doLayout();
    },


    /**
     * TODOC
     *
     * @type member
     * @param value {var} Current value
     * @param old {var} Previous value
     */
    _doLayout : function()
    {
      // invalidate inner preferred dimensions
      this._invalidatePreferredInnerDimensions();

      // accumulated width needs to be invalidated
      this._invalidateAccumulatedChildrenOuterWidth();
      this._invalidateAccumulatedChildrenOuterHeight();
    },


    /**
     * TODOC
     *
     * @type member
     * @return {String} TODOC
     */
    _computeAccumulatedChildrenOuterWidth : function() {
      var children = this.getVisibleChildren();
      var spacing = this.getSpacing();
      var result = -spacing;
      var i = 0;
      var child = children[ i ];
      while( child != null ) {
        result += child.getOuterWidth() + spacing;
        i++;
        child = children[ i ];
      }
      return result;
    },


    /**
     * TODOC
     *
     * @type member
     * @return {String} TODOC
     */
    _computeAccumulatedChildrenOuterHeight : function()
    {
      var ch = this.getVisibleChildren(), chc, i = -1, sp = this.getSpacing(), s = -sp;

      chc = ch[++i];
      while( chc ) {
        s += chc.getOuterHeight() + sp;
        chc = ch[++i];
      }

      return s;
    },




    /*
    ---------------------------------------------------------------------------
      STRETCHING SUPPORT
    ---------------------------------------------------------------------------
    */

    /**
     * TODOC
     *
     * @type member
     * @return {void}
     */
    _recomputeChildrenStretchingX : function()
    {
      var ch = this.getVisibleChildren(), chc, i = -1;

      chc = ch[++i];
      while( chc ) {
        if (chc._recomputeStretchingX() && chc._recomputeBoxWidth()) {
          chc._recomputeOuterWidth();
        }
        chc = ch[++i];
      }
    },


    /**
     * TODOC
     *
     * @type member
     * @return {void}
     */
    _recomputeChildrenStretchingY : function()
    {
      var ch = this.getVisibleChildren(), chc, i = -1;

      chc = ch[++i];
      while( chc ) {
        if (chc._recomputeStretchingY() && chc._recomputeBoxHeight()) {
          chc._recomputeOuterHeight();
        }
        chc = ch[++i];
      }
    }
  }
});

/*******************************************************************************
 * Copyright (c) 2004, 2015 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

rwt.qx.Class.define("rwt.widgets.util.VerticalBoxLayoutImpl",
{
  extend : rwt.widgets.util.LayoutImpl,




  /*
  *****************************************************************************
     PROPERTIES
  *****************************************************************************
  */

  properties :
  {
    enableFlexSupport :
    {
      check : "Boolean",
      init : true
    }
  },




  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {
    /*
    ---------------------------------------------------------------------------
      [01] COMPUTE BOX DIMENSIONS FOR AN INDIVIDUAL CHILD
    ---------------------------------------------------------------------------
    */

    /** Compute and return the box width of the given child. */
    /**
     * Global Structure:
     *  [01] COMPUTE BOX DIMENSIONS FOR AN INDIVIDUAL CHILD
     *  [02] COMPUTE NEEDED DIMENSIONS FOR AN INDIVIDUAL CHILD
     *  [03] COMPUTE NEEDED DIMENSIONS FOR ALL CHILDREN
     *  [04] UPDATE LAYOUT WHEN A CHILD CHANGES ITS OUTER DIMENSIONS
     *  [05] UPDATE CHILD ON INNER DIMENSION CHANGES OF LAYOUT
     *  [06] UPDATE LAYOUT ON JOB QUEUE FLUSH
     *  [07] UPDATE CHILDREN ON JOB QUEUE FLUSH
     *  [08] CHILDREN ADD/REMOVE/MOVE HANDLING
     *  [09] FLUSH LAYOUT QUEUES OF CHILDREN
     *  [10] LAYOUT CHILD
     *
     *  Inherits from rwt.widgets.util.LayoutImpl:
     *  [02] COMPUTE NEEDED DIMENSIONS FOR AN INDIVIDUAL CHILD
     *
     * @type member
     * @param vChild {var} TODOC
     * @return {var} TODOC
     */
    computeChildBoxWidth : function(vChild)
    {
      if (this.getWidget().getStretchChildrenOrthogonalAxis() && vChild._computedWidthTypeNull && vChild.getAllowStretchX()) {
        return this.getWidget().getInnerWidth();
      }

      return vChild.getWidthValue() || vChild._computeBoxWidthFallback();
    },


    /**
     * Compute and return the box height of the given child.
     *
     * @type member
     * @param vChild {var} TODOC
     * @return {var} TODOC
     */
    computeChildBoxHeight : function(vChild) {
      return vChild.getHeightValue() || vChild._computeBoxHeightFallback();
    },


    /**
     * Computes the height of all flexible children.
     *
     * @type member
     * @return {void}
     */
    computeChildrenFlexHeight : function()
    {
      if (this._childrenFlexHeightComputed || !this.getEnableFlexSupport()) {
        return;
      }

      this._childrenFlexHeightComputed = true;

      var vWidget = this.getWidget();
      var vChildren = vWidget.getVisibleChildren();
      var vChildrenLength = vChildren.length;
      var vCurrentChild;
      var vFlexibleChildren = [];
      var vAvailHeight = vWidget.getInnerHeight();
      var vUsedHeight = vWidget.getSpacing() * (vChildrenLength - 1);
      var vIterator;

      // *************************************************************
      // 1. Compute the sum of all static sized children and finding
      //    all flexible children.
      // *************************************************************
      for (vIterator=0; vIterator<vChildrenLength; vIterator++)
      {
        vCurrentChild = vChildren[vIterator];

        if (vCurrentChild._computedHeightTypeFlex)
        {
          vFlexibleChildren.push(vCurrentChild);

          if (vWidget._computedHeightTypeAuto) {
            vUsedHeight += vCurrentChild.getPreferredBoxHeight();
          }
        }
        else
        {
          vUsedHeight += vCurrentChild.getOuterHeight();
        }
      }

      // *************************************************************
      // 2. Compute the sum of all flexible children heights
      // *************************************************************
      var vRemainingHeight = vAvailHeight - vUsedHeight;
      var vFlexibleChildrenLength = vFlexibleChildren.length;
      var vPrioritySum = 0;

      for (vIterator=0; vIterator<vFlexibleChildrenLength; vIterator++) {
        vPrioritySum += vFlexibleChildren[vIterator]._computedHeightParsed;
      }

      // *************************************************************
      // 3. Calculating the size of each 'part'.
      // *************************************************************
      var vPartHeight = vRemainingHeight / vPrioritySum;

      if (!vWidget.getUseAdvancedFlexAllocation())
      {
        // *************************************************************
        // 4a. Computing the flex height value of each flexible child
        //     and add the height to the usedHeight, so that we can
        //     fix rounding problems later.
        // *************************************************************
        for (vIterator=0; vIterator<vFlexibleChildrenLength; vIterator++)
        {
          vCurrentChild = vFlexibleChildren[vIterator];

          vCurrentChild._computedHeightFlexValue = Math.round(vCurrentChild._computedHeightParsed * vPartHeight);
          vUsedHeight += vCurrentChild._computedHeightFlexValue;
        }
      }
      else
      {
        // *************************************************************
        // 4b. Calculating the diff. Which means respect the min/max
        //     height configuration in flex and store the higher/lower
        //     data in a diff.
        // *************************************************************
        var vAllocationDiff = 0;
        var vMinAllocationLoops, vFlexibleChildrenLength, vAdjust, vCurrentAllocationSum, vFactorSum, vComputedFlexibleHeight;

        for (vIterator=0; vIterator<vFlexibleChildrenLength; vIterator++)
        {
          vCurrentChild = vFlexibleChildren[vIterator];

          vComputedFlexibleHeight = vCurrentChild._computedHeightFlexValue = vCurrentChild._computedHeightParsed * vPartHeight;
          vAllocationDiff += vComputedFlexibleHeight - rwt.util.Numbers.limit(vComputedFlexibleHeight, vCurrentChild.getMinHeightValue(), vCurrentChild.getMaxHeightValue());
        }

        // Rounding diff
        vAllocationDiff = Math.round(vAllocationDiff);

        if( vAllocationDiff === 0 )
        {
          // *************************************************************
          // 5a. If the diff is equal zero we must not do anything more
          //     and do nearly identical the same like in 4a. which means
          //     to round the calculated flex value and add it to the
          //     used height so we can fix rounding problems later.
          // *************************************************************
          // Rounding values and fixing rounding errors
          for (vIterator=0; vIterator<vFlexibleChildrenLength; vIterator++)
          {
            vCurrentChild = vFlexibleChildren[vIterator];

            vCurrentChild._computedHeightFlexValue = Math.round(vCurrentChild._computedHeightFlexValue);
            vUsedHeight += vCurrentChild._computedHeightFlexValue;
          }
        }
        else
        {
          // *************************************************************
          // 5b. Find maximum loops of each adjustable child to adjust
          //     the height until the min/max height limits are reached.
          // *************************************************************
          var vUp = vAllocationDiff > 0;

          for (vIterator=vFlexibleChildrenLength-1; vIterator>=0; vIterator--)
          {
            vCurrentChild = vFlexibleChildren[vIterator];

            if (vUp)
            {
              vAdjust = (vCurrentChild.getMaxHeightValue() || Infinity) - vCurrentChild._computedHeightFlexValue;

              if (vAdjust > 0) {
                vCurrentChild._allocationLoops = Math.floor(vAdjust / vCurrentChild._computedHeightParsed);
              }
              else
              {
                rwt.util.Arrays.removeAt(vFlexibleChildren, vIterator);

                vCurrentChild._computedHeightFlexValue = Math.round(vCurrentChild._computedHeightFlexValue);
                vUsedHeight += Math.round(vCurrentChild._computedHeightFlexValue + vAdjust);
              }
            }
            else
            {
              vAdjust = rwt.util.Numbers.isNumber(vCurrentChild.getMinHeightValue()) ? vCurrentChild._computedHeightFlexValue - vCurrentChild.getMinHeightValue() : vCurrentChild._computedHeightFlexValue;

              if (vAdjust > 0) {
                vCurrentChild._allocationLoops = Math.floor(vAdjust / vCurrentChild._computedHeightParsed);
              }
              else
              {
                rwt.util.Arrays.removeAt(vFlexibleChildren, vIterator);

                vCurrentChild._computedHeightFlexValue = Math.round(vCurrentChild._computedHeightFlexValue);
                vUsedHeight += Math.round(vCurrentChild._computedHeightFlexValue - vAdjust);
              }
            }
          }

          // *************************************************************
          // 6. Try to reallocate the height between flexible children
          //    so that the requirements through min/max limits
          //    are satisfied.
          // *************************************************************
          while( vAllocationDiff !== 0 && vFlexibleChildrenLength > 0 ) {
            vFlexibleChildrenLength = vFlexibleChildren.length;
            vMinAllocationLoops = Infinity;
            vFactorSum = 0;

            // Find minimal loop amount
            for (vIterator=0; vIterator<vFlexibleChildrenLength; vIterator++)
            {
              vMinAllocationLoops = Math.min(vMinAllocationLoops, vFlexibleChildren[vIterator]._allocationLoops);
              vFactorSum += vFlexibleChildren[vIterator]._computedHeightParsed;
            }

            // Be sure that the adjustment is not bigger/smaller than diff
            vCurrentAllocationSum = Math.min(vFactorSum * vMinAllocationLoops, vAllocationDiff);

            // Reducing diff by current sum
            vAllocationDiff -= vCurrentAllocationSum;

            // Adding sizes to children to adjust
            for (vIterator=vFlexibleChildrenLength-1; vIterator>=0; vIterator--)
            {
              vCurrentChild = vFlexibleChildren[vIterator];
              vCurrentChild._computedHeightFlexValue += vCurrentAllocationSum / vFactorSum * vCurrentChild._computedHeightParsed;

              if (vCurrentChild._allocationLoops == vMinAllocationLoops)
              {
                vCurrentChild._computedHeightFlexValue = Math.round(vCurrentChild._computedHeightFlexValue);

                vUsedHeight += vCurrentChild._computedHeightFlexValue;
                delete vCurrentChild._allocationLoops;
                rwt.util.Arrays.removeAt(vFlexibleChildren, vIterator);
              }
              else
              {
                if (vAllocationDiff === 0)
                {
                  vCurrentChild._computedHeightFlexValue = Math.round(vCurrentChild._computedHeightFlexValue);
                  vUsedHeight += vCurrentChild._computedHeightFlexValue;
                  delete vCurrentChild._allocationLoops;
                }
                else
                {
                  vCurrentChild._allocationLoops -= vMinAllocationLoops;
                }
              }
            }
          }
        }
      }

      // *************************************************************
      // 7. Fix rounding errors
      // *************************************************************
      vCurrentChild._computedHeightFlexValue += vAvailHeight - vUsedHeight;
    },


    /**
     * TODOC
     *
     * @type member
     * @return {void}
     */
    invalidateChildrenFlexHeight : function() {
      delete this._childrenFlexHeightComputed;
    },




    /*
    ---------------------------------------------------------------------------
      [03] COMPUTE NEEDED DIMENSIONS FOR ALL CHILDREN
    ---------------------------------------------------------------------------
    */

    /**
     * Compute and return the height needed by all children of this widget
     *
     * @type member
     * @return {var} TODOC
     */
    computeChildrenNeededHeight : function()
    {
      var w = this.getWidget();
      return rwt.widgets.util.LayoutImpl.prototype.computeChildrenNeededHeight_sum.call(this) + ((w.getVisibleChildrenLength() - 1) * w.getSpacing());
    },




    /*
    ---------------------------------------------------------------------------
      [04] UPDATE LAYOUT WHEN A CHILD CHANGES ITS OUTER DIMENSIONS
    ---------------------------------------------------------------------------
    */

    /**
     * Things to do and layout when any of the childs changes its outer height.
     *  Needed by layouts where the children depends on each-other, like flow- or box-layouts.
     *
     * @type member
     * @param vChild {var} TODOC
     * @return {void}
     */
    updateSelfOnChildOuterHeightChange : function()
    {
      // if a childrens outer height changes we need to update our accumulated
      // height of all childrens (used for middle or bottom alignments)
      this.getWidget()._invalidateAccumulatedChildrenOuterHeight();
    },




    /*
    ---------------------------------------------------------------------------
      [05] UPDATE CHILD ON INNER DIMENSION CHANGES OF LAYOUT
    ---------------------------------------------------------------------------
    */

    /**
     * Actions that should be done if the inner width of the widget was changed.
     *  Normally this includes update to percent values and ranges.
     *
     * @type member
     * @param vChild {var} TODOC
     * @return {boolean} TODOC
     */
    updateChildOnInnerWidthChange : function(vChild)
    {
      // use variables here to be sure to call both methods.
      var vUpdatePercent = vChild._recomputePercentX();
      var vUpdateStretch = vChild._recomputeStretchingX();

      // priority to childs internal alignment
      if ((vChild.getHorizontalAlign() || this.getWidget().getHorizontalChildrenAlign()) == "center") {
        vChild.addToLayoutChanges("locationX");
      }

      // inform the caller if there were any notable changes occured
      return vUpdatePercent || vUpdateStretch;
    },


    /**
     * Actions that should be done if the inner height of the widget was changed.
     *  Normally this includes update to percent values and ranges.
     *
     * @type member
     * @param vChild {var} TODOC
     * @return {boolean} TODOC
     */
    updateChildOnInnerHeightChange : function(vChild)
    {
      if (this.getWidget().getVerticalChildrenAlign() == "middle") {
        vChild.addToLayoutChanges("locationY");
      }

      // use variables here to be sure to call both methods.
      var vUpdatePercent = vChild._recomputePercentY();
      var vUpdateFlex = vChild._recomputeFlexY();

      // inform the caller if there were any notable changes occured
      return vUpdatePercent || vUpdateFlex;
    },




    /*
    ---------------------------------------------------------------------------
      [06] UPDATE LAYOUT ON JOB QUEUE FLUSH
    ---------------------------------------------------------------------------
    */

    /**
     * Invalidate and recompute things because of job in queue (before the rest of job handling will be executed).
     *
     * @type member
     * @param vJobQueue {var} TODOC
     * @return {void}
     */
    updateSelfOnJobQueueFlush : function(vJobQueue)
    {
      if (vJobQueue.addChild || vJobQueue.removeChild) {
        this.getWidget()._invalidateAccumulatedChildrenOuterHeight();
      }
    },




    /*
    ---------------------------------------------------------------------------
      [07] UPDATE CHILDREN ON JOB QUEUE FLUSH
    ---------------------------------------------------------------------------
    */

    /**
     * Updates children on special jobs
     *
     * @type member
     * @param vQueue {var} TODOC
     * @return {boolean}
     */
    updateChildrenOnJobQueueFlush : function(vQueue)
    {
      var vStretchX = false, vStretchY = false;
      var vWidget = this.getWidget();

      // switching the orientation need updates for stretching on both axis
      if (vQueue.orientation) {
        vStretchX = vStretchY = true;
      }

      // different updates depending from the current orientation (or the new one)
      if (vQueue.spacing || vQueue.orientation || vQueue.reverseChildrenOrder || vQueue.verticalChildrenAlign) {
        vWidget._addChildrenToLayoutQueue("locationY");
      }

      if (vQueue.horizontalChildrenAlign) {
        vWidget._addChildrenToLayoutQueue("locationX");
      }

      if (vQueue.stretchChildrenOrthogonalAxis) {
        vStretchX = true;
      }

      // if stretching should be reworked reset the previous one and add
      // a layout job to update the width respectively height.
      if (vStretchX)
      {
        vWidget._recomputeChildrenStretchingX();
        vWidget._addChildrenToLayoutQueue("width");
      }

      if (vStretchY)
      {
        vWidget._recomputeChildrenStretchingY();
        vWidget._addChildrenToLayoutQueue("height");
      }

      return true;
    },




    /*
    ---------------------------------------------------------------------------
      [08] CHILDREN ADD/REMOVE/MOVE HANDLING
    ---------------------------------------------------------------------------
    */

    /**
     * This method combines calls of methods which should be done if a widget should be removed from the current layout.
     *  Needed by layouts where the children depends on each-other, like flow- or box-layouts.
     *
     * @type member
     * @param vChild {var} TODOC
     * @param vIndex {var} TODOC
     * @return {void}
     */
    updateChildrenOnRemoveChild : function( vChild, vIndex ) {
      var w = this.getWidget();
      var ch = w.getVisibleChildren();
      var chl = ch.length;
      var chc;
      var i = -1;
      // Fix index to be at the first flex child
      if( this.getEnableFlexSupport() )
      {
        for (var i=0; i<chl; i++)
        {
          chc = ch[i];

          if (chc.getHasFlexY())
          {
            vIndex = Math.min(vIndex, i);
            break;
          }
        }

        i = -1;
      }

      // Handle differently depending on layout mode
      switch(w.getLayoutMode())
      {
        case "bottom":
        case "top-reversed":
          while ((chc = ch[++i]) && i < vIndex) {
            chc.addToLayoutChanges("locationY");
          }

          break;

        case "middle":
        case "middle-reversed":
          chc = ch[++i];
          while( chc ) {
            chc.addToLayoutChanges("locationY");
            chc = ch[++i];
          }

          break;

        default:
          i += vIndex;

          chc = ch[++i];
          while( chc ) {
            chc.addToLayoutChanges("locationY");
            chc = ch[++i];
          }
      }
    },


    /**
     * This method combines calls of methods which should be done if a child should be moved
     *  inside the same parent to a new positions.
     *  Needed by layouts where the children depends on each-other, like flow- or box-layouts.
     *
     * @type member
     * @param vChild {var} TODOC
     * @param vIndex {var} TODOC
     * @param vOldIndex {var} TODOC
     * @return {void}
     */
    updateChildrenOnMoveChild : function(vChild, vIndex, vOldIndex)
    {
      var vChildren = this.getWidget().getVisibleChildren();

      var vStart = Math.min(vIndex, vOldIndex);
      var vStop = Math.max(vIndex, vOldIndex) + 1;
      vStop = Math.min(vChildren.length, vStop);

      for (var i=vStart; i<vStop; i++) {
        vChildren[i].addToLayoutChanges("locationY");
      }
    },




    /*
    ---------------------------------------------------------------------------
      [09] FLUSH LAYOUT QUEUES OF CHILDREN
    ---------------------------------------------------------------------------
    */

    /**
     * This method have full control of the order in which the
     *  registered (or also non-registered) children should be
     *  layouted on the horizontal axis.
     *
     * @type member
     * @param vChildrenQueue {var} TODOC
     * @return {void}
     */
    flushChildrenQueue : function(vChildrenQueue)
    {
      var w = this.getWidget(), ch = w.getVisibleChildren(), chl = ch.length, chc, i;

      // This block is needed for flex handling and
      // will inform flex children if there was any
      // change to the other content
      if (this.getEnableFlexSupport())
      {
        this.invalidateChildrenFlexHeight();

        for (i=0; i<chl; i++)
        {
          chc = ch[i];

          if (chc.getHasFlexY())
          {
            chc._computedHeightValue = null;

            if (chc._recomputeBoxHeight())
            {
              chc._recomputeOuterHeight();
              chc._recomputeInnerHeight();
            }

            vChildrenQueue[chc.toHashCode()] = chc;
            chc._layoutChanges.height = true;
          }
        }
      }

      switch(w.getLayoutMode())
      {
        case "bottom":
        case "top-reversed":
          // find the last child which has a layout request
          for (var i=chl-1; i>=0&&!vChildrenQueue[ch[i].toHashCode()]; i--) {}

          // layout all children before this last child
          for (var j=0; j<=i; j++) {
            w._layoutChild(chc = ch[j]);
          }

          break;

        case "middle":
        case "middle-reversed":
          // re-layout all children
          i = -1;

          chc = ch[++i];
          while( chc ) {
            w._layoutChild(chc);
            chc = ch[++i];
          }

          break;

        default:
          // layout all childs from the first child
          // with an own layout request to the end
          i = -1;
          var changed = false;

          chc = ch[++i];
          while( chc ) {
            if (changed || vChildrenQueue[chc.toHashCode()])
            {
              w._layoutChild(chc);
              changed = true;
            }
            chc = ch[++i];
          }
      }
    },




    /*
    ---------------------------------------------------------------------------
      [10] LAYOUT CHILD
    ---------------------------------------------------------------------------
    */

    /**
     * This is called from rwt.widgets.base.Widget and  it's task is to apply the layout
     *  (excluding border and padding) to the child.
     *
     * @type member
     * @param vChild {var} TODOC
     * @param vJobs {var} TODOC
     * @return {void}
     */
    layoutChild : function(vChild, vJobs)
    {
      this.layoutChild_sizeX(vChild, vJobs);
      this.layoutChild_sizeY(vChild, vJobs);

      this.layoutChild_sizeLimitX(vChild, vJobs);
      this.layoutChild_sizeLimitY(vChild, vJobs);

      this.layoutChild_locationX(vChild, vJobs);
      this.layoutChild_locationY(vChild, vJobs);

      this.layoutChild_marginX(vChild, vJobs);
      this.layoutChild_marginY(vChild, vJobs);
    },


    /**
     * TODOC
     *
     * @type member
     * @param vChild {var} TODOC
     * @param vJobs {var} TODOC
     * @return {void}
     * @signature function(vChild, vJobs)
     */
    layoutChild_sizeX : rwt.util.Variant.select("qx.client",
    {
      "trident|webkit|blink" : function(vChild, vJobs)
      {
        if (vJobs.initial || vJobs.width || vJobs.minWidth || vJobs.maxWidth)
        {
          if ((vChild._isWidthEssential() && (!vChild._computedWidthTypeNull || !vChild._computedMinWidthTypeNull || !vChild._computedMaxWidthTypeNull)) || (vChild.getAllowStretchX() && this.getWidget().getStretchChildrenOrthogonalAxis())) {
            vChild._renderRuntimeWidth(vChild.getBoxWidth());
          } else {
            vChild._resetRuntimeWidth();
          }
        }
      },

      "default" : function(vChild, vJobs)
      {
        if (vJobs.initial || vJobs.width)
        {
          if (vChild._isWidthEssential() && !vChild._computedWidthTypeNull) {
            vChild._renderRuntimeWidth(vChild.getWidthValue());
          } else {
            vChild._resetRuntimeWidth();
          }
        }
      }
    }),


    /**
     * TODOC
     *
     * @type member
     * @param vChild {var} TODOC
     * @param vJobs {var} TODOC
     * @return {void}
     * @signature function(vChild, vJobs)
     */
    layoutChild_sizeY : rwt.util.Variant.select("qx.client",
    {
      "trident|webkit|blink" : function(vChild, vJobs)
      {
        if (vJobs.initial || vJobs.height || vJobs.minHeight || vJobs.maxHeight)
        {
          if (vChild._isHeightEssential() && (!vChild._computedHeightTypeNull || !vChild._computedMinHeightTypeNull || !vChild._computedMaxHeightTypeNull)) {
            vChild._renderRuntimeHeight(vChild.getBoxHeight());
          } else {
            vChild._resetRuntimeHeight();
          }
        }
      },

      "default" : function(vChild, vJobs)
      {
        if (vJobs.initial || vJobs.height)
        {
          if (vChild._isHeightEssential() && !vChild._computedHeightTypeNull) {
            vChild._renderRuntimeHeight(vChild.getHeightValue());
          } else {
            vChild._resetRuntimeHeight();
          }
        }
      }
    }),


    /**
     * TODOC
     *
     * @type member
     * @param vChild {var} TODOC
     * @param vJobs {var} TODOC
     * @return {void}
     */
    layoutChild_locationY : function(vChild)
    {
      var vWidget = this.getWidget();

      // handle first child
      if (vWidget.getFirstVisibleChild() == vChild)
      {
        switch(vWidget.getLayoutMode())
        {
          case "bottom":
          case "top-reversed":
            var vPos = vWidget.getPaddingBottom() + vWidget.getAccumulatedChildrenOuterHeight() - vChild.getOuterHeight();
            break;

          case "middle":
          case "middle-reversed":
            var vPos = vWidget.getPaddingTop() + Math.round((vWidget.getInnerHeight() - vWidget.getAccumulatedChildrenOuterHeight()) / 2);
            break;

          default:
            var vPos = vWidget.getPaddingTop();
        }
      }

      // handle any following child
      else
      {
        var vPrev = vChild.getPreviousVisibleSibling();

        switch(vWidget.getLayoutMode())
        {
          case "bottom":
          case "top-reversed":
            var vPos = vPrev._cachedLocationVertical - vChild.getOuterHeight() - vWidget.getSpacing();
            break;

          default:
            var vPos = vPrev._cachedLocationVertical + vPrev.getOuterHeight() + vWidget.getSpacing();
        }
      }

      // store for next sibling
      vChild._cachedLocationVertical = vPos;

      // apply styles
      switch(this.getWidget().getLayoutMode())
      {
        case "bottom":
        case "bottom-reversed":
        case "middle-reversed":
          // add relative positions (like 'position:relative' in css)
          vPos += !vChild._computedBottomTypeNull ? vChild.getBottomValue() : !vChild._computedTopTypeNull ? -(vChild.getTopValue()) : 0;

          vChild._resetRuntimeTop();
          vChild._renderRuntimeBottom(vPos);
          break;

        default:
          // add relative positions (like 'position:relative' in css)
          vPos += !vChild._computedTopTypeNull ? vChild.getTopValue() : !vChild._computedBottomTypeNull ? -(vChild.getBottomValue()) : 0;

          vChild._resetRuntimeBottom();
          vChild._renderRuntimeTop(vPos);
      }
    },


    /**
     * TODOC
     *
     * @type member
     * @param vChild {var} TODOC
     * @param vJobs {var} TODOC
     * @return {void}
     */
    layoutChild_locationX : function(vChild)
    {
      var vWidget = this.getWidget();

      // special stretching support
      if ( rwt.client.Client.isGecko() )
      {
        if (vChild.getAllowStretchX() && vWidget.getStretchChildrenOrthogonalAxis() && vChild._computedWidthTypeNull)
        {
          vChild._renderRuntimeLeft(vWidget.getPaddingLeft() || 0);
          vChild._renderRuntimeRight(vWidget.getPaddingRight() || 0);

          return;
        }
      }

      // priority to childs internal alignment
      var vAlign = vChild.getHorizontalAlign() || vWidget.getHorizontalChildrenAlign();

      // handle center alignment
      var vPos = vAlign == "center" ? Math.round((vWidget.getInnerWidth() - vChild.getOuterWidth()) / 2) : 0;

      // the right alignment use the real 'right' styleproperty to
      // use the best available method in modern browsers
      if (vAlign == "right")
      {
        // add parent padding
        vPos += vWidget.getPaddingRight();

        // relative positions (like 'position:relative' in css)
        if (!vChild._computedRightTypeNull) {
          vPos += vChild.getRightValue();
        } else if (!vChild._computedLeftTypeNull) {
          vPos -= vChild.getLeftValue();
        }

        // apply styles
        vChild._resetRuntimeLeft();
        vChild._renderRuntimeRight(vPos);
      }
      else
      {
        // add parent padding
        vPos += vWidget.getPaddingLeft();

        // relative positions (like 'position:relative' in css)
        if (!vChild._computedLeftTypeNull) {
          vPos += vChild.getLeftValue();
        } else if (!vChild._computedRightTypeNull) {
          vPos -= vChild.getRightValue();
        }

        // apply styles
        vChild._resetRuntimeRight();
        vChild._renderRuntimeLeft(vPos);
      }
    }
  }
});

/*******************************************************************************
 * Copyright (c) 2004, 2015 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

rwt.qx.Class.define("rwt.widgets.util.HorizontalBoxLayoutImpl",
{
  extend : rwt.widgets.util.LayoutImpl,



  /*
  *****************************************************************************
     PROPERTIES
  *****************************************************************************
  */

  properties :
  {
    enableFlexSupport :
    {
      check : "Boolean",
      init : true
    }
  },




  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {
    /*
    ---------------------------------------------------------------------------
      [01] COMPUTE BOX DIMENSIONS FOR AN INDIVIDUAL CHILD
    ---------------------------------------------------------------------------
    */

    /** Compute and return the box width of the given child. */
    /**
     * Global Structure:
     *  [01] COMPUTE BOX DIMENSIONS FOR AN INDIVIDUAL CHILD
     *  [02] COMPUTE NEEDED DIMENSIONS FOR AN INDIVIDUAL CHILD
     *  [03] COMPUTE NEEDED DIMENSIONS FOR ALL CHILDREN
     *  [04] UPDATE LAYOUT WHEN A CHILD CHANGES ITS OUTER DIMENSIONS
     *  [05] UPDATE CHILD ON INNER DIMENSION CHANGES OF LAYOUT
     *  [06] UPDATE LAYOUT ON JOB QUEUE FLUSH
     *  [07] UPDATE CHILDREN ON JOB QUEUE FLUSH
     *  [08] CHILDREN ADD/REMOVE/MOVE HANDLING
     *  [09] FLUSH LAYOUT QUEUES OF CHILDREN
     *  [10] LAYOUT CHILD
     *
     *  Inherits from rwt.widgets.util.LayoutImpl:
     *  [02] COMPUTE NEEDED DIMENSIONS FOR AN INDIVIDUAL CHILD
     *
     * @type member
     * @param vChild {var} TODOC
     * @return {var} TODOC
     */
    computeChildBoxWidth : function(vChild) {
      return vChild.getWidthValue() || vChild._computeBoxWidthFallback();
    },


    /**
     * Compute and return the box height of the given child.
     *
     * @type member
     * @param vChild {var} TODOC
     * @return {var} TODOC
     */
    computeChildBoxHeight : function(vChild)
    {
      if (this.getWidget().getStretchChildrenOrthogonalAxis() && vChild._computedHeightTypeNull && vChild.getAllowStretchY()) {
        return this.getWidget().getInnerHeight();
      }

      return vChild.getHeightValue() || vChild._computeBoxHeightFallback();
    },


    /**
     * Computes the width of all flexible children.
     *
     * @type member
     * @return {void}
     */
    computeChildrenFlexWidth : function()
    {
      if (this._childrenFlexWidthComputed || !this.getEnableFlexSupport()) {
        return;
      }

      this._childrenFlexWidthComputed = true;

      var vWidget = this.getWidget();
      var vChildren = vWidget.getVisibleChildren();
      var vChildrenLength = vChildren.length;
      var vCurrentChild;
      var vFlexibleChildren = [];
      var vAvailWidth = vWidget.getInnerWidth();
      var vUsedWidth = vWidget.getSpacing() * (vChildrenLength - 1);
      var vIterator;

      // *************************************************************
      // 1. Compute the sum of all static sized children and finding
      //    all flexible children.
      // *************************************************************
      for (vIterator=0; vIterator<vChildrenLength; vIterator++)
      {
        vCurrentChild = vChildren[vIterator];

        if (vCurrentChild._computedWidthTypeFlex)
        {
          vFlexibleChildren.push(vCurrentChild);

          if (vWidget._computedWidthTypeAuto) {
            vUsedWidth += vCurrentChild.getPreferredBoxWidth();
          }
        }
        else
        {
          vUsedWidth += vCurrentChild.getOuterWidth();
        }
      }

      // *************************************************************
      // 2. Compute the sum of all flexible children widths
      // *************************************************************
      var vRemainingWidth = vAvailWidth - vUsedWidth;
      var vFlexibleChildrenLength = vFlexibleChildren.length;
      var vPrioritySum = 0;

      for (vIterator=0; vIterator<vFlexibleChildrenLength; vIterator++) {
        vPrioritySum += vFlexibleChildren[vIterator]._computedWidthParsed;
      }

      // *************************************************************
      // 3. Calculating the size of each 'part'.
      // *************************************************************
      var vPartWidth = vRemainingWidth / vPrioritySum;

      if (!vWidget.getUseAdvancedFlexAllocation())
      {
        // *************************************************************
        // 4a. Computing the flex width value of each flexible child
        //     and add the width to the usedWidth, so that we can
        //     fix rounding problems later.
        // *************************************************************
        for (vIterator=0; vIterator<vFlexibleChildrenLength; vIterator++)
        {
          vCurrentChild = vFlexibleChildren[vIterator];

          vCurrentChild._computedWidthFlexValue = Math.round(vCurrentChild._computedWidthParsed * vPartWidth);
          vUsedWidth += vCurrentChild._computedWidthFlexValue;
        }
      }
      else
      {
        // *************************************************************
        // 4b. Calculating the diff. Which means respect the min/max
        //     width configuration in flex and store the higher/lower
        //     data in a diff.
        // *************************************************************
        var vAllocationDiff = 0;
        var vMinAllocationLoops, vFlexibleChildrenLength, vAdjust, vCurrentAllocationSum, vFactorSum, vComputedFlexibleWidth;

        for (vIterator=0; vIterator<vFlexibleChildrenLength; vIterator++)
        {
          vCurrentChild = vFlexibleChildren[vIterator];

          vComputedFlexibleWidth = vCurrentChild._computedWidthFlexValue = vCurrentChild._computedWidthParsed * vPartWidth;
          vAllocationDiff += vComputedFlexibleWidth - rwt.util.Numbers.limit(vComputedFlexibleWidth, vCurrentChild.getMinWidthValue(), vCurrentChild.getMaxWidthValue());
        }

        // Rounding diff
        vAllocationDiff = Math.round(vAllocationDiff);

        if (vAllocationDiff === 0)
        {
          // *************************************************************
          // 5a. If the diff is equal zero we must not do anything more
          //     and do nearly identical the same like in 4a. which means
          //     to round the calculated flex value and add it to the
          //     used width so we can fix rounding problems later.
          // *************************************************************
          // Rounding values and fixing rounding errors
          for (vIterator=0; vIterator<vFlexibleChildrenLength; vIterator++)
          {
            vCurrentChild = vFlexibleChildren[vIterator];

            vCurrentChild._computedWidthFlexValue = Math.round(vCurrentChild._computedWidthFlexValue);
            vUsedWidth += vCurrentChild._computedWidthFlexValue;
          }
        }
        else
        {
          // *************************************************************
          // 5b. Find maximum loops of each adjustable child to adjust
          //     the width until the min/max width limits are reached.
          // *************************************************************
          var vUp = vAllocationDiff > 0;

          for (vIterator=vFlexibleChildrenLength-1; vIterator>=0; vIterator--)
          {
            vCurrentChild = vFlexibleChildren[vIterator];

            if (vUp)
            {
              vAdjust = (vCurrentChild.getMaxWidthValue() || Infinity) - vCurrentChild._computedWidthFlexValue;

              if (vAdjust > 0) {
                vCurrentChild._allocationLoops = Math.floor(vAdjust / vCurrentChild._computedWidthParsed);
              }
              else
              {
                rwt.util.Arrays.removeAt(vFlexibleChildren, vIterator);

                vCurrentChild._computedWidthFlexValue = Math.round(vCurrentChild._computedWidthFlexValue);
                vUsedWidth += Math.round(vCurrentChild._computedWidthFlexValue + vAdjust);
              }
            }
            else
            {
              vAdjust = rwt.util.Number.isNumber(vCurrentChild.getMinWidthValue()) ? vCurrentChild._computedWidthFlexValue - vCurrentChild.getMinWidthValue() : vCurrentChild._computedWidthFlexValue;

              if (vAdjust > 0) {
                vCurrentChild._allocationLoops = Math.floor(vAdjust / vCurrentChild._computedWidthParsed);
              }
              else
              {
                rwt.util.Arrays.removeAt(vFlexibleChildren, vIterator);

                vCurrentChild._computedWidthFlexValue = Math.round(vCurrentChild._computedWidthFlexValue);
                vUsedWidth += Math.round(vCurrentChild._computedWidthFlexValue - vAdjust);
              }
            }
          }

          // *************************************************************
          // 6. Try to reallocate the width between flexible children
          //    so that the requirements through min/max limits
          //    are satisfied.
          // *************************************************************
          while (vAllocationDiff !== 0 && vFlexibleChildrenLength > 0)
          {
            vFlexibleChildrenLength = vFlexibleChildren.length;
            vMinAllocationLoops = Infinity;
            vFactorSum = 0;

            // Find minimal loop amount
            for (vIterator=0; vIterator<vFlexibleChildrenLength; vIterator++)
            {
              vMinAllocationLoops = Math.min(vMinAllocationLoops, vFlexibleChildren[vIterator]._allocationLoops);
              vFactorSum += vFlexibleChildren[vIterator]._computedWidthParsed;
            }

            // Be sure that the adjustment is not bigger/smaller than diff
            vCurrentAllocationSum = Math.min(vFactorSum * vMinAllocationLoops, vAllocationDiff);

            // Reducing diff by current sum
            vAllocationDiff -= vCurrentAllocationSum;

            // Adding sizes to children to adjust
            for (vIterator=vFlexibleChildrenLength-1; vIterator>=0; vIterator--)
            {
              vCurrentChild = vFlexibleChildren[vIterator];
              vCurrentChild._computedWidthFlexValue += vCurrentAllocationSum / vFactorSum * vCurrentChild._computedWidthParsed;

              if (vCurrentChild._allocationLoops == vMinAllocationLoops)
              {
                vCurrentChild._computedWidthFlexValue = Math.round(vCurrentChild._computedWidthFlexValue);

                vUsedWidth += vCurrentChild._computedWidthFlexValue;
                delete vCurrentChild._allocationLoops;
                rwt.util.Arrays.removeAt(vFlexibleChildren, vIterator);
              }
              else
              {
                if (vAllocationDiff === 0)
                {
                  vCurrentChild._computedWidthFlexValue = Math.round(vCurrentChild._computedWidthFlexValue);
                  vUsedWidth += vCurrentChild._computedWidthFlexValue;
                  delete vCurrentChild._allocationLoops;
                }
                else
                {
                  vCurrentChild._allocationLoops -= vMinAllocationLoops;
                }
              }
            }
          }
        }
      }

      // *************************************************************
      // 7. Fix rounding errors
      // *************************************************************
      vCurrentChild._computedWidthFlexValue += vAvailWidth - vUsedWidth;
    },


    /**
     * TODOC
     *
     * @type member
     * @return {void}
     */
    invalidateChildrenFlexWidth : function() {
      delete this._childrenFlexWidthComputed;
    },




    /*
    ---------------------------------------------------------------------------
      [03] COMPUTE NEEDED DIMENSIONS FOR ALL CHILDREN
    ---------------------------------------------------------------------------
    */

    /**
     * Compute and return the width needed by all children of this widget
     *
     * @type member
     * @return {var} TODOC
     */
    computeChildrenNeededWidth : function()
    {
      var w = this.getWidget();
      return rwt.widgets.util.LayoutImpl.prototype.computeChildrenNeededWidth_sum.call(this) + ((w.getVisibleChildrenLength() - 1) * w.getSpacing());
    },




    /*
    ---------------------------------------------------------------------------
      [04] UPDATE LAYOUT WHEN A CHILD CHANGES ITS OUTER DIMENSIONS
    ---------------------------------------------------------------------------
    */

    /**
     * Things to do and layout when any of the childs changes its outer width.
     *  Needed by layouts where the children depends on each-other, like flow- or box-layouts.
     *
     * @type member
     * @param vChild {var} TODOC
     * @return {void}
     */
    updateSelfOnChildOuterWidthChange : function()
    {
      // if a childrens outer width changes we need to update our accumulated
      // width of all childrens (used for center or right alignments)
      this.getWidget()._invalidateAccumulatedChildrenOuterWidth();
    },




    /*
    ---------------------------------------------------------------------------
      [05] UPDATE CHILD ON INNER DIMENSION CHANGES OF LAYOUT
    ---------------------------------------------------------------------------
    */

    /**
     * Actions that should be done if the inner width of the widget was changed.
     *  Normally this includes update to percent values and ranges.
     *
     * @type member
     * @param vChild {var} TODOC
     * @return {var} TODOC
     */
    updateChildOnInnerWidthChange : function(vChild)
    {
      if (this.getWidget().getHorizontalChildrenAlign() == "center") {
        vChild.addToLayoutChanges("locationX");
      }

      // use variables here to be sure to call both methods.
      var vUpdatePercent = vChild._recomputePercentX();
      var vUpdateFlex = vChild._recomputeFlexX();

      // inform the caller if there were any notable changes occured
      return vUpdatePercent || vUpdateFlex;
    },


    /**
     * Actions that should be done if the inner height of the widget was changed.
     *  Normally this includes update to percent values and ranges.
     *
     * @type member
     * @param vChild {var} TODOC
     * @return {var} TODOC
     */
    updateChildOnInnerHeightChange : function(vChild)
    {
      // use variables here to be sure to call both methods.
      var vUpdatePercent = vChild._recomputePercentY();
      var vUpdateStretch = vChild._recomputeStretchingY();

      // priority to childs internal alignment
      if ((vChild.getVerticalAlign() || this.getWidget().getVerticalChildrenAlign()) == "middle") {
        vChild.addToLayoutChanges("locationY");
      }

      // inform the caller if there were any notable changes occured
      return vUpdatePercent || vUpdateStretch;
    },




    /*
    ---------------------------------------------------------------------------
      [06] UPDATE LAYOUT ON JOB QUEUE FLUSH
    ---------------------------------------------------------------------------
    */

    /**
     * Invalidate and recompute things because of job in queue (before the rest of job handling will be executed).
     *
     * @type member
     * @param vJobQueue {var} TODOC
     * @return {void}
     */
    updateSelfOnJobQueueFlush : function(vJobQueue)
    {
      if (vJobQueue.addChild || vJobQueue.removeChild) {
        this.getWidget()._invalidateAccumulatedChildrenOuterWidth();
      }
    },




    /*
    ---------------------------------------------------------------------------
      [07] UPDATE CHILDREN ON JOB QUEUE FLUSH
    ---------------------------------------------------------------------------
    */

    /**
     * Updates children on special jobs
     *
     * @type member
     * @param vQueue {var} TODOC
     * @return {boolean}
     */
    updateChildrenOnJobQueueFlush : function(vQueue)
    {
      var vStretchX = false, vStretchY = false;
      var vWidget = this.getWidget();

      // switching the orientation need updates for stretching on both axis
      if (vQueue.orientation) {
        vStretchX = vStretchY = true;
      }

      // different updates depending from the current orientation (or the new one)
      if (vQueue.spacing || vQueue.orientation || vQueue.reverseChildrenOrder || vQueue.horizontalChildrenAlign) {
        vWidget._addChildrenToLayoutQueue("locationX");
      }

      if (vQueue.verticalChildrenAlign) {
        vWidget._addChildrenToLayoutQueue("locationY");
      }

      if (vQueue.stretchChildrenOrthogonalAxis) {
        vStretchY = true;
      }

      // if stretching should be reworked reset the previous one and add
      // a layout job to update the width respectively height.
      if (vStretchX)
      {
        vWidget._recomputeChildrenStretchingX();
        vWidget._addChildrenToLayoutQueue("width");
      }

      if (vStretchY)
      {
        vWidget._recomputeChildrenStretchingY();
        vWidget._addChildrenToLayoutQueue("height");
      }

      return true;
    },




    /*
    ---------------------------------------------------------------------------
      [08] CHILDREN ADD/REMOVE/MOVE HANDLING
    ---------------------------------------------------------------------------
    */

    /**
     * This method combines calls of methods which should be done if a widget should be removed from the current layout.
     *  Needed by layouts where the children depends on each-other, like flow- or box-layouts.
     *
     * @type member
     * @param vChild {var} TODOC
     * @param vIndex {var} TODOC
     * @return {void}
     */
    updateChildrenOnRemoveChild : function(vChild, vIndex)
    {
      var w = this.getWidget(), ch = w.getVisibleChildren(), chl = ch.length, chc, i = -1;

      // Fix index to be at the first flex child
      if (this.getEnableFlexSupport())
      {
        for (i=0; i<chl; i++)
        {
          chc = ch[i];

          if (chc.getHasFlexX())
          {
            vIndex = Math.min(vIndex, i);
            break;
          }
        }

        i = -1;
      }

      // Handle differently depending on layout mode
      switch(w.getLayoutMode())
      {
        case "right":
        case "left-reversed":
          while ((chc = ch[++i]) && i < vIndex) {
            chc.addToLayoutChanges("locationX");
          }

          break;

        case "center":
        case "center-reversed":
          chc = ch[ ++i ];
          while( chc ) {
            chc.addToLayoutChanges("locationX");
            chc = ch[ ++i ];
          }

          break;

        default:
          i += vIndex;

          chc = ch[ ++i ];
          while( chc ) {
            chc.addToLayoutChanges("locationX");
            chc = ch[ ++i ];
          }
      }
    },


    /**
     * This method combines calls of methods which should be done if a child should be moved
     *  inside the same parent to a new positions.
     *  Needed by layouts where the children depends on each-other, like flow- or box-layouts.
     *
     * @type member
     * @param vChild {var} TODOC
     * @param vIndex {var} TODOC
     * @param vOldIndex {var} TODOC
     * @return {void}
     */
    updateChildrenOnMoveChild : function(vChild, vIndex, vOldIndex)
    {
      var vChildren = this.getWidget().getVisibleChildren();

      var vStart = Math.min(vIndex, vOldIndex);
      var vStop = Math.max(vIndex, vOldIndex) + 1;
      vStop = Math.min(vChildren.length, vStop);

      for (var i=vStart; i<vStop; i++) {
        vChildren[i].addToLayoutChanges("locationX");
      }
    },




    /*
    ---------------------------------------------------------------------------
      [09] FLUSH LAYOUT QUEUES OF CHILDREN
    ---------------------------------------------------------------------------
    */

    /**
     * This method have full control of the order in which the
     *  registered (or also non-registered) children should be
     *  layouted on the horizontal axis.
     *
     * @type member
     * @param vChildrenQueue {var} TODOC
     * @return {void}
     */
    flushChildrenQueue : function(vChildrenQueue)
    {
      var w = this.getWidget(), ch = w.getVisibleChildren(), chl = ch.length, chc, i;

      // This block is needed for flex handling and
      // will inform flex children if there was any
      // change to the other content
      if (this.getEnableFlexSupport())
      {
        this.invalidateChildrenFlexWidth();

        for (i=0; i<chl; i++)
        {
          chc = ch[i];

          if (chc.getHasFlexX())
          {
            chc._computedWidthValue = null;

            if (chc._recomputeBoxWidth())
            {
              chc._recomputeOuterWidth();
              chc._recomputeInnerWidth();
            }

            vChildrenQueue[chc.toHashCode()] = chc;
            chc._layoutChanges.width = true;
          }
        }
      }

      switch(w.getLayoutMode())
      {
        case "right":
        case "left-reversed":
          // find the last child which has a layout request
          for (var i=chl-1; i>=0&&!vChildrenQueue[ch[i].toHashCode()]; i--) {}

          // layout all children before this last child
          for (var j=0; j<=i; j++) {
            w._layoutChild(chc = ch[j]);
          }

          break;

        case "center":
        case "center-reversed":
          // re-layout all children
          i = -1;

          chc = ch[++i];
          while( chc ) {
            w._layoutChild(chc);
            chc = ch[++i];
          }

          break;

        default:
          // layout all childs from the first child
          // with an own layout request to the end
          i = -1;
          var changed = false;

          chc = ch[++i];
          while( chc ) {
            if (changed || vChildrenQueue[chc.toHashCode()])
            {
              w._layoutChild(chc);
              changed = true;
            }
            chc = ch[++i];
          }
      }
    },




    /*
    ---------------------------------------------------------------------------
      [10] LAYOUT CHILD
    ---------------------------------------------------------------------------
    */

    /**
     * This is called from rwt.widgets.base.Widget and  it's task is to apply the layout
     *  (excluding border and padding) to the child.
     *
     * @type member
     * @param vChild {var} TODOC
     * @param vJobs {var} TODOC
     * @return {void}
     */
    layoutChild : function(vChild, vJobs)
    {
      this.layoutChild_sizeX(vChild, vJobs);
      this.layoutChild_sizeY(vChild, vJobs);

      this.layoutChild_sizeLimitX(vChild, vJobs);
      this.layoutChild_sizeLimitY(vChild, vJobs);

      this.layoutChild_locationX(vChild, vJobs);
      this.layoutChild_locationY(vChild, vJobs);

      this.layoutChild_marginX(vChild, vJobs);
      this.layoutChild_marginY(vChild, vJobs);
    },


    /**
     * TODOC
     *
     * @type member
     * @param vChild {var} TODOC
     * @param vJobs {var} TODOC
     * @return {void}
     * @signature function(vChild, vJobs)
     */
    layoutChild_sizeX : rwt.util.Variant.select("qx.client",
    {
      "trident|webkit|blink" : function(vChild, vJobs)
      {
        if (vJobs.initial || vJobs.width || vJobs.minWidth || vJobs.maxWidth)
        {
          if (vChild._isWidthEssential() && (!vChild._computedWidthTypeNull || !vChild._computedMinWidthTypeNull || !vChild._computedMaxWidthTypeNull)) {
            vChild._renderRuntimeWidth(vChild.getBoxWidth());
          } else {
            vChild._resetRuntimeWidth();
          }
        }
      },

      "default" : function(vChild, vJobs)
      {
        if (vJobs.initial || vJobs.width)
        {
          if (vChild._isWidthEssential() && !vChild._computedWidthTypeNull) {
            vChild._renderRuntimeWidth(vChild.getWidthValue());
          } else {
            vChild._resetRuntimeWidth();
          }
        }
      }
    }),


    /**
     * TODOC
     *
     * @type member
     * @param vChild {var} TODOC
     * @param vJobs {var} TODOC
     * @return {void}
     * @signature function(vChild, vJobs)
     */
    layoutChild_sizeY : rwt.util.Variant.select("qx.client",
    {
      "trident|webkit|blink" : function(vChild, vJobs)
      {
        if (vJobs.initial || vJobs.height || vJobs.minHeight || vJobs.maxHeight)
        {
          if ((vChild._isHeightEssential() && (!vChild._computedHeightTypeNull || !vChild._computedMinHeightTypeNull || !vChild._computedMaxHeightTypeNull)) || (vChild.getAllowStretchY() && this.getWidget().getStretchChildrenOrthogonalAxis())) {
            vChild._renderRuntimeHeight(vChild.getBoxHeight());
          } else {
            vChild._resetRuntimeHeight();
          }
        }
      },

      "default" : function(vChild, vJobs)
      {
        if (vJobs.initial || vJobs.height)
        {
          if (vChild._isHeightEssential() && !vChild._computedHeightTypeNull) {
            vChild._renderRuntimeHeight(vChild.getHeightValue());
          } else {
            vChild._resetRuntimeHeight();
          }
        }
      }
    }),


    /**
     * TODOC
     *
     * @type member
     * @param vChild {var} TODOC
     * @param vJobs {var} TODOC
     * @return {void}
     */
    layoutChild_locationX : function(vChild)
    {
      var vWidget = this.getWidget();

      // handle first child
      if (vWidget.getFirstVisibleChild() == vChild)
      {
        switch(vWidget.getLayoutMode())
        {
          case "right":
          case "left-reversed":
            var vPos = vWidget.getPaddingRight() + vWidget.getAccumulatedChildrenOuterWidth() - vChild.getOuterWidth();
            break;

          case "center":
          case "center-reversed":
            var vPos = vWidget.getPaddingLeft() + Math.round((vWidget.getInnerWidth() - vWidget.getAccumulatedChildrenOuterWidth()) / 2);
            break;

          default:
            var vPos = vWidget.getPaddingLeft();
        }
      }

      // handle any following child
      else
      {
        var vPrev = vChild.getPreviousVisibleSibling();

        switch(vWidget.getLayoutMode())
        {
          case "right":
          case "left-reversed":
            var vPos = vPrev._cachedLocationHorizontal - vChild.getOuterWidth() - vWidget.getSpacing();
            break;

          default:
            var vPos = vPrev._cachedLocationHorizontal + vPrev.getOuterWidth() + vWidget.getSpacing();
        }
      }

      // store for next sibling
      vChild._cachedLocationHorizontal = vPos;

      // apply styles
      switch(vWidget.getLayoutMode())
      {
        case "right":
        case "right-reversed":
        case "center-reversed":
          // add relative positions (like 'position:relative' in css)
          vPos += !vChild._computedRightTypeNull ? vChild.getRightValue() : !vChild._computedLeftTypeNull ? -(vChild.getLeftValue()) : 0;

          vChild._resetRuntimeLeft();
          vChild._renderRuntimeRight(vPos);
          break;

        default:
          // add relative positions (like 'position:relative' in css)
          vPos += !vChild._computedLeftTypeNull ? vChild.getLeftValue() : !vChild._computedRightTypeNull ? -(vChild.getRightValue()) : 0;

          vChild._resetRuntimeRight();
          vChild._renderRuntimeLeft(vPos);
      }
    },


    /**
     * TODOC
     *
     * @type member
     * @param vChild {var} TODOC
     * @param vJobs {var} TODOC
     * @return {void}
     */
    layoutChild_locationY : function(vChild)
    {
      var vWidget = this.getWidget();

      // special stretching support
      if( rwt.client.Client.isGecko() )
      {
        if (vChild.getAllowStretchY() && vWidget.getStretchChildrenOrthogonalAxis() && vChild._computedHeightTypeNull)
        {
          vChild._renderRuntimeTop(vWidget.getPaddingTop() || 0);
          vChild._renderRuntimeBottom(vWidget.getPaddingBottom() || 0);

          return;
        }
      }

      // priority to childs internal alignment
      var vAlign = vChild.getVerticalAlign() || vWidget.getVerticalChildrenAlign();

      // handle middle alignment
      var vPos = vAlign == "middle" ? Math.round((vWidget.getInnerHeight() - vChild.getOuterHeight()) / 2) : 0;

      // the bottom alignment use the real 'bottom' styleproperty to
      // use the best available method in modern browsers
      if (vAlign == "bottom")
      {
        // add parent padding
        vPos += vWidget.getPaddingBottom();

        // relative positions (like 'position:relative' in css)
        if (!vChild._computedBottomTypeNull) {
          vPos += vChild.getBottomValue();
        } else if (!vChild._computedTopTypeNull) {
          vPos -= vChild.getTopValue();
        }

        // apply styles
        vChild._resetRuntimeTop();
        vChild._renderRuntimeBottom(vPos);
      }
      else
      {
        // add parent padding
        vPos += vWidget.getPaddingTop();

        // relative positions (like 'position:relative' in css)
        if (!vChild._computedTopTypeNull) {
          vPos += vChild.getTopValue();
        } else if (!vChild._computedBottomTypeNull) {
          vPos -= vChild.getBottomValue();
        }

        // apply styles
        vChild._resetRuntimeBottom();
        vChild._renderRuntimeTop(vPos);
      }
    }
  }
});

/*******************************************************************************
 * Copyright (c) 2011, 2013 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.remote.HandlerRegistry.add( "rwt.widgets.Label", {

  factory : function( properties ) {
    var styleMap = rwt.remote.HandlerUtil.createStyleMap( properties.style );
    styleMap.MARKUP_ENABLED = properties.markupEnabled;
    var result = new rwt.widgets.Label( styleMap );
    rwt.remote.HandlerUtil.addStatesForStyles( result, properties.style );
    result.setUserData( "isControl", true );
    rwt.remote.HandlerUtil.setParent( result, properties.parent );
    return result;
  },

  destructor : rwt.remote.HandlerUtil.getControlDestructor(),

  getDestroyableChildren : rwt.remote.HandlerUtil.getDestroyableChildrenFinder(),

  properties : rwt.remote.HandlerUtil.extendControlProperties( [
    /**
     * @name setText
     * @methodOf Label#
     * @description Sets the receivers text to the given string.
     * @param {string} text the new text
     */
    "text",
    "mnemonicIndex",
    "image",
    "alignment",
    "appearance",
    "leftMargin",
    "topMargin",
    "rightMargin",
    "bottomMargin",
    "backgroundGradient"
  ] ),

  propertyHandler : rwt.remote.HandlerUtil.extendControlPropertyHandler( {
    "backgroundGradient" : rwt.remote.HandlerUtil.getBackgroundGradientHandler()
  } ),

  listeners : rwt.remote.HandlerUtil.extendControlListeners( [] ),

  listenerHandler : rwt.remote.HandlerUtil.extendControlListenerHandler( {} ),

  methods: [ "addListener", "removeListener" ],

  methodHandler : rwt.remote.HandlerUtil.extendListenerMethodHandler( {} ),

  /**
   * @class RWT Scripting analoge to org.eclipse.swt.widgets.Label
   * @name Label
   * @extends Control
   * @description The constructor is not public.
   * @since 2.2
   */
   scriptingMethods : rwt.remote.HandlerUtil.extendControlScriptingMethods(
     /** @lends Label.prototype */
   {
     /**
      * @description  Returns the widget text.
      * @return {string} the widget text
      */
     getText : function() {
       return this.getCellContent( 1 );
     }
   } )
} );

/*******************************************************************************
 * Copyright (c) 2004, 2014 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

/**
 * The Label widget displays plain text or HTML text.
 *
 * Most complex qooxdoo widgets use instances of Label to display text.
 * The label supports auto sizing and internationalization.
 *
 * @appearance label
 */
rwt.qx.Class.define( "rwt.widgets.base.Label", {

  extend : rwt.widgets.base.Terminator,

  construct : function( text ) {
    this.base( arguments );
    if( text != null ) {
      this.setText( text );
    }
    this.initWidth();
    this.initHeight();
    this.initSelectable();
    this.initCursor();
    this.initWrap();
  },

  properties : {

    appearance : {
      refine : true,
      init : "label"
    },

    width : {
      refine : true,
      init : "auto"
    },

    height : {
      refine : true,
      init : "auto"
    },

    allowStretchX : {
      refine : true,
      init : false
    },

    allowStretchY : {
      refine : true,
      init : false
    },

    selectable : {
      refine : true,
      init : false
    },

    /**
     * The text of the label. How the text is interpreted depends on the value of the
     * property {@link #mode}.
     */
    text : {
      apply : "_applyText",
      init : "",
      dispose : true,
      check : "Label"
    },

    /**
     * Whether the text should be automatically wrapped into the next line
     */
    wrap : {
      check : "Boolean",
      init : false,
      nullable : true,
      apply : "_applyWrap"
    },

    /**
     * The alignment of the text inside the box
     */
    textAlign : {
      check : [ "left", "center", "right", "justify" ],
      nullable : true,
      themeable : true,
      apply : "_applyTextAlign"
    },

    /**
     * Whether an ellipsis symbol should be rendered if there is not enough room for the full text.
     *
     * Please note: If enabled this conflicts with a custom overflow setting.
     */
    textOverflow : {
      check : "Boolean",
      init : true
    },

    /**
     * Set how the label text should be interpreted
     *
     * <ul>
     *   <li><code>text</code> will set the text verbatim. Leading and trailing white space will be reserved.</li>
     *   <li><code>html</code> will interpret the label text as html.</li>
     *   <li><code>auto</code> will try to guess whether the text represents an HTML string or plain text.
     *       This is how older qooxdoo versions treated the text.
     *   </li>
     * <ul>
     */
    mode : {
      check : [ "html", "text", "auto" ],
      init : "auto"
    }

  },

  members : {

    _content : "",

    _applyTextAlign : function( value ) {
      if( value === null ) {
        this.removeStyleProperty( "textAlign" );
      } else {
        this.setStyleProperty( "textAlign", value );
      }
    },

    _applyFont : function( value ) {
      this._styleFont( value );
    },

    _styleFont : function( font ) {
      this._invalidatePreferredInnerDimensions();
      if( font ) {
        font.render( this );
      } else {
        rwt.html.Font.reset( this );
      }
    },

    _applyWrap : function( value ) {
      if( value == null ) {
        this.removeStyleProperty( "whiteSpace" );
      } else {
        this.setStyleProperty( "whiteSpace", value ? "normal" : "nowrap" );
      }
    },

    _applyText : function() {
      this._syncText( this.getText() );
    },

    _syncText : function( text ) {
      this._content = text;
      if( this._isCreated ) {
        this._renderContent();
      }
    },

    /**
     * Computes the needed dimension for the current text.
     */
    _computeObjectNeededDimensions : function() {
      var fontProps = this._styleProperties;
      var calc = rwt.widgets.util.FontSizeCalculation;
      var dimensions = calc.computeTextDimensions( this._content, fontProps );
      this._cachedPreferredInnerWidth = dimensions[ 0 ];
      this._cachedPreferredInnerHeight = dimensions[ 1 ];
    },

    _computePreferredInnerWidth : function() {
      this._computeObjectNeededDimensions();
      return this._cachedPreferredInnerWidth;
    },

    _computePreferredInnerHeight : function() {
      this._computeObjectNeededDimensions();
      return this._cachedPreferredInnerHeight;
    },

    _postApply : function() {
      var html = this._content;
      var element = this._getTargetNode();
      if( html == null ) {
        element.innerHTML = "";
      } else {
        var style = element.style;
        if( !this.getWrap() ) {
          if( this.getInnerWidth() < this.getPreferredInnerWidth() ) {
            style.overflow = "hidden";
          } else {
            style.overflow = "";
          }
        }
        element.innerHTML = html;
      }
    }

  }

} );

/*******************************************************************************
 * Copyright (c) 2004, 2015 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

/**
 * This widget represents an image.
 *
 * @appearance image
 */
rwt.qx.Class.define("rwt.widgets.base.Image",
{
  extend : rwt.widgets.base.Terminator,




  /*
  *****************************************************************************
     CONSTRUCTOR
  *****************************************************************************
  */

  /**
   * @param vSource {String} URL of the image
   * @param vWidth {Integer|String ? "auto"} definition of the width of the image
   * @param vHeight {Integer|String ? "auto"} definition of the height of the image
   */
  construct : function(vSource, vWidth, vHeight)
  {
    this.base(arguments);

    this._blank = rwt.remote.Connection.RESOURCE_PATH + "static/image/blank.gif";

    // Source
    if (vSource != null) {
      this.setSource(vSource);
    }

    // Dimensions
    if (vWidth != null) {
      this.setWidth(vWidth);
    } else {
      this.initWidth();
    }

    if (vHeight != null) {
      this.setHeight(vHeight);
    } else {
      this.initHeight();
    }

    // Property init
    this.initSelectable();
  },

  /*
  *****************************************************************************
     PROPERTIES
  *****************************************************************************
  */

  properties :
  {
    /*
    ---------------------------------------------------------------------------
      REFINED PROPERTIES
    ---------------------------------------------------------------------------
    */

    allowStretchX :
    {
      refine : true,
      init : false
    },

    allowStretchY :
    {
      refine : true,
      init : false
    },

    selectable :
    {
      refine : true,
      init : false
    },

    width :
    {
      refine : true,
      init : "auto"
    },

    height :
    {
      refine : true,
      init : "auto"
    },

    appearance :
    {
      refine : true,
      init : "image"
    },





    /*
    ---------------------------------------------------------------------------
      OWN PROPERTIES
    ---------------------------------------------------------------------------
    */

    /** The source uri of the image. */
    source :
    {
      check : "String",
      apply : "_applySource",
      event : "changeSource",
      nullable : true,
      themeable : true
    },


    /** The assigned preloader instance of the image. */
    preloader :
    {
      check : "rwt.html.ImagePreloader",
      apply : "_applyPreloader",
      nullable : true
    },


    /**
     * The loading status.
     *
     *  True if the image is loaded correctly. False if no image is loaded
     *  or the one that should be loaded is currently loading or not available.
     */
    loaded :
    {
      check : "Boolean",
      init : false,
      apply : "_applyLoaded"
    },


    /** Should the image be maxified in it's own container? */
    resizeToInner :
    {
      check : "Boolean",
      init : false
    }
  },




  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {
    /*
    ---------------------------------------------------------------------------
      EVENT MAPPERS
    ---------------------------------------------------------------------------
    */

    /**
     * Listener method of the "load" event - sets "loaded" property
     *
     * @type member
     * @return {void}
     */
    _onload : function() {
      this.setLoaded(true);
    },

    /*
    ---------------------------------------------------------------------------
      DISPLAYBLE HANDLING
    ---------------------------------------------------------------------------
    */

    /**
     * Registers an image at the image manager (rwt.html.ImageManager) and increases the
     * visible counter
     *
     * @type member
     * @return {void}
     */
    _beforeAppear : function()
    {
      var source = this.getSource();
      if (source)
      {
        rwt.html.ImageManager.getInstance().show(source);
        this._registeredAsVisible = true;
      }

      return this.base(arguments);
    },


    /**
     * Registers an image at the image manager (rwt.html.ImageManager) and reduces the
     * visible counter
     *
     * @type member
     * @return {void}
     */
    _beforeDisappear : function()
    {
      var source = this.getSource();
      if (source && this._registeredAsVisible)
      {
        rwt.html.ImageManager.getInstance().hide(source);
        delete this._registeredAsVisible;
      }

      return this.base(arguments);
    },




    /*
    ---------------------------------------------------------------------------
      MODIFIERS
    ---------------------------------------------------------------------------
    */

    /**
     * TODOC
     *
     * @type member
     * @param value {var} Current value
     * @param old {var} Previous value
     */
    _applySource : function(value, old)
    {
      var imageMgr = rwt.html.ImageManager.getInstance();

      if (old)
      {
        imageMgr.remove(old);

        if (this._registeredAsVisible)
        {
          imageMgr.hide(old);
          delete this._registeredAsVisible;
        }
      }

      if (value)
      {
        imageMgr.add(value);

        if (this.isSeeable())
        {
          this._registeredAsVisible = true;
          imageMgr.show(value);
        }
      }

      if (this.isCreated()) {
        this._connect();
      }
    },

    /**
     * Connects a callback method to the value manager to ensure
     * that changes to the source are handled by the image instance
     *
     * @type member
     * @return {void}
     */
    _connect : function() {
      this._syncSource( this.getSource() );
    },

    /**
     * Sets the preloader property (with creating a new instance)
     *
     * @param value {String} source of image instance
     * @return {void}
     */
    _syncSource : function(value)
    {
      if (value === null)
      {
        this.setPreloader(null);
      }
      else
      {
        var preloader = rwt.html.ImagePreloaderManager.getInstance().create(value);
        this.setPreloader(preloader);
      }
    },


    /**
     * TODOC
     *
     * @type member
     * @param value {var} Current value
     * @param old {var} Previous value
     */
    _applyPreloader : function(value, old)
    {
      if (old)
      {
        // remove event connection
        old.removeEventListener("load", this._onload, this);
      }

      if (value)
      {
        // Omit  here, otherwise the later setLoaded(true)
        // will not be executed (prevent recursion)
        this.setLoaded(false);

        if( !value.isErroneous() && value.isLoaded() ) {
          this.setLoaded(true);
        } else {
          value.addEventListener( "load", this._onload, this );
        }
      }
      else
      {
        this.setLoaded(false);
      }
    },


    /**
     * TODOC
     *
     * @type member
     * @param value {var} Current value
     * @param old {var} Previous value
     */
    _applyLoaded : function(value)
    {
      if (value && this.isCreated())
      {
        this._renderContent();
      }
      else if (!value)
      {
        this._invalidatePreferredInnerWidth();
        this._invalidatePreferredInnerHeight();
      }
    },


    /**
     * TODOC
     *
     * @type member
     * @param value {var} Current value
     * @param old {var} Previous value
     */
    _applyElement : function(value, old)
    {
      if (value)
      {
        if (!this._image)
        {
          try
          {
            this._createImageNode();
            this._image.style.border = "0 none";
            this._image.style.verticalAlign = "top";
            this._image.alt = "";
            this._image.title = "";
          }
          catch(ex) {
            throw new Error( "Failed while creating image #1 " + ex );
          }

          this._imageNodeCreated();
        }

        value.appendChild(this._image);
      }

      // call widget implmentation
      this.base(arguments, value, old);

      if (value && this.getSource()) {
        this._connect();
      }
    },

    // Create Image-Node
    // Webkit has problems with "new Image". Maybe related to "new Function" with
    // is also not working correctly.
    _createImageNode : rwt.util.Variant.select( "qx.client", {
      "webkit|blink" : function() {
        this._image = document.createElement("img");
      },
      "default" : function() {
        this._image = new Image();
      }
    } ),

    _imageNodeCreated : rwt.util.Variant.select( "qx.client", {
      "gecko|webkit|blink" : function() {
        this._styleEnabled();
      },
      "default": rwt.util.Functions.returnTrue
    } ),

    /*
    ---------------------------------------------------------------------------
      CLIENT OPTIMIZED MODIFIERS
    ---------------------------------------------------------------------------
    */

    /**
     * Internal method (called by the layout engine)
     * Applies the dimensions and then sets the source of the image instance
     *
     * @type member
     * @return {void}
     */
    _postApply : function()
    {
      this._postApplyDimensions();
      this._updateContent();
    },


    /**
     * TODOC
     *
     * @type member
     * @param value {var} Current value
     * @param old {var} Previous value
     * @return {void}
     * @signature function(value, old)
     */
    _applyEnabled : function(value, old)
    {
      if (this._image) {
        this._styleEnabled();
      }

      return this.base(arguments, value, old);
    },


    /**
     * Updates the source of the image instance
     *
     * @type member
     * @return {void}
     * @signature function()
     */
    _updateContent : function() {
      var pl = this.getPreloader();
      this._image.src = pl && pl.isLoaded() ? pl.getSource() : this._blank;
    },


    /**
     * Reset the source of the image instance to a blank image
     *
     * @type member
     * @return {void}
     * @signature function()
     */
    _resetContent : function() {
      this._image.src = this._blank;
    },

    /**
     * Sets the style values for the states enabled/disabled
     *
     * @type member
     * @return {void}
     * @signature function()
     */
    _styleEnabled : function() {
      if (this._image)
      {
        var o = this.getEnabled()===false ? 0.3 : "";
        var s = this._image.style;

        s.opacity = s.KhtmlOpacity = s.MozOpacity = o;
      }
    },




    /*
    ---------------------------------------------------------------------------
      PREFERRED DIMENSIONS: INNER
    ---------------------------------------------------------------------------
    */

    /**
     * Returns width value of preloader or 0 (if preloader is not available)
     *
     * @type member
     * @return {Integer} Returns width value of preloader or 0 (if preloader is not available)
     */
    _computePreferredInnerWidth : function()
    {
      var preloader = this.getPreloader();
      return preloader ? preloader.getWidth() : 0;
    },


    /**
     * Returns height value of preloader or 0 (if preloader is not available)
     *
     * @type member
     * @return {Integer} Returns height value of preloader or 0 (if preloader is not available)
     */
    _computePreferredInnerHeight : function()
    {
      var preloader = this.getPreloader();
      return preloader ? preloader.getHeight() : 0;
    },




    /*
    ---------------------------------------------------------------------------
      APPLY
    ---------------------------------------------------------------------------
    */

    /**
     * Sets the style attributes for width and height
     *
     * @type member
     * @return {void}
     * @signature function()
     */
    _postApplyDimensions : function() {
      try
      {
        var vImageNode = this._image;

        if (this.getResizeToInner())
        {
          vImageNode.width = this.getInnerWidth();
          vImageNode.height = this.getInnerHeight();
        }
        else
        {
          vImageNode.width = this.getPreferredInnerWidth();
          vImageNode.height = this.getPreferredInnerHeight();
        }
      }
      catch(ex)
      {
        throw new Error( "postApplyDimensions failed " + ex );
      }
    },

    /*
    ---------------------------------------------------------------------------
      CHANGES IN DIMENSIONS
    ---------------------------------------------------------------------------
    */

    /**
     * Sets the width style attribute
     *
     * @type member
     * @param vNew {var} new inner width value
     * @param vOld {var} old inner width value
     * @return {void}
     * @signature function(vNew, vOld)
     */
    _changeInnerWidth : function(vNew) {
      if (this.getResizeToInner()) {
        this._image.width = vNew;
      }
    },


    /**
     * Sets the height style attribute
     *
     * @type member
     * @param vNew {var} new inner height value
     * @param vOld {var} old inner height value
     * @return {void}
     * @signature function(vNew, vOld)
     */
    _changeInnerHeight : function(vNew) {
      if (this.getResizeToInner()) {
        this._image.height = vNew;
      }
    }

  },





  /*
  *****************************************************************************
     DESTRUCTOR
  *****************************************************************************
  */

  destruct : function()
  {
    // Remove leaking filter attribute before leaving page
    if (this._image) {
      this._image.style.filter = "";
    }

    // Remove fields
    this._disposeFields("_image");
  }
});

/*******************************************************************************
 * Copyright (c) 2004, 2014 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

/** This singleton manage all rwt.html.ImagePreloader instances. */
rwt.qx.Class.define( "rwt.html.ImagePreloaderManager", {

  extend : rwt.qx.Object,

  statics : {

    getInstance : function() {
      return rwt.runtime.Singletons.get( rwt.html.ImagePreloaderManager );
    }

  },

  /*
  *****************************************************************************
     CONSTRUCTOR
  *****************************************************************************
  */

  construct : function()
  {
    this.base(arguments);

    this._objects = {};
  },




  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {
    /**
     * Adds a rwt.html.ImagePreloader instance to the manager
     *
     * @type member
     * @param vObject {Preloader} rwt.html.ImagePreloader instance
     * @return {void}
     */
    add : function(vObject) {
      this._objects[vObject.getUri()] = vObject;
    },


    /**
     * Removes a rwt.html.ImagePreloader instance from the manager
     *
     * @type member
     * @param vObject {Preloader} rwt.html.ImagePreloader instance
     * @return {void}
     */
    remove : function(vObject) {
      delete this._objects[vObject.getUri()];
    },


    /**
     * Returns whether an image preloader instance with the given source is registered
     *
     * @type member
     * @param vSource {String} Source of preloader image instance
     * @return {Boolean} whether an image preloader instance has given source
     */
    has : function(vSource) {
      return this._objects[vSource] != null;
    },


    /**
     * Return image preloader instance with given source
     *
     * @type member
     * @param vSource {String} Source of preloader image instance
     * @return {Preloader} rwt.html.ImagePreloader instance
     */
    get : function(vSource) {
      return this._objects[vSource];
    },


    /**
     * Create new qx.io.image.preloader instance with given source
     *
     * @type member
     * @param vSource {String} Source of preloader image instance
     * @return {Preloader} new rwt.html.ImagePreloader instance
     */
    create : function(vSource)
    {
      if (this._objects[vSource]) {
        return this._objects[vSource];
      }

      return new rwt.html.ImagePreloader(vSource);
    }
  },




  /*
  *****************************************************************************
     DESTRUCTOR
  *****************************************************************************
  */

  destruct : function() {
    this._disposeFields("_objects");
  }
});

/*******************************************************************************
 * Copyright (c) 2004, 2014 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

/**
 * This class preloads one image and provides information about this image
 * after it is loaded.
 *
 * This class should not be used directly. Better use {@link rwt.html.ImagePreloaderManager}:
 *
 * <pre class='javascript'>
 * rwt.html.ImagePreloaderManager.getInstance().create(imageUrl)
 * </pre>
 */
rwt.qx.Class.define("rwt.html.ImagePreloader",
{
  extend : rwt.qx.Target,


  /*
  *****************************************************************************
     CONSTRUCTOR
  *****************************************************************************
  */

  /**
   * @param imageUrl {String} URL of the image to pre load
   */
  construct : function(imageUrl)
  {
    if (rwt.html.ImagePreloaderManager.getInstance().has(imageUrl))
    {
      return rwt.html.ImagePreloaderManager.getInstance().get(imageUrl);
    }

    this.base(arguments);

    // Create Image-Node
    // Does not work with document.createElement("img") in Webkit. Interesting.
    // Compare this to the bug in rwt.widgets.base.Image.
    this._element = new Image();

    // Define handler if image events occurs
    this._element.onload = rwt.util.Functions.bind(this.__onload, this);
    this._element.onerror = rwt.util.Functions.bind(this.__onerror, this);

    // Set Source
    this._source = imageUrl;
    this._element.src = imageUrl;

    rwt.html.ImagePreloaderManager.getInstance().add(this);
  },




  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {
    /*
    ---------------------------------------------------------------------------
      STATE MANAGERS
    ---------------------------------------------------------------------------
    */

    _source : null,
    _isLoaded : false,
    _isErroneous : false,




    /*
    ---------------------------------------------------------------------------
      CROSSBROWSER GETTERS
    ---------------------------------------------------------------------------
    */

    /**
     * Get the full URI of the image
     *
     * @type member
     * @return {String} The URI of the image
     */
    getUri : function() {
      return this._source;
    },


    /**
     * Get the full URI of the image
     *
     * @type member
     * @return {String} The URI of the image
     */
    getSource : function() {
      return this._source;
    },


    /**
     * Check whether the image is already loaded
     *
     * @type member
     * @return {Boolean} Whether the image is already loaded
     */
    isLoaded : function() {
      return this._isLoaded;
    },


    /**
     * Check whether the loading of the image failed
     *
     * @type member
     * @return {Boolean} Whether the loading of the image failed
     */
    isErroneous : function() {
      return this._isErroneous;
    },


    /**
     * Return the width of the image in pixel.
     *
     * @type member
     * @return {Integer} The width of the image in pixel.
     * @signature function()
     */
    getWidth : rwt.util.Variant.select("qx.client",
    {
      "gecko" : function() {
        return this._element.naturalWidth;
      },

      "default" : function() {
        return this._element.width;
      }
    }),


    /**
     * Return the height of the image in pixel.
     *
     * @type member
     * @return {Integer} The height of the image in pixel.
     * @signature function()
     */
    getHeight : rwt.util.Variant.select("qx.client",
    {
      "gecko" : function() {
        return this._element.naturalHeight;
      },

      "default" : function() {
        return this._element.height;
      }
    }),


    /**
     * Load handler
     *
     * @type member
     * @return {void}
     */
    __onload : function() {
      try {
        if( this._isLoaded || this._isErroneous ) {
          return;
        }
        this._isLoaded = true;
        this._isErroneous = false;
        if( this.hasEventListeners( "load" ) ) {
          this.dispatchEvent( new rwt.event.Event( "load" ), true );
        }
      } catch( ex ) {
        rwt.runtime.ErrorHandler.processJavaScriptError( ex );
      }
    },


    /**
     * Error handler
     *
     * @type member
     * @return {void}
     */
    __onerror : function() {
      try {
        if( this._isLoaded || this._isErroneous ) {
          return;
        }
        this._isLoaded = false;
        this._isErroneous = true;
        if( this.hasEventListeners( "error" ) ) {
          this.dispatchEvent( new rwt.event.Event( "error" ), true );
        }
      } catch( ex ) {
        rwt.runtime.ErrorHandler.processJavaScriptError( ex );
      }
    }
  },




  /*
  *****************************************************************************
     DESTRUCTOR
  *****************************************************************************
  */

  destruct : function()
  {
    if (this._element)
    {
      // terminate any downloading in progress and free memory for image
      // this._element.src = "";

      this._element.onload = this._element.onerror = null;
    }

    this._disposeFields("_element", "_isLoaded", "_isErroneous" );
  }
});

/*******************************************************************************
 * Copyright (c) 2002, 2013 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

rwt.qx.Class.define("rwt.widgets.util.Layout", {
  /*
  *****************************************************************************
     STATICS
  *****************************************************************************
  */

  statics : {
    ORIENTATION_HORIZONTAL : "horizontal",
    ORIENTATION_VERTICAL   : "vertical",
    ALIGN_LEFT             : "left",
    ALIGN_LEFT_REVERSED    : "left-reversed",
    ALIGN_CENTER           : "center",
    ALIGN_CENTER_REVERSED  : "center-reversed",
    ALIGN_RIGHT            : "right",
    ALIGN_RIGHT_REVERSED   : "right-reversed",
    ALIGN_TOP              : "top",
    ALIGN_TOP_REVERSED     : "top-reversed",
    ALIGN_MIDDLE           : "middle",
    ALIGN_MIDDLE_REVERSED  : "middle-reversed",
    ALIGN_BOTTOM           : "bottom",
    ALIGN_BOTTOM_REVERSED  : "bottom-reversed"
  }
});

/*******************************************************************************
 * Copyright (c) 2004, 2013 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

rwt.qx.Class.define("rwt.widgets.base.HorizontalBoxLayout", {
  extend : rwt.widgets.base.BoxLayout
});

/*******************************************************************************
 * Copyright (c) 2004, 2014 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

/**
 * A *spinner* is a control that allows you to adjust a numerical value,
 * typically within an allowed range. An obvious example would be to specify the
 * month of a year as a number in the range 1 - 12.
 *
 * To do so, a spinner encompasses a field to display the current value (a
 * textfield) and controls such as up and down buttons to change that value. The
 * current value can also be changed by editing the display field directly, or
 * using mouse wheel and cursor keys.
 *
 * To implement the range of a spinner's value, a {@link rwt.util.Range
 * Range} object is deployed as the {@link #manager} object. Here you can define the
 * boundaries of the range (*min* and *max* properties), the *default* value,
 * the *precision* and whether the range should *wrap* when stepping beyond a
 * border (see the Range documentation for more information). An optional {@link
 * #numberFormat} property allows you to control the format of how a value can
 * be entered and will be displayed.
 *
 * A brief, but non-trivial example:
 *
 * <pre>
 * var s = new rwt.widgets.base.Spinner;
 * s.set({
 *   max: 3000,
 *   min: -3000
 * });
 * var nf = new qx.util.format.NumberFormat();
 * nf.setMaximumFractionDigits(2);
 * s.setNumberFormat(nf);
 * s.getManager().setPrecision(2);
 * </pre>
 *
 * A spinner instance without any further properties specified in the
 * constructor or a subsequent *set* command will appear with default
 * values and behaviour.
 *
 * @appearance spinner
 *
 * @appearance spinner-field {rwt.widgets.base.BasicText}
 *
 * @appearance spinner-button-up {rwt.widgets.base.Image}
 * @state pressed {spinner-button-up}
 *
 * @appearance spinner-button-down {rwt.widgets.base.Image}
 * @state pressed {spinner-button-down}
 */
rwt.qx.Class.define("rwt.widgets.base.Spinner",
{
  extend : rwt.widgets.base.HorizontalBoxLayout,




  /*
  *****************************************************************************
     CONSTRUCTOR
  *****************************************************************************
  */

  construct : function(vMin, vValue, vMax)
  {
    this.base(arguments);

    // ************************************************************************
    //   TEXTFIELD
    // ************************************************************************
    this._textfield = new rwt.widgets.base.BasicText();
    this._textfield.setBorder(null);
    this._textfield.setWidth("1*");
    this._textfield.setAllowStretchY(true);
    this._textfield.setHeight(null);
    this._textfield.setVerticalAlign("middle");
    this._textfield.setAppearance("spinner-text-field");
    this.add(this._textfield);

    // ************************************************************************
    //   BUTTON LAYOUT
    // ************************************************************************
    this._buttonlayout = new rwt.widgets.base.VerticalBoxLayout();
    this._buttonlayout.setWidth("auto");
    this.add(this._buttonlayout);

    // ************************************************************************
    //   UP-BUTTON
    // ************************************************************************
    this._upbutton = new rwt.widgets.base.BasicButton( "push", true );
    this._upbutton.setAppearance("spinner-button-up");
    this._upbutton.setTabIndex(null);
    this._upbutton.setHeight("1*");
    this._buttonlayout.add(this._upbutton);

    // ************************************************************************
    //   DOWN-BUTTON
    // ************************************************************************
    this._downbutton = new rwt.widgets.base.BasicButton( "push", true );
    this._downbutton.setAppearance("spinner-button-down");
    this._downbutton.setTabIndex(null);
    this._downbutton.setHeight("1*");
    this._buttonlayout.add(this._downbutton);

    // ************************************************************************
    //   TIMER
    // ************************************************************************
    this._timer = new rwt.client.Timer(this.getInterval());

    // ************************************************************************
    //   MANAGER
    // ************************************************************************
    this.setManager(new rwt.util.Range());
    this.initWrap();

    // ************************************************************************
    //   EVENTS
    // ************************************************************************
    this.addEventListener("keypress", this._onkeypress, this);
    this.addEventListener("keydown", this._onkeydown, this);
    this.addEventListener("keyup", this._onkeyup, this);
    this.addEventListener("mousewheel", this._onmousewheel, this);

    this._textfield.addEventListener("changeValue", this._ontextchange, this);
    this._textfield.addEventListener("input", this._oninput, this);
    this._textfield.addEventListener("blur", this._onblur, this);
    this._textfield.addEventListener("keypress", this._onkeypress, this);
    this._upbutton.addEventListener("mousedown", this._onmousedown, this);
    this._downbutton.addEventListener("mousedown", this._onmousedown, this);
    this._timer.addEventListener("interval", this._oninterval, this);

    // ************************************************************************
    //   INITIALIZATION
    // ************************************************************************
    if (vMin != null) {
      this.setMin(vMin);
    }

    if (vMax != null) {
      this.setMax(vMax);
    }

    if (vValue != null) {
      this.setValue(vValue);
    }

    this._checkValue = this.__checkValue;

    this.initWidth();
    this.initHeight();

    this._last_value = "";
  },




  /*
  *****************************************************************************
     EVENTS
  *****************************************************************************
  */

  events: {
    /**
     * Fired each time the value of the spinner changes.
     * The "data" property of the event is set to the new value
     * of the spinner.
     */
    "change" : "rwt.event.DataEvent"
  },




  /*
  *****************************************************************************
     PROPERTIES
  *****************************************************************************
  */

  properties :
  {
    /*
    ---------------------------------------------------------------------------
      PROPERTIES
    ---------------------------------------------------------------------------
    */

    appearance :
    {
      refine : true,
      init : "spinner"
    },

    width :
    {
      refine : true,
      init : 60
    },

    height :
    {
      refine : true,
      init : 22
    },




    /** The amount to increment on each event (keypress or mousedown). */
    incrementAmount :
    {
      check : "Number",
      init : 1,
      apply : "_applyIncrementAmount"
    },


    /** The amount to increment on each event (keypress or mousedown). */
    wheelIncrementAmount :
    {
      check : "Number",
      init : 1
    },


    /** The amount to increment on each pageup / pagedown keypress */
    pageIncrementAmount :
    {
      check : "Number",
      init : 10
    },


    /** The current value of the interval (this should be used internally only). */
    interval :
    {
      check : "Integer",
      init : 100
    },


    /** The first interval on event based shrink/growth of the value. */
    firstInterval :
    {
      check : "Integer",
      init : 500
    },


    /** This configures the minimum value for the timer interval. */
    minTimer :
    {
      check : "Integer",
      init : 20
    },


    /** Decrease of the timer on each interval (for the next interval) until minTimer reached. */
    timerDecrease :
    {
      check : "Integer",
      init : 2
    },


    /** If minTimer was reached, how much the amount of each interval should grow (in relation to the previous interval). */
    amountGrowth :
    {
      check : "Number",
      init : 1.01
    },


    /** whether the value should wrap around */
    wrap :
    {
      check : "Boolean",
      init : false,
      apply : "_applyWrap"
    },


    /** Controls whether the textfield of the spinner is editable or not */
    editable :
    {
      check : "Boolean",
      init : true,
      apply : "_applyEditable"
    },


    /** Range manager */
    manager :
    {
      check : "rwt.util.Range",
      apply : "_applyManager",
      dispose : true
    },


    /** Holding a reference to the protected {@link _checkValue} method */
    checkValueFunction :
    {
      apply : "_applyCheckValueFunction"
    },

    /**  */
    selectTextOnInteract :
    {
      check : "Boolean",
      init : true
    }
  },




  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {

    _applyIncrementAmount : function(value) {
      this._computedIncrementAmount = value;
    },


    _applyEditable : function(value)
    {
      if (this._textfield) {
        this._textfield.setReadOnly(! value);
      }
    },


    _applyWrap : function(value)
    {
      this.getManager().setWrap(value);
      this._onchange();
    },


    _applyManager : function(value, old)
    {
      if (old)
      {
        old.removeEventListener("change", this._onchange, this);
      }

      if (value)
      {
        value.addEventListener("change", this._onchange, this);
      }

      // apply initital value
      this._onchange();
    },


    _applyCheckValueFunction : function(value) {
      this._checkValue = value;
    },

    /*
    ---------------------------------------------------------------------------
      PREFERRED DIMENSIONS
    ---------------------------------------------------------------------------
    */

    /**
     * Returns the prefered inner width for the spinner widget. Currently this
     * method returns 50.
     *
     * @type member
     * @return {Integer} prefered inner width for the spinner widget
     */
    _computePreferredInnerWidth : function() {
      return 50;
    },


    /**
     * Return the prefered inner height for the spinner widget. Currently this
     * method returns 14
     *
     * @type member
     * @return {Integer} prefered inner height for the spinner widget
     */
    _computePreferredInnerHeight : function() {
      return 14;
    },




    /*
    ---------------------------------------------------------------------------
      KEY EVENT-HANDLING
    ---------------------------------------------------------------------------
    */

    /**
     * Callback for the "keyPress" event.<br/>
     * Perform action when "Enter" (without "Alt"), control keys
     * and numeric (0-9) keys are pressed. Suppress all key events for
     * events without modifiers.
     *
     * @type member
     * @param e {rwt.event.KeyEvent} keyPress event
     * @return {void}
     */
    _onkeypress : function(e)
    {
      var vIdentifier = e.getKeyIdentifier();

      if (vIdentifier == "Enter" && !e.isAltPressed())
      {
        this._checkValue(true, false);
        if (this.getSelectTextOnInteract()) {
          this._textfield.selectAll();
        }
      }
      else
      {
        switch(vIdentifier)
        {
          case "Up":
          case "Down":
          case "Left":
          case "Right":
          case "Shift":
          case "Control":
          case "Alt":
          case "Escape":
          case "Delete":
          case "Backspace":
          case "Insert":
          case "Home":
          case "End":
          case "PageUp":
          case "PageDown":
          case "NumLock":
          case "Tab":
            break;

          default:
            if( !this._isMinus( vIdentifier ) && !this._isNumber( vIdentifier ) ) {
              var modifiers = e.getModifiers();
              if( modifiers === 0 || modifiers === rwt.event.DomEvent.SHIFT_MASK ) {
                e.preventDefault();
              }
            }
        }
      }
    },

    _isMinus : function( identifier ) {
      var caretPosition = this._textfield._getSelectionStart();
      var text = this._textfield.getValue();
      return identifier === "-" && caretPosition === 0 && !/-/.test( text );
    },

    _isNumber : function( identifier ) {
      return identifier >= "0" && identifier <= "9";
    },

    /**
     * Callback for "keyDown" event.<br/>
     * Controls the interval mode ("single" or "page")
     * and the interval increase by detecting "Up"/"Down"
     * and "PageUp"/"PageDown" keys.
     * Starting a timer to control the incrementing of the
     * spinner value.
     *
     * @type member
     * @param e {rwt.event.KeyEvent} keyDown event
     * @return {void}
     */
    _onkeydown : function(e)
    {
      var vIdentifier = e.getKeyIdentifier();

      if (this._intervalIncrease == null)
      {
        switch(vIdentifier)
        {
          case "Up":
          case "Down":
            this._intervalIncrease = vIdentifier == "Up";
            this._intervalMode = "single";

            this._resetIncrements();
            this._checkValue(true, false);

            this._increment();
            this._timer.startWith(this.getFirstInterval());

            break;

          case "PageUp":
          case "PageDown":
            this._intervalIncrease = vIdentifier == "PageUp";
            this._intervalMode = "page";

            this._resetIncrements();
            this._checkValue(true, false);

            this._pageIncrement();
            this._timer.startWith(this.getFirstInterval());

            break;
        }
      }
    },


    /**
     * Callback for "keyUp" event.<br/>
     * Detecting "Up"/"Down" and "PageUp"/"PageDown" keys.
     * If detected the interval mode and interval increase get resetted
     * and the timer for the control of the increase of the spinner value
     * gets stopped.
     *
     * @type member
     * @param e {rwt.event.KeyEvent} keyUp event
     * @return {void}
     */
    _onkeyup : function(e)
    {
      if (this._intervalIncrease != null)
      {
        switch(e.getKeyIdentifier())
        {
          case "Up":
          case "Down":
          case "PageUp":
          case "PageDown":
            this._timer.stop();

            this._intervalIncrease = null;
            this._intervalMode = null;
        }
      }
    },




    /*
    ---------------------------------------------------------------------------
      MOUSE EVENT-HANDLING
    ---------------------------------------------------------------------------
    */

    /**
     * Callback method for the "mouseDown" event of the spinner buttons.<br/>
     * State handling, registering event listeners at the spinner button and
     * invoking the increment management (resets increments, setup and start timer etc.).
     *
     * @type member
     * @param e {rwt.event.MouseEvent} mouseDown event
     * @return {void}
     */
    _onmousedown : function(e)
    {
      if (!e.isLeftButtonPressed()) {
        return;
      }

      this._checkValue(true);

      var vButton = e.getCurrentTarget();

      vButton.addState("pressed");

      vButton.addEventListener("mouseup", this._onmouseup, this);
      vButton.addEventListener("mouseout", this._onmouseup, this);

      this._intervalIncrease = vButton == this._upbutton;
      this._resetIncrements();
      this._increment();

      if (this.getSelectTextOnInteract()) {
        this._textfield.selectAll();
      }

      this._timer.setInterval(this.getFirstInterval());
      this._timer.start();
    },


    /**
     * Callback method for the "mouseUp" event of the spinner buttons.<br/>
     * State handling, removing event listeners at the spinner button, focusing
     * the text field and resetting the interval management (stopping timer,
     * resetting interval increase).
     *
     * @type member
     * @param e {rwt.event.MouseEvent} mouseUp event
     * @return {void}
     */
    _onmouseup : function(e)
    {
      var vButton = e.getCurrentTarget();

      vButton.removeState("pressed");

      vButton.removeEventListener("mouseup", this._onmouseup, this);
      vButton.removeEventListener("mouseout", this._onmouseup, this);

      if (this.getSelectTextOnInteract()) {
        this._textfield.selectAll();
      }
      this._textfield.setFocused(true);

      this._timer.stop();
      this._intervalIncrease = null;
    },


    /**
     * Callback method for the "mouseWheel" event.<br/>
     * Delegates the in-/decrementing to the manager and
     * selects the text field.
     *
     * @type member
     * @param e {rwt.event.MouseEvent} mouseWheel event
     * @return {void}
     */
    _onmousewheel : function(e)
    {
      this._checkValue(true);
      if (this.getManager().incrementValue)
      {
        this.getManager().incrementValue(this.getWheelIncrementAmount() *
                                         e.getWheelDelta());
      }
      else
      {
        var value = this.getManager().getValue() +
                                   (this.getWheelIncrementAmount() *
                                    e.getWheelDelta());
        value = this.getManager().limit(value);
        this.getManager().setValue(value);
      }
      if( this.getSelectTextOnInteract() ) {
        this._textfield.selectAll();
      }
      // RAP [rst] See https://bugs.eclipse.org/bugs/show_bug.cgi?id=283546
      e.preventDefault();
      e.stopPropagation();
      // END RAP
    },




    /*
    ---------------------------------------------------------------------------
      OTHER EVENT-HANDLING
    ---------------------------------------------------------------------------
    */

    /**
     * Event handler method for text changes
     *
     * @type member
     * @param e {rwt.event.ChangeEvent} change event
     * @return {void}
     */
    _ontextchange : function(e) {
      this._last_value = e.getOldValue();
    },

    /**
     * Callback method for the "input" event.<br/>
     * Delegates the further processing to the method
     * hold by the "checkValue" property.
     *
     * @type member
     * @param e {rwt.event.DataEvent} input event
     * @return {void}
     */
    _oninput : function() {
      this._checkValue(true, true);
    },


    /**
     * Callback method for the "change" event.<br/>
     * Sets the value of the text field and enables/disables
     * the up-/down-buttons of the min-/max-value are reached
     * (additionally stops the timer of the min-/max-boundaries are reached)
     * Dispatched the "change" event.
     *
     * @type member
     * @param e {rwt.event.ChangeEvent} change event
     * @return {void}
     */
    _onchange : function()
    {
      var vValue = this.getManager().getValue();
      this._textfield.setValue(String(vValue));

      if (vValue == this.getMin() && !this.getWrap())
      {
        this._downbutton.removeState("pressed");
        this._downbutton.setEnabled(false);
        this._timer.stop();
      }
      else
      {
        this._downbutton.resetEnabled();
      }

      if (vValue == this.getMax() && !this.getWrap())
      {
        this._upbutton.removeState("pressed");
        this._upbutton.setEnabled(false);
        this._timer.stop();
      }
      else
      {
        this._upbutton.resetEnabled();
      }

      this.createDispatchDataEvent("change", vValue);
    },


    /**
     * Callback method for the "blur" event.<br/>
     * Calls the method of the "checkValueFunction" property
     *
     * @type member
     * @param e {rwt.event.FocusEvent} blur event
     * @return {void}
     */
    _onblur : function() {
      this._checkValue(false);
    },




    /*
    ---------------------------------------------------------------------------
      MAPPING TO RANGE MANAGER
    ---------------------------------------------------------------------------
    */

    /**
     * Mapping to the "setValue" method of the Range manager
     *
     * @type member
     * @param nValue {Number} new value of the spinner
     * @return {void}
     */
    setValue : function(nValue) {
      this.getManager().setValue(this.getManager().limit(nValue));
    },


    /**
     * Mapping to the "getValue" method of the Range manager
     *
     * @type member
     * @return {Number} Current value of the spinner
     */
    getValue : function()
    {
      // make sure the manager is uptodate with what is on screen
      this._checkValue(true);
      return this.getManager().getValue();
    },


    /**
     * Mapping to the "resetValue" method of the Range manager
     *
     * @type member
     * @return {void}
     */
    resetValue : function() {
      this.getManager().resetValue();
    },


    /**
     * Mapping to the "setMax" method of the Range manager
     *
     * @type member
     * @param vMax {Number} new max value of the spinner
     * @return {Number} new max value of the spinner
     */
    setMax : function(vMax) {
      return this.getManager().setMax(vMax);
    },


    /**
     * Mapping to the "getMax" method of the Range manager
     *
     * @type member
     * @return {Number} current max value of the spinner
     */
    getMax : function() {
      return this.getManager().getMax();
    },


    /**
     * Mapping to the "setMin" method of the Range manager
     *
     * @type member
     * @param vMin {Number} new min value of the spinner
     * @return {Number} new min value of the spinner
     */
    setMin : function(vMin) {
      return this.getManager().setMin(vMin);
    },


    /**
     * Mapping to the "getMin" method of the Range manager
     *
     * @type member
     * @return {Number} current min value of the spinner
     */
    getMin : function() {
      return this.getManager().getMin();
    },


    /*
    ---------------------------------------------------------------------------
      INTERVAL HANDLING
    ---------------------------------------------------------------------------
    */

    _intervalIncrease : null,


    /**
     * Callback method for the "interval" event.<br/>
     * Stops the timer and sets a new interval. Executes the increment
     * of the spinner depending on the intervalMode and restarts the timer with
     * the new interval.
     *
     * @type member
     * @param e {rwt.event.Event} interval event
     * @return {void}
     */
    _oninterval : function()
    {
      this._timer.stop();
      this.setInterval(Math.max(this.getMinTimer(), this.getInterval() - this.getTimerDecrease()));

      if (this._intervalMode == "page")
      {
        this._pageIncrement();
      }
      else
      {
        if (this.getInterval() == this.getMinTimer()) {
          this._computedIncrementAmount = this.getAmountGrowth() * this._computedIncrementAmount;
        }

        this._increment();
      }

      var wrap = this.getManager().getWrap();

      switch( this._intervalIncrease ) {
        case true:
          if( !( this.getValue() == this.getMax() && !wrap ) ) {
            this._timer.restartWith(this.getInterval());
          }
        break;
        case false:
          if( !( this.getValue() == this.getMin() && !wrap ) ) {
            this._timer.restartWith(this.getInterval());
          }
        break;
      }
    },




    /*
    ---------------------------------------------------------------------------
      UTILITY
    ---------------------------------------------------------------------------
    */

    /**
     * Default check value utility method
     *
     * @type member
     * @param acceptEmpty {Boolean} Whether empty values are allowed or not.
     * @param acceptEdit {Boolean} Whether editing is accepted or not.
     * @return {void}
     */
    __checkValue : function(acceptEmpty, acceptEdit)
    {
      var el = this._textfield.getInputElement();

      if (!el) {
        return;
      }

      if( ( el.value === "" ) || ( el.value === "-" ) ) {
        if (!acceptEmpty)
        {
          this.resetValue();
          return;
        }
      }
      else
      {
        // cache original value
        var str_val = el.value;

        // prepare for parsing. We don't use numberFormat itself to parse the
        // string, as we want to be a little more liberal at this point since
        // we might be currently editing the string. For example, we accept
        // things like "4000."
        var parsable_str;

        parsable_str = str_val;

        // parse the string
        var val = parseFloat(parsable_str);
        var limitedVal = this.getManager().limit(val);
        var oldValue = this.getManager().getValue();
        var fixedVal = limitedVal;

        // NaN means we had a parse error, but we'll be more picky than
        // parseFloat (refuse stuff like 5.55-12.5 which parseFloat
        // parses as 5.55). We also refuse values outside the range.
        if (isNaN(val) || (limitedVal != val) || (val != parsable_str))
        {
          if (acceptEdit) {
            this._textfield.setValue(this._last_value);
          } else {
            if (isNaN(limitedVal)) {
              // reset to last correct value
              fixedVal = oldValue;
            } else {
              fixedVal = limitedVal;
            }
          }
        }
        if( acceptEdit ) {
          return;
        }

        var formattedValue;

        formattedValue = String(fixedVal);

        if ((fixedVal === oldValue) && (str_val !== formattedValue)) {
          // "silently" update the displayed value as it won't get
          // updated by the range manager since it considers the value as
          // unchanged.
          this._textfield.setValue(formattedValue);
        }

        // inform manager
        this.getManager().setValue(fixedVal);
      }
    },


    /**
     * Performs a normal increment
     *
     * @type member
     * @return {void}
     */
    _increment : function()
    {
      if (this.getManager().incrementValue)
      {
        this.getManager().incrementValue((this._intervalIncrease ? 1 : -1) *
                                         this._computedIncrementAmount);
      }
      else
      {
        var value = this.getManager().getValue() +
                                   ((this._intervalIncrease ? 1 : -1) *
                                    this._computedIncrementAmount);

        value = this.getManager().limit(value);

        this.getManager().setValue(value);
      }
    },


    /**
     * Performs a page increment
     *
     * @type member
     * @return {void}
     */
    _pageIncrement : function()
    {
      if (this.getManager().pageIncrementValue)
      {
        this.getManager().pageIncrementValue();
      }
      else
      {
        var value = this.getManager().getValue() +
                                   ((this._intervalIncrease ? 1 : -1) *
                                    this.getPageIncrementAmount());

        value = this.getManager().limit(value);

        this.getManager().setValue(value);
      }
    },


    /**
     * Reset the increments
     *
     * @type member
     * @return {void}
     */
    _resetIncrements : function()
    {
      this._computedIncrementAmount = this.getIncrementAmount();
      this.resetInterval();
    }
  },




  /*
  *****************************************************************************
     DESTRUCTOR
  *****************************************************************************
  */

  destruct : function()
  {
    var mgr = this.getManager();
    if (mgr) {
      mgr.dispose();
    }

    this._disposeObjects("_textfield", "_buttonlayout", "_upbutton", "_downbutton",
      "_timer");
  }
});

/*******************************************************************************
 * Copyright: 2004, 2015 1&1 Internet AG, Germany, http://www.1und1.de,
 *                       and EclipseSource
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v1.0 which accompanies this
 * distribution, and is available at http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

rwt.qx.Class.define( "rwt.widgets.base.BasicText", {

  extend : rwt.widgets.base.Terminator,

  construct : function( value ) {
    this.base( arguments );
    if( value != null ) {
      this.setValue( value );
    }
    this.initWidth();
    this.initHeight();
    this.initTabIndex();
    this._selectionStart = 0;
    this._selectionLength = 0;
    this.__oninput = rwt.util.Functions.bind( this._oninput, this );
    this.addEventListener( "blur", this._onblur );
    this.addEventListener( "keydown", this._onkeydown );
    this.addEventListener( "keypress", this._onkeypress );
    this.addEventListener( "keyup", this._onkeyup, this );
    this.addEventListener( "mousedown", this._onMouseDownUp, this );
    this.addEventListener( "mouseup", this._onMouseDownUp, this );
    this._typed = null;
    this._selectionNeedsUpdate = false;
    this._applyBrowserFixes();
    this._inputOverflow = "hidden";
  },

  destruct : function() {
    if( this._inputElement != null ) {
      this._inputElement.removeEventListener( "input", this.__oninput, false );
    }
    this._inputElement = null;
    this.__font = null;
    if( this._checkTimer ) {
      this._checkTimer.dispose();
      this._checkTimer = null;
    }
  },

  events: {
    "input" : "rwt.event.DataEvent"
  },

  properties : {

    allowStretchX : { refine : true, init : true },
    allowStretchY : { refine : true, init : false },
    appearance : { refine : true, init : "text-field" },
    tabIndex : { refine : true, init : 1 },
    hideFocus : { refine : true, init : true },
    width : { refine : true, init : "auto" },
    height : { refine : true, init : "auto" },
    selectable : { refine : true, init : true },

    value : {
      init : "",
      nullable : true,
      event : "changeValue",
      apply : "_applyValue",
      dispose : true // in the case we use i18n text here
    },

    textAlign : {
      check : [ "left", "center", "right", "justify" ],
      nullable : true,
      themeable : true,
      apply : "_applyTextAlign"
    },

    maxLength : {
      check : "Integer",
      apply : "_applyMaxLength",
      nullable : true
    },

    readOnly : {
      check : "Boolean",
      apply : "_applyReadOnly",
      init : false,
      event : "changeReadOnly"
    }

  },

  members : {
    _inputTag : "input",
    _inputType : "text",
    _inputElement : null,

    /////////
    // API

    setSelection : function( selection ) {
      this._selectionStart = selection[ 0 ];
      this._selectionLength = selection[ 1 ] - selection[ 0 ];
      this._renderSelection();
    },

    getSelection : function() {
      return [ this._selectionStart, this._selectionStart + this._selectionLength ];
    },

    getComputedSelection : function() {
      var start = this._getSelectionStart();
      var length = this._getSelectionLength();
      return [ start, start + length ];
    },

    getComputedValue : function() {
      var result;
      if( this.isCreated() ) {
        result = this._inputElement.value;
      } else {
        result = this.getValue();
      }
      return result;
    },

    getInputElement : function() {
      if( !this._inputElement && !this.isDisposed() ) {
        this._inputElement = document.createElement( this._inputTag );
        if( this._inputType ) {
          this._inputElement.type = this._inputType;
        }
        this._inputElement.style.position = "absolute";
        this._inputElement.autoComplete = "off";
        this._inputElement.setAttribute( "autoComplete", "off" );
      }
      return this._inputElement || null;
    },

    /////////////////////
    // selection handling

    _renderSelection : function() {
      // setting selection here might de-select all other selections, so only render if focused
      if( this.isCreated() && ( this.getFocused() || this.getParent().getFocused() ) ) {
        this._setSelectionStart( this._selectionStart );
        this._setSelectionLength( this._selectionLength );
        this._selectionNeedsUpdate = false;
      }
    },

    _detectSelectionChange : function() {
      if( this._isCreated ) {
        var start = this._getSelectionStart();
        var length = this._getSelectionLength();
        if( typeof start === "undefined" ) {
          start = 0;
        }
        if( typeof length === "undefined" ) {
          length = 0;
        }
        if( this._selectionStart !== start || this._selectionLength !== length ) {
          this._handleSelectionChange( start, length );
        }
      }
    },

    _handleSelectionChange : function( start, length ) {
      this._selectionStart = start;
      this._selectionLength = length;
      this.dispatchSimpleEvent( "selectionChanged" );
    },

    _setSelectionStart : function( vStart ) {
      this._visualPropertyCheck();
      // the try catch blocks are neccesary because FireFox raises an exception
      // if the property "selectionStart" is read while the element or one of
      // its parent elements is invisible
      // https://bugzilla.mozilla.org/show_bug.cgi?id=329354
      try {
        if( this._inputElement.selectionStart !== vStart ) {
          this._inputElement.selectionStart = vStart;
        }
      } catch(ex ) {
        // do nothing
      }
    },

    _getSelectionStart : function() {
      this._visualPropertyCheck();
      try {
        if( this.isValidString( this._inputElement.value ) ) {
          return this._inputElement.selectionStart;
        } else {
          return 0;
        }
      } catch( ex ) {
        return 0;
      }
    },

    _setSelectionLength : function( length ) {
      this._visualPropertyCheck();
      try {
        if( this.isValidString( this._inputElement.value ) ) {
          var end = this._inputElement.selectionStart + length;
          if( this._inputElement.selectionEnd != end ) {
            this._inputElement.selectionEnd = end;
          }
        }
      } catch( ex ) {
        // do nothing
      }
    },

    _getSelectionLength : function() {
      this._visualPropertyCheck();
      try {
        return this._inputElement.selectionEnd - this._inputElement.selectionStart;
      } catch( ex ) {
        return 0;
      }
    },

    selectAll : function() {
      this._visualPropertyCheck();
      if( this.getValue() != null ) {
        this._setSelectionStart( 0 );
        this._setSelectionLength( this._inputElement.value.length );
      }
      // to be sure we get the element selected
      this._inputElement.select();
      // RAP [if] focus() leads to error in IE if the _inputElement is disabled or not visible.
      // 277444: JavaScript error in IE when using setSelection on a ComboViewer with setEnabled
      // is false
      // https://bugs.eclipse.org/bugs/show_bug.cgi?id=277444
      // 280420: [Combo] JavaScript error in IE when using setSelection on an invisible Combo
      // https://bugs.eclipse.org/bugs/show_bug.cgi?id=280420
      if( this.isEnabled() && this.isSeeable() ) {
        this._inputElement.focus();
      }
      this._detectSelectionChange();
    },

    ////////////
    // rendering

    _applyElement : function( value, old ) {
      this.base( arguments, value, old );
      if( value ) {
        var inputElement = this.getInputElement();
        inputElement.disabled = this.getEnabled() === false;
        inputElement.readOnly = this.getReadOnly();
        inputElement.value = this.getValue() != null ? this.getValue().toString() : "";
        if( this.getMaxLength() != null ) {
          inputElement.maxLength = this.getMaxLength();
        }
        inputElement.style.padding = 0;
        inputElement.style.margin = 0;
        inputElement.style.border = "0 none";
        inputElement.style.background = "transparent";
        // See Bug 419676: [Text] Input element of Text field may not be vertically centered in IE
        if( rwt.client.Client.isTrident() ) {
          inputElement.style.verticalAlign = "top";
        }
        inputElement.style.overflow = this._inputOverflow;
        inputElement.style.outline = "none";
        inputElement.style.resize = "none";
        inputElement.style.WebkitAppearance = "none";
        inputElement.style.MozAppearance = "none";
        this._renderFont();
        this._renderTextColor();
        this._renderTextAlign();
        this._renderCursor();
        this._renderTextShadow();
        this._textInit();
        this._getTargetNode().appendChild( this._inputElement );
      }
    },

    _textInit : function() {
      this._inputElement.addEventListener( "input", this.__oninput, false );
      this._applyBrowserFixesOnCreate();
    },

    _postApply : function() {
      this._syncFieldWidth();
      this._syncFieldHeight();
    },

    _changeInnerWidth : function() {
      this._syncFieldWidth();
    },

    _changeInnerHeight : function() {
      this._syncFieldHeight();
      this._centerFieldVertically();
    },

    _syncFieldWidth : function() {
      this._inputElement.style.width = Math.max( 2, this.getInnerWidth() ) + "px";
    },

    _syncFieldHeight : function() {
      if( this._inputTag !== "input" ) {
        this._inputElement.style.height = this.getInnerHeight() + "px";
      }
    },

    _applyCursor : function() {
      if( this.isCreated() ) {
        this._renderCursor();
      }
    },

    _renderCursor : function() {
      var value = this.getCursor();
      if( value ) {
        this._inputElement.style.cursor = value;
      } else {
        this._inputElement.style.cursor = "";
      }
    },

    _applyTextAlign : function() {
      if( this._inputElement ) {
        this._renderTextAlign();
      }
    },

    _renderTextAlign : function() {
      this._inputElement.style.textAlign = this.getTextAlign() || "";
    },

    _applyEnabled : function( value, old ) {
      if( this.isCreated() ) {
        this._inputElement.disabled = value === false;
      }
      return this.base( arguments, value, old );
    },

    _applyValue : function() {
      this._renderValue();
      this._detectSelectionChange();
    },

    _renderValue : function() {
      this._inValueProperty = true;
      var value = this.getValue();
      if( this.isCreated() ) {
        if (value === null) {
          value = "";
        }
        if( this._inputElement.value !== value ) {
          this._inputElement.value = value;
        }
      }
      delete this._inValueProperty;
    },

    _applyMaxLength : function( value ) {
      if( this._inputElement ) {
        this._inputElement.maxLength = value == null ? "" : value;
      }
    },

    _applyReadOnly : function( value ) {
      if( this._inputElement ) {
        this._inputElement.readOnly = value;
      }
      this.toggleState( "readonly", value );
    },

    _renderTextColor : function() {
      if( this.isCreated() ) {
        var color = this.getEnabled() ? this.getTextColor() : this.__theme$textColor;
        if( this._textColor !== color ) {
          this._textColor = color;
          rwt.html.Style.setStyleProperty( this._inputElement, "color", color || "" );
        }
      }
    },

    _applyFont : function( value ) {
      this._styleFont( value );
    },

    _styleFont : function( value ) {
      this.__font = value;
      this._renderFont();
    },

    _renderFont : function() {
      if( this.isCreated() ) {
        if( this.__font != null ) {
          this.__font.renderElement( this._inputElement );
        } else {
          rwt.html.Font.resetElement( this._inputElement );
        }
      }
    },

    _applyTextShadow : function( value ) {
      this.__textShadow = value;
      if( this._inputElement ) {
        this._renderTextShadow();
      }
    },

    _renderTextShadow : function() {
      rwt.html.Style.setTextShadow( this._inputElement, this.__textShadow );
    },

    _visualizeFocus : function() {
      this.base( arguments );
      if( !rwt.widgets.util.FocusHandler.blockFocus ) {
        try {
          this._inputElement.focus();
        } catch( ex ) {
          // ignore
        }
      }
    },

    _visualizeBlur : function() {
      this.base( arguments );
      try {
        this._inputElement.blur();
      } catch( ex ) {
        // ignore
      }
    },

    _afterAppear : function() {
      this.base( arguments );
      this._centerFieldVertically();
      this._renderSelection();
    },


    _centerFieldVertically : function() {
      if( this._inputTag === "input" && this._inputElement ) {
        var innerHeight = this.getInnerHeight();
        var inputElementHeight = this._inputElement.offsetHeight;
        if( inputElementHeight !== 0 ) {
          var top = ( innerHeight - inputElementHeight ) / 2;
          if( top < 0 ) {
            top = 0;
          }
          this._inputElement.style.top = Math.floor( top ) + "px";
        }
      }
    },

    ////////////////
    // event handler

    _oninput : function() {
      try {
        var doit = true;
        if( this.hasEventListeners( "input" ) ) {
          doit = this.dispatchEvent( new rwt.event.DataEvent( "input", this._typed ), true );
        }
        if( doit ) {
          // at least webkit does sometiems fire "input" before the selection is updated
          rwt.client.Timer.once( this._updateValueProperty, this, 0 );
        } else if( rwt.client.Client.isWebkit() || rwt.client.Client.isBlink() ) {
          // some browser set new selection after input event, ignoring all changes before that
          rwt.client.Timer.once( this._renderSelection, this, 0 );
          this._selectionNeedsUpdate = true;
        }
      } catch( ex ) {
        rwt.runtime.ErrorHandler.processJavaScriptError( ex );
      }
    },

    _updateValueProperty : function() {
      if( !this.isDisposed() ) {
        this.setValue( this.getComputedValue().toString() );
      }
    },

    _ontabfocus : function() {
      this.selectAll();
    },

    _applyFocused : function( newValue, oldValue ) {
      this.base( arguments, newValue, oldValue );
      if( newValue && !rwt.widgets.util.FocusHandler.mouseFocus ) {
        this._renderSelection();
      }
    },

    _onblur : function() {
      // RAP workaround for https://bugs.eclipse.org/bugs/show_bug.cgi?id=201080
      if( this.getParent() != null ) {
        this._setSelectionLength( 0 );
      }
    },

    // [rst] Catch backspace in readonly text fields to prevent browser default
    // action (which commonly triggers a history step back)
    // See https://bugs.eclipse.org/bugs/show_bug.cgi?id=178320
    _onkeydown : function( e ) {
      if( e.getKeyIdentifier() == "Backspace" && this.getReadOnly() ) {
        e.preventDefault();
      }
      this._detectSelectionChange();
      this._typed = null;
    },

    // [if] Stops keypress propagation
    // see https://bugs.eclipse.org/bugs/show_bug.cgi?id=335779
    _onkeypress : function( e ) {
      if( e.getKeyIdentifier() !== "Tab" ) {
        e.stopPropagation();
      }
      if( this._selectionNeedsUpdate ) {
        this._renderSelection();
      }
      this._detectSelectionChange();
      this._typed = String.fromCharCode( e.getCharCode() );
    },

    _onkeyup : function() {
      if( this._selectionNeedsUpdate ) {
        this._renderSelection();
      }
      this._detectSelectionChange();
      this._typed = null;
    },

    _onMouseDownUp : function() {
      this._detectSelectionChange();
      this._typed = null;
    },

    /////////////////
    // browser quirks

    _applyBrowserFixes : rwt.util.Variant.select( "qx.client", {
      "default" : function() {},
      "trident" : function() {
        // See Bug 372193 - Text widget: Modify Event not fired for Backspace key in IE
        this._checkTimer = new rwt.client.Timer( 0 );
        this._checkTimer.addEventListener( "interval", this._checkValueChanged, this );
        // For delete, backspace, CTRL+X, etc:
        this.addEventListener( "keypress", this._checkTimer.start, this._checkTimer );
        this.addEventListener( "keyup", this._checkTimer.start, this._checkTimer );
        // For context menu: (might not catch the change instantly
        this.addEventListener( "mousemove", this._checkValueChanged, this );
        this.addEventListener( "mouseout", this._checkValueChanged, this );
        // Backup for all other cases (e.g. menubar):
        this.addEventListener( "blur", this._checkValueChanged, this );
      }
    } ),

    _checkValueChanged : function() {
      this._checkTimer.stop();
      var newValue = this.getComputedValue();
      var oldValue = this.getValue();
      if( newValue !== oldValue ) {
        this._oninput();
      }
    },

    _applyBrowserFixesOnCreate  : rwt.util.Variant.select( "qx.client", {
      "default" : function() {},
      "webkit|blink" : function() {
        this.addEventListener( "keydown", this._preventEnter, this );
        this.addEventListener( "keypress", this._preventEnter, this );
        this.addEventListener( "keyup", this._preventEnter, this );
      }
    } ),

    _preventEnter : function( event ) {
      if( event.getKeyIdentifier() === "Enter" ) {
        event.preventDefault();
      }
    },

    /////////
    // helper

    isValidString : function( v ) {
      return typeof v === "string" && v !== "";
    }
  }

} );

/*******************************************************************************
 * Copyright (c) 2004, 2013 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

rwt.qx.Class.define("rwt.widgets.base.VerticalBoxLayout",
{
  extend : rwt.widgets.base.BoxLayout,

  properties :
  {
    orientation :
    {
      refine : true,
      init : "vertical"
    }
  }
});

/*******************************************************************************
 * Copyright (c) 2004, 2014 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

/**
 * This manager is used by all objects which needs ranges like rwt.widgets.base.Spinner, ...
 */
rwt.qx.Class.define( "rwt.util.Range", {

  extend : rwt.qx.Target,

  events: {
    "change" : "rwt.event.Event"
  },

  properties : {

    /** current value of the Range object */
    value : {
      check : "!isNaN(value)&&value>=this.getMin()&&value<=this.getMax()",
      nullable : true,
      event : "change",
      init : 0
    },

    /** maximum fraction digits */
    precision : {
      check : "Integer",
      nullable : true,
      event : "change",
      init : 0
    },

    /** minimal value of the Range object */
    min : {
      check : "Number",
      apply : "_applyMin",
      event : "change",
      init : 0
    },

    /** maximal value of the Range object */
    max : {
      check : "Number",
      apply : "_applyMax",
      event : "change",
      init : 100
    },

    /** whether the value should wrap around */
    wrap : {
      check : "Boolean",
      init : false
    }
  },

  members : {

    /**
     * TODOC
     *
     * @type member
     * @param value {var} Current value
     * @param old {var} Previous value
     */
    _applyMax : function( value ) {
      this.setValue( Math.min( this.getValue(), value ) );
    },

    /**
     * TODOC
     *
     * @type member
     * @param value {var} Current value
     * @param old {var} Previous value
     */
    _applyMin : function( value ) {
      this.setValue( Math.max( this.getValue(), value) );
    },

    limit : function( value ) {
      var precision = this.getPrecision();
      if( precision != null ) {
        var mover = Math.pow( 10, precision );
      }

      if (this.getWrap()) {
        if (precision != null) {
          // round to the precision'th digit
          value = Math.round( value * mover ) / mover;
        }

        if (value < this.getMin()) {
          return ( this.getMax() - ( this.getMin() - value ) ) + 1;
        }
        if (value > this.getMax()) {
          return ( this.getMin() + ( value - this.getMax() ) ) - 1;
        }
      }

      if( value < this.getMin() ) {
        return this.getMin();
      }

      if( value > this.getMax() ) {
        return this.getMax();
      }

      if( precision != null ) {
        return Math.round( value * mover ) / mover;
      } else {
        return value;
      }
    }
  }
} );

/*******************************************************************************
 * Copyright (c) 2004, 2014 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

/**
 * @appearance tab-view
 */
rwt.qx.Class.define("rwt.widgets.TabFolder",
{
  extend : rwt.widgets.base.BoxLayout,




  /*
  *****************************************************************************
     CONSTRUCTOR
  *****************************************************************************
  */

  construct : function() {
    this.base( arguments );
    this.addEventListener( "changeFocused", rwt.widgets.util.TabUtil.onTabFolderChangeFocused );
    this.addEventListener( "keypress", rwt.widgets.util.TabUtil.onTabFolderKeyPress );
    this._bar = new rwt.widgets.base.TabFolderBar();
    this._pane = new rwt.widgets.base.TabFolderPane();
    this.add( this._bar, this._pane );
  },




  /*
  *****************************************************************************
     PROPERTIES
  *****************************************************************************
  */

  properties :
  {
    appearance :
    {
      refine : true,
      init : "tab-view"
    },

    orientation :
    {
      refine : true,
      init : "vertical"
    },

    alignTabsToLeft :
    {
      check : "Boolean",
      init : true,
      apply : "_applyAlignTabsToLeft"
    },

    placeBarOnTop :
    {
      check : "Boolean",
      init : true,
      apply : "_applyPlaceBarOnTop"
    }
  },




  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {

    /**
     * TODOC
     *
     * @type member
     * @return {AbstractPane} TODOC
     */
    getPane : function() {
      return this._pane;
    },

    /**
     * TODOC
     *
     * @type member
     * @return {AbstractBar} TODOC
     */
    getBar : function() {
      return this._bar;
    },

    /**
     * TODOC
     *
     * @type member
     * @param value {var} Current value
     * @param old {var} Previous value
     */
    _applyAlignTabsToLeft : function(value)
    {
      var vBar = this._bar;

      vBar.setHorizontalChildrenAlign(value ? "left" : "right");

      // force re-apply of states for all tabs
      vBar._addChildrenToStateQueue();
    },


    /**
     * TODOC
     *
     * @type member
     * @param value {var} Current value
     * @param old {var} Previous value
     */
    _applyPlaceBarOnTop : function(value)
    {
      // This does not work if we use flexible zones
      // this.setReverseChildrenOrder(!value);
      var vBar = this._bar;

      // move bar around
      if (value) {
        vBar.moveSelfToBegin();
      } else {
        vBar.moveSelfToEnd();
      }

      // force re-apply of states for all tabs
      vBar._addChildrenToStateQueue();
    }
  },

  destruct : function() {
    this._disposeObjects( "_bar", "_pane" );
  }

});

/*******************************************************************************
 * Copyright (c) 2004, 2014 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

/**
 * Each instance manages vItems set of radio options: qx.ui.form.RadioButton, qx.ui.toolbar.RadioButton, ...
 */
rwt.qx.Class.define("rwt.widgets.util.RadioManager",
{
  extend : rwt.qx.Target,




  /*
  *****************************************************************************
     CONSTRUCTOR
  *****************************************************************************
  */

  construct : function(vName, vMembers)
  {
    // we don't need the manager data structures
    this.base(arguments);

    // create item array
    this._items = [];

    // apply name property
    this.setName(vName != null ? vName : rwt.widgets.util.RadioManager.AUTO_NAME_PREFIX + this.toHashCode());

    if (vMembers != null)
    {
      // add() iterates over arguments, but vMembers is an array
      this.add.apply(this, vMembers);
    }
  },




  /*
  *****************************************************************************
     STATICS
  *****************************************************************************
  */

  statics : {
    AUTO_NAME_PREFIX : "qx-radio-"
  },




  /*
  *****************************************************************************
     PROPERTIES
  *****************************************************************************
  */

  properties :
  {
    selected :
    {
      nullable : true,
      apply : "_applySelected",
      event : "changeSelected",
      check : "rwt.qx.Object"
    },

    name :
    {
      check : "String",
      nullable : true,
      apply : "_applyName"
    }
  },




  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {
    /*
    ---------------------------------------------------------------------------
      UTILITIES
    ---------------------------------------------------------------------------
    */

    /**
     * TODOC
     *
     * @type member
     * @return {var} TODOC
     */
    getItems : function() {
      return this._items;
    },


    /**
     * TODOC
     *
     * @type member
     * @return {var} TODOC
     */
    getEnabledItems : function()
    {
      var b = [];

      for (var i=0, a=this._items, l=a.length; i<l; i++)
      {
        if (a[i].getEnabled()) {
          b.push(a[i]);
        }
      }

      return b;
    },


    /**
     * TODOC
     *
     * @type member
     * @param vItem {var} TODOC
     * @param vChecked {var} TODOC
     * @return {void}
     */
    handleItemChecked : function(vItem, vChecked)
    {
      if (vChecked) {
        this.setSelected(vItem);
      } else if (this.getSelected() == vItem) {
        this.setSelected(null);
      }
    },




    /*
    ---------------------------------------------------------------------------
      REGISTRY
    ---------------------------------------------------------------------------
    */

    /**
     * TODOC
     *
     * @type member
     * @param varargs {var} TODOC
     * @return {void}
     */
    add : function()
    {
      var vItems = arguments;
      var vLength = vItems.length;
      var vItem;

      for (var i=0; i<vLength; i++)
      {
        vItem = vItems[i];

        if (rwt.util.Arrays.contains(this._items, vItem)) {
          return;
        }

        // Push RadioButton to array
        this._items.push(vItem);

        // Inform radio button about new manager
        vItem.setManager(this);

        // Need to update internal value?
        if (vItem.getChecked()) {
          this.setSelected(vItem);
        }

        // Apply Make name the same
        vItem.setName(this.getName());
      }
    },


    /**
     * TODOC
     *
     * @type member
     * @param vItem {var} TODOC
     * @return {void}
     */
    remove : function(vItem)
    {
      // Remove RadioButton from array
      rwt.util.Arrays.remove(this._items, vItem);

      // Inform radio button about new manager
      vItem.setManager(null);

      // if the radio was checked, set internal selection to null
      if (vItem.getChecked()) {
        this.setSelected(null);
      }
    },




    /*
    ---------------------------------------------------------------------------
      APPLY ROUTINES
    ---------------------------------------------------------------------------
    */

    /**
     * TODOC
     *
     * @type member
     * @param value {var} Current value
     * @param old {var} Previous value
     */
    _applySelected : function(value, old)
    {
      if (old) {
        old.setChecked(false);
      }

      if (value) {
        value.setChecked(true);
      }
    },


    /**
     * TODOC
     *
     * @type member
     * @param value {var} Current value
     * @param old {var} Previous value
     */
    _applyName : function(value)
    {
      for (var i=0, vItems=this._items, vLength=vItems.length; i<vLength; i++) {
        vItems[i].setName(value);
      }
    },




    /*
    ---------------------------------------------------------------------------
      SELECTION
    ---------------------------------------------------------------------------
    */

    /**
     * TODOC
     *
     * @type member
     * @param vItem {var} TODOC
     * @return {void}
     */
    selectNext : function(vItem)
    {
      var vIndex = this._items.indexOf(vItem);

      if (vIndex == -1) {
        return;
      }

      var i = 0;
      var vLength = this._items.length;

      // Find next enabled item
      vIndex = (vIndex + 1) % vLength;

      while (i < vLength && !this._items[vIndex].getEnabled())
      {
        vIndex = (vIndex + 1) % vLength;
        i++;
      }

      this._selectByIndex(vIndex);
    },


    /**
     * TODOC
     *
     * @type member
     * @param vItem {var} TODOC
     * @return {void}
     */
    selectPrevious : function(vItem)
    {
      var vIndex = this._items.indexOf(vItem);

      if (vIndex == -1) {
        return;
      }

      var i = 0;
      var vLength = this._items.length;

      // Find previous enabled item
      vIndex = (vIndex - 1 + vLength) % vLength;

      while (i < vLength && !this._items[vIndex].getEnabled())
      {
        vIndex = (vIndex - 1 + vLength) % vLength;
        i++;
      }

      this._selectByIndex(vIndex);
    },


    /**
     * TODOC
     *
     * @type member
     * @param vIndex {var} TODOC
     * @return {void}
     */
    _selectByIndex : function(vIndex)
    {
      if (this._items[vIndex].getEnabled())
      {
        this.setSelected(this._items[vIndex]);
        this._items[vIndex].setFocused(true);
      }
    }
  },




  /*
  *****************************************************************************
     DESTRUCTOR
  *****************************************************************************
  */

  destruct : function() {
    this._disposeObjectDeep("_items", 1);
  }
});

/*******************************************************************************
 * Copyright (c) 2004, 2013 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

/**
 * @appearance tab-view-bar
 */
rwt.qx.Class.define("rwt.widgets.base.TabFolderBar",
{
  extend : rwt.widgets.base.BoxLayout,




  /*
  *****************************************************************************
     CONSTRUCTOR
  *****************************************************************************
  */

  construct : function()
  {
    this.base(arguments);

    this.initZIndex();
    this.initHeight();
    this._manager = new rwt.widgets.util.RadioManager();
  },




  /*
  *****************************************************************************
     PROPERTIES
  *****************************************************************************
  */

  properties :
  {
    appearance :
    {
      refine : true,
      init : "tab-view-bar"
    },

    zIndex :
    {
      refine : true,
      init : 2
    },

    height :
    {
      refine : true,
      init : "auto"
    }
  },

  members : {

    /**
     * Get the selection manager.
     *
     * @type member
     * @return {rwt.widgets.util.RadioManager} the selection manager of the bar.
     */
    getManager : function() {
      return this._manager;
    }

  },

  destruct : function() {
    this._disposeObjects( "_manager" );
  }

} );

/*******************************************************************************
 * Copyright (c) 2004, 2013 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

/**
 * @appearance tab-view-pane
 */
rwt.qx.Class.define("rwt.widgets.base.TabFolderPane",
{
  extend : rwt.widgets.base.Parent,




  /*
  *****************************************************************************
     CONSTRUCTOR
  *****************************************************************************
  */

  construct : function()
  {
    this.base(arguments);

    this.initZIndex();
    this.initHeight();
  },




  /*
  *****************************************************************************
     PROPERTIES
  *****************************************************************************
  */

  properties :
  {
    appearance :
    {
      refine : true,
      init : "tab-view-pane"
    },

    zIndex :
    {
      refine : true,
      init : 1
    },

    height :
    {
      refine : true,
      init : "1*"
    }
  }
});

/*******************************************************************************
 * Copyright (c) 2004, 2014 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

/**
 * @appearance popup
 */
rwt.qx.Class.define("rwt.widgets.base.Popup",
{
  extend : rwt.widgets.base.Parent,




  /*
  *****************************************************************************
     CONSTRUCTOR
  *****************************************************************************
  */

  construct : function()
  {
    this.base(arguments);

    this.setZIndex(this._minZIndex);

    // Init Focus Handler
    if (this._isFocusRoot) {
      this.activateFocusRoot();
    }

    this.initHeight();
    this.initWidth();
  },




  /*
  *****************************************************************************
     PROPERTIES
  *****************************************************************************
  */

  properties :
  {
    appearance :
    {
      refine : true,
      init : "popup"
    },

    width :
    {
      refine : true,
      init : "auto"
    },

    height :
    {
      refine : true,
      init : "auto"
    },


    /**
     * Make element displayed (if switched to true the widget will be created, if needed, too).
     *  Instead of rwt.widgets.base.Widget, the default is false here.
     */
    display :
    {
      refine : true,
      init : false
    },




    /**
     * Whether to let the system decide when to hide the popup. Setting
     *  this to false gives you better control but it also requires you
     *  to handle the closing of the popup.
     */
    autoHide :
    {
      check : "Boolean",
      init : true
    },


    /** Center the popup on open */
    centered :
    {
      check : "Boolean",
      init : false
    },


    /**
     * Whether the popup should be restricted to the visible area of the page when opened.
     */
    restrictToPageOnOpen :
    {
      check : "Boolean",
      init : true
    },


    /**
     * The minimum offset to the left of the page too keep when
     * {@link #restrictToPageOnOpen} is true (in pixels).
     */
    restrictToPageLeft :
    {
      check : "Integer",
      init : 0
    },


    /**
     * The minimum offset to the right of the page too keep when
     * {@link #restrictToPageOnOpen} is true (in pixels).
     */
    restrictToPageRight :
    {
      check : "Integer",
      init : 0
    },


    /**
     * The minimum offset to the top of the page too keep when
     * {@link #restrictToPageOnOpen} is true (in pixels).
     */
    restrictToPageTop :
    {
      check : "Integer",
      init : 0
    },


    /**
     * The minimum offset to the bottom of the page too keep when
     * {@link #restrictToPageOnOpen} is true (in pixels).
     */
    restrictToPageBottom :
    {
      check : "Integer",
      init : 0
    }

  },




  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {
    _isFocusRoot : false,

    _showTimeStamp : (new Date(0)).valueOf(),
    _hideTimeStamp : (new Date(0)).valueOf(),

    getFocusRoot : function() {
      return this.isFocusRoot() ? this : null;
    },

    /*
    ---------------------------------------------------------------------------
      APPEAR/DISAPPEAR
    ---------------------------------------------------------------------------
    */

    /**
     * Callback for "beforeAppear" event.<br/>
     * Moves the popup out of the visible area to ensure the popup widget is
     * displayed in the boundaries of the document. This mechnism jumps in when
     * {@link #restrictToPageOnOpen} is set to <code>true</code> (default).<br/>
     * Additionally the popup widget is registered at the popup manager and the
     * method {@link #bringToFront} is called.
     *
     * @type member
     * @return {void}
     */
    _beforeAppear : function()
    {
      this.base(arguments);

      if (this.getRestrictToPageOnOpen())
      {
        this._wantedLeft = this.getLeft();

        if (this._wantedLeft != null)
        {
          // Move the popup out of the view so its size could be calculated before
          // it is positioned.
          this.setLeft(10000);

          if (this.getElement() != null)
          {
            // The popup was already visible once before
            // -> Move it immediately before it gets visible again
            this.getElement().style.left = 10000;
          }
        }
      }

      rwt.widgets.util.PopupManager.getInstance().add(this);
      rwt.widgets.util.PopupManager.getInstance().update(this);

      this._showTimeStamp = (new Date()).valueOf();
      this.bringToFront();
    },


    /**
     * Callback method for the "beforeDisappear" event.<br/>
     * The popup widget gets deregistered from the popup manager.
     *
     * @type member
     * @return {void}
     */
    _beforeDisappear : function()
    {
      this.base(arguments);

      rwt.widgets.util.PopupManager.getInstance().remove(this);

      this._hideTimeStamp = (new Date()).valueOf();
    },


    /**
     * Callback method for the "afterAppear" event.<br/>
     * If the property {@link #restrictToPageOnOpen} is set to <code>true</code>
     * the popup gets repositioned to get displayed within the boundaries of the
     * client document.
     *
     * @type member
     * @return {void}
     */
    _afterAppear : function()
    {
      this.base(arguments);

      if (this.getRestrictToPageOnOpen())
      {
        var doc = rwt.widgets.base.ClientDocument.getInstance();
        var docWidth = doc.getClientWidth();
        var docHeight = doc.getClientHeight();

        var scrollTop = rwt.html.Viewport.getScrollTop();
        var scrollLeft = rwt.html.Viewport.getScrollLeft();

        var restrictToPageLeft = this.getRestrictToPageLeft() + scrollLeft;
        var restrictToPageRight = this.getRestrictToPageRight() - scrollLeft;
        var restrictToPageTop = this.getRestrictToPageTop() + scrollTop;
        var restrictToPageBottom = this.getRestrictToPageBottom() - scrollTop;

        var left = (this._wantedLeft == null) ? this.getLeft() : this._wantedLeft;
        var top = this.getTop();
        var width = this.getBoxWidth();
        var height = this.getBoxHeight();

        var oldLeft = this.getLeft();
        var oldTop = top;

        // NOTE: We check right and bottom first, because top and left should have
        //       priority, when both sides are violated.
        if (left + width > docWidth - restrictToPageRight) {
          left = docWidth - restrictToPageRight - width;
        }

        if (top + height > docHeight - restrictToPageBottom) {
          top = docHeight - restrictToPageBottom - height;
        }

        if (left < restrictToPageLeft) {
          left = restrictToPageLeft;
        }

        if (top < restrictToPageTop) {
          top = restrictToPageTop;
        }

        if (left != oldLeft || top != oldTop)
        {
          var self = this;

          window.setTimeout(function()
          {
            self.setLeft(left);
            self.setTop(top);
          },
          0);
        }
      }
    },




    /*
    ---------------------------------------------------------------------------
      ACTIVE/INACTIVE
    ---------------------------------------------------------------------------
    */

    /**
     * Sets the popup widget as active child
     *
     * @type member
     * @return {void}
     */
    _makeActive : function() {
      this.getFocusRoot().setActiveChild(this);
    },


    /**
     * Give back the focus control to the focus root.
     *
     * @type member
     * @return {void}
     */
    _makeInactive : function()
    {
      var vRoot = this.getFocusRoot();
      var vCurrent = vRoot.getActiveChild();

      if (vCurrent == this) {
        vRoot.setActiveChild(vRoot);
      }
    },




    /*
    ---------------------------------------------------------------------------
      ZIndex Positioning
    ---------------------------------------------------------------------------
    */

    _minZIndex : 1e6,


    /**
     * Sets the {@link #zIndex} to Infinity and calls the
     * method {@link #_sendTo}
     *
     * @type member
     * @return {void}
     */
    bringToFront : function()
    {
      this.setZIndex(this._minZIndex+1000000);
      this._sendTo();
    },

    /**
     * Resets the zIndex of all registered popups and menus
     * (getting the instances via the {@link rwt.widgets.util.PopupManager} and
     * the {@link qx.ui.menu.Manager}) one higher than the defined minimum zIndex.
     *
     * @type member
     * @return {void}
     */
    _sendTo : function()
    {
      var vPopups = rwt.util.Objects.getValues(rwt.widgets.util.PopupManager.getInstance().getAll());
      var zIndexCompare = function(a, b) {
        return a.getZIndex() - b.getZIndex();
      };
      var manager = rwt.event.EventHandler.getMenuManager();
      var vMenus = rwt.util.Objects.getValues(manager.getAll());
      var vAll = vPopups.concat(vMenus).sort(zIndexCompare);

      var vLength = vAll.length;
      var vIndex = this._minZIndex;

      for (var i=0; i<vLength; i++) {
        vAll[i].setZIndex(vIndex++);
      }
    },




    /*
    ---------------------------------------------------------------------------
      TIMESTAMP HANDLING
    ---------------------------------------------------------------------------
    */

    /**
     * Utility method to get the current showTimeStamp
     *
     * @type member
     * @return {Number} Timestamp
     */
    getShowTimeStamp : function() {
      return this._showTimeStamp;
    },


    /**
     * Utility method to get the current showTimeStamp
     *
     * @type member
     * @return {Number} Timestamp
     */
    getHideTimeStamp : function() {
      return this._hideTimeStamp;
    },




    /*
    ---------------------------------------------------------------------------
      UTILITIES
    ---------------------------------------------------------------------------
    */

    /**
     * Positions the popup relative to some reference element.
     *
     * @type member
     * @param el {Element|rwt.widgets.base.Widget} Reference DOM element/widget.
     * @param offsetX {Integer ? 0} Offset in pixels in X direction (optional).
     * @param offsetY {Integer ? 0} Offset in pixels in Y direction (optional).
     */
    positionRelativeTo : function(el, offsetX, offsetY)
    {
      if (el instanceof rwt.widgets.base.Widget) {
        el = el.getElement();
      }

      if (el)
      {
       var elementPos = rwt.html.Location.get(el);
       this.setLocation(
         elementPos.left + (offsetX || 0),
         elementPos.top + (offsetY || 0)
       );
      }
      else
      {
        throw new Error( 'Missing reference element' );
      }
    },


    /**
     * Centers the popup using the coordinates of the {@link rwt.widgets.base.ClientDocument}.
     * This method does only work if the Popup has already been rendered, so it
     * is best to call it in the {@link rwt.widgets.base.Widget#appear} event.
     *
     * @type member
     */
    centerToBrowser : function()
    {
      var d = rwt.widgets.base.ClientDocument.getInstance();

      var left = (d.getClientWidth() - this.getBoxWidth()) / 2;
      var top = (d.getClientHeight() - this.getBoxHeight()) / 2;

      this.setLeft(left < 0 ? 0 : left);
      this.setTop(top < 0 ? 0 : top);
    }
  },


  /*
  *****************************************************************************
     DESTRUCTOR
  *****************************************************************************
  */

  destruct : function()
  {
    rwt.widgets.util.PopupManager.getInstance().remove(this);

    this._disposeFields("_showTimeStamp", "_hideTimeStamp");
  }
});

/*******************************************************************************
 * Copyright (c) 2004, 2014 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

/** This singleton is used to manager multiple instances of popups and their state. */
rwt.qx.Class.define( "rwt.widgets.util.PopupManager", {

  extend : rwt.util.ObjectManager,

  statics : {

    getInstance : function() {
      return rwt.runtime.Singletons.get( rwt.widgets.util.PopupManager );
    }

  },

  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {
    /*
    ---------------------------------------------------------------------------
      METHODS
    ---------------------------------------------------------------------------
    */

    /**
     * Updates all registered popups
     *
     * @type member
     * @param vTarget {rwt.widgets.base.Popup} current widget
     * @return {void}
     */
    update : function(vTarget)
    {
      // be sure that target is correctly set (needed for contains() later)
      if (!(vTarget instanceof rwt.widgets.base.Widget)) {
        vTarget = null;
      }

      var vPopup, vHashCode;
      var vAll = this.getAll();

      for (vHashCode in vAll)
      {
        vPopup = vAll[vHashCode];

        if (!vPopup.getAutoHide() || vTarget == vPopup || vPopup.contains(vTarget)) {
          continue;
        }

        vPopup.hide();
      }
    }
  }
});

/*******************************************************************************
 * Copyright (c) 2004, 2014 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

/**
 * This class represents a selection and manage incoming events for widgets
 * which need selection support.
 */
rwt.qx.Class.define("rwt.widgets.util.SelectionManager",
{
  extend : rwt.qx.Target,




  /*
  *****************************************************************************
     CONSTRUCTOR
  *****************************************************************************
  */

  construct : function(vBoundedWidget)
  {
    this.base(arguments);

    this._selectedItems = new rwt.widgets.util.Selection();

    if (vBoundedWidget != null) {
      this.setBoundedWidget(vBoundedWidget);
    }
  },



  /*
  *****************************************************************************
     EVENTS
  *****************************************************************************
  */

  events:
  {
    /**
     * Fired on a selection change. The "data" proeprty is set to an array of
     * selected items as returned by {@link #getSelectedItems}.
     **/
    "changeSelection" : "rwt.event.DataEvent"
  },



  /*
  *****************************************************************************
     PROPERTIES
  *****************************************************************************
  */

  properties :
  {
    /** This contains the currently assigned widget (qx.ui.form.List, ...) */
    boundedWidget :
    {
      check : "rwt.widgets.base.Widget",
      nullable : true
    },


    /** Should multiple selection be allowed? */
    multiSelection :
    {
      check: "Boolean",
      init : true
    },


    /** Enable drag selection? */
    dragSelection :
    {
      check : "Boolean",
      init : true
    },


    /** Should the user be able to select */
    canDeselect :
    {
      check : "Boolean",
      init : true
    },


    /** Should a change event be fired? */
    fireChange :
    {
      check : "Boolean",
      init : true
    },


    /** The current anchor in range selections. */
    anchorItem :
    {
      check : "Object",
      nullable : true,
      apply : "_applyAnchorItem",
      event : "changeAnchorItem"
    },


    /** The last selected item */
    leadItem :
    {
      check : "Object",
      nullable : true,
      apply : "_applyLeadItem",
      event : "changeLeadItem"
    },


    /** Grid selection */
    multiColumnSupport :
    {
      check : "Boolean",
      init : false
    }
  },




  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {
    /*
    ---------------------------------------------------------------------------
      APPLY ROUTINES
    ---------------------------------------------------------------------------
    */

    /**
     * TODOC
     *
     * @type member
     * @param value {var} Current value
     * @param old {var} Previous value
     */
    _applyAnchorItem : function(value, old)
    {
      if (old) {
        this.renderItemAnchorState(old, false);
      }

      if (value) {
        this.renderItemAnchorState(value, true);
      }
    },


    /**
     * TODOC
     *
     * @type member
     * @param value {var} Current value
     * @param old {var} Previous value
     */
    _applyLeadItem : function(value, old)
    {
      if (old) {
        this.renderItemLeadState(old, false);
      }

      if (value) {
        this.renderItemLeadState(value, true);
      }
    },




    /*
    ---------------------------------------------------------------------------
      MAPPING TO BOUNDED WIDGET
    ---------------------------------------------------------------------------
    */

    /**
     * TODOC
     *
     * @type member
     * @return {var} TODOC
     */
    _getFirst : function() {
      return this.getBoundedWidget().getFirstVisibleChild();
    },


    /**
     * TODOC
     *
     * @type member
     * @return {var} TODOC
     */
    _getLast : function() {
      return this.getBoundedWidget().getLastVisibleChild();
    },


    /**
     * TODOC
     *
     * @type member
     * @return {var} TODOC
     */
    getFirst : function()
    {
      var vItem = this._getFirst();

      if (vItem) {
        return vItem.getEnabled() ? vItem : this.getNext(vItem);
      }
    },


    /**
     * TODOC
     *
     * @type member
     * @return {var} TODOC
     */
    getLast : function()
    {
      var vItem = this._getLast();

      if (vItem) {
        return vItem.getEnabled() ? vItem : this.getPrevious(vItem);
      }
    },


    /**
     * TODOC
     *
     * @type member
     * @return {var} TODOC
     */
    getItems : function() {
      return this.getBoundedWidget().getChildren();
    },


    /**
     * TODOC
     *
     * @type member
     * @param vItem {var} TODOC
     * @return {var} TODOC
     */
    getNextSibling : function(vItem) {
      return vItem.getNextSibling();
    },


    /**
     * TODOC
     *
     * @type member
     * @param vItem {var} TODOC
     * @return {var} TODOC
     */
    getPreviousSibling : function(vItem) {
      return vItem.getPreviousSibling();
    },


    /**
     * TODOC
     *
     * @type member
     * @param vItem {var} TODOC
     * @return {var | null} TODOC
     */
    getNext : function(vItem)
    {
      while (vItem)
      {
        vItem = this.getNextSibling(vItem);

        if (!vItem) {
          break;
        }

        if (this.getItemEnabled(vItem)) {
          return vItem;
        }
      }

      return null;
    },


    /**
     * TODOC
     *
     * @type member
     * @param vItem {var} TODOC
     * @return {var | null} TODOC
     */
    getPrevious : function(vItem)
    {
      while (vItem)
      {
        vItem = this.getPreviousSibling(vItem);

        if (!vItem) {
          break;
        }

        if (this.getItemEnabled(vItem)) {
          return vItem;
        }
      }

      return null;
    },


    /**
     * TODOC
     *
     * @type member
     * @param vItem1 {var} TODOC
     * @param vItem2 {var} TODOC
     * @return {boolean} TODOC
     */
    isBefore : function(vItem1, vItem2)
    {
      var cs = this.getItems();
      return cs.indexOf(vItem1) < cs.indexOf(vItem2);
    },


    /**
     * TODOC
     *
     * @type member
     * @param vItem1 {var} TODOC
     * @param vItem2 {var} TODOC
     * @return {var} TODOC
     */
    isEqual : function(vItem1, vItem2) {
      return vItem1 == vItem2;
    },




    /*
    ---------------------------------------------------------------------------
      MAPPING TO ITEM PROPERTIES
    ---------------------------------------------------------------------------
    */

    /**
     * TODOC
     *
     * @type member
     * @param vItem {var} TODOC
     * @return {var} TODOC
     */
    getItemHashCode : function(vItem) {
      return vItem.toHashCode();
    },




    /*
    ---------------------------------------------------------------------------
      MAPPING TO ITEM DIMENSIONS
    ---------------------------------------------------------------------------
    */

    /**
     * TODOC
     *
     * @type member
     * @param vItem {var} TODOC
     * @param vTopLeft {var} TODOC
     * @return {void}
     */
    scrollItemIntoView : function(vItem, vTopLeft) {
      vItem.scrollIntoView(vTopLeft);
    },


    /**
     * TODOC
     *
     * @type member
     * @param vItem {var} TODOC
     * @return {var} TODOC
     */
    getItemLeft : function(vItem) {
      return vItem.getOffsetLeft();
    },


    /**
     * TODOC
     *
     * @type member
     * @param vItem {var} TODOC
     * @return {var} TODOC
     */
    getItemTop : function(vItem) {
      return vItem.getOffsetTop();
    },


    /**
     * TODOC
     *
     * @type member
     * @param vItem {var} TODOC
     * @return {var} TODOC
     */
    getItemWidth : function(vItem) {
      return vItem.getOffsetWidth();
    },


    /**
     * TODOC
     *
     * @type member
     * @param vItem {var} TODOC
     * @return {var} TODOC
     */
    getItemHeight : function(vItem) {
      return vItem.getOffsetHeight();
    },


    /**
     * TODOC
     *
     * @type member
     * @param vItem {var} TODOC
     * @return {var} TODOC
     */
    getItemEnabled : function(vItem) {
      return vItem.getEnabled();
    },




    /*
    ---------------------------------------------------------------------------
      ITEM STATE MANAGMENT
    ---------------------------------------------------------------------------
    */

    /**
     * TODOC
     *
     * @type member
     * @param vItem {var} TODOC
     * @param vIsSelected {var} TODOC
     * @return {void}
     */
    renderItemSelectionState : function( vItem, vIsSelected ) {
      vItem.toggleState( "selected", vIsSelected );
      if( vItem.handleStateChange ) {
        vItem.handleStateChange();
      }
    },


    /**
     * TODOC
     *
     * @type member
     * @param vItem {var} TODOC
     * @param vIsAnchor {var} TODOC
     * @return {void}
     */
    renderItemAnchorState : function( vItem, vIsAnchor ) {
      vItem.toggleState( "anchor", vIsAnchor );
      if( vItem.handleStateChange != null ) {
        vItem.handleStateChange();
      }
    },


    /**
     * TODOC
     *
     * @type member
     * @param vItem {var} TODOC
     * @param vIsLead {var} TODOC
     * @return {void}
     */
    renderItemLeadState : function( vItem, vIsLead ) {
      vItem.toggleState( "lead", vIsLead );
      if( vItem.handleStateChange != null ) {
        vItem.handleStateChange();
      }
    },




    /*
    ---------------------------------------------------------------------------
      SELECTION HANDLING
    ---------------------------------------------------------------------------
    */

    /**
     * TODOC
     *
     * @type member
     * @param vItem {var} TODOC
     * @return {var} TODOC
     */
    getItemSelected : function(vItem) {
      return this._selectedItems.contains(vItem);
    },


    /**
     * Make a single item selected / not selected
     *
     * #param vItem[rwt.widgets.base.Widget]: Item which should be selected / not selected
     * #param vSelected[Boolean]: Should this item be selected?
     *
     * @type member
     * @param vItem {var} TODOC
     * @param vSelected {var} TODOC
     * @return {void}
     */
    setItemSelected : function(vItem, vSelected)
    {
      switch(this.getMultiSelection())
      {
          // Multiple item selection is allowed
        case true:
          if (!this.getItemEnabled(vItem)) {
            return;
          }

          // If selection state is not to be changed => return
          if (this.getItemSelected(vItem) == vSelected) {
            return;
          }

          // Otherwise render new state
          this.renderItemSelectionState(vItem, vSelected);

          // Add item to selection hash / delete it from there
          if( vSelected ) {
            this._selectedItems.add( vItem );
          } else {
            this._selectedItems.remove( vItem );
          }

          // Dispatch change Event
          this._dispatchChange();

          break;

          // Multiple item selection is NOT allowed

        case false:
          var item0 = this.getSelectedItems()[0];

          if (vSelected)
          {
            // Precheck for any changes
            var old = item0;

            if (this.isEqual(vItem, old)) {
              return;
            }

            // Reset rendering of previous selected item
            if (old != null) {
              this.renderItemSelectionState(old, false);
            }

            // Render new item as selected
            this.renderItemSelectionState(vItem, true);

            // Reset current selection hash
            this._selectedItems.removeAll();

            // Add new one
            this._selectedItems.add(vItem);

            // Dispatch change Event
            this._dispatchChange();
          }
          else
          {
            // Pre-check if item is currently selected
            // Do not allow deselection in single selection mode
            if (!this.isEqual(item0, vItem))
            {
              // Reset rendering as selected item
              this.renderItemSelectionState(vItem, false);

              // Dispatch change Event
              this._dispatchChange();
            }
          }

          break;
      }
    },


    /**
     * Get the selected items (objects)
     *
     * @type member
     * @return {var} TODOC
     */
    getSelectedItems : function() {
      return this._selectedItems.toArray();
    },


    /**
     * TODOC
     *
     * @type member
     * @return {var} TODOC
     */
    getSelectedItem : function() {
      return this._selectedItems.getFirst();
    },


    /**
     * Select given items
     *
     * #param vItems[Array of Widgets]: Items to select
     *
     * @type member
     * @param vItems {var} TODOC
     * @return {void}
     */
    setSelectedItems : function(vItems)
    {
      var oldVal = this._getChangeValue();

      // Temporary disabling of event fire
      var oldFireChange = this.getFireChange();
      this.setFireChange(false);

      // Deselect all currently selected items
      this._deselectAll();

      // Apply new selection
      var vItem;
      var vItemLength = vItems.length;

      for (var i=0; i<vItemLength; i++)
      {
        vItem = vItems[i];

        if (!this.getItemEnabled(vItem)) {
          continue;
        }

        // Add item to selection
        this._selectedItems.add(vItem);

        // Render new state for item
        this.renderItemSelectionState(vItem, true);
      }

      // Recover change event status
      this.setFireChange(oldFireChange);

      // Dispatch change Event
      if (oldFireChange && this._hasChanged(oldVal)) {
        this._dispatchChange();
      }
    },


    /**
     * TODOC
     *
     * @type member
     * @param vItem {var} TODOC
     * @return {void}
     */
    setSelectedItem : function(vItem)
    {
      if (!vItem) {
        return;
      }

      if (!this.getItemEnabled(vItem)) {
        return;
      }

      var oldVal = this._getChangeValue();

      // Temporary disabling of event fire
      var oldFireChange = this.getFireChange();
      this.setFireChange(false);

      // Deselect all currently selected items
      this._deselectAll();

      // Add item to selection
      this._selectedItems.add(vItem);

      // Render new state for item
      this.renderItemSelectionState(vItem, true);

      // Recover change event status
      this.setFireChange(oldFireChange);

      // Dispatch change Event
      if (oldFireChange && this._hasChanged(oldVal)) {
        this._dispatchChange();
      }
    },


    /**
     * Select all items.
     *
     * @type member
     * @return {void}
     */
    selectAll : function()
    {
      var oldVal = this._getChangeValue();

      // Temporary disabling of event fire
      var oldFireChange = this.getFireChange();
      this.setFireChange(false);

      // Call sub method to select all items
      this._selectAll();

      // Recover change event status
      this.setFireChange(oldFireChange);

      // Dispatch change Event
      if (oldFireChange && this._hasChanged(oldVal)) {
        this._dispatchChange();
      }
    },


    /**
     * Sub method for selectAll. Handles the real work
     *  to select all items.
     *
     * @type member
     * @return {void | Boolean} TODOC
     */
    _selectAll : function()
    {
      if (!this.getMultiSelection()) {
        return;
      }

      var vItem;
      var vItems = this.getItems();
      var vItemsLength = vItems.length;

      // Reset current selection hash
      this._selectedItems.removeAll();

      for (var i=0; i<vItemsLength; i++)
      {
        vItem = vItems[i];

        if (!this.getItemEnabled(vItem)) {
          continue;
        }

        // Add item to selection
        this._selectedItems.add(vItem);

        // Render new state for item
        this.renderItemSelectionState(vItem, true);
      }

      return true;
    },


    /**
     * Deselect all items.
     *
     * @type member
     * @return {void}
     */
    deselectAll : function()
    {
      var oldVal = this._getChangeValue();

      // Temporary disabling of event fire
      var oldFireChange = this.getFireChange();
      this.setFireChange(false);

      // Call sub method to deselect all items
      this._deselectAll();

      // Recover change event status
      this.setFireChange(oldFireChange);

      // Dispatch change Event
      if( oldFireChange && this._hasChanged( oldVal ) ) {
        this._dispatchChange();
      }
    },


    /**
     * Sub method for deselectAll. Handles the real work
     *  to deselect all items.
     *
     * @type member
     */
    _deselectAll : function()
    {
      // Render new state for items
      var items = this._selectedItems.toArray();

      for (var i=0; i<items.length; i++) {
        this.renderItemSelectionState(items[i], false);
      }

      // Delete all entries in selectedItems hash
      this._selectedItems.removeAll();

      return true;
    },


    /**
     * Select a range of items.
     *
     * #param vItem1[rwt.widgets.base.Widget]: Start item
     * #param vItem2[rwt.widgets.base.Widget]: Stop item
     *
     * @type member
     * @param vItem1 {var} TODOC
     * @param vItem2 {var} TODOC
     * @return {void}
     */
    selectItemRange : function(vItem1, vItem2)
    {
      var oldVal = this._getChangeValue();

      // Temporary disabling of event fire
      var oldFireChange = this.getFireChange();
      this.setFireChange(false);

      // Call sub method to select the range of items
      this._selectItemRange(vItem1, vItem2, true);

      // Recover change event status
      this.setFireChange(oldFireChange);

      // Dispatch change Event
      if (oldFireChange && this._hasChanged(oldVal)) {
        this._dispatchChange();
      }
    },


    /**
     * Sub method for selectItemRange. Handles the real work
     * to select a range of items.
     *
     * #param vItem1[rwt.widgets.base.Widget]: Start item
     * #param vItem2[rwt.widgets.base.Widget]: Stop item
     * #param vDelect[Boolean]: Deselect currently selected items first?
     *
     * @type member
     * @param vItem1 {var} TODOC
     * @param vItem2 {var} TODOC
     * @param vDeselect {var} TODOC
     * @return {var | Boolean} TODOC
     */
    _selectItemRange : function(vItem1, vItem2, vDeselect)
    {
      // Pre-Check a revert call if vItem2 is before vItem1
      if (this.isBefore(vItem2, vItem1)) {
        return this._selectItemRange(vItem2, vItem1, vDeselect);
      }

      // Deselect all
      if (vDeselect) {
        this._deselectAll();
      }

      var vCurrentItem = vItem1;

      while (vCurrentItem != null)
      {
        if (this.getItemEnabled(vCurrentItem))
        {
          // Add item to selection
          this._selectedItems.add(vCurrentItem);

          // Render new state for item
          this.renderItemSelectionState(vCurrentItem, true);
        }

        // Stop here if we reached target item
        if (this.isEqual(vCurrentItem, vItem2)) {
          break;
        }

        // Get next item
        vCurrentItem = this.getNext(vCurrentItem);
      }

      return true;
    },


    /**
     * Internal method for deselection of ranges.
     *
     * #param vItem1[rwt.widgets.base.Widget]: Start item
     * #param vItem2[rwt.widgets.base.Widget]: Stop item
     *
     * @type member
     * @param vItem1 {var} TODOC
     * @param vItem2 {var} TODOC
     * @return {var} TODOC
     */
    _deselectItemRange : function(vItem1, vItem2)
    {
      // Pre-Check a revert call if vItem2 is before vItem1
      if (this.isBefore(vItem2, vItem1)) {
        return this._deselectItemRange(vItem2, vItem1);
      }

      var vCurrentItem = vItem1;

      while (vCurrentItem != null)
      {
        // Add item to selection
        this._selectedItems.remove(vCurrentItem);

        // Render new state for item
        this.renderItemSelectionState(vCurrentItem, false);

        // Stop here if we reached target item
        if (this.isEqual(vCurrentItem, vItem2)) {
          break;
        }

        // Get next item
        vCurrentItem = this.getNext(vCurrentItem);
      }
    },




    /*
    ---------------------------------------------------------------------------
      MOUSE EVENT HANDLING
    ---------------------------------------------------------------------------
    */

    _activeDragSession : false,


    /**
     * TODOC
     *
     * @type member
     * @param vItem {var} TODOC
     * @param e {Event} TODOC
     * @return {void}
     */
    handleMouseDown : function(vItem, e)
    {
      // stop propagation of the event here to prevent
      // reaction of subwidgets
      e.stopPropagation();

      // Only allow left and right button
      if (!e.isLeftButtonPressed() && !e.isRightButtonPressed()) {
        return;
      }

      // Keep selection on right click on already selected item
      if (e.isRightButtonPressed() && this.getItemSelected(vItem)) {
        return;
      }

      // Shift Key
      //   or
      // Click on an unseleted item (without Ctrl)
      if (e.isShiftPressed() || this.getDragSelection() || (!this.getItemSelected(vItem) && !e.isCtrlPressed()))
      {
        // Handle event
        this._onmouseevent(vItem, e);
      }
      else
      {
        // Update lead item
        this.setLeadItem(vItem);
      }

      // Handle dragging
      this._activeDragSession = this.getDragSelection();

      if (this._activeDragSession)
      {
        // Add mouseup listener and register as capture widget
        this.getBoundedWidget().addEventListener("mouseup", this._ondragup, this);
        this.getBoundedWidget().setCapture(true);
      }
    },


    /**
     * TODOC
     *
     * @type member
     * @param e {Event} TODOC
     * @return {void}
     */
    _ondragup : function()
    {
      this.getBoundedWidget().removeEventListener("mouseup", this._ondragup, this);
      this.getBoundedWidget().setCapture(false);
      this._activeDragSession = false;
    },


    /**
     * TODOC
     *
     * @type member
     * @param vItem {var} TODOC
     * @param e {Event} TODOC
     * @return {void}
     */
    handleMouseUp : function(vItem, e)
    {
      if (!e.isLeftButtonPressed()) {
        return;
      }

      if (e.isCtrlPressed() || this.getItemSelected(vItem) && !this._activeDragSession) {
        this._onmouseevent(vItem, e);
      }

      if (this._activeDragSession)
      {
        this._activeDragSession = false;
        this.getBoundedWidget().setCapture(false);
      }
    },


    /**
     * TODOC
     *
     * @type member
     * @param oItem {Object} TODOC
     * @param e {Event} TODOC
     * @return {void}
     */
    handleMouseOver : function(oItem, e)
    {
      if (!this.getDragSelection() || !this._activeDragSession) {
        return;
      }

      this._onmouseevent(oItem, e, true);
    },

    // currently unused placeholder
    /**
     * TODOC
     *
     * @type member
     * @param vItem {var} TODOC
     * @param e {Event} TODOC
     * @return {void}
     */
    handleClick : function() {},

    // currently unused placeholder
    /**
     * TODOC
     *
     * @type member
     * @param vItem {var} TODOC
     * @param e {Event} TODOC
     * @return {void}
     */
    handleDblClick : function() {},


    /**
     * Internal handler for all mouse events bound to this manager.
     *
     * @type member
     * @param oItem {Object} TODOC
     * @param e {Event} TODOC
     * @param bOver {Boolean} TODOC
     * @return {void}
     */
    _onmouseevent : function(oItem, e, bOver)
    {
      if (!this.getItemEnabled(oItem)) {
        return;
      }

      // ********************************************************************
      //   Init
      // ********************************************************************
      // Cache current (old) values
      var oldVal = this._getChangeValue();
      var oldLead = this.getLeadItem();

      // Temporary disabling of event fire
      var oldFireChange = this.getFireChange();
      this.setFireChange(false);

      // Cache selection and count
      var selectedItems = this.getSelectedItems();
      var selectedCount = selectedItems.length;

      // Update lead item
      this.setLeadItem(oItem);

      // Cache current anchor item
      var currentAnchorItem = this.getAnchorItem();

      // Cache keys pressed
      var vCtrlKey = e.isCtrlPressed();
      var vShiftKey = e.isShiftPressed();

      // ********************************************************************
      //   Do we need to update the anchor?
      // ********************************************************************
      if(   !currentAnchorItem
          || selectedCount === 0
          || ( vCtrlKey && !vShiftKey && this.getMultiSelection() && !this.getDragSelection() ) )
      {
        this.setAnchorItem( oItem );
        currentAnchorItem = oItem;
      }

      // ********************************************************************
      //   Mode #1: Replace current selection with new one
      // ********************************************************************
      if ((!vCtrlKey && !vShiftKey && !this._activeDragSession || !this.getMultiSelection()))
      {
        if (!this.getItemEnabled(oItem)) {
          return;
        }

        // Remove current selection
        this._deselectAll();

        // Update anchor item
        this.setAnchorItem(oItem);

        if (this._activeDragSession)
        {
          // a little bit hacky, but seems to be a fast way to detect if we slide to top or to bottom
          this.scrollItemIntoView((this.getBoundedWidget().getScrollTop() > (this.getItemTop(oItem) - 1) ? this.getPrevious(oItem) : this.getNext(oItem)) || oItem);
        }

        if (!this.getItemSelected(oItem)) {
          this.renderItemSelectionState(oItem, true);
        }

        // Clear up and add new one
        // this._selectedItems.removeAll();
        this._selectedItems.add(oItem);

        this._addToCurrentSelection = true;
      }

      // ********************************************************************
      //   Mode #2: (De-)Select item range in mouse drag session
      // ********************************************************************
      else if (this._activeDragSession && bOver)
      {
        if (oldLead) {
          this._deselectItemRange(currentAnchorItem, oldLead);
        }

        // Drag down
        if (this.isBefore(currentAnchorItem, oItem))
        {
          if (this._addToCurrentSelection) {
            this._selectItemRange(currentAnchorItem, oItem, false);
          } else {
            this._deselectItemRange(currentAnchorItem, oItem);
          }
        }

        // Drag up
        else
        {
          if (this._addToCurrentSelection) {
            this._selectItemRange(oItem, currentAnchorItem, false);
          } else {
            this._deselectItemRange(oItem, currentAnchorItem);
          }
        }

        // a little bit hacky, but seems to be a fast way to detect if we slide to top or to bottom
        this.scrollItemIntoView((this.getBoundedWidget().getScrollTop() > (this.getItemTop(oItem) - 1) ? this.getPrevious(oItem) : this.getNext(oItem)) || oItem);
      }

      // ********************************************************************
      //   Mode #3: Add new item to current selection (ctrl pressed)
      // ********************************************************************
      else if (this.getMultiSelection() && vCtrlKey && !vShiftKey)
      {
        if (!this._activeDragSession) {
          this._addToCurrentSelection = !(this.getCanDeselect() && this.getItemSelected(oItem));
        }

        this.setItemSelected(oItem, this._addToCurrentSelection);
        this.setAnchorItem(oItem);
      }

      // ********************************************************************
      //   Mode #4: Add new (or continued) range to selection
      // ********************************************************************
      else if (this.getMultiSelection() && vCtrlKey && vShiftKey)
      {
        if (!this._activeDragSession) {
          this._addToCurrentSelection = !(this.getCanDeselect() && this.getItemSelected(oItem));
        }

        if (this._addToCurrentSelection) {
          this._selectItemRange(currentAnchorItem, oItem, false);
        } else {
          this._deselectItemRange(currentAnchorItem, oItem);
        }
      }

      // ********************************************************************
      //   Mode #5: Replace selection with new range selection
      // ********************************************************************
      else if (this.getMultiSelection() && !vCtrlKey && vShiftKey)
      {
        if (this.getCanDeselect()) {
          this._selectItemRange(currentAnchorItem, oItem, true);
        }
        else
        {
          if (oldLead) {
            this._deselectItemRange(currentAnchorItem, oldLead);
          }

          this._selectItemRange(currentAnchorItem, oItem, false);
        }
      }

      // Recover change event status
      this.setFireChange(oldFireChange);

      // Dispatch change Event
      if (oldFireChange && this._hasChanged(oldVal)) {
        this._dispatchChange();
      }
    },




    /*
    ---------------------------------------------------------------------------
      KEY EVENT HANDLER
    ---------------------------------------------------------------------------
    */

    /**
     * Handles key event to perform selection and navigation
     *
     * @type member
     * @param vDomEvent {rwt.event.KeyEvent} event object
     * @return {void}
     */
    handleKeyPress : function(vDomEvent)
    {
      var oldVal = this._getChangeValue();

      // Temporary disabling of event fire
      var oldFireChange = this.getFireChange();
      this.setFireChange(false);

      // Ctrl+A: Select all
      if (vDomEvent.getKeyIdentifier() == "A" && vDomEvent.isCtrlPressed())
      {
        if (this.getMultiSelection())
        {
          this._selectAll();

          // Update lead item to this new last
          // (or better here: first) selected item
          this.setLeadItem(this.getFirst());
        }
      }

      // Default operation
      else
      {
        var aIndex = this.getAnchorItem();
        var itemToSelect = this.getItemToSelect(vDomEvent);

        if (itemToSelect && this.getItemEnabled(itemToSelect))
        {
          // Update lead item to this new last selected item
          this.setLeadItem(itemToSelect);

          // Scroll new item into view
          this.scrollItemIntoView(itemToSelect);

          // Stop event handling
          vDomEvent.preventDefault();

          // Select a range
          if (vDomEvent.isShiftPressed() && this.getMultiSelection())
          {
            // Make it a little bit more failsafe:
            // Set anchor if not given already. Allows us to select
            // a range without any previous selection.
            if (aIndex == null) {
              this.setAnchorItem(itemToSelect);
            }

            // Select new range (and clear up current selection first)
            this._selectItemRange(this.getAnchorItem(), itemToSelect, true);
          }
          else if (!vDomEvent.isCtrlPressed())
          {
            // Clear current selection
            this._deselectAll();

            // Update new item to be selected
            this.renderItemSelectionState(itemToSelect, true);

            // Add item to new selection
            this._selectedItems.add(itemToSelect);

            // Update anchor to this new item
            // (allows following shift range selection)
            this.setAnchorItem(itemToSelect);
          }
          else if (vDomEvent.getKeyIdentifier() == "Space")
          {
            if (this._selectedItems.contains(itemToSelect))
            {
              // Update new item to be selected
              this.renderItemSelectionState(itemToSelect, false);

              // Add item to new selection
              this._selectedItems.remove(itemToSelect);

              // Fix anchor item
              this.setAnchorItem(this._selectedItems.getFirst());
            }
            else
            {
              // Clear current selection
              if (!vDomEvent.isCtrlPressed() || !this.getMultiSelection()) {
                this._deselectAll();
              }

              // Update new item to be selected
              this.renderItemSelectionState(itemToSelect, true);

              // Add item to new selection
              this._selectedItems.add(itemToSelect);

              // Update anchor to this new item
              // (allows following shift range selection)
              this.setAnchorItem(itemToSelect);
            }
          }
        }
      }

      // Recover change event status
      this.setFireChange(oldFireChange);

      // Dispatch change Event
      if (oldFireChange && this._hasChanged(oldVal)) {
        this._dispatchChange();
      }
    },


    /**
     * TODOC
     *
     * @type member
     * @param vKeyboardEvent {var} TODOC
     * @return {null | var} TODOC
     */
    getItemToSelect : function(vKeyboardEvent)
    {
      // Don't handle ALT here
      if (vKeyboardEvent.isAltPressed()) {
        return null;
      }
      // Handle event by key identifier
      switch(vKeyboardEvent.getKeyIdentifier())
      {
        case "Home":
          return this.getHome(this.getLeadItem());

        case "End":
          return this.getEnd(this.getLeadItem());

        case "Down":
          return this.getDown(this.getLeadItem());

        case "Up":
          return this.getUp(this.getLeadItem());

        case "Left":
          return this.getLeft(this.getLeadItem());

        case "Right":
          return this.getRight(this.getLeadItem());

        case "PageUp":
          return this.getPageUp(this.getLeadItem()) || this.getHome(this.getLeadItem());

        case "PageDown":
          return this.getPageDown(this.getLeadItem()) || this.getEnd(this.getLeadItem());

        case "Space":
          if (vKeyboardEvent.isCtrlPressed()) {
            return this.getLeadItem();
          }
      }

      return null;
    },




    /*
    ---------------------------------------------------------------------------
      CHANGE HANDLING
    ---------------------------------------------------------------------------
    */

    /**
     * TODOC
     *
     * @type member
     * @return {void}
     */
    _dispatchChange : function()
    {
      if (!this.getFireChange()) {
        return;
      }

      if (this.hasEventListeners("changeSelection")) {
        this.dispatchEvent(new rwt.event.DataEvent("changeSelection", this.getSelectedItems()), true);
      }
    },


    /**
     * TODOC
     *
     * @type member
     * @param sOldValue {String} TODOC
     * @return {var} TODOC
     */
    _hasChanged : function(sOldValue) {
      return sOldValue != this._getChangeValue();
    },


    /**
     * TODOC
     *
     * @type member
     * @return {var} TODOC
     */
    _getChangeValue : function() {
      return this._selectedItems.getChangeValue();
    },




    /*
    ---------------------------------------------------------------------------
      POSITION HANDLING
    ---------------------------------------------------------------------------
    */

    /**
     * TODOC
     *
     * @type member
     * @return {var} TODOC
     */
    getHome : function() {
      return this.getFirst();
    },


    /**
     * TODOC
     *
     * @type member
     * @return {var} TODOC
     */
    getEnd : function() {
      return this.getLast();
    },


    /**
     * TODOC
     *
     * @type member
     * @param vItem {var} TODOC
     * @return {var} TODOC
     */
    getDown : function(vItem)
    {
      if (!vItem) {
        return this.getFirst();
      }

      return this.getMultiColumnSupport() ? (this.getUnder(vItem) || this.getLast()) : this.getNext(vItem);
    },


    /**
     * TODOC
     *
     * @type member
     * @param vItem {var} TODOC
     * @return {var} TODOC
     */
    getUp : function(vItem)
    {
      if (!vItem) {
        return this.getLast();
      }

      return this.getMultiColumnSupport() ? (this.getAbove(vItem) || this.getFirst()) : this.getPrevious(vItem);
    },


    /**
     * TODOC
     *
     * @type member
     * @param vItem {var} TODOC
     * @return {null | var} TODOC
     */
    getLeft : function(vItem)
    {
      if (!this.getMultiColumnSupport()) {
        return null;
      }

      return !vItem ? this.getLast() : this.getPrevious(vItem);
    },


    /**
     * TODOC
     *
     * @type member
     * @param vItem {var} TODOC
     * @return {null | var} TODOC
     */
    getRight : function(vItem)
    {
      if (!this.getMultiColumnSupport()) {
        return null;
      }

      return !vItem ? this.getFirst() : this.getNext(vItem);
    },


    /*
    ---------------------------------------------------------------------------
      PAGE HANDLING
    ---------------------------------------------------------------------------
    */

    /**
     * Jump a "page" up.
     *
     * #param vItem[rwt.widgets.base.Widget]: Relative to this widget
     *
     * @type member
     * @param vItem {var} TODOC
     * @return {var} TODOC
     */
    getPageUp : function()
    {
      // Find next item
      var nextItem = this.getLeadItem();

      if (!nextItem) {
        nextItem = this.getFirst();
      }

      var vBoundedWidget = this.getBoundedWidget();
      if( vBoundedWidget.isCreated() ) {
        var vParentScrollTop = vBoundedWidget.getScrollTop();
        var vParentClientHeight = vBoundedWidget.getClientHeight();
        // Normally we should reach the status "lead" for the
        // nextItem after two iterations.
        var tryLoops = 0;

        while (tryLoops < 2)
        {
          while (nextItem && (this.getItemTop(nextItem) - this.getItemHeight(nextItem) >= vParentScrollTop)) {
            nextItem = this.getUp(nextItem);
          }

          // This should never occour after the fix above
          if (nextItem == null) {
            break;
          }

          // If the nextItem is not anymore the leadItem
          // Means: There has occured a change.
          // We break here. This is normally the second step.
          if (nextItem != this.getLeadItem())
          {
            // be sure that the top is reached
            this.scrollItemIntoView(nextItem, true);
            break;
          }

          // Update scrolling (this is normally the first step)
          vBoundedWidget.setScrollTop(vParentScrollTop - vParentClientHeight - this.getItemHeight(nextItem));

          // Use the real applied value instead of the calulated above
          vParentScrollTop = vBoundedWidget.getScrollTop();

          // Increment counter
          tryLoops++;
        }
      }

      return nextItem;
    },


    /**
     * Jump a "page" down.
     *
     * #param vItem[rwt.widgets.base.Widget]: Relative to this widget
     *
     * @type member
     * @param vItem {var} TODOC
     * @return {var} TODOC
     */
    getPageDown : function()
    {
      // Find next item
      var nextItem = this.getLeadItem();

      if (!nextItem) {
        nextItem = this.getFirst();
      }

      var vBoundedWidget = this.getBoundedWidget();
      if( vBoundedWidget.isCreated() ) {
        var vParentScrollTop = vBoundedWidget.getScrollTop();
        var vParentClientHeight = vBoundedWidget.getClientHeight();

        // Normally we should reach the status "lead" for the
        // nextItem after two iterations.
        var tryLoops = 0;

        while (tryLoops < 2)
        {
          // Find next
          while (nextItem && ((this.getItemTop(nextItem) + (2 * this.getItemHeight(nextItem))) <= (vParentScrollTop + vParentClientHeight))) {
            nextItem = this.getDown(nextItem);
          }

          // This should never occour after the fix above
          if (nextItem == null) {
            break;
          }

          // If the nextItem is not anymore the leadItem
          // Means: There has occured a change.
          // We break here. This is normally the second step.
          if (nextItem != this.getLeadItem()) {
            break;
          }

          // Update scrolling (this is normally the first step)
          vBoundedWidget.setScrollTop(vParentScrollTop + vParentClientHeight - 2 * this.getItemHeight(nextItem));

          // Use the real applied value instead of the calulated above
          vParentScrollTop = vBoundedWidget.getScrollTop();

          // Increment counter
          tryLoops++;
        }
      }

      return nextItem;
    }
  },




  /*
  *****************************************************************************
     DESTRUCTOR
  *****************************************************************************
  */

  destruct : function() {
    this._disposeObjects("_selectedItems");
  }
});

/*******************************************************************************
 * Copyright (c) 2004, 2014 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

/**
 * Helper for rwt.widgets.util.SelectionManager, contains data for selections
 */
rwt.qx.Class.define( "rwt.widgets.util.Selection", {

  extend : rwt.qx.Object,

  construct : function() {
    this.base( arguments );
    this.__storage = [];
  },

  members : {

    /**
     * Add an item to the selection
     *
     * @type member
     * @param item {var} item to add
     * @return {void}
     */
    add : function( item ) {
      var index = this.__storage.indexOf( item );
      if( index === -1 ) {
        this.__storage.push( item );
      }
    },

    /**
     * Remove an item from the selection
     *
     * @type member
     * @param item {var} item to remove
     * @return {void}
     */
    remove : function( item ) {
      var index = this.__storage.indexOf( item );
      if( index !== -1 ) {
        this.__storage.splice( index, 1 );
      }
    },

    /**
     * Remove all items from the selection
     *
     * @type member
     * @return {void}
     */
    removeAll : function() {
      this.__storage = [];
    },

    /**
     * Check whether the selection contains a given item
     *
     * @type member
     * @param item {var} item to check for
     * @return {Boolean} whether the selection contains the item
     */
    contains : function( item ) {
      return this.__storage.indexOf( item ) !== -1;
    },

    /**
     * Convert selection to an array
     *
     * @type member
     * @return {Array} array representation of the selection
     */
    toArray : function() {
      return this.__storage.slice( 0 );
    },

    /**
     * Return first element of the Selection
     *
     * @type member
     * @return {var} first item of the selection
     */
    getFirst : function() {
      return this.__storage.length > 0 ? this.__storage[ 0 ] : null;
    },

    /**
     * Get a string representation of the Selection. The return value can be used to compare selections.
     *
     * @type member
     * @return {String} string representation of the Selection
     */
    getChangeValue : function() {
      var sb = [];
      for( var i = 0; i < this.__storage.length; i++ ) {
        sb.push( this.__storage[ i ].toHashCode() );
      }
      sb.sort();
      return sb.join( ";" );
    },

    /**
     * Whether the selection is empty
     *
     * @type member
     * @return {Boolean} whether the selection is empty
     */
    isEmpty : function() {
      return this.__storage.length === 0;
    }

  },

  destruct : function() {
    this._disposeFields( "__storage" );
  }

} );

/*******************************************************************************
 * Copyright (c) 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

/*jshint nonew:false */
namespace( "rwt.widgets.util" );

rwt.widgets.util.ScrollBarsActivator = function( scrollable ) {
  this._scrollable = scrollable;
  this._hovered = false;
  this._activateScrollBarsTimer = new rwt.client.Timer( 150 );
  this._activateScrollBarsTimer.addEventListener( "interval", this._onActivationTimer, this );
  this._deactivateScrollBarsTimer = new rwt.client.Timer( 1000 );
  this._deactivateScrollBarsTimer.addEventListener( "interval", this._onDeactivationTimer, this );
  this._registerListeners();
};

rwt.widgets.util.ScrollBarsActivator.install = function( scrollable ) {
  new rwt.widgets.util.ScrollBarsActivator( scrollable );
};

rwt.widgets.util.ScrollBarsActivator.prototype = {

  _registerListeners : function() {
    this._scrollable.addEventListener( "elementOver", this._onClientOver, this );
    this._scrollable.addEventListener( "elementOut", this._onClientOut, this );
    if( this._scrollable instanceof rwt.widgets.Grid ) {
      this._scrollable.addEventListener( "topItemChanged", this._onScroll, this );
      this._scrollable.addEventListener( "scrollLeftChanged", this._onScroll, this );
    } else {
      this._scrollable.addEventListener( "scroll", this._onScroll, this );
    }
    this._scrollable.addEventListener( "dispose", this._onDispose, this );
  },

  _onDispose : function() {
    this._activateScrollBarsTimer.dispose();
    this._activateScrollBarsTimer = null;
    this._deactivateScrollBarsTimer.dispose();
    this._deactivateScrollBarsTimer = null;
  },

  _onScroll : function() {
    this._activateScrollBars( !this._hovered );
  },

  _onClientOver : function( event ) {
    if( !this._hovered && this._scrollable.contains( event.getOriginalTarget() ) ) {
      this._hovered = true;
      this._activateScrollBarsTimer.stop();
      this._activateScrollBarsTimer.start();
    }
  },

  _onClientOut : function( event ) {
    var related = event.getRelatedTarget();
    if( !this._scrollable.contains( related ) ) {
      this._hovered = false;
      this._deactivateScrollBars();
    }
  },

  _onChangeCapture : function() {
    if( !this._hovered ) {
      this._deactivateScrollBars();
    }
  },

  _onActivationTimer : function() {
    if( this._hovered ) {
      this._activateScrollBars( false );
    }
  },

  _onDeactivationTimer : function() {
    if( !this._hovered ) {
      this._deactivateScrollBars();
    }
  },

  _activateScrollBars : function( autoDeactivate ) {
    if( !this._scrollable.isDisposed() ) {
      this._scrollable.getHorizontalBar().addState( "active" );
      this._scrollable.getVerticalBar().addState( "active" );
      this._activateScrollBarsTimer.stop();
      this._deactivateScrollBarsTimer.stop();
      if( autoDeactivate ) {
        this._deactivateScrollBarsTimer.start();
      }
    }
  },

  _deactivateScrollBars : function() {
    if( !this._scrollable.isDisposed() ) {
      var capture = rwt.event.EventHandler.getCaptureWidget();
      if( capture && this._scrollable.contains( capture ) ) {
        capture.addEventListener( "changeCapture", this._onChangeCapture, this );
      } else {
        this._scrollable.getHorizontalBar().removeState( "active" );
        this._scrollable.getVerticalBar().removeState( "active" );
        this._activateScrollBarsTimer.stop();
        this._deactivateScrollBarsTimer.stop();
      }
    }
  }

};

/*******************************************************************************
 * Copyright (c) 2008, 2015 Innoopract Informationssysteme GmbH and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Innoopract Informationssysteme GmbH - initial API and implementation
 *    EclipseSource - ongoing development
 ******************************************************************************/

rwt.qx.Class.define( "rwt.widgets.base.AbstractSlider", {

  extend : rwt.widgets.base.Parent,

  construct : function( horizontal ) {
    this.base( arguments );
    this.setOverflow( "hidden" );
    this._horizontal = horizontal;
    // properties (using virtual units):
    this._selection = 0;
    this._minimum = 0;
    this._maximum = 100;
    this._increment = 1;
    this._pageIncrement = 10;
    this._thumbLength = 10;
    // state:
    this._minThumbSize = 0;
    this._thumbLengthPx = 0;
    this._thumbDragOffset = 0;
    this._autoRepeat = ""; // string indicating to auto-repeat an action
    this._mouseOffset = 0; // horizontal or vertical offset to slider start
    this._delayTimer = new rwt.client.Timer( 250 ); // delay auto-repeated actions
    this._repeatTimer = new rwt.client.Timer( 100 ); // for auto-repeated actions
    // subwidgets:
    this._thumb = new rwt.widgets.base.BasicButton( "push", true );
    this._minButton = new rwt.widgets.base.BasicButton( "push", true );
    this._maxButton = new rwt.widgets.base.BasicButton( "push", true );
    this.add( this._thumb );
    this.add( this._minButton );
    this.add( this._maxButton );
    this._configureSubwidgets();
    this._configureAppearance();
    this._setStates();
    this._registerListeners();
    this._setDisplayFor( this._minButton );
    this._setDisplayFor( this._maxButton );
  },

  destruct : function() {
    this._delayTimer.stop();
    this._delayTimer.dispose();
    this._delayTimer = null;
    this._repeatTimer.stop();
    this._repeatTimer.dispose();
    this._repeatTimer = null;
    this._thumb = null;
    this._minButton = null;
    this._maxButton = null;
  },

  members : {

    setThumb : function( value ) {
      if( value <= 0 ) {
        throw new Error( "Scrollbar thumb must be positive" );
      }
      this._thumbLength = value;
      this._renderThumb();
    },

    getThumb : function() {
      return this._thumbLength;
    },

    setMaximum : function( value ) {
      if( value < 0 ) {
        throw new Error( "Scrollbar maximum must be positive" );
      }
      this._maximum = value;
      this._renderThumb();
      this.dispatchSimpleEvent( "changeMaximum" );
    },

    getMaximum : function() {
      return this._maximum;
    },

    setMinimum : function( value ) {
      this._minimum = value;
      this._renderThumb();
      this.dispatchSimpleEvent( "changeMinimum" );
    },

    getMinimum : function() {
      return this._maximum;
    },

    setMinThumbSize : function( value ) {
      this._minThumbSize =  value;
    },

    ////////////
    // protected

    _setSelection : function( value ) {
      var newSelection = this._limitSelection( Math.round( value ) );
      if( newSelection !== this._selection ) {
        this._selection = newSelection;
        this._selectionChanged();
      }
    },

    _setIncrement : function( value ) {
      this._increment = value;
    },

    _setPageIncrement : function( value ) {
      this._pageIncrement = value;
    },

    ////////////////
    // Eventhandlers

    _registerListeners : function() {
      this._repeatTimer.addEventListener( "interval", this._onRepeatTimerInterval, this );
      this._delayTimer.addEventListener( "interval", this._repeatTimerStart, this );
      this.addEventListener( "changeWidth", this._onChangeSize, this );
      this.addEventListener( "changeHeight", this._onChangeSize, this );
      this.addEventListener( "changeEnabled", this._onChangeEnabled, this );
      this.addEventListener( "mousedown", this._onMouseDown, this );
      this.addEventListener( "mouseup", this._onMouseUp, this );
      this.addEventListener( "mouseout",  this._onMouseOut, this );
      this.addEventListener( "mouseover",  this._onMouseOver, this );
      this.addEventListener( "mousemove", this._onMouseMove, this );
      this.addEventListener( "mousewheel", this._onMouseWheel, this );
      this._thumb.addEventListener( "mousedown", this._onThumbMouseDown, this );
      this._thumb.addEventListener( "mousemove", this._onThumbMouseMove, this );
      this._thumb.addEventListener( "mouseup", this._onThumbMouseUp, this );
      this._minButton.addEventListener( "mousedown", this._onMinButtonMouseEvent, this );
      this._maxButton.addEventListener( "mousedown", this._onMaxButtonMouseEvent, this );
      this._minButton.addEventListener( "stateOverChanged", this._onMinButtonMouseEvent, this );
      this._maxButton.addEventListener( "stateOverChanged", this._onMaxButtonMouseEvent, this );

    },

    _selectionChanged : function() {
      this._renderThumb();
      if( this._autoRepeat !== "" && !this._repeatTimer.isEnabled() ) {
        this._delayTimer.start();
      }
    },

    _onChangeSize : function() {
      this._renderThumb();
    },

    _onChangeEnabled : function( event ) {
      this._thumb.setVisibility( event.getValue() );
    },

    _onMouseWheel : function( event ) {
      if ( event.getTarget() === this ) {
        event.preventDefault();
        event.stopPropagation();
        var data = event.getWheelDelta();
        var change = ( data / Math.abs( data ) ) * this._increment;
        var sel = this._selection - change;
        if( sel < this._minimum ) {
          sel = this._minimum;
        }
        if( sel > ( this._maximum - this._thumbLength ) ) {
          sel = this._maximum - this._thumbLength;
        }
        this._setSelection( sel );
      }
    },

    _onMouseDown : function( event ) {
      if( event.isLeftButtonPressed() ) {
        this._mouseOffset = this._getMouseOffset( event );
        this._handleLineMouseDown();
      }
    },

    _onMouseUp : function() {
      this.setCapture( false );
      this._autoRepeat = "";
      this._delayTimer.stop();
      this._repeatTimer.stop();
    },

    _onMouseOver : function( event ) {
      var target = event.getOriginalTarget();
      if ( target === this && this._autoRepeat.slice( 0, 4 ) === "line" ) {
        this.setCapture( false );
        this._repeatTimerStart();
      }
    },

    _onMouseOut : function( event ) {
      var target = event.getRelatedTarget();
      var outOfSlider = target !== this && !this.contains( target );
      if( outOfSlider && this._autoRepeat.slice( 0, 4 ) === "line" ) {
        this.setCapture( true );
        this._delayTimer.stop();
        this._repeatTimer.stop();
      }
    },

    _onMouseMove : function( event ) {
      this._mouseOffset = this._getMouseOffset( event );
    },

    _onMinButtonMouseEvent : function( event ) {
      event.stopPropagation();
      if( this._minButton.hasState( "pressed" ) ) {
        this._autoRepeat = "minButton";
        this._setSelection( this._selection - this._increment );
      } else {
        this._autoRepeat = "";
      }
    },

    _onMaxButtonMouseEvent : function( event ) {
      event.stopPropagation();
      if( this._maxButton.hasState( "pressed" ) ) {
        this._autoRepeat = "maxButton";
        this._setSelection( this._selection + this._increment );
      } else {
        this._autoRepeat = "";
      }
    },

    _onThumbMouseDown : function( event ) {
      event.stopPropagation();
      this._thumb.addState( "pressed" );
      if( event.isLeftButtonPressed() ) {
        var mousePos = this._getMouseOffset( event );
        this._thumbDragOffset = mousePos - this._getThumbPosition();
        this._thumb.setCapture( true );
      }
    },

    _onThumbMouseMove : function( event ) {
      event.stopPropagation();
      if( this._thumb.getCapture() ) {
        var mousePos = this._getMouseOffset( event );
        var newSelection = this._pxToVirtual( mousePos - this._thumbDragOffset );
        this._setSelection( newSelection );
      }
    },

    _onThumbMouseUp : function( event ) {
      if( this._thumb.hasState( "pressed" ) ) {
        event.stopPropagation();
        this._repeatTimer.stop();
        this._thumb.setCapture( false );
        this._thumb.removeState( "pressed" );
      }
    },

    ////////////
    // Internals

    _configureSubwidgets : function() {
      if( this._horizontal ) {
        this._thumb.setHeight( "100%" );
        this._minButton.setHeight( "100%" );
        this._maxButton.setHeight( "100%" );
        this._maxButton.setRight( 0 );
      } else {
        this._thumb.setWidth( "100%" );
        this._minButton.setWidth( "100%" );
        this._maxButton.setWidth( "100%" );
        this._maxButton.setBottom( 0 );
      }
      this._minButton.setTabIndex( null );
      this._maxButton.setTabIndex( null );
      this._thumb.setTabIndex( null );
    },

    _setStates : function() {
      var style = this._horizontal ? "rwt_HORIZONTAL" : "rwt_VERTICAL";
      var state = this._horizontal ? "horizontal" : "vertical";
      this.addState( style );
      this._minButton.addState( style );
      this._minButton.addState( state );
      this._maxButton.addState( style );
      this._maxButton.addState( state );
      this._thumb.addState( style );
      // We need to render appearance now because valid layout values
      // (i.e. a number) might be needed by the constructor
      this._renderAppearance();
      this._minButton._renderAppearance();
      this._maxButton._renderAppearance();
      this._thumb._renderAppearance();
    },

    // overwritten:
    _visualizeFocus : function() {
      this.base( arguments );
      this._thumb.addState( "focused" );
    },

    // overwritten:
    _visualizeBlur : function() {
      this.base( arguments );
      this._thumb.removeState( "focused" );
    },

    _repeatTimerStart : function() {
      this._delayTimer.stop();
      if( this._autoRepeat !== "" ) {
        this._repeatTimer.start();
      }
    },

    _onRepeatTimerInterval : function() {
      switch( this._autoRepeat ) {
        case "minButton":
          this._setSelection( this._selection - this._increment );
        break;
        case "maxButton":
          this._setSelection( this._selection + this._increment );
        break;
        case "linePlus":
        case "lineMinus":
          this._handleLineMouseDown();
        break;
      }
    },

    _handleLineMouseDown : function() {
      var mode;
      var thumbHalf = this._thumbLengthPx / 2;
      var pxSel = this._getThumbPosition() + thumbHalf;
      var newSelection;
      if( this._mouseOffset > pxSel ) {
        newSelection = this._selection + this._pageIncrement;
        mode = "linePlus";
      } else {
        mode = "lineMinus";
        newSelection = this._selection - this._pageIncrement;
      }
      if( this._autoRepeat === "" || this._autoRepeat === mode ) {
        this._autoRepeat = mode;
        this._setSelection( newSelection );
      }
    },

    _renderThumb : function() {
      this._renderThumbSize(); // Size first since it's evaluated by _virtualToPx
      this._renderThumbPosition();
    },

    _renderThumbPosition : function() {
      this._setThumbPositionPx( this._virtualToPx( this._selection ) );
      this.dispatchSimpleEvent( "updateToolTip", this );
    },

    _renderThumbSize : function() {
      var success = false;
      var lineSize = this._getLineSize();
      var diff = this._maximum - this._minimum;
      if( lineSize > 0 && diff > 0 ) {
        var newSize = this._thumbLength * lineSize / diff;
        this._setThumbLengthPx( Math.max( this._minThumbSize, Math.round( newSize ) ) );
        success = true;
      }
      return success;
    },

    _setThumbLengthPx : function( value ) {
      this._thumbLengthPx = value;
      if( this._horizontal ) {
        this._thumb.setWidth( this._thumbLengthPx );
      } else {
        this._thumb.setHeight( this._thumbLengthPx );
      }
    },

    _setThumbPositionPx : function( value ) {
      if( this._horizontal ) {
        this._thumb.setLeft( value );
      } else {
        this._thumb.setTop( value );
      }
    },

    _pxToVirtual : function( px ) {
      var buttonSize = this._getMinButtonWidth();
      var result = ( px - buttonSize ) / this._getVirtualToPxRatio() + this._minimum;
      return this._limitSelection( Math.round( result ) );
    },

    _virtualToPx : function( virtual ) {
      return   this._getMinButtonWidth()
             + this._getVirtualToPxRatio() * ( virtual - this._minimum );
    },

    _getVirtualToPxRatio : function() {
      var numPixels = Math.max( 0, this._getLineSize() - this._thumbLengthPx );
      var numVirtual = this._maximum - this._minimum - this._thumbLength;
      return numVirtual === 0 ? 0 : numPixels / numVirtual;
    },

    //////////
    // Helpers

    _limitSelection : function( value ) {
      var result = value;
      if( value >= ( this._maximum - this._thumbLength ) ) {
        result = this._maximum - this._thumbLength;
      }
      if( result <= this._minimum ) {
        result = this._minimum;
      }
      return result;
    },

    _getMouseOffset : function( mouseEvent ) {
      var location = rwt.html.Location;
      var result;
      if( this._horizontal ) {
        result = mouseEvent.getPageX() - location.getLeft( this.getElement() );
      } else {
        result = mouseEvent.getPageY() - location.getTop( this.getElement() );
      }
      return result;
    },

    _getThumbPosition : function() {
      var result;
      if( this._horizontal ) {
        result = this._thumb.getLeft();
      } else {
        result = this._thumb.getTop();
      }
      return result;
    },

    _getLineSize : function() {
      var buttonSize = this._getMinButtonWidth() + this._getMaxButtonWidth();
      return this._getSliderSize() - this.getFrameWidth() - buttonSize;
    },

    _getSliderSize : function() {
      var result;
      if( this._horizontal ) {
        result = this.getWidth();
      } else {
        result = this.getHeight();
      }
      return result;
    },

    _getMinButtonWidth : function() {
      var result;
      if( this._horizontal ) {
        result = this._minButton.getWidth();
      } else {
        result = this._minButton.getHeight();
      }
      return result;
    },

    _getMaxButtonWidth : function() {
      var result;
      if( this._horizontal ) {
        result = this._maxButton.getWidth();
      } else {
        result = this._maxButton.getHeight();
      }
      return result;
    },

    _setDisplayFor : function( button ) {
      if( button.getImage()[ 0 ] === null ) {
        if( this._horizontal ) {
          button.setWidth( 0 );
        } else {
          button.setHeight( 0 );
        }
        button.setDisplay( false );
      }
    }

  }
} );

/*******************************************************************************
 * Copyright (c) 2011, 2015 Innoopract Informationssysteme GmbH and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Innoopract Informationssysteme GmbH - initial API and implementation
 *    EclipseSource - ongoing development
 ******************************************************************************/

rwt.qx.Class.define( "rwt.widgets.base.ScrollBar", {

  extend : rwt.widgets.base.AbstractSlider,

  construct : function( horizontal ) {
    this.base( arguments, horizontal );
    this._idealValue = 0;
    this._idealThumb = 10;
    this._lastDispatchedValue = 0;
    this._renderSum = 0;
    this._renderSamples = 0;
    this.setMinimum( 0 );
    this._hasSelectionListener = false;
    var themeValues = new rwt.theme.ThemeValues( this.__states );
    this.setMinThumbSize( themeValues.getCssDimension( "ScrollBar-Thumb", "min-height" ) );
    this._autoThumbSize = true;
    this.setIncrement( 20 );
    this.addEventListener( "mousedown", this._stopEvent, this );
    this.addEventListener( "mouseup", this._stopEvent, this );
    this.addEventListener( "click", this._stopEvent, this );
    this.addEventListener( "dblclick", this._stopEvent, this );
  },

  members : {

    _configureAppearance : function() {
      this.setAppearance( "scrollbar" );
      this._thumb.setAppearance( "scrollbar-thumb" );
      this._minButton.setAppearance( "scrollbar-min-button" );
      this._maxButton.setAppearance( "scrollbar-max-button" );
    },

    _applyOpacity : function( value, old ) {
      this.base( arguments, value, old );
      // No transition for the very first time opacity is applied (widget creation)
      rwt.html.Style.setTransition( this, "opacity 250ms" );
    },

    //////
    // API

    setValue : function( value ) {
      this._idealValue = value;
      this._setSelection( value );
    },

    getValue : function() {
      return this._selection;
    },

    setMaximum : function( value ) {
      this.base( arguments, value );
      this._checkValue();
    },

    setThumb : function( value ) {
      this.base( arguments, value );
      this._checkValue();
      this._updatePageIncrement();
    },

    setIncrement : function( value ) {
      this._setIncrement( value );
    },

    setHasSelectionListener : function( value ) {
      this._hasSelectionListener = value;
    },

    getHasSelectionListener : function() {
      return this._hasSelectionListener;
    },

    isHorizontal : function() {
      return this._horizontal;
    },

    setAutoThumbSize : function( autoThumbSize ) {
      this._autoThumbSize = autoThumbSize;
    },

    ////////////
    // Internals

    _updateThumbLength : function() {
      if( this._autoThumbSize ) {
        var size = this._getSliderSize();
        if( size > 0) {
          this.setThumb( size );
        }
      }
    },

    _updatePageIncrement : function() {
      this._setPageIncrement( this.getThumb() );
    },

    _stopEvent : function( event ) {
      event.stopPropagation();
      event.preventDefault();
    },

    _dispatchValueChanged : function() {
      this._lastDispatchedValue = this._selection;
      this.createDispatchEvent( "changeValue" );
    },

    _updateStepsize : function() {
      var oldValue = this._selection;
      this.base( arguments );
      if( oldValue !== this._selection ) {
        this._dispatchValueChanged();
      }
    },

    //////////////
    // Overwritten

    _onChangeSize : function() {
      this._updateThumbLength();
      this._updatePageIncrement();
      this.base( arguments );
    },

    _renderThumbSize : function() {
      if( this.base( arguments ) ) {
        this._renderThumbIcon();
      }
    },

    _renderThumbIcon : function() {
      if( this._horizontal ) {
        var iconWidth = this._thumb.getCellWidth( 1 );
        var iconVisible = this._thumbLengthPx >= ( iconWidth + 6 );
        this._thumb.setCellVisible( 1, iconVisible );
      } else {
        var iconHeight = this._thumb.getCellHeight( 1 );
        var iconVisible = this._thumbLengthPx >= ( iconHeight + 6 );
        this._thumb.setCellVisible( 1, iconVisible );
      }
    },

    _checkValue : function() {
      if( this._idealValue !== null && this._idealValue ) {
        this._setSelection( this._idealValue );
      } else {
        this._setSelection( this._selection );
      }
    },

    _setSelection : function( value ) {
      if( value !== this._idealValue ) {
        this._idealValue = null;
      }
      this.base( arguments, value );
    },

    _selectionChanged : function() {
      this.base( arguments );
      this._dispatchValueChanged();
    }

  }

} );

/*******************************************************************************
 * Copyright (c) 2004, 2014 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

/**
 * The image preloader can be used to fill the browser cache with images,
 * which are needed later. Once all images are pre loaded a "complete"
 * event is fired.
 */
rwt.qx.Class.define("rwt.html.ImagePreloaderSystem",
{
  extend : rwt.qx.Target,



  /*
  *****************************************************************************
     CONSTRUCTOR
  *****************************************************************************
  */

  /**
   * If the callback is provided the preloading starts automatically and the callback
   * is called on completion of the pre loading. Otherwhise the pre loading has to be
   * started manually using {@link #start}.
   *
   * @param vPreloadList {String[]} list of image URLs to preload
   * @param vCallBack {Function} callback function. This function gets called after the
   *    preloading is completed
   * @param vCallBackScope {Object?window} scope for the callback function
   */
  construct : function(vPreloadList, vCallBack, vCallBackScope)
  {
    this.base(arguments);

    // internally use a map for the image sources
    if( vPreloadList instanceof Array ) {
      this._list = rwt.util.Objects.fromArray( vPreloadList );
    } else {
      this._list = vPreloadList;
    }

    // Create timer
    this._timer = new rwt.client.Timer( 3000 );
    this._timer.addEventListener("interval", this.__oninterval, this);

    // If we use the compact syntax, automatically add an event listeners and start the loading process
    if (vCallBack) {
      this.addEventListener("completed", vCallBack, vCallBackScope || null);
    }
  },



  /*
  *****************************************************************************
     EVENTS
  *****************************************************************************
  */

  events:
  {
    /** Fired after the pre loading of the images is complete */
    "completed" : "rwt.event.Event"
  },




  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {
    _stopped : false,




    /*
    ---------------------------------------------------------------------------
      USER ACCESS
    ---------------------------------------------------------------------------
    */

    /**
     * Start the preloading
     *
     * @type member
     * @return {void}
     */
    start : function()
    {
      if (rwt.util.Objects.isEmpty(this._list))
      {
        this.createDispatchEvent("completed");
        return;
      }

      for (var vSource in this._list)
      {
        var vPreloader = rwt.html.ImagePreloaderManager.getInstance().create( vSource );

        if (vPreloader.isErroneous() || vPreloader.isLoaded()) {
          delete this._list[vSource];
        }
        else
        {
          vPreloader._origSource = vSource;

          vPreloader.addEventListener("load", this.__onload, this);
          vPreloader.addEventListener("error", this.__onerror, this);
        }
      }

      // Initial check
      this._check();
    },




    /*
    ---------------------------------------------------------------------------
      EVENT LISTENERS
    ---------------------------------------------------------------------------
    */

    /**
     * Load event handler
     *
     * @type member
     * @param e {Event} Event object
     */
    __onload : function(e)
    {
      if (this.getDisposed()) {
        return;
      }

      delete this._list[e.getTarget()._origSource];
      this._check();
    },


    /**
     * Error handler
     *
     * @type member
     * @param e {Event} Event object
     */
    __onerror : function(e)
    {
      if (this.getDisposed()) {
        return;
      }

      delete this._list[e.getTarget()._origSource];
      this._check();
    },


    /**
     * Timer interval handler
     *
     * @type member
     * @param e {Event} Event object
     */
    __oninterval : function()
    {
      this._stopped = true;
      this._timer.stop();

      this.createDispatchEvent("completed");
    },




    /*
    ---------------------------------------------------------------------------
      CHECK
    ---------------------------------------------------------------------------
    */

    /**
     * Checks whether the pre loading is complete and dispatches the "complete" event.
     *
     * @type member
     */
    _check : function()
    {
      if (this._stopped) {
        return;
      }

      if (rwt.util.Objects.isEmpty(this._list))
      {
        this._timer.stop();
        this.createDispatchEvent("completed");
      }
      else
      {
        // Restart timer for timeout
        this._timer.restart();
      }
    }
  },

  /*
  *****************************************************************************
     DESTRUCTOR
  *****************************************************************************
  */

  destruct : function()
  {
    if (this._timer)
    {
      this._timer.removeEventListener("interval", this.__oninterval, this);
      this._disposeObjects("_timer");
    }

    this._disposeFields("_list");
  }
});

/*******************************************************************************
 * Copyright (c) 2004, 2013 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

/**
 * Cross browser abstractions to work with iframes.
 */
rwt.qx.Class.define("rwt.html.Iframes",
{
  /*
  *****************************************************************************
     STATICS
  *****************************************************************************
  */

  statics :
  {
    /**
     * Get the DOM window object of an iframe.
     *
     * @type static
     * @param vIframe {Element} DOM element of the iframe.
     * @return {DOMWindow} The DOM window object of the iframe.
     * @signature function(vIframe)
     */
    getWindow : function( vIframe ) {
      try {
        var vDoc = rwt.html.Iframes.getDocument( vIframe );
        return vDoc ? vDoc.defaultView : null;
      } catch( ex ) {
        return null;
      }
    },

    /**
     * Get the DOM document object of an iframe.
     *
     * @type static
     * @param vIframe {Element} DOM element of the iframe.
     * @return {DOMDocument} The DOM document object of the iframe.
     * @signature function(vIframe)
     */
    getDocument : function( vIframe ) {
      try {
        return vIframe.contentDocument;
      } catch( ex ) {
        return null;
      }
    },

    /**
     * Get the HTML body element of the iframe.
     *
     * @type static
     * @param vIframe {Element} DOM element of the iframe.
     * @return {Element} The DOM node of the <code>body</code> element of the iframe.
     */
    getBody : function(vIframe)
    {
      var vDoc = rwt.html.Iframes.getDocument(vIframe);
      return vDoc ? vDoc.getElementsByTagName("body")[0] : null;
    }
  }
});

/*******************************************************************************
 * Copyright (c) 2012, 2015 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

namespace( "rwt.remote" );

(function(){

var Client = rwt.client.Client;

rwt.remote.Request = function( url, method, responseType ) {
  this._url = url;
  this._method = method;
  this._async = true;
  this._success = null;
  this._error = null;
  this._data = null;
  this._responseType = responseType;
  this._request = rwt.remote.Request.createXHR();
};

rwt.remote.Request.createXHR = function() {
  return new XMLHttpRequest();
};

rwt.remote.Request.prototype = {

    dispose : function() {
      if( this._request != null ) {
        this._request.onreadystatechange = null;
        this._request.abort();
        this._success = null;
        this._error = null;
        this._request = null;
      }
    },

    send : function() {
      var urlpar = null;
      var post = this._method === "POST";
      if( !post && this._data ) {
        urlpar = this._data;
      }
      var url = this._url;
      if( urlpar ) {
        url += ( url.indexOf( "?" ) >= 0 ? "&" : "?" ) + urlpar;
      }
      this._request.open( this._method, url, this._async );
      this._configRequest();
      this._request.send( post ? this._data : undefined );
      if( !this._shouldUseStateListener() ) {
        this._onReadyStateChange();
      }
      if( !this._async ) {
        this.dispose();
      }
    },

    setAsynchronous : function( value ) {
      this._async = value;
    },

    getAsynchronous : function() {
      return this._async;
    },

    setSuccessHandler : function( handler, context ) {
      this._success = function(){ handler.apply( context, arguments ); };
    },

    setErrorHandler : function( handler, context ) {
      this._error = function(){ handler.apply( context, arguments ); };
    },

    setData : function( value ) {
      this._data = value;
    },

    getData : function() {
      return this._data;
    },

    _configRequest : function() {
      if( !( Client.isWebkit() || Client.isBlink() ) ) {
        this._request.setRequestHeader( "Referer", window.location.href );
      }
      var contentType = "application/json; charset=UTF-8";
      this._request.setRequestHeader( "Content-Type", contentType );
      if( this._shouldUseStateListener() ) {
        this._request.onreadystatechange = rwt.util.Functions.bind( this._onReadyStateChange, this );
      }
    },

    _shouldUseStateListener : function() {
      var result = true;
      if( !this._async && Client.isGecko() && Client.getMajor() < 4 ) {
        // see Bug 398951 - RAP does not start in Firefox 3.x
        result = false;
      }
      return result;
    },

    _onReadyStateChange : function() {
      if( this._request.readyState === 4 ) {
        var text;
        // [if] typeof(..) == "unknown" is IE specific. Used to prevent error:
        // "The data necessary to complete this operation is not yet available"
        if( typeof this._request.responseText !== "unknown" ) {
          text = this._request.responseText;
        }
        var event = {
          "responseText" : text,
          "status" : this._request.status,
          "responseHeaders" : this._getHeaders(),
          "target" : this
        };
        if( this._request.status === 200 ) {
          if( this._success ) {
            this._success( event );
          }
        } else {
          if( this._error ) {
            this._error( event );
          }
        }
        if( this._async ) {
          this.dispose();
        }
      }
    },

    _getHeaders : function() {
      var text = this._request.getAllResponseHeaders();
      var values = text.split( /[\r\n]+/g );
      var result = {};
      for( var i=0; i < values.length; i++ ) {
        var pair = values[ i ].match( /^([^:]+)\s*:\s*(.+)$/i );
        if( pair ) {
          result[ pair[ 1 ] ] = pair[ 2 ];
        }
      }
      return result;
    }

};

}());

/*******************************************************************************
 * Copyright (c) 2004, 2014 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

(function() {

var getToolTip = function() {
  return rwt.widgets.base.WidgetToolTip.getInstance();
};

rwt.qx.Class.define( "rwt.widgets.util.ToolTipManager", {

  extend : rwt.qx.Object,

  statics : {

    getInstance : function() {
      return rwt.runtime.Singletons.get( rwt.widgets.util.ToolTipManager );
    }

  },

  properties : {
    currentToolTipTarget : {
      nullable : true,
      apply : "_applyCurrentToolTipTarget"
    }
  },

  members : {

    /**
     * TODOC
     *
     * @type member
     * @param value {var} Current value
     * @param old {var} Previous value
     * @return {void | Boolean} TODOC
     */
    _applyCurrentToolTipTarget : function(value, old) {

      // If old tooltip existing, hide it and clear widget binding
      if (old)
      {
        getToolTip()._stopShowTimer();
        getToolTip()._startHideTimer();
        old.removeEventListener( "updateToolTip", this._updateEventHandler );
      }

      getToolTip().setBoundToWidget( value );

      // If new tooltip is not null, set it up and start the timer
      if (value) {
        getToolTip()._startShowTimer();
        value.addEventListener( "updateToolTip", this._updateEventHandler );
      }
    },

    handleMouseEvent : function( event ) {
      var type = event.getType();
      if( type === "mouseover" ) {
        this._handleMouseOver( event );
      } else if ( type === "mouseout" ) {
        this._handleMouseOut( event );
      } else if ( type === "mousemove" ) {
        this._handleMouseMove( event );
      }
    },

    _handleMouseOver : function( e ) {
      var vTarget = e.getTarget();
      if( vTarget === getToolTip() || getToolTip().contains( vTarget ) ) {
        this.setCurrentToolTipTarget( getToolTip().getLastWidget() );
        return;
      }
      // Allows us to use DOM Nodes as tooltip target :)
      if (!(vTarget instanceof rwt.widgets.base.Widget) && vTarget.nodeType == 1) {
        vTarget = rwt.event.EventHandlerUtil.getTargetObject(vTarget);
      }
      while (vTarget != null && vTarget.getToolTipText() === null ) {
        vTarget = vTarget.getParent();
      }
      this.setCurrentToolTipTarget( vTarget );
    },

    _handleMouseOut : function( e ) {
      var vTarget = e.getTarget();
      var vRelatedTarget = e.getRelatedTarget();
      if( vTarget === getToolTip() ) {
        return;
      }
      var tTarget = this.getCurrentToolTipTarget();
      if (tTarget && (vRelatedTarget == getToolTip() || getToolTip().contains(vRelatedTarget))) {
        return;
      }
      if (vRelatedTarget && vTarget && vTarget.contains(vRelatedTarget)) {
        return;
      }
      if (tTarget && !vRelatedTarget) {
        this.setCurrentToolTipTarget( null );
      }
    },

    _handleMouseMove : function( e ) {
      if( this.getCurrentToolTipTarget() ) {
        getToolTip()._handleMouseMove( e );
      }
    },

    handleFocus : function() {
      // nothing to do
    },

    handleBlur : function(e)
    {
      var vTarget = e.getTarget();

      if (!vTarget) {
        return;
      }

      var tTarget = this.getCurrentToolTipTarget();

      if (tTarget === vTarget) {
        getToolTip()._stopShowTimer();
        getToolTip()._startHideTimer();
      }
    },

    handleKeyEvent : function( event ) {
      switch( event.getKeyIdentifier() ) {
        case "Control":
        case "Alt":
        case "Shift":
        case "Meta":
        case "Win":
        break;
        default:
          getToolTip()._stopShowTimer();
          getToolTip()._quickHide();
        break;
      }
    },

    _updateEventHandler : function( target ) {
      if( getToolTip().getBoundToWidget() === target ) {
        getToolTip().updateText();
      }
    }

  }

} );

}() );

/*******************************************************************************
 * Copyright (c) 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

namespace( "rwt.client" );

rwt.client.FileUploader = function() {
  this._sequenceId = 0;
  this._holder = {};
};


rwt.client.FileUploader.getInstance = function() {
  return rwt.runtime.Singletons.get( rwt.client.FileUploader );
};

rwt.client.FileUploader.createFormData = function() {
  return new FormData();
};

rwt.client.FileUploader.prototype = {

  addFile : function( file ) {
    var result = "f" + this._sequenceId;
    this._holder[ result ] = file;
    this._sequenceId++;
    return result;
  },

  // For testing only:
  getFileById : function( id ) {
    return this._holder[ id ];
  },

  submit : function( callProperties ) {
    var url = callProperties.url;
    var fileIds = callProperties.fileIds;
    var formData = rwt.client.FileUploader.createFormData();
    for( var i = 0; i < fileIds.length; i++ ) {
      var file = this._holder[ fileIds[ i ] ];
      if( !file ) {
        throw new Error( "Unkown file id \"" + fileIds[ i ] + "\"." );
      }
      formData.append( file.name, file );
    }
    var xhr = rwt.remote.Request.createXHR();
    xhr.open( "POST", url );
    xhr.send( formData );
  }

};

/*******************************************************************************
 * Copyright (c) 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.remote.HandlerRegistry.add( "rwt.client.FileUploader", {

  factory : function() {
    return rwt.client.FileUploader.getInstance();
  },

  service : true,

  methods : [ "submit" ]

} );

/*******************************************************************************
 * Copyright (c) 2004, 2014 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 *
 * This class contains code based on the following work:
 *
 *  * Yahoo! UI Library, version 2.2.0
 *    http://developer.yahoo.com/yui
 *    Copyright (c) 2007, Yahoo! Inc.
 *    License: BSD, http://developer.yahoo.com/yui/license.txt
 ******************************************************************************/

/**
 * A helper for using the browser history in JavaScript Applications without
 * reloading the main page.
 *
 * Adds entries to the browser history and fires a "request" event when one of
 * the entries was requested by the user (e.g. by clicking on the back button).
 *
 * Browser history support is currently available for Internet Explorer 6/7,
 * Firefox, Opera 9 and WebKit. Safari 2 and older are not yet supported.
 *
 * This module is based on the ideas behind the YUI Browser History Manager
 * by Julien Lecomte (Yahoo), which is described at
 * http://yuiblog.com/blog/2007/02/21/browser-history-manager/. The Yahoo
 * implementation can be found at http://developer.yahoo.com/yui/history.
 * The original code is licensed under a BSD license
 * (http://developer.yahoo.com/yui/license.txt).
 */
rwt.qx.Class.define( "rwt.client.BrowserNavigation", {

  extend : rwt.qx.Target,

  statics : {

    getInstance : function() {
      return rwt.runtime.Singletons.get( rwt.client.BrowserNavigation );
    }

  },

  construct : function() {
    this.base(arguments);
    this._hasNavigationListener = false;
    this._titles = {};
    this._state = this.__getState();
    this.__startTimer();
  },

  events: {
    /**
     * Fired when the user moved in the history. The data property of the event
     * holds the state, which was passed to {@link #addToHistory}.
     */
    "request" : "rwt.event.DataEvent"
  },


  properties : {

    timeoutInterval : {
      check: "Number",
      init : 100,
      apply : "_applyTimeoutInterval"
    }

  },

  members : {

    /**
     * Adds an entry to the browser history.
     *
     * @type member
     * @param state {String} a string representing the state of the
     *          application. This command will be delivered in the data property of
     *          the "request" event.
     * @param newTitle {String ? null} the page title to set after the history entry
     *          is done. This title should represent the new state of the application.
     */
    addToHistory : function( state, newTitle ) {
      if( newTitle != null ) {
        document.title = newTitle;
      }
      this._titles[ state ] = document.title;
      if( state != this._state ) {
        // RAP [if] Prevent the event dispatch
        this._state = state;
        this.__storeState( state );
      }
    },

    /**
     * Get the current state of the browser history.
     *
     * @return {String} The current state
     */
    getState : function() {
      return this._state;
    },

    /**
     * Navigates back in the browser history.
     * Simulates a back button click.
     */
     navigateBack : function() {
       rwt.client.Timer.once(function() {history.back();}, 0);
     },

    /**
     * Navigates forward in the browser history.
     * Simulates a forward button click.
     */
     navigateForward : function() {
       rwt.client.Timer.once(function() {history.forward();}, 0);
     },

    /**
     * Apply the interval of the timer.
     *
     * @type member
     * @param newInterval {Integer} new timeout interval
     */
    _applyTimeoutInterval : function(value) {
      this._timer.setInterval(value);
    },

    /**
     * called on changes to the history using the browser buttons
     *
     * @param state {String} new state of the history
     */
    __onHistoryLoad : function(state) {
      this._state = state;
      this.createDispatchDataEvent("request", state);
      if (this._titles[state] != null) {
        document.title = this._titles[state];
      }
    },


    /**
     * Starts the timer polling for updates to the history IFrame on IE
     * or the fragment identifier on other browsers.
     */
    __startTimer : function() {
      this._timer = new rwt.client.Timer(this.getTimeoutInterval());

      this._timer.addEventListener( "interval", function() {
        var newHash = this.__getState();
        if( newHash != this._state ) {
          this.__onHistoryLoad(newHash);
        }
      }, this );

      if( this._hasNavigationListener ) {
        this._timer.start();
      }
    },


    /**
     * Returns the fragment identifier of the top window URL
     *
     * @return {String} the fragment identifier
     */
    __getHash : function()
    {
      // RAP [if] Fix for bug 295816
      //var href = top.location.href;
      var href = window.location.href;
      var idx = href.indexOf( "#" );
      return idx >= 0 ? href.substring(idx+1) : "";
    },


    /**
     * Browser dependent function to read the current state of the history
     *
     * @return {String} current state of the browser history
     */
    __getState : function() {
      return decodeURIComponent(this.__getHash());
    },

    /**
     * Save a state into the browser history.
     *
     * @param state {String} state to save
     * @return {Boolean} Whether the state could be saved. This function may
     *   fail on the Internet Explorer if the hidden IFrame is not yet fully
     *   loaded.
     */
    __storeState : function( state ) {
      // RAP [if] Fix for bug 295816
      //top.location.hash = "#" + encodeURIComponent(state);
      window.location.hash = "#" + encodeURIComponent( state ).replace( /%2F/g, "/" );
      return true;
    },

    setHasNavigationListener : function( value ) {
      this._hasNavigationListener = value;
      if( value ) {
        this.addEventListener( "request", this._historyNavigated, this );
        if( this._timer ) {
          this._timer.start();
        }
      } else {
        this.removeEventListener( "request", this._historyNavigated, this );
        if( this._timer ) {
          this._timer.stop();
        }
      }
    },

    _historyNavigated : function( event ) {
      var state = event.getData();
      var server = rwt.remote.Connection.getInstance();
      server.getRemoteObject( this ).notify( "Navigation", {
        "state" : state
      } );
    }

  },

  destruct : function()
  {
    this._timer.stop();
    this._disposeObjects("_timer");
    this._disposeFields("_iframe", "_titles");
  }
});

/*******************************************************************************
 * Copyright (c) 2012, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.remote.HandlerRegistry.add( "rwt.client.BrowserNavigation", {

  factory : function() {
    return rwt.client.BrowserNavigation.getInstance();
  },

  service : true,

  listeners : [
    "Navigation"
  ],

  methods : [
    "addToHistory"
  ],

  methodHandler : {
    "addToHistory" : function( object, value ) {
      object.addToHistory( value.state, value.title );
    }
  }

} );

/*******************************************************************************
 * Copyright (c) 2004, 2014 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

/**
 * This manager (singleton) manage all drag and drop handling of a rwt.qx.Init instance.
 */
rwt.qx.Class.define( "rwt.event.DragAndDropHandler", {

  extend : rwt.util.ObjectManager,

  statics : {

    getInstance : function() {
      return rwt.runtime.Singletons.get( rwt.event.DragAndDropHandler );
    }

  },

  /*
  *****************************************************************************
     CONSTRUCTOR
  *****************************************************************************
  */

  construct : function()
  {
    this.base(arguments);

    this.__data = {};
    this.__actions = {};
    this.__cursors = {};

    var vCursor, vAction;
    var vActions = [ "move", "copy", "alias", "nodrop" ];

    for (var i=0, l=vActions.length; i<l; i++)
    {
      vAction = vActions[i];
      vCursor = this.__cursors[vAction] = new rwt.widgets.base.Image();
      vCursor.setAppearance("cursor-dnd-" + vAction);
      vCursor.setZIndex(1e8);
    }
  },




  /*
  *****************************************************************************
     PROPERTIES
  *****************************************************************************
  */

  properties :
  {
    sourceWidget :
    {
      check : "rwt.widgets.base.Widget",
      nullable : true
    },

    destinationWidget :
    {
      check : "rwt.widgets.base.Widget",
      nullable : true,
      apply : "_applyDestinationWidget"
    },

    currentAction :
    {
      check : "String",
      nullable : true,
      event : "changeCurrentAction"
    },


    /**
     * The default delta x of the cursor feedback.
     *
     * @see #setCursorPosition
     */
    defaultCursorDeltaX :
    {
      check : "Integer",
      init : 5
    },


    /**
     * The default delta y of the cursor feedback.
     *
     * @see #setCursorPosition
     */
    defaultCursorDeltaY :
    {
      check : "Integer",
      init : 15
    }
  },




  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {
    __lastDestinationEvent : null,




    /*
    ---------------------------------------------------------------------------
      COMMON MODIFIER
    ---------------------------------------------------------------------------
    */

    /**
     * TODOC
     *
     * @type member
     * @param value {var} Current value
     * @param old {var} Previous value
     */
    _applyDestinationWidget : function(value)
    {
      if (value)
      {
        value.dispatchEvent(new rwt.event.DragEvent("dragdrop", this.__lastDestinationEvent, value, this.getSourceWidget()));
        this.__lastDestinationEvent = null;
      }
    },




    /*
    ---------------------------------------------------------------------------
      DATA HANDLING
    ---------------------------------------------------------------------------
    */

    /**
     * Add data of mimetype.
     *
     * #param vMimeType[String]: A valid mimetype
     * #param vData[Any]: Any value for the mimetype
     *
     * @type member
     * @param vMimeType {var} TODOC
     * @param vData {var} TODOC
     * @return {void}
     */
    addData : function(vMimeType, vData) {
      this.__data[vMimeType] = vData;
    },


    /**
     * TODOC
     *
     * @type member
     * @param vMimeType {var} TODOC
     * @return {var} TODOC
     */
    getData : function(vMimeType) {
      return this.__data[vMimeType];
    },


    /**
     * TODOC
     *
     * @type member
     * @return {void}
     */
    clearData : function() {
      this.__data = {};
    },




    /*
    ---------------------------------------------------------------------------
      MIME TYPE HANDLING
    ---------------------------------------------------------------------------
    */

    /**
     * TODOC
     *
     * @type member
     * @return {var} TODOC
     */
    getDropDataTypes : function()
    {
      var vDestination = this.getDestinationWidget();
      var vDropTypes = [];

      // If there is not any destination, simple return
      if (!vDestination) {
        return vDropTypes;
      }

      // Search for matching mimetypes
      var vDropDataTypes = vDestination.getDropDataTypes();

      for (var i=0, l=vDropDataTypes.length; i<l; i++)
      {
        if (vDropDataTypes[i] in this.__data) {
          vDropTypes.push(vDropDataTypes[i]);
        }
      }

      return vDropTypes;
    },

    /**
     * @signature function(e)
     */
    getDropTarget : rwt.util.Variant.select("qx.client",
    {
      // This hack is no longer needed for Firefox 2.0
      // We should verify, which Firefox version needed this hack.
      /*
      "gecko" : function(e)
      {
        var vCurrent = e.getTarget();

        // work around gecko bug (all other browsers are correct)
        // clicking on a free space and drag prohibit the get of
        // a valid event target. The target is always the element
        // which was the one with the mousedown event before.
        if (vCurrent == this.__dragCache.sourceWidget) {
          vCurrent = rwt.event.EventHandlerUtil.getTargetObject(rwt.html.ElementFromPoint.getElementFromPoint(e.getPageX(), e.getPageY()));
        } else {
          vCurrent = rwt.event.EventHandlerUtil.getTargetObject(null, vCurrent);
        }

        while (vCurrent != null)
        {
          if (!vCurrent.supportsDrop(this.__dragCache)) {
            return null;
          }

          if (this.supportsDrop(vCurrent)) {
            return vCurrent;
          }

          vCurrent = vCurrent.getParent();
        }

        return null;
      },
      */

      "default" : function(e)
      {
        var vCurrent = e.getTarget();

        while (vCurrent != null)
        {
          if (!vCurrent.supportsDrop(this.__dragCache)) {
            return null;
          }

          if (this.supportsDrop(vCurrent)) {
            return vCurrent;
          }

          vCurrent = vCurrent.getParent();
        }

        return null;
      }
    }),





    /*
    ---------------------------------------------------------------------------
      START DRAG
    ---------------------------------------------------------------------------
    */

    /**
     * This needed be called from any "dragstart" event to really start drag session.
     *
     * @type member
     * @return {void}
     * @throws TODOC
     */
    startDrag : function()
    {
      if (!this.__dragCache) {
        throw new Error("Invalid usage of startDrag. Missing dragInfo!");
      }

      // Update status flag
      this.__dragCache.dragHandlerActive = true;

      // Internal storage of source widget
      this.setSourceWidget(this.__dragCache.sourceWidget);

      // Add feedback widget
      if (this.__feedbackWidget)
      {
        this.__feedbackWidget.setVisibility(false);

        var doc = rwt.widgets.base.ClientDocument.getInstance();
        doc.add(this.__feedbackWidget);
        this.__feedbackWidget.setZIndex(1e8);
      }
    },




    /*
    ---------------------------------------------------------------------------
      FIRE IMPLEMENTATION FOR USER EVENTS
    ---------------------------------------------------------------------------
    */

    /**
     * TODOC
     *
     * @type member
     * @param fromWidget {var} TODOC
     * @param toWidget {var} TODOC
     * @param e {Event} TODOC
     * @return {void}
     */
    _fireUserEvents : function(fromWidget, toWidget, e)
    {
      if (fromWidget && fromWidget != toWidget && fromWidget.hasEventListeners("dragout")) {
        fromWidget.dispatchEvent(new rwt.event.DragEvent("dragout", e, fromWidget, toWidget), true);
      }

      if (toWidget)
      {
        if (fromWidget != toWidget && toWidget.hasEventListeners("dragover")) {
          toWidget.dispatchEvent(new rwt.event.DragEvent("dragover", e, toWidget, fromWidget), true);
        }

        if (toWidget.hasEventListeners("dragmove")) {
          toWidget.dispatchEvent(new rwt.event.DragEvent("dragmove", e, toWidget, null), true);
        }
      }
    },




    /*
    ---------------------------------------------------------------------------
      HANDLER FOR MOUSE EVENTS
    ---------------------------------------------------------------------------
    */

    /**
     * This wraps the mouse events to custom handlers.
     *
     * @type member
     * @param e {Event} TODOC
     * @return {var} TODOC
     */
    handleMouseEvent : function(e)
    {
      switch(e.getType())
      {
        case "mousedown":
          return this._handleMouseDown(e);

        case "mouseup":
          return this._handleMouseUp(e);

        case "mousemove":
          return this._handleMouseMove(e);
      }
    },


    /**
     * This starts the core drag and drop session.
     *
     * To really get drag and drop working you need to define
     * a function which you attach to "dragstart"-event, which
     * invokes at least this.startDrag()
     *
     * @type member
     * @param e {Event} TODOC
     * @return {void}
     */
    _handleMouseDown : function(e)
    {
      if (e.getDefaultPrevented() || !e.isLeftButtonPressed()) {
        return;
      }

      if(this.__dragCache == null)
      {
        // Store initial dragCache
        this.__dragCache =
        {
          startScreenX      : e.getScreenX(),
          startScreenY      : e.getScreenY(),
          pageX             : e.getPageX(),
          pageY             : e.getPageY(),
          sourceWidget      : e.getTarget(),
          sourceElement     : e.getDomTarget(),
          sourceTopLevel    : e.getTarget().getTopLevelWidget(),
          dragHandlerActive : false,
          hasFiredDragStart : false
        };
      }
    },


    /**
     * Handler for mouse move events
     *
     * @type member
     * @param e {Event} TODOC
     * @return {void}
     */
    _handleMouseMove : function(e)
    {
      // Return if dragCache was not filled before
      if (!this.__dragCache) {
        return;
      }

      /*
        Default handling if drag handler is activated
      */

      if (this.__dragCache.dragHandlerActive)
      {
        // Update page coordinates
        this.__dragCache.pageX = e.getPageX();
        this.__dragCache.pageY = e.getPageY();

        // Get current target
        var currentDropTarget = this.getDropTarget(e);

        // Update action
        this.setCurrentAction(currentDropTarget ? this._evalNewAction(e.isShiftPressed(), e.isCtrlPressed(), e.isAltPressed()) : null);

        // Fire user events
        this._fireUserEvents(this.__dragCache.currentDropWidget, currentDropTarget, e);

        // Store current widget
        this.__dragCache.currentDropWidget = currentDropTarget;

        // Update cursor icon
        this._renderCursor();

        // Update user feedback
        this._renderFeedbackWidget();
      }

      /*
        Initial activation and fire of dragstart
      */

      else if (!this.__dragCache.hasFiredDragStart)
      {
        if (Math.abs(e.getScreenX() - this.__dragCache.startScreenX) > 5 || Math.abs(e.getScreenY() - this.__dragCache.startScreenY) > 5)
        {
          // Fire dragstart event to finally allow the above if to handle next events
          this.__dragCache.sourceWidget.dispatchEvent(new rwt.event.DragEvent("dragstart", e, this.__dragCache.sourceWidget), true);

          // Update status flag
          this.__dragCache.hasFiredDragStart = true;

          // Look if handler become active
          if (this.__dragCache.dragHandlerActive)
          {
            // Fire first user events
            var currentDropWidget = this.getDropTarget( e );
            this._fireUserEvents( null, currentDropWidget, e);

            // Update status flags
            this.__dragCache.currentDropWidget = currentDropWidget;

            // Activate capture for clientDocument
            rwt.widgets.base.ClientDocument.getInstance().setCapture(true);
          }
        }
      }
    },


    /**
     * Handle mouse up event. Normally this finalize the drag and drop event.
     *
     * @type member
     * @param e {Event} TODOC
     * @return {void}
     */
    _handleMouseUp : function(e)
    {
      // Return if dragCache was not filled before
      if (!this.__dragCache) {
        return;
      }

      if (this.__dragCache.dragHandlerActive) {
        this._endDrag(this.getDropTarget(e), e);
      }
      else
      {
        // Clear drag cache
        this.__dragCache = null;
      }
    },




    /*
    ---------------------------------------------------------------------------
      HANDLER FOR KEY EVENTS
    ---------------------------------------------------------------------------
    */

    /**
     * This wraps the key events to custom handlers.
     *
     * @type member
     * @param e {Event} TODOC
     * @return {void}
     */
    handleKeyEvent : function(e)
    {
      if (!this.__dragCache) {
        return;
      }

      switch(e.getType())
      {
        case "keydown":
          this._handleKeyDown(e);
          return;

        case "keyup":
          this._handleKeyUp(e);
          return;
      }
    },


    /**
     * TODOC
     *
     * @type member
     * @param e {Event} TODOC
     * @return {void}
     */
    _handleKeyDown : function(e)
    {
      // Stop Drag on Escape
      if (e.getKeyIdentifier() == "Escape") {
        this.cancelDrag(e);
      }

      // Update cursor and action on press of modifier keys
      else if (this.getCurrentAction() != null)
      {
        // TODO this doesn't work in WebKit because WebKit doesn't fire keyevents for modifier keys
        switch(e.getKeyIdentifier())
        {
          case "Shift":
          case "Control":
          case "Alt":
            this.setAction(this._evalNewAction(e.isShiftPressed(), e.isCtrlPressed(), e.isAltPressed()));
            this._renderCursor();

            e.preventDefault();
        }
      }
    },


    /**
     * TODOC
     *
     * @type member
     * @param e {Event} TODOC
     * @return {void}
     */
    _handleKeyUp : function(e)
    {
      // TODO this doesn't work in WebKit because WebKit doesn't fire keyevents for modifier keys
      var bShiftPressed = e.getKeyIdentifier() == "Shift";
      var bCtrlPressed = e.getKeyIdentifier() == "Control";
      var bAltPressed = e.getKeyIdentifier() == "Alt";

      if (bShiftPressed || bCtrlPressed || bAltPressed)
      {
        if (this.getCurrentAction() != null)
        {
          this.setAction(this._evalNewAction(!bShiftPressed && e.isShiftPressed(), !bCtrlPressed && e.isCtrlPressed(), !bAltPressed && e.isAltPressed()));
          this._renderCursor();

          e.preventDefault();
        }
      }
    },




    /*
    ---------------------------------------------------------------------------
      IMPLEMENTATION OF DRAG&DROP SESSION FINALISATION
    ---------------------------------------------------------------------------
    */

    /**
     * Cancel current drag and drop session
     *
     * @type member
     * @param e {Event} TODOC
     * @return {void}
     */
    cancelDrag : function(e)
    {
      // Return if dragCache was not filled before
      if (!this.__dragCache) {
        return;
      }

      if (this.__dragCache.dragHandlerActive) {
        this._endDrag(null, e);
      }
      else
      {
        // Clear drag cache
        this.__dragCache = null;
      }
    },


    /**
     * TODOC
     *
     * @type member
     * @return {void}
     */
    globalCancelDrag : function()
    {
      if (this.__dragCache && this.__dragCache.dragHandlerActive) {
        this._endDragCore();
      }
    },


    /**
     * This will be called to the end of each drag and drop session
     *
     * @type member
     * @param currentDestinationWidget {var} TODOC
     * @param e {Event} TODOC
     * @return {void}
     */
    _endDrag : function(currentDestinationWidget, e)
    {
      // Use given destination widget
      if (currentDestinationWidget)
      {
        this.__lastDestinationEvent = e;
        this.setDestinationWidget(currentDestinationWidget);
      }

      // Dispatch dragend event
      this.getSourceWidget().dispatchEvent(new rwt.event.DragEvent("dragend", e, this.getSourceWidget(), currentDestinationWidget), true);

      // Fire dragout event
      // RAP : We create this event on the server-side:
      //this._fireUserEvents(this.__dragCache && this.__dragCache.currentDropWidget, null, e);

      // Call helper
      this._endDragCore();
    },


    /**
     * TODOC
     *
     * @type member
     * @return {void}
     */
    _endDragCore : function()
    {
      // Cleanup feedback widget
      if (this.__feedbackWidget)
      {
        var doc = rwt.widgets.base.ClientDocument.getInstance();
        doc.remove(this.__feedbackWidget);

        if (this.__feedbackAutoDispose) {
          this.__feedbackWidget.destroy();
        }

        this.__feedbackWidget = null;
      }

      // Remove cursor
      var oldCursor = this.__cursor;

      if (oldCursor)
      {
        oldCursor._style.display = "none";
        this.__cursor = null;
      }

      this._cursorDeltaX = null;
      this._cursorDeltaY = null;

      // Reset drag cache for next drag and drop session
      if (this.__dragCache)
      {
        this.__dragCache.currentDropWidget = null;
        this.__dragCache = null;
      }

      // Deactivate capture for clientDocument
      rwt.widgets.base.ClientDocument.getInstance().setCapture(false);

      // Cleanup data and actions
      this.clearData();
      this.clearActions();

      // Cleanup widgets
      this.setSourceWidget(null);
      this.setDestinationWidget(null);
    },




    /*
    ---------------------------------------------------------------------------
      IMPLEMENTATION OF CURSOR UPDATES
    ---------------------------------------------------------------------------
    */

    /**
     * Sets the position of the cursor feedback (the icon showing whether dropping
     * is allowed at the current position and which action a drop will do).
     *
     * @type member
     * @param deltaX {int} The number of pixels the top-left corner of the
     *          cursor feedback should be away from the mouse cursor in x direction.
     * @param deltaY {int} The number of pixels the top-left corner of the
     *          cursor feedback should be away from the mouse cursor in y direction.
     * @return {void}
     */
    setCursorPosition : function(deltaX, deltaY)
    {
      this._cursorDeltaX = deltaX;
      this._cursorDeltaY = deltaY;
    },


    /**
     * Select and setup the current used cursor
     *
     * @type member
     * @return {void}
     */
    _renderCursor : function()
    {
      var vNewCursor;
      var vOldCursor = this.__cursor;

      switch(this.getCurrentAction())
      {
        case "move":
          vNewCursor = this.__cursors.move;
          break;

        case "copy":
          vNewCursor = this.__cursors.copy;
          break;

        case "alias":
          vNewCursor = this.__cursors.alias;
          break;

        default:
          vNewCursor = this.__cursors.nodrop;
      }

      // Hide old cursor
      if (vNewCursor != vOldCursor && vOldCursor != null) {
        vOldCursor._style.display = "none";
      }

      // Ensure that the cursor is created
      if (!vNewCursor._initialLayoutDone)
      {
        rwt.widgets.base.ClientDocument.getInstance().add(vNewCursor);
        rwt.widgets.base.Widget.flushGlobalQueues();
      }

      // Apply position with runtime style (fastest qooxdoo method)
      vNewCursor._renderRuntimeLeft(this.__dragCache.pageX + ((this._cursorDeltaX != null) ? this._cursorDeltaX : this.getDefaultCursorDeltaX()));
      vNewCursor._renderRuntimeTop(this.__dragCache.pageY + ((this._cursorDeltaY != null) ? this._cursorDeltaY : this.getDefaultCursorDeltaY()));

      // Finally show new cursor
      if (vNewCursor != vOldCursor) {
        vNewCursor._style.display = "";
      }

      // Store new cursor
      this.__cursor = vNewCursor;
    },




    /*
    ---------------------------------------------------------------------------
      IMPLEMENTATION OF DROP TARGET VALIDATION
    ---------------------------------------------------------------------------
    */

    /**
     * TODOC
     *
     * @type member
     * @param vWidget {var} TODOC
     */
    supportsDrop : function(vWidget)
    {
      var vTypes = vWidget.getDropDataTypes();

      if (!vTypes) {
        return false;
      }

      for (var i=0; i<vTypes.length; i++)
      {
        if (vTypes[i] in this.__data) {
          return true;
        }
      }

      return false;
    },




    /*
    ---------------------------------------------------------------------------
      ACTION HANDLING
    ---------------------------------------------------------------------------
    */

    /**
     * TODOC
     *
     * @type member
     * @param vAction {var} TODOC
     * @param vForce {var} TODOC
     * @return {void}
     */
    addAction : function(vAction, vForce)
    {
      this.__actions[vAction] = true;

      // Defaults to first added action
      if (vForce || this.getCurrentAction() == null) {
        this.setCurrentAction(vAction);
      }
    },


    /**
     * TODOC
     *
     * @type member
     * @return {void}
     */
    clearActions : function()
    {
      this.__actions = {};
      this.setCurrentAction(null);
    },


    /**
     * TODOC
     *
     * @type member
     * @param vAction {var} TODOC
     * @return {void}
     */
    removeAction : function(vAction)
    {
      delete this.__actions[vAction];

      // Reset current action on remove
      if (this.getCurrentAction() == vAction) {
        this.setCurrentAction(null);
      }
    },


    /**
     * TODOC
     *
     * @type member
     * @param vAction {var} TODOC
     * @return {void}
     */
    setAction : function(vAction)
    {
      if (vAction != null && !(vAction in this.__actions)) {
        this.addAction(vAction, true);
      } else {
        this.setCurrentAction(vAction);
      }
    },


    /**
     * TODOC
     *
     * @type member
     * @param vKeyShift {var} TODOC
     * @param vKeyCtrl {var} TODOC
     * @param vKeyAlt {var} TODOC
     * @return {var | null} TODOC
     */
    _evalNewAction : function(vKeyShift, vKeyCtrl, vKeyAlt)
    {
      if (vKeyShift && vKeyCtrl && "alias" in this.__actions) {
        return "alias";
      } else if (vKeyShift && vKeyAlt && "copy" in this.__actions) {
        return "copy";
      } else if (vKeyShift && "move" in this.__actions) {
        return "move";
      } else if (vKeyAlt && "alias" in this.__actions) {
        return "alias";
      } else if (vKeyCtrl && "copy" in this.__actions) {
        return "copy";
      }
      else
      {
        // Return the first action found
        for (var vAction in this.__actions) {
          return vAction;
        }
      }

      return null;
    },




    /*
    ---------------------------------------------------------------------------
      USER FEEDBACK SUPPORT
    ---------------------------------------------------------------------------
    */

    /**
     * Sets the widget to show as feedback for the user. This widget should
     * represent the object(s) the user is dragging.
     *
     * @type member
     * @param widget {rwt.widgets.base.Widget} the feedback widget.
     * @param deltaX {int ? 10} the number of pixels the top-left corner of the widget
     *          should be away from the mouse cursor in x direction.
     * @param deltaY {int ? 10} the number of pixels the top-left corner of the widget
     *          should be away from the mouse cursor in y direction.
     * @param autoDisposeWidget {Boolean} whether the widget should be disposed when
     *          dragging is finished or cancelled.
     * @return {void}
     */
    setFeedbackWidget : function(widget, deltaX, deltaY, autoDisposeWidget)
    {
      this.__feedbackWidget = widget;
      this.__feedbackDeltaX = (deltaX != null) ? deltaX : 10;
      this.__feedbackDeltaY = (deltaY != null) ? deltaY : 10;
      this.__feedbackAutoDispose = autoDisposeWidget ? true : false;
    },


    /**
     * Renders the user feedback widget at the correct location.
     *
     * @type member
     * @return {void}
     */
    _renderFeedbackWidget : function()
    {
      if (this.__feedbackWidget)
      {
        this.__feedbackWidget.setVisibility(true);

        // Apply position with runtime style (fastest qooxdoo method)
        this.__feedbackWidget._renderRuntimeLeft(this.__dragCache.pageX + this.__feedbackDeltaX);
        this.__feedbackWidget._renderRuntimeTop(this.__dragCache.pageY + this.__feedbackDeltaY);
      }
    }
  },




  /*
  *****************************************************************************
     DESTRUCTOR
  *****************************************************************************
  */

  destruct : function()
  {
    this._disposeObjectDeep("__cursors", 1);
    this._disposeObjects("__feedbackWidget");
    this._disposeFields("__dragCache", "__data", "__actions", "__lastDestinationEvent");
  }
});

/*******************************************************************************
 * Copyright (c) 2004, 2013 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

/** The event object for drag and drop sessions */
rwt.qx.Class.define("rwt.event.DragEvent",
{
  extend : rwt.event.MouseEvent,




  /*
  *****************************************************************************
     CONSTRUCTOR
  *****************************************************************************
  */

  construct : function(vType, vMouseEvent, vTarget, vRelatedTarget)
  {
    this._mouseEvent = vMouseEvent;

    var vOriginalTarget = null;

    switch(vType)
    {
      case "dragstart":
      case "dragover":
        vOriginalTarget = vMouseEvent.getOriginalTarget();
    }

    this.base(arguments, vType, vMouseEvent.getDomEvent(), vTarget.getElement(), vTarget, vOriginalTarget, vRelatedTarget);
  },




  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {
    /*
    ---------------------------------------------------------------------------
      UTILITIY
    ---------------------------------------------------------------------------
    */

    /**
     * TODOC
     *
     * @type member
     * @return {var} TODOC
     */
    getMouseEvent : function() {
      return this._mouseEvent;
    },




    /*
    ---------------------------------------------------------------------------
      APPLICATION CONNECTION
    ---------------------------------------------------------------------------
    */

    /**
     * TODOC
     *
     * @type member
     * @return {void}
     * @throws TODOC
     */
    startDrag : function()
    {
      if (this.getType() != "dragstart") {
        throw new Error("rwt.event.DragEvent startDrag can only be called during the dragstart event: " + this.getType());
      }

      this.stopPropagation();
      rwt.event.DragAndDropHandler.getInstance().startDrag();
    },




    /*
    ---------------------------------------------------------------------------
      DATA SUPPORT
    ---------------------------------------------------------------------------
    */

    /**
     * TODOC
     *
     * @type member
     * @param sType {String} TODOC
     * @param oData {Object} TODOC
     * @return {void}
     */
    addData : function(sType, oData) {
      rwt.event.DragAndDropHandler.getInstance().addData(sType, oData);
    },


    /**
     * TODOC
     *
     * @type member
     * @param sType {String} TODOC
     * @return {var} TODOC
     */
    getData : function(sType) {
      return rwt.event.DragAndDropHandler.getInstance().getData(sType);
    },


    /**
     * TODOC
     *
     * @type member
     * @return {void}
     */
    clearData : function() {
      rwt.event.DragAndDropHandler.getInstance().clearData();
    },


    /**
     * TODOC
     *
     * @type member
     * @return {var} TODOC
     */
    getDropDataTypes : function() {
      return rwt.event.DragAndDropHandler.getInstance().getDropDataTypes();
    },




    /*
    ---------------------------------------------------------------------------
      ACTION SUPPORT
    ---------------------------------------------------------------------------
    */

    /**
     * TODOC
     *
     * @type member
     * @param sAction {String} TODOC
     * @return {void}
     */
    addAction : function(sAction) {
      rwt.event.DragAndDropHandler.getInstance().addAction(sAction);
    },


    /**
     * TODOC
     *
     * @type member
     * @param sAction {String} TODOC
     * @return {void}
     */
    removeAction : function(sAction) {
      rwt.event.DragAndDropHandler.getInstance().removeAction(sAction);
    },


    /**
     * TODOC
     *
     * @type member
     * @return {var} TODOC
     */
    getAction : function() {
      return rwt.event.DragAndDropHandler.getInstance().getCurrentAction();
    },


    /**
     * TODOC
     *
     * @type member
     * @return {void}
     */
    clearActions : function() {
      rwt.event.DragAndDropHandler.getInstance().clearActions();
    },




    /*
    ---------------------------------------------------------------------------
      USER FEEDBACK SUPPORT
    ---------------------------------------------------------------------------
    */

    /**
     * Sets the widget to show as feedback for the user. This widget should
     * represent the object(s) the user is dragging.
     *
     * @type member
     * @param widget {rwt.widgets.base.Widget} the feedback widget.
     * @param deltaX {int ? 10} the number of pixels the top-left corner of the widget
     *          should be away from the mouse cursor in x direction.
     * @param deltaY {int ? 10} the number of pixels the top-left corner of the widget
     *          should be away from the mouse cursor in y direction.
     * @param autoDisposeWidget {Boolean} whether the widget should be disposed when
     *          dragging is finished or cancelled.
     * @return {void}
     */
    setFeedbackWidget : function(widget, deltaX, deltaY, autoDisposeWidget) {
      rwt.event.DragAndDropHandler.getInstance().setFeedbackWidget(widget, deltaX, deltaY, autoDisposeWidget);
    },




    /*
    ---------------------------------------------------------------------------
      CURSPOR POSITIONING SUPPORT
    ---------------------------------------------------------------------------
    */

    /**
     * Sets the position of the cursor feedback (the icon showing whether dropping
     * is allowed at the current position and which action a drop will do).
     *
     * @type member
     * @param deltaX {int} The number of pixels the top-left corner of the
     *          cursor feedback should be away from the mouse cursor in x direction.
     * @param deltaY {int} The number of pixels the top-left corner of the
     *          cursor feedback should be away from the mouse cursor in y direction.
     * @return {void}
     */
    setCursorPosition : function(deltaX, deltaY) {
      rwt.event.DragAndDropHandler.getInstance().setCursorPosition(deltaX, deltaY);
    }
  },




  /*
  *****************************************************************************
     DESTRUCTOR
  *****************************************************************************
  */

  destruct : function() {
    this._disposeFields("_mouseEvent");
  }
});

/*******************************************************************************
 * Copyright (c) 2004, 2014 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

/**
 * Container widget for internal frames (iframes).
 *
 * An iframe can display any HTML page inside the widget.
 *
 * @appearance iframe
 */
rwt.qx.Class.define("rwt.widgets.base.Iframe",
{
  extend : rwt.widgets.base.Terminator,




  /*
  *****************************************************************************
     CONSTRUCTOR
  *****************************************************************************
  */

  /**
   * @param vSource {String?null} URL of the HTML page displayed in the iframe.
   */
  construct : function(vSource)
  {
    this.base(arguments);

    this.initSelectable();
    this.initTabIndex();
    this.initScrolling();

    if (vSource != null) {
      this.setSource(vSource);
    }
  },


  /*
  *****************************************************************************
     EVENTS
  *****************************************************************************
  */

  events:
  {
    /**
     * The "load" event is fired after the iframe content has successfully been loaded.
     */
    "load" : "rwt.event.Event"
  },





  /*
  *****************************************************************************
     STATICS
  *****************************************************************************
  */

  statics :
  {
    load : function( obj ) {
      try {
        if( !obj ) {
          throw new Error("Could not find iframe which was loaded [A]!");
        }
        if( obj.currentTarget ) {
          obj = obj.currentTarget;
        }
        // Find iframe instance and call onload
        if( obj._QxIframe ) {
          obj._QxIframe._onload();
        } else if( obj.parentNode ) { // Check for parentNode necessary, see Bug 346064
          throw new Error("Could not find iframe which was loaded [B]!");
        }
      } catch( ex ) {
        rwt.runtime.ErrorHandler.processJavaScriptError( ex );
      }
    },

    _useAlternateLayouting : function() {
      return rwt.client.Client.isMobileSafari();
    }

  },




  /*
  *****************************************************************************
     PROPERTIES
  *****************************************************************************
  */

  properties :
  {
    tabIndex :
    {
      refine : true,
      init : 0
    },

    selectable :
    {
      refine : true,
      init : false
    },

    appearance :
    {
      refine : true,
      init : "iframe"
    },

    /**
     * Source URL of the iframe.
     */
    source :
    {
      check : "String",
      apply : "_applySource",
      event : "changeSource",
      nullable : true
    },

    /**
     * Name of the iframe.
     */
    frameName :
    {
      check : "String",
      init : "",
      apply : "_applyFrameName"
    },


    /** Whether the iframe's content pane should have scroll bars */
    scrolling :
    {
      check : ["yes", "no", "auto"],
      init  : "auto",
      apply : "_applyScrolling"
    }
  },




  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {
    /**
     * Get the DOM element of the iframe.
     *
     * @type member
     * @return {Element} The DOM element of the iframe.
     */
    getIframeNode : function() {
      return this._iframeNode;
    },


    /**
     * Change the DOM element of the iframe.
     *
     * @type member
     * @param vIframeNode {Element} The new DOM element of the iframe.
     */
    setIframeNode : function(vIframeNode) {
      /*jshint boss: true */
      return this._iframeNode = vIframeNode;
    },


    /**
     * TODOC
     *
     * @type member
     * @return {var} TODOC
     */
    getBlockerNode : function() {
      return this._blockerNode;
    },


    /**
     * TODOC
     *
     * @type member
     * @param vBlockerNode {var} TODOC
     * @return {var} TODOC
     */
    setBlockerNode : function(vBlockerNode) {
      /*jshint boss: true */
      return this._blockerNode = vBlockerNode;
    },




    /*
    ---------------------------------------------------------------------------
      WINDOW & DOCUMENT ACCESS
    ---------------------------------------------------------------------------
    */

    /**
     * Get the DOM window object of the iframe.
     *
     * @type member
     * @return {DOMWindow} The DOM window object of the iframe.
     */
    getContentWindow : function()
    {
      if (this.isCreated()) {
        return rwt.html.Iframes.getWindow(this.getIframeNode());
      } else {
        return null;
      }
    },


    /**
     * Get the DOM document object of the iframe.
     *
     * @type member
     * @return {DOMDocument} The DOM document object of the iframe.
     */
    getContentDocument : function()
    {
      if (this.isCreated()) {
        return rwt.html.Iframes.getDocument(this.getIframeNode());
      } else {
        return null;
      }
    },

    /**
     * @signature function()
     */
    isLoaded : function() {
      return this._isLoaded;
    },

    /*
    ---------------------------------------------------------------------------
      METHODS
    ---------------------------------------------------------------------------
    */

    /**
     * Reload the contents of the iframe.
     *
     * @type member
     */
    reload : function()
    {
      if (this.isCreated() && this.getContentWindow())
      {
        this._isLoaded = false;

        var currentSource = this.queryCurrentUrl() || this.getSource();

        try
        {
          /*
          Some gecko users might have an exception here:
            Exception... "Component returned failure code: 0x805e000a
            [nsIDOMLocation.replace]"  nsresult: "0x805e000a (<unknown>)"
          */
          try
          {
            this.getContentWindow().location.replace(currentSource);
          }
          catch(ex)
          {
            this.getIframeNode().src = currentSource;
          }
        }
        catch(ex) {
          throw new Error( "Iframe source could not be set! This may be related to AdBlock Plus Firefox Extension." );
        }
      }
    },


    /**
     * Returns the current (served) URL inside the iframe
     *
     * @return {String} Returns the location href or null (if a query is not possible/allowed)
     */
    queryCurrentUrl : function()
    {
      var doc = this.getContentDocument();

      try
      {
        if (doc && doc.location) {
          return doc.location.href;
        }
      }
      catch(ex) {}

      return null;
    },


    /**
     * Cover the iframe with a transparent blocker div element. This prevents
     * mouse or key events to be handled by the iframe. To release the blocker
     * use {@link #release}.
     *
     * @type member
     */
    block : function()
    {
      if (this._blockerNode &&
         (!this._blockerNode.parentElement ||
         (rwt.client.Client.isGecko() && !this._blockerNode.parentNode))) {
        this._getBlockerParent().appendChild(this._blockerNode);
      }
    },


    /**
     * Release the blocker set by {@link #block}.
     *
     * @type member
     */
    release : function()
    {
      if (this._blockerNode &&
         (this._blockerNode.parentElement ||
         (rwt.client.Client.isGecko() && this._blockerNode.parentNode))) {
        this._getBlockerParent().removeChild(this._blockerNode);
      }
    },


    /**
     * Get the parent element of the blocker node. Respects extended border
     * elements.
     *
     * @return {Element} the blocker's parent element
     */
    _getBlockerParent : function()
    {
      var el = this.getElement();
      if (this._innerStyle) {
        return el.firstChild;
      } else {
        return el;
      }
    },



    /*
    ---------------------------------------------------------------------------
      ELEMENT HELPER
    ---------------------------------------------------------------------------
    */

    /**
     * Creates an template iframe element and sets all required html and style properties.
     *
     * @type static
     * @param vFrameName {String} Name of the iframe.
     */
    _generateIframeElement : function()
    {
      var frameEl = this._createIframeNode( this.getFrameName() );

      frameEl._QxIframe = this;

      frameEl.frameBorder = "0";
      frameEl.frameSpacing = "0";

      frameEl.marginWidth = "0";
      frameEl.marginHeight = "0";

      if( !rwt.widgets.base.Iframe._useAlternateLayouting() ) {
        frameEl.width = "100%";
        frameEl.height = "100%";
      }

      frameEl.hspace = "0";
      frameEl.vspace = "0";

      frameEl.border = "0";
      frameEl.unselectable = "on";
      frameEl.allowTransparency = "true";

      frameEl.style.position = "absolute";
      frameEl.style.top = 0;
      frameEl.style.left = 0;

      return frameEl;
    },

    _createIframeNode : function( frameName ) {
      var frameEl = rwt.widgets.base.Iframe._element = document.createElement("iframe");
      frameEl.onload = rwt.widgets.base.Iframe.load;
      if (frameName) {
        frameEl.name = frameName;
      }
      return frameEl;
    },


    /**
     * TODOC
     *
     * @type static
     * @return {void}
     */
    _generateBlockerElement : function()
    {
      var blockerEl = rwt.widgets.base.Iframe._blocker = document.createElement("div");
      var blockerStyle = blockerEl.style;

      blockerStyle.position = "absolute";
      blockerStyle.top = 0;
      blockerStyle.left = 0;
      blockerStyle.width = "100%";
      blockerStyle.height = "100%";
      blockerStyle.zIndex = 1;
      // IE 9/10 needs a background image in order to capture mouse events
      // 441842: [Browser] Disabled state does not work in IE10
      // https://bugs.eclipse.org/bugs/show_bug.cgi?id=441842
      if( rwt.client.Client.isTrident() && rwt.client.Client.getVersion() < 11 ) {
        var blank = rwt.remote.Connection.RESOURCE_PATH + "static/image/blank.gif";
        blockerStyle.backgroundImage = "url(" + blank + ")";
      }

      return blockerEl;
    },






    /*
    ---------------------------------------------------------------------------
      APPLY ROUTINES
    ---------------------------------------------------------------------------
    */

    /**
     * TODOC
     *
     * @type member
     * @param value {var} Current value
     * @param old {var} Previous value
     */
    _applyElement : function(value, old)
    {
      var iframeNode = this.setIframeNode(this._generateIframeElement());
      this.setBlockerNode(this._generateBlockerElement());

      this._syncSource();
      this._syncScrolling();

      value.appendChild(iframeNode);

      this.base(arguments, value, old);
    },


    /**
     * TODOC
     *
     * @type member
     * @return {void}
     */
    _beforeAppear : function()
    {
      this.base(arguments);

      // register to iframe manager as active widget
      rwt.widgets.util.IframeManager.getInstance().add(this);
    },


    /**
     * TODOC
     *
     * @type member
     * @return {void}
     */
    _beforeDisappear : function()
    {
      this.base(arguments);

      // deregister from iframe manager
      rwt.widgets.util.IframeManager.getInstance().remove(this);
    },


    /**
     * TODOC
     *
     * @type member
     * @param value {var} Current value
     * @param old {var} Previous value
     */
    _applySource : function()
    {
      if (this.isCreated()) {
        this._syncSource();
      }
    },


    /**
     * TODOC
     *
     * @type member
     * @return {void}
     */
    _syncSource : function()
    {
      var currentSource = this.getSource();

      if (currentSource == null || currentSource === "") {
        currentSource = rwt.remote.Connection.RESOURCE_PATH + "static/html/blank.html";
      }

      this._isLoaded = false;

      try
      {
        // the guru says ...
        // it is better to use 'replace' than 'src'-attribute, since 'replace' does not interfer
        // with the history (which is taken care of by the history manager), but there
        // has to be a loaded document
        if (this.getContentWindow())
        {
          /*
          Some gecko users might have an exception here:
            Exception... "Component returned failure code: 0x805e000a
            [nsIDOMLocation.replace]"  nsresult: "0x805e000a (<unknown>)"
          */
          try
          {
            this.getContentWindow().location.replace(currentSource);
          }
          catch(ex)
          {
            this.getIframeNode().src = currentSource;
          }
        }
        else
        {
          this.getIframeNode().src = currentSource;
        }
      }
      catch(ex) {
        throw new Error( "Iframe source could not be set! This may be related to AdBlock Plus Firefox Extension." );
      }
    },


    // property apply
    _applyScrolling : function()
    {
      if (this.isCreated()) {
        this._syncScrolling();
      }
    },


    /**
     * Sync scrolling property to the iframe DOM node.
     *
     * @type member
     */
    _syncScrolling : function() {
      this.getIframeNode().setAttribute("scrolling", this.getScrolling());
    },


    _applyFrameName : function()
    {
      if (this.isCreated()) {
        throw new Error("Not allowed to set frame name after it has been created");
      }
    },




    /*
    ---------------------------------------------------------------------------
      EVENT HANDLER
    ---------------------------------------------------------------------------
    */

    /**
     * TODOC
     *
     * @type member
     * @return {void}
     */
    _onload : function()
    {
      if (!this._isLoaded)
      {
        this._isLoaded = true;
        this.createDispatchEvent("load");
      }
    },


    /*
    ---------------------------------------------------------------------------
      LOAD STATUS
    ---------------------------------------------------------------------------
    */

    _isLoaded : false
  },


  defer : function( statics, members ) {
    if( rwt.widgets.base.Iframe._useAlternateLayouting() ) {
      var originalRenderWidth = members._renderRuntimeWidth;
      var originalRenderHeight = members._renderRuntimeHeight;
      var originalResetWidth = members._resetRuntimeWidth;
      var originalResetHeight = members._resetRuntimeHeight;
      members._renderRuntimeWidth = function( value ) {
        originalRenderWidth.call( this, value );
        this._iframeNode.style.minWidth = value + "px";
        this._iframeNode.style.maxWidth = value + "px";
      };
      members._renderRuntimeHeight = function( value ) {
        originalRenderHeight.call( this, value );
        this._iframeNode.style.minHeight = value + "px";
        this._iframeNode.style.maxHeight = value + "px";
      };
      members._resetRuntimeWidth = function( value ) {
        originalResetWidth.call( this, value );
        this._iframeNode.style.minWidth = "";
        this._iframeNode.style.maxWidth = "";
      };
      members._resetRuntimeHeight = function( value ) {
        originalResetHeight.call( this, value );
        this._iframeNode.style.minHeight = "";
        this._iframeNode.style.maxHeight = "";
      };
    }
  },

  /*
  *****************************************************************************
     DESTRUCTOR
  *****************************************************************************
  */

  destruct : function()
  {
    if (this._iframeNode)
    {
      this._iframeNode._QxIframe = null;
      this._iframeNode.onload = null;
      this._iframeNode = null;
      this._getTargetNode().innerHTML = "";
    }
    this._disposeFields("__onload", "_blockerNode");
  }
});

/*******************************************************************************
 * Copyright (c) 2004, 2014 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

/**
 * Provides resizing behavior to any widget.
 */
rwt.qx.Mixin.define("rwt.widgets.util.MResizable",
{
  /*
  *****************************************************************************
     CONSTRUCTOR
  *****************************************************************************
  */

  construct : function()
  {
    this._frame = new rwt.widgets.base.Terminator();
    this._frame.setAppearance("resizer-frame");
    this.addEventListener("mousedown", this._onmousedown);
    this.addEventListener("mouseup", this._onmouseup);
    this.addEventListener("mousemove", this._onmousemove);
  },





  /*
  *****************************************************************************
     PROPERTIES
  *****************************************************************************
  */

  properties :
  {
    /** It is resizable in the left direction. */
    resizableWest :
    {
      check : "Boolean",
      init : true,
      apply : "_applyResizable"
    },


    /** It is resizable in the top direction. */
    resizableNorth :
    {
      check : "Boolean",
      init : true,
      apply : "_applyResizable"
    },


    /** It is resizable in the right direction. */
    resizableEast :
    {
      check : "Boolean",
      init : true,
      apply : "_applyResizable"
    },


    /** It is resizable in the bottom direction. */
    resizableSouth :
    {
      check : "Boolean",
      init : true,
      apply : "_applyResizable"
    },


    /** If the window is resizable */
    resizable :
    {
      group : [ "resizableNorth", "resizableEast", "resizableSouth", "resizableWest" ],
      mode  : "shorthand"
    },


    /** The resize method to use */
    resizeMethod :
    {
      init : "frame",
      check : [ "opaque", "lazyopaque", "frame", "translucent" ],
      event : "changeResizeMethod"
    }
  },






  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {
    /**
     * Adjust so that it returns a boolean instead of an array.
     *
     * @type member
     * @return {Boolean} TODOC
     */
    isResizable : function() {
      return this.getResizableWest() || this.getResizableEast() || this.getResizableNorth() || this.getResizableSouth();
    },


    /**
     * Adjust so that it returns a boolean instead of an array.
     * Wrapper around isResizable. Please use isResizable instead.
     *
     * @type member
     * @return {Boolean} TODOC
     */
    getResizable : function() {
      return this.isResizable();
    },



    _applyResizable : function() {
      // placeholder
    },


    /**
     * TODOC
     *
     * @type member
     * @param e {Event} TODOC
     * @return {void}
     */
    _onmousedown : function(e)
    {
      if (this._resizeNorth || this._resizeSouth || this._resizeWest || this._resizeEast)
      {
        // enable capturing
        this.setCapture(true);

        // activate global cursor
        this.getTopLevelWidget().setGlobalCursor(this.getCursor());

        // caching element
        var el = this.getElement();

        // measuring and caching of values for resize session
        var pa = this._getResizeParent();
        var pl = pa.getElement();

        // compute locations
        var paLoc = rwt.html.Location.get(pl, "scroll");
        var elLoc = rwt.html.Location.get(el);

        // handle frame and translucently
        switch(this.getResizeMethod())
        {
          case "translucent":
            this.setOpacity(0.5);
            break;

          case "frame":
            var f = this._frame;

            if (f.getParent() != pa)
            {
              f.setParent(pa);
              rwt.widgets.base.Widget.flushGlobalQueues();
            }

            f._renderRuntimeLeft(elLoc.left - paLoc.left);
            f._renderRuntimeTop(elLoc.top - paLoc.top);

            f._renderRuntimeWidth(el.offsetWidth);
            f._renderRuntimeHeight(el.offsetHeight);

            f.setZIndex(this.getZIndex() + 1);

            break;
        }

        // create resize session
        var s = this._resizeSession = {};
        var minRef = this._getMinSizeReference();

        if (this._resizeWest)
        {
          s.boxWidth = el.offsetWidth;
          s.boxRight = elLoc.right;
        }

        if (this._resizeWest || this._resizeEast)
        {
          s.boxLeft = elLoc.left;

          s.parentContentLeft = paLoc.left;
          s.parentContentRight = paLoc.right;

          s.minWidth = minRef.getMinWidthValue();
          s.maxWidth = minRef.getMaxWidthValue();
        }

        if (this._resizeNorth)
        {
          s.boxHeight = el.offsetHeight;
          s.boxBottom = elLoc.bottom;
        }

        if (this._resizeNorth || this._resizeSouth)
        {
          s.boxTop = elLoc.top;

          s.parentContentTop = paLoc.top;
          s.parentContentBottom = paLoc.bottom;

          s.minHeight = minRef.getMinHeightValue();
          s.maxHeight = minRef.getMaxHeightValue();
        }
      }
      else
      {
        // cleanup resize session
        delete this._resizeSession;
      }

      // stop event
      e.stopPropagation();
    },


    /**
     * TODOC
     *
     * @type member
     * @param e {Event} TODOC
     * @return {void}
     */
    _onmouseup : function(e)
    {
      var s = this._resizeSession;

      if (s)
      {
        // disable capturing
        this.setCapture(false);

        // deactivate global cursor
        this.getTopLevelWidget().setGlobalCursor(null);

        // sync sizes to frame
        if(    this.getResizeMethod() === "lazyopaque"
            || ( this.getResizeMethod() === "frame" && this._frame && this._frame.getParent() )
         ) {
          if (s.lastLeft != null) {
            this.setLeft(s.lastLeft);
          }

          if (s.lastTop != null) {
            this.setTop(s.lastTop);
          }

          if (s.lastWidth != null)
          {
            this._changeWidth(s.lastWidth);
          }

          if (s.lastHeight != null)
          {
            this._changeHeight(s.lastHeight);
          }

          if (this.getResizeMethod() == "frame") {
            this._frame.setParent(null);
          }
        } else if( this.getResizeMethod() === "translucent" ) {
          this.setOpacity(null);
        }
        delete this._resizeSession;
      }

      // stop event
      e.stopPropagation();
    },


    /**
     * TODOC
     *
     * @type member
     * @param p {var} TODOC
     * @param e {Event} TODOC
     * @return {var} TODOC
     */
    _near : function(p, e) {
      return e > (p - 5) && e < (p + 5);
    },


    /**
     * TODOC
     *
     * @type member
     * @param e {Event} TODOC
     * @return {void}
     */
    _onmousemove : function(e)
    {
      if (this._disableResize) {
        return;
      }

      var s = this._resizeSession;

      if (s)
      {
        if (this._resizeWest)
        {
          s.lastWidth = rwt.util.Numbers.limit(s.boxWidth + s.boxLeft - Math.max(e.getPageX(), s.parentContentLeft), s.minWidth, s.maxWidth);
          s.lastLeft = s.boxRight - s.lastWidth - s.parentContentLeft;
        }
        else if (this._resizeEast)
        {
          s.lastWidth = rwt.util.Numbers.limit(Math.min(e.getPageX(), s.parentContentRight) - s.boxLeft, s.minWidth, s.maxWidth);
        }

        if (this._resizeNorth)
        {
          s.lastHeight = rwt.util.Numbers.limit(s.boxHeight + s.boxTop - Math.max(e.getPageY(), s.parentContentTop), s.minHeight, s.maxHeight);
          s.lastTop = s.boxBottom - s.lastHeight - s.parentContentTop;
        }
        else if (this._resizeSouth)
        {
          s.lastHeight = rwt.util.Numbers.limit(Math.min(e.getPageY(), s.parentContentBottom) - s.boxTop, s.minHeight, s.maxHeight);
        }

        switch(this.getResizeMethod())
        {
          case "opaque":
          case "translucent":
            if (this._resizeWest || this._resizeEast)
            {
              this.setWidth(s.lastWidth);

              if (this._resizeWest) {
                this.setLeft(s.lastLeft);
              }
            }

            if (this._resizeNorth || this._resizeSouth)
            {
              this.setHeight(s.lastHeight);

              if (this._resizeNorth) {
                this.setTop(s.lastTop);
              }
            }

            break;

          default:
            var o = this.getResizeMethod() == "frame" ? this._frame : this;

            if (this._resizeWest || this._resizeEast)
            {
              o._renderRuntimeWidth(s.lastWidth);

              if (this._resizeWest) {
                o._renderRuntimeLeft(s.lastLeft);
              }
            }

            if (this._resizeNorth || this._resizeSouth)
            {
              o._renderRuntimeHeight(s.lastHeight);

              if (this._resizeNorth) {
                o._renderRuntimeTop(s.lastTop);
              }
            }
        }
      }
      else
      {
        var resizeMode = "";
        var el = this.getElement();

        this._resizeNorth = this._resizeSouth = this._resizeWest = this._resizeEast = false;

        var elLoc = rwt.html.Location.get(el);

        if (this._near(elLoc.top, e.getPageY()))
        {
          if (this.getResizableNorth())
          {
            resizeMode = "n";
            this._resizeNorth = true;
          }
        }
        else if (this._near(elLoc.bottom, e.getPageY()))
        {
          if (this.getResizableSouth())
          {
            resizeMode = "s";
            this._resizeSouth = true;
          }
        }

        if (this._near(elLoc.left, e.getPageX()))
        {
          if (this.getResizableWest())
          {
            resizeMode += "w";
            this._resizeWest = true;
          }
        }
        else if (this._near(elLoc.right, e.getPageX()))
        {
          if (this.getResizableEast())
          {
            resizeMode += "e";
            this._resizeEast = true;
          }
        }

        if (this._resizeNorth || this._resizeSouth || this._resizeWest || this._resizeEast) {
          this.setCursor(resizeMode + "-resize");
        } else {
          this.resetCursor();
        }
      }

      // stop event
      e.stopPropagation();
    }
  },





  /*
  *****************************************************************************
     DESTRUCTOR
  *****************************************************************************
  */

  destruct : function() {
    this._disposeObjects("_frame");
  }
});

/*******************************************************************************
 * Copyright (c) 2007, 2012 David Perez Carmona, EclipseSource, and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for RAP
 ******************************************************************************/

/**
 * A popup that can be resized.
 */
rwt.qx.Class.define("rwt.widgets.base.ResizablePopup",
{
  extend   : rwt.widgets.base.Popup,
  include  : rwt.widgets.util.MResizable,

  construct : function()
  {
    this.base(arguments);

    this.initMinWidth();
    this.initMinHeight();
    this.initWidth();
    this.initHeight();
  },




  /*
  *****************************************************************************
     PROPERTIES
  *****************************************************************************
  */

  properties:
  {
    appearance :
    {
      refine : true,
      init : "resizer"
    },

    minWidth :
    {
      refine : true,
      init : "auto"
    },

    minHeight :
    {
      refine : true,
      init : "auto"
    },

    width :
    {
      refine : true,
      init : "auto"
    },

    height :
    {
      refine : true,
      init : "auto"
    }
  },






  members:
  {

    _changeWidth: function(value) {
      this.setWidth(value);
    },

    _changeHeight: function(value) {
      this.setHeight(value);
    },

    /**
     * @return {Widget}
     */
    _getResizeParent: function() {
      return this.getParent();
    },

    /**
     * @return {Widget}
     */
    _getMinSizeReference: function() {
      return this;
    }
  }
});

/*******************************************************************************
 * Copyright (c) 2004, 2014 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

/**
 * @state active
 * @state maximized This state is active if the window is maximized
 *
 * @appearance window The main window object
 * @appearance window-resize-frame {rwt.widgets.base.Terminator}
 * @appearance window-captionbar-icon {rwt.widgets.base.Image}
 * @appearance window-captionbar-title {rwt.widgets.base.Label} The label of the caption bar
 * @appearance window-captionbar-minimize-button {rwt.widgets.base.BasicButton}
 * @appearance window-captionbar-restore-button {rwt.widgets.base.BasicButton}
 * @appearance window-captionbar-maximize-button {rwt.widgets.base.BasicButton}
 * @appearance window-captionbar-close-button {rwt.widgets.base.BasicButton}
 * @appearance window-statusbar {rwt.widgets.base.HorizontalBoxLayout}
 * @appearance window-statusbar-text {rwt.widgets.base.Label}
 *
 * @appearance window-captionbar {rwt.widgets.base.HorizontalBoxLayout}
 * @state active {window-captionbar}
 */
rwt.qx.Class.define("rwt.widgets.base.Window",
{
  extend : rwt.widgets.base.ResizablePopup,



  /*
  *****************************************************************************
     CONSTRUCTOR
  *****************************************************************************
  */

  construct : function(vCaption, vIcon, vWindowManager)
  {
    this.base(arguments);

    // ************************************************************************
    //   MANAGER
    // ************************************************************************
    // Init Window Manager
    this.setWindowManager(vWindowManager || rwt.widgets.base.Window.getDefaultWindowManager());

    // ************************************************************************
    //   LAYOUT
    // ************************************************************************
    var l = this._layout = new rwt.widgets.base.VerticalBoxLayout();
    l.setEdge(0);
    this.add(l);

    // ************************************************************************
    //   CAPTIONBAR
    // ************************************************************************
    var cb = this._captionBar = new rwt.widgets.base.HorizontalBoxLayout();
    cb.setAppearance("window-captionbar");
    cb.setHeight("auto");
    cb.setOverflow("hidden");
    l.add(cb);

    // ************************************************************************
    //   CAPTIONICON
    // ************************************************************************
    var ci = this._captionIcon = new rwt.widgets.base.Image();
    ci.setAppearance("window-captionbar-icon");
    cb.add(ci);

    // ************************************************************************
    //   CAPTIONTITLE
    // ************************************************************************
    var ct = this._captionTitle = new rwt.widgets.base.Label(vCaption);
    ct.setAppearance("window-captionbar-title");
    ct.setSelectable(false);
    cb.add(ct);

    // ************************************************************************
    //   CAPTIONFLEX
    // ************************************************************************
    var cf = this._captionFlex = new rwt.widgets.base.HorizontalSpacer();
    cb.add(cf);

    // ************************************************************************
    //   CAPTIONBUTTONS: MINIMIZE
    // ************************************************************************
    var bm = this._minimizeButton = new rwt.widgets.base.BasicButton( "push", true );

    bm.setAppearance("window-captionbar-minimize-button");
    bm.setTabIndex(null);

    bm.addEventListener("execute", this._onminimizebuttonclick, this);
    bm.addEventListener("mousedown", this._onbuttonmousedown, this);

    cb.add(bm);

    // ************************************************************************
    //   CAPTIONBUTTONS: RESTORE
    // ************************************************************************
    var br = this._restoreButton = new rwt.widgets.base.BasicButton( "push", true );

    br.setAppearance("window-captionbar-restore-button");
    br.setTabIndex(null);

    br.addEventListener("execute", this._onrestorebuttonclick, this);
    br.addEventListener("mousedown", this._onbuttonmousedown, this);

    // don't add initially
    // cb.add(br);
    // ************************************************************************
    //   CAPTIONBUTTONS: MAXIMIZE
    // ************************************************************************
    var bx = this._maximizeButton = new rwt.widgets.base.BasicButton( "push", true );

    bx.setAppearance("window-captionbar-maximize-button");
    bx.setTabIndex(null);

    bx.addEventListener("execute", this._onmaximizebuttonclick, this);
    bx.addEventListener("mousedown", this._onbuttonmousedown, this);

    cb.add(bx);

    // ************************************************************************
    //   CAPTIONBUTTONS: CLOSE
    // ************************************************************************
    var bc = this._closeButton = new rwt.widgets.base.BasicButton( "push", true );

    bc.setAppearance("window-captionbar-close-button");
    bc.setTabIndex(null);

    bc.addEventListener("execute", this._onclosebuttonclick, this);
    bc.addEventListener("mousedown", this._onbuttonmousedown, this);

    cb.add(bc);

    // ************************************************************************
    //   PANE
    // ************************************************************************
    var p = this._pane = new rwt.widgets.base.Parent();
    p.setHeight("1*");
    p.setOverflow("hidden");
    l.add(p);

    // ************************************************************************
    //   STATUSBAR
    // ************************************************************************
    var sb = this._statusBar = new rwt.widgets.base.HorizontalBoxLayout();
    sb.setAppearance("window-statusbar");
    sb.setHeight("auto");

    // ************************************************************************
    //   STATUSTEXT
    // ************************************************************************
    var st = this._statusText = new rwt.widgets.base.Label("Ready");
    st.setAppearance("window-statusbar-text");
    st.setSelectable(false);
    sb.add(st);

    // ************************************************************************
    //   INIT
    // ************************************************************************
    if (vCaption != null) {
      this.setCaption(vCaption);
    }

    if (vIcon != null) {
      this.setIcon(vIcon);
    }

    // ************************************************************************
    //   FUNCTIONAL
    // ************************************************************************
    this.setAutoHide(false);

    // ************************************************************************
    //   EVENTS: WINDOW
    // ************************************************************************
    this.addEventListener("mousedown", this._onwindowmousedown);
    this.addEventListener("click", this._onwindowclick);

    // ************************************************************************
    //   EVENTS: CAPTIONBAR
    // ************************************************************************
    cb.addEventListener("mousedown", this._oncaptionmousedown, this);
    cb.addEventListener("mouseup", this._oncaptionmouseup, this);
    cb.addEventListener("mousemove", this._oncaptionmousemove, this);
    cb.addEventListener("dblclick", this._oncaptiondblblick, this);

    // ************************************************************************
    //   REMAPPING
    // ************************************************************************
    this.remapChildrenHandlingTo(this._pane);
  },




  /*
  *****************************************************************************
     STATICS
  *****************************************************************************
  */

  statics :
  {
    /*
    ---------------------------------------------------------------------------
      MANAGER HANDLING
    ---------------------------------------------------------------------------
    */

    /**
     * Returns the default window manager. If no exists a new instance of
     * the manager is created.
     *
     * @type static
     * @return {rwt.widgets.util.WindowManager} window manager instance
     */
    getDefaultWindowManager : function()
    {
      if (!rwt.widgets.base.Window._defaultWindowManager) {
        rwt.widgets.base.Window._defaultWindowManager = new rwt.widgets.util.WindowManager();
      }

      return rwt.widgets.base.Window._defaultWindowManager;
    }
  },




  /*
  *****************************************************************************
     PROPERTIES
  *****************************************************************************
  */

  properties :
  {
    /** Appearance of the widget */
    appearance :
    {
      refine : true,
      init : "window"
    },


    /** The windowManager to use for. */
    windowManager :
    {
      check : "rwt.widgets.util.WindowManager",
      event : "changeWindowManager"
    },


    /**
     * If the window is active, only one window in a single rwt.widgets.util.WindowManager could
     *  have set this to true at the same time.
     */
    active :
    {
      check : "Boolean",
      init : false,
      apply : "_applyActive",
      event : "changeActive"
    },


    /** Should be window be modal (this disable minimize and maximize buttons) */
    modal :
    {
      check : "Boolean",
      init : false,
      apply : "_applyModal",
      event : "changeModal"
    },


    /** The current mode (minimized or maximized) of the window instance
     * <b>Attention:</b> if the window instance is neither maximized nor minimized this
     * property will return <code>null</code>
     */
    mode :
    {
      check : [ "minimized", "maximized" ],
      init : null,
      nullable: true,
      apply : "_applyMode",
      event : "changeMode"
    },


    /** The opener (button) of the window */
    opener :
    {
      check : "rwt.widgets.base.Widget"
    },


    /** The text of the caption */
    caption :
    {
      apply : "_applyCaption",
      event : "changeCaption",
      dispose : true
    },


    /** The icon of the caption */
    icon :
    {
      check : "String",
      nullable : true,
      apply : "_applyIcon",
      event : "changeIcon"
    },


    /** The text of the statusbar */
    status :
    {
      check : "String",
      init : "Ready",
      apply : "_applyStatus",
      event :"changeStatus"
    },


    /** Should the close button be shown */
    showClose :
    {
      check : "Boolean",
      init : true,
      apply : "_applyShowClose"
    },


    /** Should the maximize button be shown */
    showMaximize :
    {
      check : "Boolean",
      init : true,
      apply : "_applyShowMaximize"
    },


    /** Should the minimize button be shown */
    showMinimize :
    {
      check : "Boolean",
      init : true,
      apply : "_applyShowMinimize"
    },


    /** Should the statusbar be shown */
    showStatusbar :
    {
      check : "Boolean",
      init : false,
      apply : "_applyShowStatusbar"
    },


    /** Should the user have the ability to close the window */
    allowClose :
    {
      check : "Boolean",
      init : true,
      apply : "_applyAllowClose"
    },


    /** Should the user have the ability to maximize the window */
    allowMaximize :
    {
      check : "Boolean",
      init : true,
      apply : "_applyAllowMaximize"
    },


    /** Should the user have the ability to minimize the window */
    allowMinimize :
    {
      check : "Boolean",
      init : true,
      apply : "_applyAllowMinimize"
    },


    /** If the text (in the captionbar) should be visible */
    showCaption :
    {
      check : "Boolean",
      init : true,
      apply : "_applyShowCaption"
    },


    /** If the icon (in the captionbar) should be visible */
    showIcon :
    {
      check : "Boolean",
      init : true,
      apply : "_applyShowIcon"
    },


    /** If the window is moveable */
    moveable :
    {
      check : "Boolean",
      init : true,
      event : "changeMoveable"
    },


    /** The move method to use */
    moveMethod :
    {
      check : [ "opaque", "frame", "translucent" ],
      init : "opaque",
      event : "changeMoveMethod"
    }
  },




  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {

    _isFocusRoot : true,

    /*
    ---------------------------------------------------------------------------
      UTILITIES
    ---------------------------------------------------------------------------
    */

    /**
     * Accessor method for the pane sub widget
     *
     * @type member
     * @return {rwt.widgets.base.Parent} pane sub widget
     */
    getPane : function() {
      return this._pane;
    },


    /**
     * Accessor method for the captionbar sub widget
     *
     * @type member
     * @return {rwt.widgets.base.HorizontalBoxLayout} captionbar sub widget
     */
    getCaptionBar : function() {
      return this._captionBar;
    },


    /**
     * Accessor method for the statusbar sub widget
     *
     * @type member
     * @return {rwt.widgets.base.HorizontalBoxLayout} statusbar sub widget
     */
    getStatusBar : function() {
      return this._statusBar;
    },


    /**
     * Closes the current window instance.
     * Technically calls the {@link rwt.widgets.base.Widget#hide} method.
     *
     * @type member
     * @return {void}
     */
    close : function() {
      this.hide();
    },


    /**
     * Opens the window.<br/>
     * Sets the opener property (if available) and centers
     * the window if the property {@link #centered} is enabled.
     *
     * @type member
     * @param vOpener {Object} Opener widget
     * @return {void}
     */
    open : function(vOpener)
    {
      if (vOpener != null) {
        this.setOpener(vOpener);
      }

      if (this.getCentered()) {
        this.centerToBrowser();
      }

      this.show();
    },


    /**
     * Set the focus on the window.<br/>
     * Setting the {@link #active} property to <code>true</code>
     *
     * @type member
     * @return {void}
     */
    focus : function() {
      this.setActive(true);
    },


    /**
     * Release the focus on the window.<br/>
     * Setting the {@link #active} property to <code>false</code>
     *
     * @type member
     * @return {void}
     */
    blur : function() {
      this.setActive(false);
    },


    /**
     * Maximize the window by setting the property {@link mode} to <code>maximized</code>
     *
     * @type member
     * @return {void}
     */
    maximize : function() {
      this.setMode("maximized");
    },


    /**
     * Maximize the window by setting the property {@link mode} to <code>minimized</code>
     *
     * @type member
     * @return {void}
     */
    minimize : function() {
      this.setMode("minimized");
    },


    /**
     * Maximize the window by setting the property {@link mode} to <code>null</code>
     *
     * @type member
     * @return {void}
     */
    restore : function() {
      this.setMode(null);
    },




    /*
    ---------------------------------------------------------------------------
      APPEAR/DISAPPEAR
    ---------------------------------------------------------------------------
    */

    /**
     * Executes routines to ensure the window is displayed correctly and gains control.<br/>
     * Hides all open popups, sets the focus root to the current window, adds
     * the current window to the window manager and calls {@link rwt.widgets.base.Popup#_makeActive}.
     *
     * @type member
     * @return {void}
     */
    _beforeAppear : function()
    {
      // Intentionally bypass superclass and call super.super._beforeAppear
      rwt.widgets.base.Parent.prototype._beforeAppear.call(this);

      // Hide popups
      rwt.widgets.util.PopupManager.getInstance().update();

      // Configure the focus root to be the current opened window
      rwt.event.EventHandler.setFocusRoot(this);

      this.getWindowManager().add(this);
      this._makeActive();
    },


    /**
     * Executes routines to ensure the window releases all control.<br/>
     * Resets the focus root, release the capturing on any contained widget,
     * deregisters from the window manager and calls {@link rwt.widgets.base.Popup#_makeInactive}.
     *
     * @type member
     * @return {void}
     */
    _beforeDisappear : function()
    {
      // Intentionally bypass superclass and call super.super._beforeDisappear
      rwt.widgets.base.Parent.prototype._beforeDisappear.call(this);

      // Reset focus root
      var vFocusRoot = rwt.event.EventHandler.getFocusRoot();

      if (vFocusRoot == this || this.contains(vFocusRoot)) {
        rwt.event.EventHandler.setFocusRoot(null);
      }

      // Be sure to disable any capturing inside invisible parts
      // Is this to much overhead?
      // Are there any other working solutions?
      var vWidget = rwt.event.EventHandler.getCaptureWidget();

      if (vWidget && this.contains(vWidget)) {
        vWidget.setCapture(false);
      }

      this.getWindowManager().remove(this);
      this._makeInactive();
    },




    /*
    ---------------------------------------------------------------------------
      ZIndex Positioning
    ---------------------------------------------------------------------------
    */

    _minZIndex : 1e5,


    /**
     * Gets all registered window instances (sorted by the zIndex) and resets
     * the zIndex on all instances.
     *
     * @type member
     * @return {void}
     */
    _sendTo : function()
    {
      var zIndexCompare = function(a, b) {
        return a.getZIndex() - b.getZIndex();
      };
      var vAll = rwt.util.Objects.getValues(this.getWindowManager().getAll()).sort(zIndexCompare);
      var vLength = vAll.length;
      var vIndex = this._minZIndex;

      for (var i=0; i<vLength; i++) {
        vAll[i].setZIndex(vIndex++);
      }
    },




    /*
    ---------------------------------------------------------------------------
      MODIFIERS
    ---------------------------------------------------------------------------
    */

    /**
     * TODOC
     *
     * @type member
     * @param value {var} Current value
     * @param old {var} Previous value
     */
    _applyActive : function(value, old)
    {
      if (old)
      {
        if (this.getFocused()) {
          this.setFocused(false);
        }
        if (this.getWindowManager().getActiveWindow() == this) {
          this.getWindowManager().setActiveWindow(null);
        }
        this._setActiveState( false );

      }
      else
      {
        // Switch focus
        // Also do this if gets inactive as this moved the focus outline
        // away from any focused child.
        if (!this.getFocusedChild()) {
          this.setFocused(true);
        }
        this._setActiveState( true );
        this.getWindowManager().setActiveWindow(this);
        this.bringToFront();

      }
    },

    _setActiveState : function( value ) {
      if( !this.getWindowManager().blockActiveState ) {
        this.toggleState( "active", value );
        this._captionBar.toggleState( "active", value );
        this._minimizeButton.toggleState( "active", value );
        this._restoreButton.toggleState( "active", value );
        this._maximizeButton.toggleState( "active", value );
        this._closeButton.toggleState( "active", value );
      }
    },


    /**
     * TODOC
     *
     * @type member
     * @param value {var} Current value
     * @param old {var} Previous value
     */
    _applyModal : function( value ) {
      // Inform blocker
      if( this._initialLayoutDone && this.getVisibility() && this.getDisplay() ) {
        var vTop = this.getTopLevelWidget();
        if( value ) {
          vTop.block( this );
        } else {
          vTop.release( this );
        }
      }
    },


    /**
     * TODOC
     *
     * @type member
     * @param value {var} Current value
     * @param old {var} Previous value
     * @return {var} TODOC
     */
    _applyAllowClose : function() {
      this._closeButtonManager();
    },


    /**
     * TODOC
     *
     * @type member
     * @param value {var} Current value
     * @param old {var} Previous value
     * @return {var} TODOC
     */
    _applyAllowMaximize : function() {
      this._maximizeButtonManager();
    },


    /**
     * TODOC
     *
     * @type member
     * @param value {var} Current value
     * @param old {var} Previous value
     * @return {var} TODOC
     */
    _applyAllowMinimize : function() {
      this._minimizeButtonManager();
    },


    /**
     * TODOC
     *
     * @type member
     * @param value {var} Current value
     * @param old {var} Previous value
     */
    _applyMode : function(value, old)
    {
      switch(value)
      {
        case "minimized":
          this._disableResize = true;
          this._minimize();
          break;

        case "maximized":
          this._disableResize = true;
          this._maximize();
          break;

        default:
          delete this._disableResize;
          switch(old)
          {
            case "maximized":
              this._restoreFromMaximized();
              break;

            case "minimized":
              this._restoreFromMinimized();
              break;
          }
      }
    },


    /**
     * TODOC
     *
     * @type member
     * @param value {var} Current value
     * @param old {var} Previous value
     */
    _applyShowCaption : function(value)
    {
      if (value) {
        this._captionBar.addAt(this._captionTitle, this.getShowIcon() ? 1 : 0);
      } else {
        this._captionBar.remove(this._captionTitle);
      }
    },


    /**
     * TODOC
     *
     * @type member
     * @param value {var} Current value
     * @param old {var} Previous value
     */
    _applyShowIcon : function(value)
    {
      if (value) {
        this._captionBar.addAtBegin(this._captionIcon);
      } else {
        this._captionBar.remove(this._captionIcon);
      }
    },


    /**
     * TODOC
     *
     * @type member
     * @param value {var} Current value
     * @param old {var} Previous value
     */
    _applyShowStatusbar : function(value)
    {
      if (value) {
        this._layout.addAtEnd(this._statusBar);
      } else {
        this._layout.remove(this._statusBar);
      }
    },


    /**
     * TODOC
     *
     * @type member
     * @param value {var} Current value
     * @param old {var} Previous value
     */
    _applyShowClose : function(value)
    {
      if (value) {
        this._captionBar.addAtEnd(this._closeButton);
      } else {
        this._captionBar.remove(this._closeButton);
      }
    },


    /**
     * TODOC
     *
     * @type member
     * @param value {var} Current value
     * @param old {var} Previous value
     */
    _applyShowMaximize : function(value)
    {
      if (value)
      {
        var t = this.getMode() == "maximized" ? this._restoreButton : this._maximizeButton;

        if (this.getShowMinimize()) {
          this._captionBar.addAfter(t, this._minimizeButton);
        } else {
          this._captionBar.addAfter(t, this._captionFlex);
        }
      }
      else
      {
        this._captionBar.remove(this._maximizeButton);
        this._captionBar.remove(this._restoreButton);
      }
    },


    /**
     * TODOC
     *
     * @type member
     * @param value {var} Current value
     * @param old {var} Previous value
     */
    _applyShowMinimize : function(value)
    {
      if (value) {
        this._captionBar.addAfter(this._minimizeButton, this._captionFlex);
      } else {
        this._captionBar.remove(this._minimizeButton);
      }
    },


    /**
     * Enables/disables the minimize button in order of the {@link #allowMinimize} property
     *
     * @type member
     */
    _minimizeButtonManager : function() {
      if( this.getAllowMinimize() === false ) {
        this._minimizeButton.setEnabled( false );
      } else {
        this._minimizeButton.resetEnabled();
      }
    },


    /**
     * Enables/disables the close button in order of the {@link #allowClose} property
     *
     * @type member
     */
    _closeButtonManager : function() {
      if( this.getAllowClose() === false ) {
        this._closeButton.setEnabled( false );
      } else {
        this._closeButton.resetEnabled();
      }
    },


    /**
     * Disables the maximize and restore buttons when the window instance is already maximized,
     * otherwise the {@link #enabled} property of both buttons get resetted.
     *
     * @type member
     */
    _maximizeButtonManager : function() {
      var b = this.getAllowMaximize() && this.getResizable() && this._computedMaxWidthTypeNull && this._computedMaxHeightTypeNull;
      if( this._maximizeButton ) {
        if( b === false ) {
          this._maximizeButton.setEnabled( false );
        } else {
          this._maximizeButton.resetEnabled();
        }
      }
      if( this._restoreButton ) {
        if( b === false ) {
          this._restoreButton.setEnabled( false );
        } else {
          this._restoreButton.resetEnabled();
        }
      }
    },


    /**
     * TODOC
     *
     * @type member
     * @param value {var} Current value
     * @param old {var} Previous value
     */
    _applyStatus : function(value) {
      this._statusText.setText(value);
    },


    /**
     * TODOC
     *
     * @type member
     * @param value {var} Current value
     * @param old {var} Previous value
     * @return {void} TODOC
     */
    _applyMaxWidth : function(value)
    {
      this.base(arguments, value);
      this._maximizeButtonManager();
    },


    /**
     * TODOC
     *
     * @type member
     * @param value {var} Current value
     * @param old {var} Previous value
     * @return {void} TODOC
     */
    _applyMaxHeight : function(value)
    {
      this.base(arguments, value);
      this._maximizeButtonManager();
    },


    /**
     * TODOC
     *
     * @type member
     * @param value {var} Current value
     * @param old {var} Previous value
     * @return {var} TODOC
     */
    _applyResizable : function() {
      this._maximizeButtonManager();
    },


    /**
     * TODOC
     *
     * @type member
     * @param value {var} Current value
     * @param old {var} Previous value
     */
    _applyCaption : function(value) {
      this._captionTitle.setText(value);
    },

    /**
     * TODOC
     *
     * @type member
     * @param value {var} Current value
     * @param old {var} Previous value
     */
    _applyIcon : function(value) {
      this._captionIcon.setSource(value);
    },




    /*
    ---------------------------------------------------------------------------
      STATE LAYOUT IMPLEMENTATION
    ---------------------------------------------------------------------------
    */

    /**
     * Minimizes the window. Technically this methods calls the {@link rwt.widgets.base.Widget#blur}
     * and the {@link rwt.widgets.base.Widget#hide} methods.
     *
     * @type member
     * @return {void}
     */
    _minimize : function()
    {
      this.blur();
      this.hide();
    },


    /**
     * Restores the window from maximized mode.<br/>
     * Restores the previous dimension and location, removes the
     * state <code>maximized</code> and replaces the restore button
     * with the maximize button.
     *
     * @type member
     * @return {void}
     */
    _restoreFromMaximized : function()
    {
      // restore previous dimension and location
      this.setLeft(this._previousLeft ? this._previousLeft : null);
      this.setWidth(this._previousWidth ? this._previousWidth : null);
      this.setRight(this._previousRight ? this._previousRight : null);

      this.setTop(this._previousTop ? this._previousTop : null);
      this.setHeight(this._previousHeight ? this._previousHeight : null);
      this.setBottom(this._previousBottom ? this._previousBottom : null);

      // update state
      this.removeState("maximized");

      // toggle button
      if (this.getShowMaximize())
      {
        var cb = this._captionBar;
        var v = cb.indexOf(this._restoreButton);

        cb.remove(this._restoreButton);
        cb.addAt(this._maximizeButton, v);
      }

      // finally focus the window
      this.focus();
    },


    /**
     * Restores the window from minimized mode.<br/>
     * Reset the window mode to maximized if the window
     * has the state maximized and call {@link rwt.widgets.base.Widget#show} and
     * {@link rwt.widgets.base.Widget#focus}
     *
     * @type member
     * @return {void}
     */
    _restoreFromMinimized : function()
    {
      if (this.hasState("maximized")) {
        this.setMode("maximized");
      }

      this.show();
      this.focus();
    },


    /**
     * Maximizes the window.<br/>
     * Stores the current dimension and location and setups up
     * the new ones. Adds the state <code>maximized</code> and toggles
     * the buttons in the caption bar.
     *
     * @type member
     * @return {void}
     */
    _maximize : function()
    {
      if (this.hasState("maximized")) {
        return;
      }

      // store current dimension and location
      this._previousLeft = this.getLeft();
      this._previousWidth = this.getWidth();
      this._previousRight = this.getRight();
      this._previousTop = this.getTop();
      this._previousHeight = this.getHeight();
      this._previousBottom = this.getBottom();

      // setup new dimension and location
      this.setLeft( 0 );
      this.setTop( 0 );
      this.setWidth( "100%" );
      this.setHeight( "100%" );

      // update state
      this.addState("maximized");

      // toggle button
      if (this.getShowMaximize())
      {
        var cb = this._captionBar;
        var v = cb.indexOf(this._maximizeButton);

        cb.remove(this._maximizeButton);
        cb.addAt(this._restoreButton, v);
      }

      // finally focus the window
      this.focus();
    },




    /*
    ---------------------------------------------------------------------------
      EVENTS: WINDOW
    ---------------------------------------------------------------------------
    */


    /**
     * Stops every mouse click on the window by calling {@link rwt.event.Event#stopPropagation}
     *
     * @type member
     * @param e {rwt.event.MouseEvent} mouse click event
     * @return {void}
     */
    _onwindowclick : function(e)
    {
      // stop event
      e.stopPropagation();
    },


    /**
     * Focuses the window instance.
     *
     * @type member
     * @param e {rwt.event.MouseEvent} mouse down event
     * @return {void}
     */
    _onwindowmousedown : function() {
      try {
        this.focus();
      } catch( ex ) {
        rwt.runtime.ErrorHandler.processJavaScriptError( ex );
      }
    },



    /*
    ---------------------------------------------------------------------------
      EVENTS: BUTTONS
    ---------------------------------------------------------------------------
    */

    /**
     * Stops every mouse down event on each button in the captionbar
     * by calling {@link rwt.event.Event#stopPropagation}
     *
     * @type member
     * @param e {rwt.event.MouseEvent} mouse down event
     * @return {void}
     */
    _onbuttonmousedown : function(e) {
      e.stopPropagation();
    },


    /**
     * Minmizes the window, removes all states from the minimize button and
     * stops the further propagation of the event (calling {@link rwt.event.Event#stopPropagation}).
     *
     * @type member
     * @param e {rwt.event.MouseEvent} mouse click event
     * @return {void}
     */
    _onminimizebuttonclick : function(e)
    {
      this.minimize();

      // we need to be sure that the button gets the right states after clicking
      // because the button will move and does not get the mouseup event anymore
      this._minimizeButton.removeState("pressed");
      this._minimizeButton.removeState("abandoned");
      this._minimizeButton.removeState("over");

      e.stopPropagation();
    },


    /**
     * Restores the window, removes all states from the restore button and
     * stops the further propagation of the event (calling {@link rwt.event.Event#stopPropagation}).
     *
     * @type member
     * @param e {rwt.event.MouseEvent} mouse click event
     * @return {void}
     */
    _onrestorebuttonclick : function(e)
    {
      this.restore();

      // we need to be sure that the button gets the right states after clicking
      // because the button will move and does not get the mouseup event anymore
      this._restoreButton.removeState("pressed");
      this._restoreButton.removeState("abandoned");
      this._restoreButton.removeState("over");

      e.stopPropagation();
    },


    /**
     * Maximizes the window, removes all states from the maximize button and
     * stops the further propagation of the event (calling {@link rwt.event.Event#stopPropagation}).
     *
     * @type member
     * @param e {rwt.event.MouseEvent} mouse click event
     * @return {void}
     */
    _onmaximizebuttonclick : function(e)
    {
      this.maximize();

      // we need to be sure that the button gets the right states after clicking
      // because the button will move and does not get the mouseup event anymore
      this._maximizeButton.removeState("pressed");
      this._maximizeButton.removeState("abandoned");
      this._maximizeButton.removeState("over");

      e.stopPropagation();
    },


    /**
     * Closes the window, removes all states from the close button and
     * stops the further propagation of the event (calling {@link rwt.event.Event#stopPropagation}).
     *
     * @type member
     * @param e {rwt.event.MouseEvent} mouse click event
     * @return {void}
     */
    _onclosebuttonclick : function(e)
    {
      this.close();

      // we need to be sure that the button gets the right states after clicking
      // because the button will move and does not get the mouseup event anymore
      this._closeButton.removeState("pressed");
      this._closeButton.removeState("abandoned");
      this._closeButton.removeState("over");

      e.stopPropagation();
    },




    /*
    ---------------------------------------------------------------------------
      EVENTS: CAPTIONBAR
    ---------------------------------------------------------------------------
    */

    /**
     * Enables the capturing of the caption bar and prepares the drag session and the
     * appearance (translucent, frame or opaque) for the moving of the window.
     *
     * @type member
     * @param e {rwt.event.MouseEvent} mouse down event
     * @return {void}
     */
    _oncaptionmousedown : function(e)
    {
      if (!e.isLeftButtonPressed() || !this.getMoveable() || this.getMode() != null) {
        return;
      }

      // enable capturing
      this._captionBar.setCapture(true);

      // element cache
      var el = this.getElement();

      // measuring and caching of values for drag session
      var pa = this.getParent();
      var pl = pa.getElement();

      // compute locations
      var paLoc = rwt.html.Location.get(pl, "scroll");
      var elLoc = rwt.html.Location.get(el);

      this._dragSession =
      {
        offsetX                   : e.getPageX() - elLoc.left + paLoc.left,
        offsetY                   : e.getPageY() - elLoc.top + paLoc.top,
        parentAvailableAreaLeft   : paLoc.left + 5,
        parentAvailableAreaTop    : paLoc.top + 5,
        parentAvailableAreaRight  : paLoc.right - 5,
        parentAvailableAreaBottom : paLoc.bottom - 5
      };

      // handle frame and translucently
      switch(this.getMoveMethod())
      {
        case "translucent":
          this.setOpacity(0.5);
          break;

        case "frame":
          var f = this._frame;

          if (f.getParent() != this.getParent())
          {
            f.setParent(this.getParent());

            // This flush is required to get the element node, needed by
            // the code below and the other event handlers
            rwt.widgets.base.Widget.flushGlobalQueues();
          }

          f._renderRuntimeLeft(elLoc.left - paLoc.left);
          f._renderRuntimeTop(elLoc.top - paLoc.top);

          f._renderRuntimeWidth(el.offsetWidth);
          f._renderRuntimeHeight(el.offsetHeight);

          f.setZIndex(this.getZIndex() + 1);

          break;
      }
    },


    /**
     * Disables the capturing of the caption bar and moves the window
     * to the last position of the drag session. Also restores the appearance
     * of the window.
     *
     * @type member
     * @param e {rwt.event.MouseEvent} mouse up event
     * @return {void}
     */
    _oncaptionmouseup : function()
    {
      var s = this._dragSession;

      if (!s) {
        return;
      }

      // disable capturing
      this._captionBar.setCapture(false);

      // move window to last position
      if (s.lastX != null) {
        this.setLeft(s.lastX);
      }

      if (s.lastY != null) {
        this.setTop(s.lastY);
      }

      // handle frame and translucently
      switch(this.getMoveMethod())
      {
        case "translucent":
          this.setOpacity(null);
          break;

        case "frame":
          this._frame.setParent(null);
          break;
      }

      // cleanup session
      delete this._dragSession;
    },


    /**
     * Does the moving of the window by rendering the position
     * of the window (or frame) at runtime using direct dom methods.
     *
     * @type member
     * @param e {rwt.event.Event} mouse move event
     * @return {void}
     */
    _oncaptionmousemove : function(e)
    {
      var s = this._dragSession;

      // pre check for active session and capturing
      if (!s || !this._captionBar.getCapture()) {
        return;
      }

      // pre check if we go out of the available area
      if (!rwt.util.Numbers.isBetween(e.getPageX(), s.parentAvailableAreaLeft, s.parentAvailableAreaRight) || !rwt.util.Numbers.isBetween(e.getPageY(), s.parentAvailableAreaTop, s.parentAvailableAreaBottom)) {
        return;
      }

      // use the fast and direct dom methods
      var o = this.getMoveMethod() == "frame" ? this._frame : this;

      o._renderRuntimeLeft(s.lastX = e.getPageX() - s.offsetX);
      o._renderRuntimeTop(s.lastY = e.getPageY() - s.offsetY);
    },


    /**
     * Maximizes the window or restores it if it is already
     * maximized.
     *
     * @type member
     * @param e {rwt.event.MouseEvent} double click event
     * @return {void}
     */
    _oncaptiondblblick : function()
    {
      if (!this._maximizeButton.getEnabled()) {
        return;
      }

      return this.getMode() == "maximized" ? this.restore() : this.maximize();
    }
  },




  /*
  *****************************************************************************
     DESTRUCTOR
  *****************************************************************************
  */

  destruct : function()
  {
    this._disposeObjects("_layout", "_captionBar", "_captionIcon",
      "_captionTitle", "_captionFlex", "_closeButton", "_minimizeButton",
      "_maximizeButton", "_restoreButton", "_pane", "_statusBar", "_statusText");
  }
});

/*******************************************************************************
 * Copyright (c) 2004, 2013 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

/**
 * This widget can be used to create a horizontal spacing between
 * widgets in e.g. a {@link rwt.widgets.base.HorizontalBoxLayout} or in
 * a menu or toolbar.
 *
 * By default it tries to occupy the all the remaining space by setting
 * a flex width of <code>1*</code>.
 */
rwt.qx.Class.define("rwt.widgets.base.HorizontalSpacer",
{
  extend : rwt.widgets.base.Terminator,

  construct : function()
  {
    this.base(arguments);

    this.initWidth();
  },

  properties :
  {
    width :
    {
      refine : true,
      init : "1*"
    }
  }
});

/*******************************************************************************
 * Copyright (c) 2004, 2014 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

/** This singleton manages rwt.widgets.base.Windows */
rwt.qx.Class.define("rwt.widgets.util.WindowManager",
{
  extend : rwt.util.ObjectManager,





  /*
  *****************************************************************************
     PROPERTIES
  *****************************************************************************
  */

  properties :
  {
    /** This property holds the current active window */
    activeWindow :
    {
      check : "Object",
      nullable : true,
      apply : "_applyActiveWindow"
    }
  },




  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {

    blockActiveState : false,

    /*
    ---------------------------------------------------------------------------
      APPLY ROUTINES
    ---------------------------------------------------------------------------
    */

    /**
     * TODOC
     *
     * @type member
     * @param value {var} Current value
     * @param old {var} Previous value
     */
    _applyActiveWindow : function(value, old)
    {
      rwt.widgets.util.PopupManager.getInstance().update();

      if (old) {
        old.setActive(false);
      }

      if (value) {
        value.setActive(true);
      }

      if (old && old.getModal()) {
        old.getTopLevelWidget().release(old);
      }

      if (value && value.getModal()) {
        value.getTopLevelWidget().block(value);
      }
    },




    /*
    ---------------------------------------------------------------------------
      UTILITIES
    ---------------------------------------------------------------------------
    */

    /**
     * Updates all registered window instances
     *
     * @type member
     * @return {void}
     */
    update : function()
    {
      var vWindow;
      var vAll = this.getAll();

      for (var vHashCode in vAll)
      {
        vWindow = vAll[vHashCode];

        if (!vWindow.getAutoHide()) {
          continue;
        }

        vWindow.hide();
      }
    },




    /*
    ---------------------------------------------------------------------------
      MANAGER INTERFACE
    ---------------------------------------------------------------------------
    */

    /**
     * Compares two windows (used as sort method in {@link #remove}).
     * Sorts the windows by checking which of the given windows is active.
     * If none of those two are active the zIndex are subtracted from each
     * other to determine the sort order.
     *
     * @type member
     * @param w1 {rwt.widgets.base.Window} first window to compare
     * @param w2 {rwt.widgets.base.Window} second window to compare
     * @return {int | var} 1 for first window active, -1 for second window active
     * and the subtraction of the zIndex if none of the two are active.
     */
    compareWindows : function(w1, w2)
    {
      switch(w1.getWindowManager().getActiveWindow())
      {
        case w1:
          return 1;

        case w2:
          return -1;
      }

      return w1.getZIndex() - w2.getZIndex();
    },


    /**
     * Adds a {@link rwt.widgets.base.Window} instance to the manager and
     * sets it as active window.
     *
     * @type member
     * @param vWindow {rwt.widgets.base.Window} window instance to add
     * @return {void}
     */
    add : function(vWindow)
    {
      this.base(arguments, vWindow);

      this.setActiveWindow(vWindow);
    },


    /**
     * Removes a {@link rwt.widgets.base.Window} instance from the manager.
     * If the current active window is the one which should be removed the
     * existing windows are compared to determine the new active window
     * (using the {@link #compareWindows} method).
     *
     * @type member
     * @param vWindow {rwt.widgets.base.Window} window instance
     * @return {void}
     */
    remove : function( vWindow ) {
      this.base( arguments, vWindow );
      if( this.getActiveWindow() == vWindow ) {
        var a = [];
        for( var i in this._objects ) {
          a.push( this._objects[ i ] );
        }
        var l = a.length;
        if( l === 0 ) {
          this.setActiveWindow( null );
        } else if ( l === 1 ) {
          this.setActiveWindow( a[ 0 ] );
        } else if ( l > 1 ) {
          a.sort( this.compareWindows );
          this.setActiveWindow( a[ l - 1 ] );
        }
      }
    }

  }
});

/*******************************************************************************
 * Copyright (c) 2004, 2013 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

/**
 * @appearance menu-separator
 * @appearance menu-separator-line {rwt.widgets.base.Terminator}
 */
rwt.qx.Class.define( "rwt.widgets.MenuItemSeparator", {

  extend : rwt.widgets.base.Parent,

  construct : function() {
    this.base(arguments);

    this.initHeight();

    // Fix IE Styling Issues
    this.setStyleProperty("fontSize", "0");
    this.setStyleProperty("lineHeight", "0");

    // LINE
    this._line = new rwt.widgets.base.Terminator();
    this._line.setAnonymous(true);
    this._line.setAppearance("menu-separator-line");
    this.add(this._line);

    // EVENTS
    // needed to stop the event, and keep the menu showing
    this.addEventListener("mousedown", this._onmousedown);
  },

  properties : {
    height : {
      refine : true,
      init : "auto"
    },

    appearance : {
      refine : true,
      init : "menu-separator"
    }
  },

  members : {

    /**
     * Returns <code>false</code> to clarify that the Separator widget has no icon
     *
     * @signature function()
     * @return {Boolean} false
     */
    hasIcon : rwt.util.Functions.returnFalse,

    /**
     * Returns <code>false</code> to clarify that the Separator widget has no label
     *
     * @signature function()
     * @return {Boolean} false
     */
    hasLabel : rwt.util.Functions.returnFalse,

    /**
     * Returns <code>false</code> to clarify that the Separator widget has no shortcut
     *
     * @signature function()
     * @return {Boolean} false
     */
    hasShortcut : rwt.util.Functions.returnFalse,

    /**
     * Returns <code>false</code> to clarify that the Separator widget has no sub menu
     *
     * @signature function()
     * @return {Boolean} false
     */
    hasMenu : rwt.util.Functions.returnFalse,


    /**
     * Callback method for the "mouseDown" event<br/>
     * Simply stops the propagation of the event
     *
     * @type member
     * @param e {rwt.event.MouseEvent} mouseDown event
     * @return {void}
     */
    _onmousedown : function(e) {
      e.stopPropagation();
    }
  },

  destruct : function() {
    this._disposeObjects( "_line" );
  }

} );

/*******************************************************************************
 * Copyright (c) 2004, 2014 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

/**
 * @appearance tab-view-page
 */
rwt.qx.Class.define( "rwt.widgets.base.TabFolderPage", {

  extend : rwt.widgets.base.Parent,

  construct : function( vButton ) {
    this.base( arguments );
    if( vButton !== undefined ) {
      this.setButton( vButton );
    }
    this.initTop();
    this.initRight();
    this.initBottom();
    this.initLeft();
  },

  properties : {

    top : {
      refine : true,
      init : 0
    },

    right : {
      refine : true,
      init : 0
    },

    bottom : {
      refine : true,
      init : 0
    },

    left : {
      refine : true,
      init : 0
    },

    /**
     * Make element displayed (if switched to true the widget will be created, if needed, too).
     *  Instead of rwt.widgets.base.Widget, the default is false here.
     */
    display : {
      refine: true,
      init : false
    },

    /** The attached tab of this page. */
    button : {
      check : "rwt.widgets.TabItem",
      apply : "_applyButton"
    }

  },

  members : {

    _applyButton : function( value, old ) {
      if( old ) {
        old.setPage( null );
      }
      if( value ) {
        value.setPage( this );
      }
    }

  }

} );

/*******************************************************************************
 * Copyright (c) 2011, 2015 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

/*global console: false */

rwt.qx.Class.define( "rwt.runtime.ErrorHandler", {

  statics : {

    _overlay : null,
    _box : null,

    processJavaScriptErrorInResponse : function( script, error, currentRequest ) {
      var content = this._getErrorPageHeader();
      content += "<pre>" + this._gatherErrorDetails( error, script, currentRequest ) + "</pre>";
      this.showErrorPage( content );
    },

    processJavaScriptError : function( error ) {
      this.errorObject = error; // for later inspection by developer
      if( typeof console === "object" ) {
        var msg = "Error: " + ( error.message ? error.message : error );
        if( typeof console.error !== "undefined" ) { // IE returns "object" for typeof
          console.error( msg );
        } else if( typeof console.log !== "undefined" ) {
          console.log( msg );
        }
        if( typeof console.log === "function" && error.stack ) {
          console.log( "Error stack:\n" + error.stack );
        } else if( typeof console.trace !== "undefined" ) {
          console.trace();
        }
      }
      var debug = true;
      try {
        debug = rwt.util.Variant.isSet( "qx.debug", "on" );
      } catch( ex ) {
        // ignore: Variant may not be loaded yet
      }
      if( debug ) {
        var content = this._getErrorPageHeader();
        content += "<pre>" + this._gatherErrorDetails( error ) + "</pre>";
        this.showErrorPage( content );
        throw error;
      }
    },

    showErrorPage : function( content ) {
      this._enableTextSelection();
      this._freezeApplication();
      document.title = "Error Page";
      this._createErrorPageArea().innerHTML = content;
    },

    showErrorBox : function( errorType, freeze ) {
      if( freeze ) {
        this._freezeApplication();
      }
      if( errorType !== "connection error" ) {
        this._unloadAllIframes();
      }
      this._overlay = this._createOverlay();
      this._box = this._createErrorBoxArea( 450, 150 );
      this._box.style.padding = "0px";
      this._box.style.border = "1px solid #3B5998";
      this._box.style.overflow = "hidden";
      var errorBoxData = this._getErrorBoxData( errorType );
      this._title = this._createErrorBoxTitleArea( this._box );
      this._title.innerHTML = errorBoxData.title;
      this._description = this._createErrorBoxDescriptionArea( this._box );
      this._description.innerHTML = errorBoxData.description;
      this._action = this._createErrorBoxActionArea( this._box );
      if( errorBoxData.action ) {
        this._action.innerHTML = errorBoxData.action;
      }
      var hyperlink = this._action.getElementsByTagName( "a" )[ 0 ];
      if( hyperlink ) {
        this._styleHyperlinkAsButton( hyperlink );
        hyperlink.focus();
      }
    },

    showWaitHint : function() {
      this._overlay = this._createOverlay();
      var themeStore = rwt.theme.ThemeStore.getInstance();
      var cssElement = "SystemMessage-DisplayOverlay";
      var icon = themeStore.getSizedImage( cssElement, {}, "background-image" );
      if( icon && icon[ 0 ] ) {
        this._box = this._createErrorBoxArea( icon[ 1 ], icon[ 2 ] );
        rwt.html.Style.setBackgroundImage( this._box, icon[ 0 ] );
        this._box.style.backgroundColor = "transparent";
        this._box.style.border = "none";
        this._box.style.overflow = "hidden";
      }
    },

    hideErrorBox : function() {
      if( this._box ) {
        this._box.parentNode.removeChild( this._box );
        this._box = null;
      }
      if( this._overlay ) {
        this._overlay.parentNode.removeChild( this._overlay );
        this._overlay = null;
      }
      rwt.event.EventHandler.setBlockKeyEvents( false );
    },

    _getErrorPageHeader : function() {
       var errorBoxData = this._getErrorBoxData( "client error" );
       var result = "<h2>" + errorBoxData.title + "</h2>";
       result += "<h3>" + errorBoxData.action + "</h3>";
       result += "<hr/>";
       return result;
    },

    _gatherErrorDetails : function( error, script, currentRequest ) {
      var info = [];
      try {
        info.push( "Error: " + error + "\n" );
        if( script ) {
          info.push( "Script: " + script );
        }
        if( error instanceof Error ) {
          for( var key in error ) { // NOTE : does not work in webkit (no iteration)
            info.push( key + ": " + error[ key ] );
          }
          if( error.stack ) { // ensures stack is printed in webkit, might be printed twice in gecko
            info.push( "Stack: " + error.stack );
          }
       }
        info.push( "Debug: " + rwt.util.Variant.get( "qx.debug" ) );
        if( currentRequest ) {
          info.push( "Request: " + currentRequest.getData() );
        }
        var inFlush = rwt.widgets.base.Widget._inFlushGlobalQueues;
        if( inFlush ) {
          info.push( "Phase: " + rwt.widgets.base.Widget._flushGlobalQueuesPhase );
        }
      } catch( ex ) {
        // ensure we get a info no matter what
      }
      return info.join( "\n  " );
    },

    _createOverlay : function() {
      var element = document.createElement( "div" );
      var themeStore = rwt.theme.ThemeStore.getInstance();
      var color = themeStore.getColor( "SystemMessage-DisplayOverlay", {}, "background-color" );
      var alpha = themeStore.getAlpha( "SystemMessage-DisplayOverlay", {}, "background-color" );
      var style = element.style;
      style.position = "absolute";
      style.width = "100%";
      style.height = "100%";
      style.backgroundColor = color === "undefined" ? "transparent" : color;
      style.opacity = alpha;
      style.zIndex = 100000000;
      document.body.appendChild( element );
      rwt.event.EventHandler.setBlockKeyEvents( true );
      return element;
    },

    _createErrorPageArea : function() {
      var element = document.createElement( "div" );
      var style = element.style;
      style.position = "absolute";
      style.width = "100%";
      style.height = "100%";
      style.backgroundColor = "#ffffff";
      style.zIndex = 100000001;
      style.overflow = "auto";
      style.padding = "10px";
      document.body.appendChild( element );
      return element;
    },

    _createErrorBoxArea : function( width, height ) {
      var element = document.createElement( "div" );
      var style = element.style;
      style.position = "absolute";
      style.width = width + "px";
      style.height = height + "px";
      var doc = rwt.widgets.base.ClientDocument.getInstance();
      var left = ( doc.getClientWidth() - width ) / 2;
      var top = ( doc.getClientHeight() - height ) / 2;
      style.left = ( left < 0 ? 0 : left ) + "px";
      style.top = ( top < 0 ? 0 : top ) + "px";
      style.zIndex = 100000001;
      style.padding = "10px";
      style.textAlign = "center";
      style.fontFamily = 'verdana,"lucida sans",arial,helvetica,sans-serif';
      style.fontSize = "12px";
      style.fontStyle = "normal";
      style.fontWeight = "normal";
      document.body.appendChild( element );
      return element;
    },

    _createErrorBoxTitleArea : function( parentElement ) {
      var element = document.createElement( "div" );
      var style = element.style;
      style.position = "absolute";
      style.left = "0px";
      style.top = "0px";
      style.width = "100%";
      style.height = "40px";
      style.padding = "10px";
      style.textAlign = "left";
      style.backgroundColor = "#406796";
      style.color = "white";
      style.fontSize = "14px";
      style.fontWeight = "bold";
      parentElement.appendChild( element );
      return element;
    },

    _createErrorBoxDescriptionArea : function( parentElement ) {
      var element = document.createElement( "div" );
      var style = element.style;
      style.position = "absolute";
      style.left = "0px";
      style.top = "40px";
      style.width = "100%";
      style.height = "70px";
      style.padding = "10px";
      style.overflow = "auto";
      style.textAlign = "left";
      style.backgroundColor = "white";
      style.color = "#4a4a4a";
      style.fontSize = "14px";
      parentElement.appendChild( element );
      return element;
    },

    _createErrorBoxActionArea : function( parentElement ) {
      var element = document.createElement( "div" );
      var style = element.style;
      style.position = "absolute";
      style.left = "0px";
      style.top = "110px";
      style.width = "100%";
      style.height = "40px";
      style.padding = "10px";
      style.textAlign = "center";
      style.borderTop = "1px solid #CCCCCC";
      style.backgroundColor = "#F2F2F2";
      style.fontSize = "14px";
      parentElement.appendChild( element );
      return element;
    },

    _freezeApplication : function() {
      try {
        var display = rwt.widgets.Display.getCurrent();
        display.setExitConfirmation( null );
        //qx.io.remote.RequestQueue.getInstance().setEnabled( false );
        rwt.event.EventHandler.detachEvents();
        rwt.qx.Target.prototype.dispatchEvent = function() {};
        rwt.animation.Animation._stopLoop();
      } catch( ex ) {
        try {
          console.log( "_freezeApplication exception: " + ex );
        } catch( exTwo ) {
          // ignore
        }
      }
    },

    _unloadAllIframes : function() {
      var iframes = document.getElementsByTagName( "iframe" );
      for( var i = 0; i < iframes.length; i++ ) {
        iframes[ i ].src = rwt.remote.Connection.RESOURCE_PATH + "static/html/blank.html";
      }
    },

    _enableTextSelection : function() {
      var doc = rwt.widgets.base.ClientDocument.getInstance();
      doc.setSelectable( true );
      if( rwt.client.Client.isGecko() ) {
        var EventHandlerUtil = rwt.event.EventHandlerUtil;
        document.documentElement.removeEventListener( "mousedown",
                                                      EventHandlerUtil._ffMouseFixListener,
                                                      false );
      }
    },

    _getErrorBoxData : function( errorType ) {
      var result = {
        title : "",
        description : ""
      };
      var messages = rwt.client.ClientMessages.getInstance();
      switch( errorType ) {
        case "invalid request counter":
        case "request failed":
          result.title = messages.getMessage( "ServerError" );
          result.description = messages.getMessage( "ServerErrorDescription" );
          result.action = "<a href=\"" + this._getRestartURL() + "\">"
                        + messages.getMessage( "Restart" ) + "</a>";
          break;
        case "session timeout":
          result.title = messages.getMessage( "SessionTimeout" );
          result.description = messages.getMessage( "SessionTimeoutDescription" );
          result.action = "<a href=\"" + this._getRestartURL() + "\">"
                        + messages.getMessage( "Restart" ) + "</a>";
          break;
        case "connection error":
          result.title = messages.getMessage( "ConnectionError" );
          result.description = messages.getMessage( "ConnectionErrorDescription" );
          result.action = "<a href=\"javascript:rwt.remote.Connection.getInstance()._retry();\">"
                        + messages.getMessage( "Retry" ) + "</a>";
          break;
        case "client error":
          result.title = messages.getMessage( "ClientError" );
          result.action = messages.getMessage( "Details" );
          break;
        default:
          result.title = messages.getMessage( "ServerError" );
          result.action = "<a href=\"" + this._getRestartURL() + "\">"
                        + messages.getMessage( "Restart" ) + "</a>";
      }
      result.title = rwt.util.Encoding.replaceNewLines( result.title, "" );
      result.description = rwt.util.Encoding.replaceNewLines( result.description, "<br/>" );
      return result;
    },

    _getRestartURL : function() {
      var result = String( window.location );
      var index = result.indexOf( "#" );
      if( index != -1 ) {
        result = result.substring( 0, index );
      }
      return result;
    },

    _styleHyperlinkAsButton : function( element ) {
      var style = element.style;
      style.outline = "none";
      style.textDecoration = "none";
      style.backgroundColor = "#E8E8E8";
      style.color = "#4a4a4a";
      style.padding = "5px 15px";
      style.borderTop = "1px solid #CCCCCC";
      style.borderRight = "1px solid #333333";
      style.borderBottom = "1px solid #333333";
      style.borderLeft = "1px solid #CCCCCC";
    }

  }

} );

/*******************************************************************************
 * Copyright (c) 2013, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

namespace( "rwt.widgets.util" );

(function() {

var Variant = rwt.util.Variant;

rwt.widgets.util.CellRendererRegistry = function() {

  var Wrapper = function() {};
  var rendererMap = {};

  this.add = function( renderer ) {
    checkRenderer( renderer );
    extendRenderer( renderer );
    rendererMap[ renderer.cellType ] = renderer;
  };

  this.getRendererFor = function( type ) {
    return rendererMap[ type ] || null;
  };

  this.removeRendererFor = function( type ) {
    delete rendererMap[ type ];
  };

  this.getAll = function() {
    Wrapper.prototype = rendererMap;
    return new Wrapper();
  };

  var checkRenderer = function( renderer ) {
    if(    renderer == null
        || typeof renderer.contentType !== "string"
        || typeof renderer.cellType !== "string" )
    {
      throw new Error( "Can not register invalid renderer" );
    }
    if( rendererMap[ renderer.cellType ] != null ) {
      throw new Error( "Renderer for cellType " + renderer.cellType + " already registered" );
    }
  };

  var extendRenderer = function( renderer ) {
    var innerCreateElement = renderer.createElement || defaultCreateElement;
    renderer.createElement = function( cellData ) {
      var result = innerCreateElement( cellData );
      result.style.position = "absolute";
      result.style.overflow = "hidden";
      // NOTE : older IE can (in quirksmode) not deal with multiple css classes!
      var cssClass = cellData.selectable ? "rwt-cell-selectable" : "rwt-cell";
      if( isValidCssClass( cellData.name ) ) {
        cssClass += " " + cellData.name;
      }
      result.setAttribute( "class", cssClass );
      return result;
    };
  };

  var defaultCreateElement = function() {
    return document.createElement( "div" );
  };

  this.add( defaultTextRenderer );
  this.add( defaultImageRenderer );

};

var isValidCssClass = function( name ) {
  if( name && name.length > 1 ) {
    return    name.charAt( 0 ).match( /[a-zA-Z]/ )
           && name.match( /^[a-zA-Z0-9_\-]*$/ );
  } else {
    return false;
  }
};

rwt.widgets.util.CellRendererRegistry.getInstance = function() {
  return rwt.runtime.Singletons.get( rwt.widgets.util.CellRendererRegistry );
};

///////////////////
// default renderer

var Encoding = rwt.util.Encoding;

var escapeText = function( text, removeNewLines ) {
  var result = Encoding.escapeText( text, false );
  result = Encoding.replaceNewLines( result, removeNewLines ? "" : "<br/>" );
  result = Encoding.replaceWhiteSpaces( result );
  return result;
};

var alignmentStyleToCss = {
  "LEFT" : "left",
  "CENTER" : "center",
  "RIGHT" : "right",
  "TOP" : "top",
  "BOTTOM" : "bottom"
};

var defaultTextRenderer = {
  "cellType" : "text",
  "contentType" : "text",
  "createElement" : function( cellData ) {
    var result = document.createElement( "div" );
    result.style.textAlign = alignmentStyleToCss[ cellData.horizontalAlignment ] || "left";
    result.style.whiteSpace = cellData.wrap ? "" : "nowrap";
    result.style.textOverflow = "ellipsis";
    return result;
  },
  "renderContent" : Variant.select( "qx.client", {
    "trident" : function( element, content, cellData, options ) {
      var text = content || "";
      if( options.markupEnabled ) {
        if( element.rap_Markup !== text ) {
          element.innerHTML = text;
          element.rap_Markup = text;
        }
      } else if( options.seeable ) {
        if( options.removeNewLines ) {
          text = Encoding.replaceNewLines( text, "" );
        }
        element.innerText = text; // considerably faster than innerHTML
      } else {
        element.innerHTML = escapeText( text, options.removeNewLines );
      }
    },
    "default" : function( element, content, cellData, options ) {
      var text = content || "";
      if( options.markupEnabled ) {
        if( text !== element.rap_Markup ) {
          element.innerHTML = text;
          element.rap_Markup = text;
        }
      } else {
        element.innerHTML = escapeText( text, options.removeNewLines );
      }
    }
  } )
};

var defaultImageRenderer = {
  "cellType" : "image",
  "contentType" : "image",
  "renderContent" : function( element, content, cellData, options ) {
    var opacity = options.enabled ? 1 : 0.3;
    var src = content ? content[ 0 ] : null;
    rwt.html.Style.setBackgroundImage( element, src );
    element.style.opacity = opacity;
  },
  "createElement" : function( cellData ) {
    var result = document.createElement( "div" );
    rwt.html.Style.setBackgroundRepeat( result, "no-repeat" );
    var position = [ "center", "center" ];
    if( cellData.scaleMode === "FIT" ) {
      rwt.html.Style.setBackgroundSize( result, "contain" );
    } else if( cellData.scaleMode === "FILL" ) {
      rwt.html.Style.setBackgroundSize( result, "cover" );
    } else if( cellData.scaleMode === "STRETCH" ) {
      rwt.html.Style.setBackgroundSize( result, "100% 100%" );
    } else {
      position[ 0 ] = alignmentStyleToCss[ cellData.horizontalAlignment ] || "center";
      position[ 1 ] = alignmentStyleToCss[ cellData.verticalAlignment ] || "center";
    }
    rwt.html.Style.setBackgroundPosition( result, position.join( " " ) );
    return result;
  }
};

}() );

/*******************************************************************************
 * Copyright (c) 2011, 2015 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

(function( $ ){

rwt.qx.Class.define( "rwt.widgets.base.GridRowContainer", {
  extend : rwt.widgets.base.VerticalBoxLayout,

  construct : function() {
    this.base( arguments );
    this.$rows = $( "<div>" ).css( fillLayout ).appendTo( this );
    this.$el = $( this );
    this.setOverflow( "hidden" );
    this._scrollLeft = 0;
    this._rowHeight = 16;
    this._rowWidth = 0;
    this._horzGridBorder = null;
    this._rowBorder = null;
    this._baseAppearance = null;
    this._topItem = null;
    this._vertGridLines = [];
    this._vertGridBorder = null;
    this._renderTime = null;
    this._topItemIndex = 0;
    this._items = [];
    this._asyncQueue = {};
    this._asyncTimer = new rwt.client.Timer( 0 );
    this._asyncTimer.addEventListener( "interval", this._onAsyncTimer, this );
    this._hoverItem = null;
    this._hoverTargetType = [];
    this._config = rwt.widgets.base.GridRowContainer.createRenderConfig();
    this.addEventListener( "elementOver", this._onElementOver, this );
    this.addEventListener( "elementOut", this._onElementOut, this );
  },

  destruct : function() {
    while( this.getRowCount() > 0 ) {
      this.getRow( 0 ).dispose();
    }
    this._rowBorder = null;
    this._topItem = null;
    this._renderTime = null;
    this._items = null;
    this._hoverItem = null;
    this._hoverTargetType = null;
    this._asyncTimer.dispose();
    this._asyncTimer = null;
  },

  statics : {

    createRenderConfig : function() {
      return {
        "textColor" : null,
        "font" : null,
        "enabled" : true,
        "seeable" : false,
        "focused" : false,
        "linesVisible" : false,
        "fullSelection" : false,
        "hideSelection" : false,
        "alwaysHideSelection" : false,
        "autoHeight" : false,
        "variant" : null,
        "selectionPadding" : null,
        "indentionWidth" : 16,
        "hasCheckBoxes" : false,
        "checkBoxLeft" : null,
        "checkBoxWidth" : null,
        "columnCount" : 0,
        "treeColumn" : 0,
        "alignment" : [],
        "wordWrap" : [],
        "itemLeft" : [],
        "itemWidth" : [],
        "itemImageLeft" : [],
        "itemImageWidth" : [],
        "itemTextLeft" : [],
        "itemTextWidth" : [],
        "itemCellCheck" : [],
        "itemCellCheckLeft" : [],
        "itemCellCheckWidth" : []
      };
    }

  },

  members : {

    /////////////
    // Public API

    setTopItem : function( item, index, render ) {
      this._topItem = item;
      if( render ) {
        var delta = index - this._topItemIndex;
        this._topItemIndex = index;
        var forwards = delta > 0;
        delta = Math.abs( delta );
        if( delta >= this.getRowCount() ) {
          this._renderAll( true );
        } else {
          var numberOfShiftingRows = this.getRowCount() - delta;
          var updateFromRow = forwards ? numberOfShiftingRows : 0;
          var newFirstRow = this.getRow( forwards ? delta : numberOfShiftingRows );
          this._sortRows( newFirstRow, forwards );
          this._updateRows( updateFromRow, delta, true );
        }
        this._checkHoverItem();
      } else {
        this._topItemIndex = index;
      }
    },

    /**
     * Returns a map with values for treeRow configuration. (see _createRenderConfig).
     * Will not be changed by TreeRow or TreeRowContainer. When doing changes renderAll must
     * be called for them take effect.
     */
    getRenderConfig : function() {
      return this._config;
    },

    /**
     * Calls this function with an item as the parameter. Expects a boolean as return value.
     */
    setSelectionProvider : function( func, context ) {
      this._selectionProvider = [ func, context ];
    },

    setBaseAppearance : function( value ) {
      this._baseAppearance = value;
    },

    // TODO [tb] : the rest of the setters could be refactored to "update" functions using _config.

    setRowWidth : function( width ) {
      this._rowWidth = width;
      this.$rows.css( "width", width );
      this._forEachRow( function( row ) {
        row.setWidth( width );
      } );
    },

    setRowHeight : function( height ) {
      this._rowHeight = height;
      this._forEachRow( function( row ) {
        row.setHeight( height );
      } );
      this._updateRowCount();
    },

    setCellToolTipsEnabled : function( value ) {
      this._cellToolTipsEnabled = value;
      if( value ) {
        this.setToolTipText( "" );
      } else {
        this.resetToolTipText();
      }
    },

    getCellToolTipsEnabled : function() {
      return this._cellToolTipsEnabled;
    },

    requestToolTipText : function() {
      this.dispatchSimpleEvent( "renderCellToolTip", this._hoverRow, true );
    },

    getToolTipTargetBounds : function() {
      return rwt.widgets.util.GridCellToolTipSupport.getCurrentToolTipTargetBounds( this._hoverRow );
    },

    updateRowLines : function() {
      var border = this._config.linesVisible ? this._getHorizontalGridBorder() : null;
      this._rowBorder = border;
      this._forEachRow( function( row ) {
        row.$el.css( "border", border );
        row.setState( "linesvisible", this._config.linesVisible );
      } );
    },

    getRowCount : function() {
      return this.$rows.prop( "childElementCount" );
    },

    getRow : function( index ) {
      return this.$rows.prop( "children" )[ index ][ "row" ];
    },

    renderAll : function() {
      this._renderAll( false );
    },

    renderItemQueue : function( queue ) {
      for( var key in queue ) {
        var item = queue[ key ];
        var index = this._items.indexOf( item );
        if( index !== -1 ) {
          this._renderRow( this.getRow( index ), item );
        }
      }
    },

    renderItem : function( item ) {
      if( this._isCreated && item != null ) {
        var row = this.findRowByItem( item );
        if( row!= null ) {
          this._renderRow( row, item );
        }
      }
    },

    renderRowHeight : function() {
      this._forEachRow( function( row ) {
        var item = this.findItemByRow( row );
        if( item != null ) {
          row.renderHeight( item, this._config );
        }
      } );
    },

    setScrollLeft : function( value ) {
      this._scrollLeft = value;
      if( this.isSeeable() ) {
        this.base( arguments, value );
      }
    },

    findRowByElement : function( target ) {
      while( target && !target.row && !target.rwtWidget ) {
        target = target.parentElement;
      }
      return target ? target.row : null;
    },

    findItemByRow : function( targetRow ) {
      var index = -1;
      var rowCount = this.getRowCount();
      for( var i = 0; i < rowCount && index === -1; i++ ) {
        if( this.getRow( i ) === targetRow ) {
          index = i;
        }
      }
      return index !== -1 ? this._items[ index ] : null;
    },

    findRowByItem : function( targetItem ) {
      var index = this._items.indexOf( targetItem );
      return index !== -1 ? this.getRow( index ) : null;
    },

    getRowIndex : function( row ) {
      return this._items.indexOf( this.findItemByRow( row ) );
    },

    getHoverItem : function() {
      return this._hoverItem;
    },

    ///////////
    // Internal

    _renderGridVertical : function() {
      var linesNeeded = this._config.linesVisible ? this._config.columnCount : 0;
      for( var i = 0; i < linesNeeded; i++ ) {
        this._renderVerticalGridline( i );
      }
      for( var i = linesNeeded; i < this._vertGridLines.length; i++ ) {
        this._removeGridLine( i );
      }
    },

    _renderVerticalGridline : function( column ) {
      var width = this._config.itemWidth[ column ];
      var left = this._config.itemLeft[ column ] + width - 1;
      if( width > 0 ) {
        var line = this._getVerticalGridline( column );
        line.style.left = left + "px";
        line.style.height = this.getHeight() + "px";
      } else {
        this._removeGridLine( column );
      }
    },

    _getVerticalGridline : function( column ) {
      if( typeof this._vertGridLines[ column ] === "undefined" ) {
        var line = document.createElement( "div" );
        line.style.zIndex = 1;
        line.style.position = "absolute";
        line.style.top = "0px";
        line.style.width = "0px";
        this._getVerticalGridBorder().renderElement( line );
        // Important: add to outer element to keep the row-to-children mapping intact
        this.$el.append( line );
        this._vertGridLines[ column ] = line;
      }
      return this._vertGridLines[ column ];
    },

    _removeGridLine : function( column ) {
      if( this._vertGridLines[ column ] ) {
        $( this._vertGridLines[ column ] ).detach();
        delete this._vertGridLines[ column ];
      }
    },

    _getVerticalGridBorder : function() {
      if( this._vertGridBorder === null ) {
        this._vertGridBorder = this._getGridBorder( { "vertical" : true } );
      }
      return this._vertGridBorder;
    },

    _getHorizontalGridBorder : function() {
      if( this._horzGridBorder === null ) {
        this._horzGridBorder = this._getGridBorder( { "horizontal" : true } );
      }
      return this._horzGridBorder;
    },

    _getGridBorder : function( state ) {
      if( this._config.rowTemplate ) {
        state.rowtemplate = true;
      }
      var tvGrid = new rwt.theme.ThemeValues( state );
      var cssElement = rwt.util.Strings.toFirstUp( this._baseAppearance ) + "-GridLine";
      var gridColor = tvGrid.getCssColor( cssElement, "color" );
      tvGrid.dispose();
      var borderWidths = [ 0, 0, 0, 0 ];
      gridColor = gridColor == "undefined" ? "transparent" : gridColor;
      if( state.horizontal ) {
        borderWidths[ 2 ] = 1;
      } else if( state.vertical ) {
        borderWidths[ 1 ] = 1;
      }
      return new rwt.html.Border( borderWidths, "solid", gridColor );
    },

    _getRowAppearance : function() {
      return this._baseAppearance + "-row";
    },

    ////////////
    // Internals

    _renderAll : function( contentOnly ) {
      if( !contentOnly ) {
        this._renderGridVertical();
      }
      this._updateRows( 0, this.getRowCount(), contentOnly );
    },

    _updateRowCount : function() {
      var rowsNeeded = Math.round( ( this.getHeight() / this._rowHeight ) + 0.5 );
      while( this.getRowCount() < rowsNeeded ) {
        var row = new rwt.widgets.base.GridRow();
        row.setAppearance( this._getRowAppearance() );
        row.$el.css( {
          "zIndex": 0,
          "width": this._rowWidth,
          "height": this._rowHeight,
          "border": this._rowBorder
        } );
        row.setState( "linesvisible", this._config.linesVisible );
        this.$rows.append( row.$el );
      }
      while( this.getRowCount() > rowsNeeded ) {
        this.getRow( this.getRowCount() - 1 ).dispose();
      }
      this._items.length = this.getRowCount();
      this._updateRowsEvenState();
    },

    _updateRowsEvenState: function() {
      this._forEachRow( function( row, i ) {
        row.updateEvenState( this._topItemIndex + i );
      } );
    },

    _updateRows : function( from, delta, contentOnly ) {
      this._updateRowsEvenState();
      var item = this._topItem;
      var to = from + delta;
      var rowIndex = 0;
      while( item != null && rowIndex < this.getRowCount() ) {
        this._items[ rowIndex ] = item;
        if( rowIndex >= from && rowIndex <= to ) {
          this._renderRow( this.getRow( rowIndex ), item, contentOnly );
        }
        item = item.getNextItem();
        rowIndex++;
      }
      for( var i = rowIndex; i < this.getRowCount(); i++ ) {
        this._renderRow( this.getRow( i ), null, contentOnly );
        this._items[ i ] = null;
      }
    },

    _renderRow : function( row, item, contentOnly ) {
       row.renderItem( item,
                       this._config,
                       this._isSelected( item ),
                       this._getHoverElement( item ),
                       contentOnly );
    },

    _sortRows : function( newFirstRow, forwards ) {
      var lastRowIndex = this.getRowCount() - 1;
      while( this.getRow( 0 ) !== newFirstRow ) {
        if( forwards ) {
          this.$rows.append( this.getRow( 0 ).$el );
          this._items.push( this._items.shift() );
        } else {
          this.$rows.prepend( this.getRow( lastRowIndex ).$el );
          this._items.unshift( this._items.pop() );
        }
      }
    },

    _checkHoverItem : function() {
      var x = rwt.event.MouseEvent.getClientX();
      var y = rwt.event.MouseEvent.getClientY();
      var element = rwt.event.EventHandlerUtil.getElementAt( x, y );
      var row = this.findRowByElement( element );
      if( this._hoverRow !== row ) {
        this._onRowOver( row, element );
      }
    },

    _onElementOver : function( event ) {
      var element = event.getDomTarget();
      this._onRowOver( this.findRowByElement( element ), element );
    },

    _onElementOut : function( event ) {
      var target = event.getDomEvent();
      var related = rwt.event.EventHandlerUtil.getRelatedTargetObjectFromEvent( target );
      if( !this.findRowByElement( related ) ) {
        this._hoverTargetType = [];
        this._setHoverItem( null, null );
      }
    },

    _onRowOver : function( row, element ) {
      if( row ) {
        var item = this.findItemByRow( row );
        var targetTypes = row.identify( element );
        if( item !== this._hoverItem || this._hoverTargetType[ 0 ] !== targetTypes[ 0 ] ) {
          this._hoverTargetType = targetTypes;
          this._setHoverItem( item, row );
        }
      }
    },

    _setHoverItem : function( item, row ) {
      var oldItem = this._hoverItem;
      this._hoverItem = item;
      this._hoverRow = row || ( item ? this.findRowByItem( item ) : null );
      if( oldItem !== item ) {
        this.dispatchSimpleEvent( "hoverItem", item );
        this.dispatchSimpleEvent( "updateToolTip", this );
        this._renderAsync( oldItem );
      }
      this._renderAsync( item );
    },

    _getHoverElement : function( item ) {
      var result = null;
      if( this._hoverItem === item ) {
        result = this._hoverTargetType;
      }
      return result;
    },

    _renderAsync : function( item ) {
      // async rendering needed in some cases where webkit (and possibly other browser) get confused
      // when changing dom-elements in "mouseover" events
      if( item !== null ) {
        this._asyncQueue[ item.toHashCode() ] = item;
        this._asyncTimer.start();
      }
    },

    _onAsyncTimer : function() {
      this._asyncTimer.stop();
      this.renderItemQueue( this._asyncQueue );
      this._asyncQueue = {};
    },

    _isSelected : function( item ) {
      return this._selectionProvider[ 0 ].call( this._selectionProvider[ 1 ], item );
    },

    _forEachRow : function( fn ) {
      var rowCount = this.getRowCount();
      for( var i = 0; i < rowCount; i++ ) {
        fn.call( this, this.getRow( i ), i );
      }
    },

    //////////////
    // Overwritten

    _applyHeight : function( value, oldValue ) {
      this.base( arguments, value, oldValue );
      this._updateRowCount();
    },

    _afterAppear : function() {
      this.base( arguments );
      this.setScrollLeft( this._scrollLeft );
    },

    supportsDrop : function() {
      return true;
    }

  }
} );

var fillLayout = {
  "position" : "absolute",
  "left" : 0,
  "top" : 0,
  "height" : "100%"
};

}( rwt.util._RWTQuery ));

/*******************************************************************************
 * Copyright (c) 2011, 2014 Innoopract Informationssysteme GmbH and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Innoopract Informationssysteme GmbH - initial API and implementation
 *    EclipseSource - ongoing development
 ******************************************************************************/

namespace( "rwt.widgets.util" );

rwt.widgets.util.GridRowContainerWrapper = function() {
  this._fixedColumns = 0;
  this._container = [];
  this._container[ 0 ] = new rwt.widgets.base.GridRowContainer();
  this._container[ 1 ] = new rwt.widgets.base.GridRowContainer();
  this._config = rwt.widgets.base.GridRowContainer.createRenderConfig();
  this._width = 0;
  this._splitOffset = 0;
  this._rowWidth = 0;
  this.addEventListener( "hoverItem", this._onHoverItem, this );
};

rwt.widgets.util.GridRowContainerWrapper.createInstance = function() {
  if( !this.prototype._protoInit ) {
    for( var i = 0; i < this._CONTAINER_DELEGATES.length; i++ ) {
      this._createContainerDelegater( this._CONTAINER_DELEGATES[ i ] );
    }
    for( var i = 0; i < this._CONTAINER_GETTER_DELEGATES.length; i++ ) {
      this._createContainerGetterDelegater( this._CONTAINER_GETTER_DELEGATES[ i ] );
    }
    this.prototype._protoInit = true;
  }
  return new rwt.widgets.util.GridRowContainerWrapper();
};

rwt.widgets.util.GridRowContainerWrapper._createContainerDelegater = function( funcName ) {
  this.prototype[ funcName ] = function() {
    this._container[ 0 ][ funcName ].apply( this._container[ 0 ], arguments );
    this._container[ 1 ][ funcName ].apply( this._container[ 1 ], arguments );
  };
};

rwt.widgets.util.GridRowContainerWrapper._createContainerGetterDelegater = function( funcName ) {
  this.prototype[ funcName ] = function() {
    return this._container[ 0 ][ funcName ].apply( this._container[ 0 ], arguments );
  };
};

rwt.widgets.util.GridRowContainerWrapper._CONTAINER_DELEGATES = [
  "setParent",
  "destroy",
  "addEventListener",
  "removeEventListener",
  "setSelectionProvider",
  "setHeight",
  "setTop",
  "setBackgroundColor",
  "setBackgroundImage",
  "setRowHeight",
  "setTopItem",
  "renderItem",
  "setToolTip",
  "renderItemQueue",
  "setBaseAppearance",
  "setCellToolTipsEnabled",
  "getRow",
  "setToolTipText"
];

rwt.widgets.util.GridRowContainerWrapper._CONTAINER_GETTER_DELEGATES = [
  "getTop",
  "getHeight",
  "getHoverItem",
  "getElement",
  "getChildrenLength",
  "getRowCount"
];

rwt.widgets.util.GridRowContainerWrapper.prototype = {

  _protoInit : false,

  ///////////////////
  // Wrapper-only API

  getSubContainer : function( pos ) {
    return this._container[ pos ] || null;
  },

  setFixedColumns : function( value ) {
    this._fixedColumns = value;
    this._updateConfig();
  },

  getFixedColumns : function() {
    return this._fixedColumns;
  },

  /////////////////////////////////////////////
  // New Implementation of TreeRowContainer API

  getRenderConfig : function() {
    return this._config;
  },

  setPostRenderFunction : function() {
    // TODO [tb] : Dummy!
  },

  setWidth : function( value ) {
    this._width = value;
    this._layoutX();
  },

  getWidth : function() {
    return this._width;
  },

  setRowWidth : function( value ) {
    this._rowWidth = value;
    this._layoutX();
  },

  setScrollLeft : function( value ) {
    this._container[ 1 ].setScrollLeft( value );
  },

  findItemByRow : function( row ) {
    var result = this._container[ 0 ].findItemByRow( row );
    if( result == null ) {
      result = this._container[ 1 ].findItemByRow( row );
    }
    return result;
  },

  findRowByElement : function( el ) {
    var result = this._container[ 0 ].findRowByElement( el );
    if( result == null ) {
      result = this._container[ 0 ].findRowByElement( el );
    }
    return result;
  },

  updateRowLines : function() {
    this._container[ 0 ].getRenderConfig().linesVisible = this._config.linesVisible;
    this._container[ 0 ].updateRowLines();
    this._container[ 1 ].getRenderConfig().linesVisible = this._config.linesVisible;
    this._container[ 1 ].updateRowLines();
  },

  renderAll : function() {
    this._updateConfig();
    this._container[ 0 ].renderAll();
    this._container[ 1 ].renderAll();
  },

  getSplitOffset : function( column ) {
    return column < this._fixedColumns ? 0 : this._splitOffset;
  },

  getRowIndex : function( row ) {
    var index = this._container[ 0 ].getRowIndex( row );
    if( index < 0 ) {
      index = this._container[ 1 ].getRowIndex( row );
    }
    return index;
  },

  _updateConfig : function() {
    var configLeft = this._container[ 0 ].getRenderConfig();
    var configRight = this._container[ 1 ].getRenderConfig();
    this._copyConfigToSubContainer( configLeft, configRight );
    configLeft.containerNumber = 0;
    configRight.containerNumber = 1;
    configRight.hasCheckBoxes = false;
    var columnOrder = this._getColumnOrder();
    var rightColumnsOffset = this._computeRightColumnsOffset( columnOrder );
    for( var i = 0; i < columnOrder.length; i++ ) {
      var column = columnOrder[ i ];
      if( i < this._fixedColumns ) {
        configRight.itemWidth[ column ] = 0;
      } else {
        configLeft.itemWidth[ column ] = 0;
        configRight.itemLeft[ column ] -= rightColumnsOffset;
        configRight.itemImageLeft[ column ] -= rightColumnsOffset;
        configRight.itemTextLeft[ column ] -= rightColumnsOffset;
      }
    }
    if( this._splitOffset !== rightColumnsOffset ) {
      this._splitOffset = rightColumnsOffset;
      this._layoutX();
    }
  },

  _copyConfigToSubContainer : function( configLeft, configRight ) {
    for( var key in this._config ) {
      if( this._config[ key ] instanceof Array ) {
        configLeft[ key ] = this._config[ key ].concat();
        configRight[ key ] = this._config[ key ].concat();
      } else {
        configLeft[ key ] = this._config[ key ];
        configRight[ key ] = this._config[ key ];
      }
    }
  },

  _computeRightColumnsOffset : function( columnOrder ) {
    var rightColumnsOffset = 0;
    if( columnOrder.length > this._fixedColumns ) {
      rightColumnsOffset = this._config.itemLeft[ columnOrder[ this._fixedColumns ] ];
    } else {
      rightColumnsOffset = this._width;
    }
    return rightColumnsOffset;
  },

  _layoutX : function() {
    var leftWidth = Math.min( this._splitOffset, this._width );
    this._container[ 0 ].setWidth( leftWidth );
    this._container[ 0 ].setRowWidth( leftWidth );
    this._container[ 1 ].setLeft( leftWidth );
    this._container[ 1 ].setWidth( this._width - leftWidth );
    this._container[ 1 ].setRowWidth( this._rowWidth - leftWidth );
  },

  _getColumnOrder : function() {
    var result = [];
    var offsets = this._config.itemLeft.concat();
    var sorted = offsets.concat().sort( function( a, b ){ return a - b; } );
    for( var i = 0; i < sorted.length; i++ ) {
      var pos = offsets.indexOf( sorted[ i ] );
      result[ i ] = pos;
      offsets[ pos ] = null; // TODO [tb] : test
    }
    return result;
  },

  _onHoverItem : function( item ) {
    for( var i = 0; i < this._container.length; i++ ) {
      this._container[ i ]._setHoverItem( item );
    }
  },

  findRowByItem : function( item, column ) {
    var pos = column < this._fixedColumns ? 0 : 1;
    return this._container[ pos ].findRowByItem( item );
  }

};

/*******************************************************************************
 * Copyright (c) 2011, 2014 Innoopract Informationssysteme GmbH and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Innoopract Informationssysteme GmbH - initial API and implementation
 *    EclipseSource - ongoing development
 ******************************************************************************/

namespace( "rwt.widgets.util" );

rwt.widgets.util.GridUtil = {

  /////////////////
  // API for Server

  setFixedColumns : function( tree, value ) {
    var container = tree.getRowContainer();
    if( container.setFixedColumns ) {
      container.setFixedColumns( value );
      tree.update();
    }
  },

  ///////////////
  // API for Grid

  createTreeRowContainer : function( argsmap ) {
    var result;
    if( argsmap.splitContainer ) {
      result = rwt.widgets.util.GridRowContainerWrapper.createInstance();
    } else {
      result = new rwt.widgets.base.GridRowContainer();
    }
    return result;
  },

  getColumnByPageX : function( grid, pageX ) {
    var container = grid.getRowContainer();
    var splitContainer = container instanceof rwt.widgets.util.GridRowContainerWrapper;
    if( splitContainer ) {
      container = grid.getRowContainer().getSubContainer( 0 );
    }
    var result = this._getColumnByPageX( container, pageX );
    if( result === -1 && splitContainer ) {
      container = grid.getRowContainer().getSubContainer( 1 );
      result = this._getColumnByPageX( container, pageX );
    }
    return result;
  },

  ////////////
  // Internals

  _getColumnByPageX : function( container, pageX ) {
    var config = container.getRenderConfig();
    var columnCount = config.columnCount;
    var columnIndex = columnCount === 0 ? 0 : -1;
    var element = container.getRow( 0 ).$el.get( 0 );
    var leftOffset = rwt.html.Location.getLeft( element );
    for( var i = 0; columnIndex == -1 && i < columnCount; i++ ) {
      var pageLeft = leftOffset + config.itemLeft[ i ];
      if( pageX >= pageLeft && pageX < pageLeft + config.itemWidth[ i ] ) {
        columnIndex = i;
      }
    }
    return columnIndex;
  }

};

/*******************************************************************************
 * Copyright (c) 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

namespace( "rwt.widgets.util" );

rwt.widgets.util.GridSynchronizer = function( grid ) {
  this._grid = grid;
  this._grid.addEventListener( "selectionChanged", this._onSelectionChanged, this );
  this._grid.addEventListener( "focusItemChanged", this._onFocusItemChanged, this );
  this._grid.addEventListener( "topItemChanged", this._onTopItemChanged, this );
  this._grid.addEventListener( "scrollLeftChanged", this._onScrollLeftChanged, this );
  this._grid.getRootItem().addEventListener( "update", this._onItemUpdate, this );
};

rwt.widgets.util.GridSynchronizer.prototype = {

  _onSelectionChanged : function( event ) {
    if( !rwt.remote.EventUtil.getSuspended() ) {
      var item = event.item;
      var type = event.type;
      var connection = rwt.remote.Connection.getInstance();
      if( type === "selection" ) {
        connection.getRemoteObject( this._grid ).set( "selection", this._getSelectionList() );
      } else if( type === "check" ) {
        connection.getRemoteObject( item ).set( "checked", item.isChecked() );
      } else if( type === "cellCheck" ) {
        connection.getRemoteObject( item ).set( "cellChecked", this._getCellChecked( item ) );
      }
      this._notifySelectionChanged( event );
    }
  },

  _notifySelectionChanged : function( event ) {
    var detail;
    var type = event.type;
    if( type === "check" || type === "cellCheck") {
      detail = "check";
    } else if( type === "cell" ) {
      detail = "cell";
    } else if( type === "hyperlink" ) {
      detail = "hyperlink";
    }
    var properties = {
      "item" : this._getItemId( event.item ),
      "detail" : detail,
      "index" : event.index,
      "text" : event.text
    };
    if( type === "defaultSelection" ) {
      rwt.remote.EventUtil.notifyDefaultSelected( this._grid, properties );
    } else {
      rwt.remote.EventUtil.notifySelected( this._grid, properties );
    }
  },

  _onFocusItemChanged : function() {
    if( !rwt.remote.EventUtil.getSuspended() ) {
      var connection = rwt.remote.Connection.getInstance();
      var itemId = this._getItemId( this._grid.getFocusItem() );
      connection.getRemoteObject( this._grid ).set( "focusItem", itemId );
    }
  },

  _onTopItemChanged : function() {
    if( !rwt.remote.EventUtil.getSuspended() ) {
      var vScroll = this._grid.getVerticalBar();
      var connection = rwt.remote.Connection.getInstance();
      var remoteObject = connection.getRemoteObject( this._grid );
      remoteObject.set( "topItemIndex", this._grid.getTopItemIndex() );
      if( vScroll.getHasSelectionListener() ) {
        connection.onNextSend( function() {
          connection.getRemoteObject( vScroll ).notify( "Selection" );
        }, this );
      }
      if( remoteObject.isListening( "SetData" ) ) {
        connection.onNextSend( function() {
          remoteObject.notify( "SetData" );
        }, this );
      }
      if( vScroll.getHasSelectionListener() || remoteObject.isListening( "SetData" ) ) {
        connection.sendDelayed( 400 );
      }
    }
  },

  _onScrollLeftChanged : function() {
    // TODO [tb] : There should be a check for suspended,
    // but currently this is needed to sync the value with the
    // server when the scrollbars are hidden by the server.
    var hScroll = this._grid.getHorizontalBar();
    var connection = rwt.remote.Connection.getInstance();
    var remoteObject = connection.getRemoteObject( this._grid );
    remoteObject.set( "scrollLeft", hScroll.getValue() );
    if( hScroll.getHasSelectionListener() ) {
      connection.onNextSend( function() {
        connection.getRemoteObject( hScroll ).notify( "Selection" );
      }, this );
      connection.sendDelayed( 400 );
    }
  },

  _onItemUpdate : function( event ) {
    if( !rwt.remote.EventUtil.getSuspended() || event.rendering ) {
      var connection = rwt.remote.Connection.getInstance();
      if( event.msg === "height" ) {
        connection.getRemoteObject( event.target ).set( "height", event.target.getOwnHeight() );
      } else if( event.msg === "expanded" || event.msg === "collapsed" ) {
        var expanded = event.msg === "expanded";
        connection.getRemoteObject( event.target ).set( "expanded", expanded );
        connection.getRemoteObject( this._grid ).notify( expanded ? "Expand" : "Collapse", {
          "item" : this._getItemId( event.target )
        } );
      }
    }
  },

  _getSelectionList : function() {
    var result = [];
    var selection = this._grid.getSelection();
    for( var i = 0; i < selection.length; i++ ) {
      result.push( this._getItemId( selection[ i ] ) );
    }
    return result;
  },

  _getCellChecked : function( item ) {
    var cellChecked = item.getCellChecked();
    var result = [];
    for( var i = 0; i < this._grid.getRenderConfig().columnCount; i++ ) {
      result[ i ] = cellChecked[ i ] === true;
    }
    return result;
  },

  _getItemId : function( item ) {
    var ObjectRegistry = rwt.remote.ObjectRegistry;
    var result;
    if( item.isCached() ) {
      result = ObjectRegistry.getId( item );
    } else {
      var parent = item.getParent();
      if( parent.isRootItem() ) {
        result = ObjectRegistry.getId( this._grid );
      } else {
        result = ObjectRegistry.getId( parent );
      }
      result += "#" + parent.indexOf( item );
    }
    return result;
  }

};

/*******************************************************************************
 * Copyright (c) 2010, 2014 Innoopract Informationssysteme GmbH and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Innoopract Informationssysteme GmbH - initial API and implementation
 *    EclipseSource - ongoing development
 ******************************************************************************/

/**
 * Represents a visible TreeItem.
 */

(function( $ ) {

var cellRenderer = rwt.widgets.util.CellRendererRegistry.getInstance().getAll();

rwt.qx.Class.define( "rwt.widgets.base.GridRow", {

  extend : rwt.qx.Target,

  construct : function() {
    this.base( arguments );
    this.$el = $( "<div>" ).css( {
      "overflow" : "hidden",
      "userSelect" : "none",
      "height" : 16,
      "position" : "relative"
    });
    this.$el.prop( "row", this );
    this._styleMap = {};
    this._appearance = null;
    this._overlayStyleMap = {};
    this._elementStyleCache = {};
    this._variant = null;
    this.$expandIcon = null;
    this.$checkBox = null;
    this.$overlay = null;
    this.$treeColumnParts = [];
    this._lastAttributes = {};
    this.$cellLabels = [];
    this.$cellImages = [];
    this.$cellCheckBoxes = [];
    this.$cellBackgrounds = [];
    this.$indentIcons = [];
    this._usedIdentIcons = 0;
    this._cellsRendered = 0;
    this._templateRenderer = null;
  },

  destruct : function() {
    this.$el.removeProp( "row" ).detach();
    this.$el = null;
    this.$expandIcon = null;
    this.$checkBox = null;
    this.$treeColumnParts = null;
    this.$cellLabels = null;
    this.$cellImages = null;
    this.$cellCheckBoxes = null;
    this.$cellBackgrounds = null;
    this.$indentIcons = null;
  },

  members : {

    renderItem : function( item, config, selected, hoverTarget, scrolling ) {
      this._usedIdentIcons = 0;
      if( item !== null ) {
        var renderSelected = this._renderAsSelected( config, selected );
        this._renderStates( item, config, renderSelected, hoverTarget );
        this._renderBackground( item, config, renderSelected );
        // TODO [tb] : item foreground and font could be inherited
        this._renderItemForeground( item, config );
        this._renderItemFont( item, config );
        if( config.treeColumn !== -1 ) {
          this._renderIndention( item, config, hoverTarget );
        }
        if( config.rowTemplate ) {
          this.renderHeight( item, config );
          this._renderTemplate( item, config );
        } else {
          this._renderColumnModel( item, config, hoverTarget, renderSelected, scrolling );
          this.renderHeight( item, config );
        }
        this._renderOverlay( item, config );
        this._hideRemainingElements();
      } else {
        var contentOnly = scrolling || !config;
        this.$el.css( {
          "backgroundColor" : "",
          "backgroundImage" : "",
          "backgroundGradient" : ""
       } );
        if( config.rowTemplate ) {
          this._renderTemplate( null, config );
          this._hideRemainingElements();
        } else {
          this._clearContent( config );
          if( !contentOnly ) {
            this._renderAllBounds( config );
          }
        }
      }
      this._renderHtmlAttributes( item, config );
      this.dispatchSimpleEvent( "itemRendered", item );
    },

    identify : function( node ) {
      var result = [ "other" ];
      var match = function( candidate ) {
        return candidate != null && candidate.is( node );
      };
      if( match( this.$expandIcon ) ) {
        result = [ "expandIcon" ];
      } else if( match( this.$checkBox ) ) {
        result = [ "checkBox" ];
      } else if( this.$cellCheckBoxes.some( match ) ) {
        var cell = this.$cellCheckBoxes.filter( match )[ 0 ];
        result = [ "cellCheckBox", this.$cellCheckBoxes.indexOf( cell ) ];
      } else {
        while( !this.$el.is( node ) && result[ 0 ] === "other" ) { // Can be removed?
          if( this.$treeColumnParts.some( match ) ) {
            result = [ "treeColumn" ]; // TODO [tb] : now should be [ "label", 0 ] / [ "image", 0 ]
          } else if( this._templateRenderer ) {
            if( this._templateRenderer.isCellSelectable( node ) ) {
              result = [ "selectableCell", this._templateRenderer.getCellName( node ) ];
            }
          }
          node = node.parentNode;
        }
      }
      return result;
    },

    updateEvenState : function( index ) {
      this.setState( "even", index % 2 === 0 );
    },

    setAppearance : function( appearance ) {
      this._appearance = appearance;
    },

    getAppearance : function() {
      return this._appearance;
    },

    setWidth : function( width ) {
      this.$el.css( "width", width );
    },

    setHeight : function( height ) {
      this.$el.css( "height", height );
    },

    getTop : function() {
      return this.$el.get( 0 ).offsetTop;
    },

    getWidth : function() {
      // Do NOT use anything like offsetWidth/outerWidth/clientRectBounds for this, it would
      // force rendering and potentially impact performance!
      return parseInt( this.$el.css( "width" ) || "0" );
    },

    getHeight : function() {
      return parseInt( this.$el.css( "height" ) || "0" );
    },

    ////////////
    // internals

    _renderColumnModel : function( item, config, hoverTarget, renderSelected, contentOnly ) {
      this._renderCheckBox( item, config, hoverTarget, contentOnly );
      this._renderCells( item, config, renderSelected, hoverTarget, contentOnly );
    },

    _renderTemplate : function( item, config ) {
      var hasIndention =    item
                         && typeof config.treeColumn === "number"
                         && config.treeColumn > -1;
      var xOffset = hasIndention ? this._correctOffset( 0, item, config ) : 0;
      var renderer = this._getTemplateRenderer( config );
      renderer.targetBounds = [ xOffset, 0, this.getWidth() - xOffset, this.getHeight() ];
      renderer.markupEnabled = config.markupEnabled;
      renderer.targetIsEnabled = config.enabled;
      renderer.targetIsSeeable = config.seeable;
      renderer.renderItem( item );
    },

    _getTemplateRenderer : function( config ) {
      if( this._templateRenderer == null ) {
        this._templateRenderer = new rwt.widgets.util.TemplateRenderer(
          config.rowTemplate,
          this.$el.get( 0 ),
          100
        );
      }
      return this._templateRenderer;
    },

    renderHeight : function( item, config ) {
      if( config.autoHeight ) {
        var computedHeight = this._computeAutoHeight( item, config );
        if( item.getDefaultHeight() >= computedHeight - 1 ) {
          // forgive rounding error for network optimization
          computedHeight = null;
        }
        item.setHeight( computedHeight, true );
      }
      var itemHeight = item.getOwnHeight();
      if( itemHeight !== this.getHeight() ) {
        this.$el.css( "height", item.getOwnHeight() );
      }
    },

    _computeAutoHeight : function( item, config ) {
      var maxHeight = 0;
      for( var i = 0; i < this.$cellLabels.length; i++ ) {
        if( this.$cellLabels[ i ] ) {
          maxHeight = Math.max( maxHeight, Math.ceil( this.$cellLabels[ i ].outerHeight() ) );
        }
      }
      var padding = this._getCellPadding( config );
      return maxHeight + padding[ 0 ] + padding[ 2 ];
    },

    _renderStates : function( item, config, selected, hoverTarget ) {
      this.setState( "rowtemplate", config.rowTemplate != null );
      this.setState( "checked", item.isChecked() );
      this.setState( "grayed", item.isGrayed() );
      this.setState( "parent_unfocused", this._renderAsUnfocused( config ) );
      this.setState( "selected", config.fullSelection ? selected : false );
      this._renderVariant( item.getVariant() );
      this._renderOverState( hoverTarget, config );
      this._styleMap = this._getStyleMap();
      this.setState( "selected", selected );
      if( config.fullSelection ) {
        this._overlayStyleMap = this._getOverlayStyleMap( selected );
      } else {
        this._overlayStyleMap = this._getTreeColumnStyleMap( selected );
      }
    },

    _renderVariant : function( variant ) {
      if( this._variant != variant ) {
        if( this._variant != null ) {
          this.setState( this._variant, false );
        }
        this._variant = variant;
        if( this._variant != null ) {
          this.setState( this._variant, true );
        }
      }
    },

    _renderOverState : function( hoverTarget, config ) {
      var fullOverState = hoverTarget !== null && config.fullSelection;
      var singleOverState = hoverTarget != null && hoverTarget[ 0 ] === "treeColumn";
      this.setState( "over", fullOverState || singleOverState );
    },

    setState : function( state, value ) {
      if( !this.__states ) {
        this.__states = {};
      }
      if( value ) {
        this.__states[ state ] = true;
      } else {
        delete this.__states[ state ];
      }
    },

    hasState : function( state ) {
      return this.__states && this.__states[ state ] ? true : false;
    },

    _getStyleMap : function() {
      var manager = rwt.theme.AppearanceManager.getInstance();
      return manager.styleFrom( this._appearance, this.__states );
    },

    _getOverlayStyleMap : function() {
      var manager = rwt.theme.AppearanceManager.getInstance();
      return manager.styleFrom( this._appearance + "-overlay", this.__states );
    },

    _getTreeColumnStyleMap : function( selected ) {
      var manager = rwt.theme.AppearanceManager.getInstance();
      var overlayMap = manager.styleFrom( this._appearance + "-overlay", this.__states );
      if( selected ) {
        var rowMap = manager.styleFrom( this._appearance, this.__states );
        overlayMap.rowForeground = rowMap.foreground;
      } else {
        overlayMap.rowForeground = "undefined";
      }
      return overlayMap;
    },

    _renderBackground : function( item, config ) {
      var color = this._styleMap.background;
      var image = this._styleMap.backgroundImage;
      var gradient = this._styleMap.backgroundGradient;
      if( config.enabled !== false && item !== null && item.getBackground() !== null ) {
        color = item.getBackground();
        image = null;
        gradient = null;
      }
      // Note: "undefined" is a string stored in the themestore
      this.$el.css( {
        "backgroundColor" :  color !== "undefined" ? color || "" : "",
        "backgroundImage" : image !== "undefined" ? image || "" : "",
        "backgroundGradient" : gradient !== "undefined" || "" ? gradient : ""
      } );
    },

    _hasOverlayBackground : function( config ) {
      if( !config.fullSelection && config.rowTemplate ) {
        return false;
      }
      return    this._overlayStyleMap.background !== "undefined"
             || this._overlayStyleMap.backgroundImage !== null
             || this._overlayStyleMap.backgroundGradient !== null;
    },

    // TODO: broken on first render
    _renderIndention : function( item, config, hoverTarget ) {
      var expandSymbol = this._getExpandSymbol( item, config, hoverTarget );
      if( expandSymbol != null ) {
        this.$expandIcon = this._addIndentSymbol( item.getLevel(), config, expandSymbol );
      } else {
        this.$expandIcon = null;
      }
      var lineSymbol = this._getLineSymbol( item, config );
      if( lineSymbol != null ) {
        var parent = item.getParent();
        while( !parent.isRootItem() ) {
          if( parent.hasNextSibling() ) {
            this._addIndentSymbol( parent.getLevel(), config, lineSymbol );
          }
          parent = parent.getParent();
        }
      }
    },

    _getExpandSymbol : function( item, config, hoverTarget ) {
      var states = this._getParentStates( config );
      if( item.getLevel() === 0 && !item.hasPreviousSibling() ) {
        states.first = true;
      }
      if( !item.hasNextSibling() ) {
        states.last = true;
      }
      if( item.hasChildren() ) {
        if( item.isExpanded() ) {
          states.expanded = true;
        } else {
          states.collapsed = true;
        }
      }
      if( hoverTarget && hoverTarget[ 0 ] === "expandIcon" ) {
        states.over = true;
      }
      return this._getImageFromAppearance( "indent", states );
    },

    _getLineSymbol : function( item, config ) {
      var states = this._getParentStates( config );
      states.line = true;
      return this._getImageFromAppearance( "indent", states );
    },

    _getParentStates : function( config ) {
      var result = {};
      if( config.variant ) {
        result[ config.variant ] = true;
      }
      return result;
    },

    _getImageFromAppearance : function( image, states ) {
      var appearance = this._appearance + "-" + image;
      var manager = rwt.theme.AppearanceManager.getInstance();
      var styleMap = manager.styleFrom( appearance, states );
      var valid = styleMap && styleMap.backgroundImage;
      return valid ? styleMap.backgroundImage : null;
    },

    _addIndentSymbol : function( level, config, source ) {
      var result = null;
      var nextLevelOffset = ( level + 1 ) * config.indentionWidth;
      var cellWidth = config.itemWidth[ config.treeColumn ];
      if( nextLevelOffset <= cellWidth || config.rowTemplate ) {
        var offset = level * config.indentionWidth;
        var width = nextLevelOffset - offset;
        var element = this._getIndentImage();
        this._setImage( element, source, config.enabled );
        element.css( { "left" : offset, "top" : 0, "width" : width, "height" : "100%" } );
        result = element;
      }
      return result;
    },

    _renderCheckBox : function( item, config, hoverTarget, contentOnly ) {
      if( config.hasCheckBoxes ) {
        this.setState( "over", hoverTarget && hoverTarget[ 0 ] === "checkBox" );
        this.setState( "disabled", !item.isCellCheckable( 0 ) );
        var image = this._getImageFromAppearance( "check-box", this.__states );
        this.setState( "over", hoverTarget !== null );
        this.setState( "disabled", false );
        if( this.$checkBox === null ) {
          this.$checkBox = this._createElement( 3 ).css( {
            "backgroundRepeat" : "no-repeat",
            "backgroundPosition" : "center"
          } );
        }
        this.$checkBox.css( "display", image === null ? "none" : "" );
        this._setImage( this.$checkBox, image, config.enabled );
        if( config.treeColumn !== -1 || !contentOnly ) {
          var left = this._getCheckBoxLeft( item, config );
          var width = this._getCheckBoxWidth( item, config );
          this.$checkBox.css( { "left" : left, "top" : 0, "width" : width, "height" : "100%" } );
        }
      }
    },

    _renderCells : function( item, config, selected, hoverTarget, contentOnly ) {
      var columns = this._getColumnCount( config );
      if( this._cellsRendered > columns ) {
        this._removeCells( columns, this._cellsRendered );
      }
      for( var i = 0; i < columns; i++ ) {
        var isTreeColumn = this._isTreeColumn( i, config );
        if( this._getItemWidth( item, i, config ) > 0 ) {
          this._renderCellBackground( item, i, config, contentOnly );
          this._renderCellCheckBox( item, i, config, isTreeColumn, contentOnly, hoverTarget );
          var imageElement = this._renderCellImage( item, i, config, isTreeColumn, contentOnly );
          var labelElement = this._renderCellLabel( item, i, config, isTreeColumn, contentOnly );
          if( !config.fullSelection && isTreeColumn ) {
            this.$treeColumnParts = [ imageElement, labelElement ];
          }
        } else {
          this._removeCell( i );
        }
      }
      this._cellsRendered = columns;
    },

    _renderOverlay : function( item, config ) {
      if( item && this._hasOverlayBackground( config ) ) {
        this._styleOverlay( item, config );
        this._layoutOverlay( item, config );
      } else if( this.$overlay ){
        this.$overlay.css( "display", "none" );
      }
    },

    _styleOverlay : function() {
      var element = this._getOverlayElement();
      var styleMap = this._overlayStyleMap;
      var gradient = styleMap.backgroundGradient;
      if( gradient ) {
        this._renderOverlayGradient( element, gradient );
      } else {
        element.css( {
          "backgroundColor" : styleMap.background,
          "opacity" : styleMap.backgroundAlpha
      } );
      }
    },

    _renderOverlayGradient : function( element, gradient ) {
      element.css( "backgroundGradient", gradient || "" );
    },

    _layoutOverlay : function( item, config ) { // TODO: broken on first render
      if( !config.fullSelection ) {
        var element = this._getOverlayElement();
        var cell = config.treeColumn;
        var padding = config.selectionPadding;
        var left = this._getItemTextLeft( item, cell, config );
        left -= padding[ 0 ];
        var width = this._getItemTextWidth( item, cell, config );
        width += width > 0 ? padding[ 0 ] : 0;
        var visualWidth  = this._getVisualTextWidth( item, cell, config );
        visualWidth  += padding[ 0 ] + padding[ 1 ];
        width = Math.min( width, visualWidth );
        element.css( { "left" : left, "width" : width } );
      }
    },

    _renderCellBackground : function( item, cell, config, contentOnly ) {
      var background = this._getCellBackgroundColor( item, cell, config );
      var renderBounds = false;
      if( background !== "undefined" && background != this._styleMap.backgroundColor ) {
        renderBounds = !contentOnly || !this.$cellBackgrounds[ cell ];
        var element = this._getBackgroundElement( cell );
        element.css( "backgroundColor", background );
      } else if( this.$cellBackgrounds[ cell ] ) {
        this.$cellBackgrounds[ cell ].css( "backgroundColor", "" );
        renderBounds = !contentOnly;
      }
      if( renderBounds ) {
        this._renderCellBackgroundBounds( item, cell, config );
      }
    },

    _renderCellBackgroundBounds : function( item, cell, config ) {
      var element = this.$cellBackgrounds[ cell ];
      if( element ) {
        var left = this._getItemLeft( item, cell, config );
        var width = this._getItemWidth( item, cell, config );
        element.css( { "left" : left, "top" : 0, "width" : width, "height" : "100%" } );
      }
    },

    _renderCellCheckBox : function( item, cell, config, isTreeColumn, contentOnly, hoverTarget ) {
      var element = null;
      var renderBounds = false;
      if( config.itemCellCheck[ cell ] ) {
        this.setState( "checked", item.isCellChecked( cell ) );
        this.setState( "disabled", !item.isCellCheckable( cell ) );
        this.setState( "grayed", item.isCellGrayed( cell ) );
        this.setState( "over",    hoverTarget
                               && hoverTarget[ 0 ] === "cellCheckBox"
                               && hoverTarget[ 1 ] === cell );
        var image = this._getImageFromAppearance( "check-box", this.__states );
        this.setState( "disabled", false );
        renderBounds = isTreeColumn || !contentOnly || !this.$cellCheckBoxes[ cell ];
        element = this._getCellCheckImage( cell );
        element.css( "display", image === null ? "none" : "" );
        this._setImage( element, image, config.enabled );
      }
      if( renderBounds ) {
        this._renderCellCheckBounds( item, cell, config );
      }
      return element;
    },

    _renderCellCheckBounds : function( item, cell, config ) {
      var element = this.$cellCheckBoxes[ cell ];
      if( element ) {
        var left = this._getCellCheckLeft( item, cell, config );
        var width = this._getCellCheckWidth( item, cell, config );
        element.css( { "left" : left, "top" : 0, "width" : width, "height" : "100%" } );
      }
    },

    _renderCellImage : function( item, cell, config, isTreeColumn, contentOnly ) {
      var source = item.getImage( cell );
      var element = null;
      var renderBounds = false;
      if( source !== null ) {
        renderBounds = isTreeColumn || !contentOnly || !this.$cellImages[ cell ];
        element = this._getCellImage( cell );
        this._setImage( element, source[ 0 ], renderBounds ? config.enabled : null );
      } else if( this.$cellImages[ cell ] ) {
        renderBounds = isTreeColumn || !contentOnly;
        element = this._getCellImage( cell );
        this._setImage( element, null, null );
      }
      if( renderBounds ) {
        this._renderCellImageBounds( item, cell, config );
      }
      return element;
    },

    _renderCellImageBounds : function( item, cell, config ) {
      var element = this.$cellImages[ cell ];
      if( element ) {
        var left = this._getItemImageLeft( item, cell, config );
        var width = this._getItemImageWidth( item, cell, config );
        element.css( { "left" : left, "top" : 0, "width" : width, "height" : "100%" } );
      }
    },

    _renderCellLabel : function( item, cell, config, isTreeColumn, contentOnly ) {
      // NOTE [tb] : When scrolling in Firefox, it may happen that the text
      //             becomes temorarily invisible. This is a browser-bug
      //             that ONLY occurs when Firebug is installed.
      var element = null;
      var renderBounds = false;
      if( item.hasText( cell ) ) {
        renderBounds = isTreeColumn || !contentOnly || !this.$cellLabels[ cell ];
        element = this._getTextElement( cell );
        this._renderElementContent( element, item, cell, config );
        if( renderBounds ) {
          element.css( "textAlign", isTreeColumn ? "left" : this._getAlignment( cell, config ) );
        }
        this._styleLabel( element, item, cell, config );
      } else if( this.$cellLabels[ cell ] ) {
        renderBounds = isTreeColumn || !contentOnly;
        element = this._getTextElement( cell );
        this._renderElementContent( element, null, -1, config );
      }
      if( renderBounds ) {
        this._renderCellLabelBounds( item, cell, config );
      }
      return element;
    },

    _renderCellLabelBounds : function( item, cell, config ) {
      var element = this.$cellLabels[ cell ];
      if( element ) {
        var left = this._getItemTextLeft( item, cell, config );
        var width = this._getItemTextWidth( item, cell, config );
        var top = this._getCellPadding( config )[ 0 ];
        // TODO : for vertical center rendering line-height should also be set,
        //        but not otherwise. Also not sure about bottom alignment.
        element.css( { "left" : left, "top" : top, "width" : width, "height" : "auto" } );
      }
    },

    _renderElementContent : function( element, item, cell, config ) {
      var options = {
        "markupEnabled" : config.markupEnabled,
        "seeable" : config.seeable,
        "removeNewLines" : true
      };
      cellRenderer.text.renderContent( element.get( 0 ),
                                       item ? item.getText( cell ) : null,
                                       null,
                                       options );
    },

    _styleLabel : function( element, item, cell, config ) {
      this._setForeground( element, this._getCellColor( item, cell, config ) );
      this._setFont( element, item.getCellFont( cell ) );
      this._setWordWrap( element, config.wordWrap[ cell ] );
    },

    _renderItemForeground : function( item, config ) {
      this._setForeground( this.$el, this._getItemColor( item, config ) );
    },

    _renderItemFont : function( item, config ) {
      if( this._elementStyleCache.font !== config.font ) {
        this._elementStyleCache.font = config.font;
        this._setFont( this.$el, config.font );
      }
      if( this._elementStyleCache.textDecoration !== this._styleMap.textDecoration ) {
        this._elementStyleCache.textDecoration = this._styleMap.textDecoration;
        this._setTextDecoration( this.$el, this._styleMap.textDecoration );
      }
      if( this._elementStyleCache.textOverflow !== this._styleMap.textOverflow ) {
        this._elementStyleCache.textOverflow = this._styleMap.textOverflow;
        this._setTextOverflow( this.$el, this._styleMap.textOverflow );
      }
      if( this._elementStyleCache.textShadow !== this._styleMap.textShadow ) {
        this._elementStyleCache.textShadow = this._styleMap.textShadow;
        this.$el.css( "textShadow", this._styleMap.textShadow || "" );
      }
    },

    _renderHtmlAttributes : function( item, config ) {
      this.$el.removeAttr( Object.keys( this._lastAttributes ).join( " " ) );
      var attributes = item ? item.getHtmlAttributes() : {};
      if( attributes[ "id" ] && config.containerNumber === 1 ) {
        attributes = rwt.util.Objects.copy( attributes );
        attributes[ "id" ] += "-1";
      }
      this.$el.attr( attributes );
      this._lastAttributes = attributes;
    },

    _getCellBackgroundColor : function( item, cell, config ) {
      var result;
      if( config.enabled === false ) {
        result = "undefined";
      } else {
        result = item.getCellBackground( cell );
      }
      return result;
    },

    _getCellColor : function( item, cell, config ) {
      var treeColumn = this._isTreeColumn( cell, config );
      var allowOverlay = config.fullSelection || treeColumn;
      var result = allowOverlay ? this._overlayStyleMap.foreground : "undefined";
      if(    result === "undefined"
          && config.enabled !== false
          && item.getCellForeground( cell )
      ) {
        result = item.getCellForeground( cell );
      }
      if( result === "undefined" && treeColumn && !config.fullSelection ) {
        // If there is no overlay the tree column foreground may still have a different color
        // due to selection. In this case _overlayStyleMap has the tree column foreground color.
        result = this._overlayStyleMap.rowForeground;
      }
       if( result === "undefined" ) {
         result = "inherit";
      }
      return result;
    },

    _getItemColor : function( item, config ) {
      var result = "undefined";
      if( config.fullSelection ) {
        result = this._overlayStyleMap.foreground;
      }
      if( result === "undefined" ) {
        result = this._styleMap.foreground;
      }
      if( result === "undefined" ) {
        result = config.textColor;
      }
      if( result === "undefined" ) {
        result = "inherit";
      }
      return result;
    },

    _getCellFont : function( item, cell, config ) {
      var result = item.getCellFont( cell );
      if( result === null || result === "" ) {
        result = config.font;
      }
      return result;
    },

    _getVisualTextWidth : function( item, cell, config ) {
      var calc = rwt.widgets.util.FontSizeCalculation;
      var result = 0;
      if( this.$cellLabels[ cell ] ) {
        var font = this._getCellFont( item, cell, config );
        var fontProps = this._getFontProps( font );
        var text = this.$cellLabels[ cell ].html();
        var dimensions = calc.computeTextDimensions( text, fontProps );
        result = dimensions[ 0 ];
      }
      return result;
    },

    _renderAsUnfocused : function( config ) {
      return !config.focused && !this.hasState( "dnd_selected" );
    },

    _renderAsSelected : function( config, selected ) {
      return    ( selected || this.hasState( "dnd_selected" ) )
             && ( !config.hideSelection || config.focused )
             && !config.alwaysHideSelection;
    },

    _getFontProps : function( font ) {
      var result = {};
      if( font instanceof rwt.html.Font ) {
        font.renderStyle( result );
      } else {
        var fontObject = rwt.html.Font.fromString( font );
        fontObject.renderStyle( result );
        fontObject.dispose();
      }
      return result;
    },

    /////////////
    // DOM-Helper

    _setFont : function( element, font ) {
      if( font === "" || font === null ) {
        this._resetFont( element );
      } else {
        if( font instanceof rwt.html.Font ) {
          font.renderStyle( element.get( 0 ).style );
        } else {
          element.css( "font", font );
        }
      }
    },

    _resetFont : function( element ) {
      element.css( {
        "font" : "",
        "fontFamily" : "",
        "fontSize" : "",
        "fontVariant" : "",
        "fontStyle" : "",
        "fontWeight" : ""
      } );
    },

    _setTextDecoration : function( element, decoration ) {
      element.css( {
        "textDecoration" : ( decoration == null || decoration === "none" ) ? "" : decoration
      } );
    },

    _setTextOverflow : function( element, overflow ) {
      element.css( "textOverflow", ( overflow == null || overflow === "clip" ) ? "" : overflow );
    },

    _setWordWrap : function( element, wordWrap ) {
      element.css( "whiteSpace", wordWrap ? "" : "nowrap" );
    },

    _setForeground : function( element, color ) {
      element.css( "color", color || "" );
    },

    _setImage : function( element, src, enabled ) {
      var opacity = enabled ? 1 : 0.3;
      element.css( { "opacity" : enabled != null ? opacity : "", "backgroundImage" : src || "" } );
    },

    _getTextElement : function( cell ) {
      var result = this.$cellLabels[ cell ];
      if( !result ) {
        result = this._createElement( 3 );
        result.css( {
          "textDecoration" : "inherit",
          "textOverflow": "inherit",
          "backgroundColor" : ""
        } );
        this.$cellLabels[ cell ] = result;
      }
      return result;
    },

    _getCellImage : function( cell ) {
      var result = this.$cellImages[ cell ];
      if( !result ) {
        result = this._createElement( 3 );
        result.css( { "backgroundRepeat" : "no-repeat", "backgroundPosition" : "center" } );
        this.$cellImages[ cell ] = result;
      }
      return result;
    },

    _getCellCheckImage : function( cell ) {
      var result = this.$cellCheckBoxes[ cell ];
      if( !result ) {
        result = this._createElement( 3 );
        result.css( { "backgroundRepeat" : "no-repeat", "backgroundPosition" : "center" } );
        this.$cellCheckBoxes[ cell ] = result;
      }
      return result;
    },

    _getOverlayElement : function() {
      if( this.$overlay === null ) {
        this.$overlay = this._createElement( 2 );
        this.$overlay.css( { "width" : "100%", "height" : "100%" } );
      }
      return this.$overlay.css( { "display" : "" } );
    },

    _getBackgroundElement : function( cell ) {
      var result = this.$cellBackgrounds[ cell ];
      if( !result ) {
        result = this._createElement( 1 );
        this.$cellBackgrounds[ cell ] = result;
      }
      return result;
    },

    _getIndentImage : function() {
      var result;
      if( this._usedIdentIcons < this.$indentIcons.length ) {
        result = this.$indentIcons[ this._usedIdentIcons ];
      } else {
        result = this._createElement( 3 ).css( {
          "backgroundRepeat" : "no-repeat",
          "backgroundPosition" : "center",
          "zIndex" : 3
        } );
        this.$indentIcons.push( result );
      }
      this._usedIdentIcons++;
      return result.html( "" ).css( { "backgroundColor" : "", "display" : "" } );
    },

    _createElement : function( zIndex ) {
      return $( "<div>" ).css( {
        "position" : "absolute",
        "overflow" : "hidden",
        "zIndex" : zIndex
      } ).appendTo( this.$el );
    },

    _clearContent : function( config ) {
      for( var i = 0; i < this.$cellBackgrounds.length; i++ ) {
        if( this.$cellBackgrounds[ i ] ) {
          this.$cellBackgrounds[ i ].css( "backgroundColor", "" );
        }
      }
      for( var i = 0; i < this.$cellCheckBoxes.length; i++ ) {
        if( this.$cellCheckBoxes[ i ] ) {
          this.$cellCheckBoxes[ i ].css( "backgroundImage", "" );
        }
      }
      for( var i = 0; i < this.$cellImages.length; i++ ) {
        if( this.$cellImages[ i ] ) {
          this.$cellImages[ i ].css( "backgroundImage", "" );
        }
      }
      for( var i = 0; i < this.$cellLabels.length; i++ ) {
        if( this.$cellLabels[ i ] ) {
          this._renderElementContent( this.$cellLabels[ i ], null, -1, config );
        }
      }
      if( this.$checkBox ) {
        this.$checkBox.css( "backgroundImage", "" );
      }
      this._renderOverlay( null );
      this._hideRemainingElements();
    },

    _renderAllBounds : function( config ) {
      var columns = this._getColumnCount( config );
      for( var i = 0; i < columns; i++ ) {
        // tree column bounds can not be rendered without item, is rendered always anyway
        if( !this._isTreeColumn( i, config ) ) {
          this._renderCellLabelBounds( null, i, config );
          this._renderCellImageBounds( null, i, config );
        }
        this._renderCellBackgroundBounds( null, i, config );
      }
    },

    _hideRemainingElements : function() {
      for( var i = this._usedIdentIcons; i < this.$indentIcons.length; i++ ) {
        this.$indentIcons[ i ].css( "display", "none" );
      }
    },

    _removeCells : function( from, to ) {
      for( var i = from; i < to; i++ ) {
        this._removeCell( i );
      }
    },

    _removeCell : function( cell ) {
      this._removeNode( this.$cellBackgrounds, cell );
      this._removeNode( this.$cellImages, cell );
      this._removeNode( this.$cellCheckBoxes, cell );
      this._removeNode( this.$cellLabels, cell );
    },

    _removeNode : function( arr, pos ) {
      var node = arr[ pos ];
      if( node ) {
        node.detach();
        arr[ pos ] = null;
      }
    },

    ////////////////
    // layout-helper

    _getCheckBoxLeft : function( item, config ) {
      return this._correctOffset( config.checkBoxLeft, item, config );
    },

    _getCheckBoxWidth : function( item, config ) {
      var result = config.checkBoxWidth;
      var offset = this._getCheckBoxLeft( item, config );
      return this._correctWidth( result, offset, 0, config );
    },

    _getItemLeft : function( item, columnIndex, config ) {
      return config.itemLeft[ columnIndex ];
    },

    _getItemWidth : function( item, columnIndex, config ) {
      return config.itemWidth[ columnIndex ];
    },

    _getItemImageLeft : function( item, columnIndex, config ) {
      var result = config.itemImageLeft[ columnIndex ];
      if( this._isTreeColumn( columnIndex, config ) ) {
        result = this._correctOffset( result, item, config );
      }
      return result;
    },

    _getItemImageWidth : function( item, columnIndex, config ) {
      var result = config.itemImageWidth[ columnIndex ];
      if( this._isTreeColumn( columnIndex, config ) ) {
        var offset = this._getItemImageLeft( item, columnIndex, config );
        result = this._correctWidth( result, offset, columnIndex, config );
      }
      return result;
    },

    _getCellCheckLeft : function( item, columnIndex, config ) {
      var result = config.itemCellCheckLeft[ columnIndex ];
      if( this._isTreeColumn( columnIndex, config ) ) {
        result = this._correctOffset( result, item, config );
      }
      return result;
    },

    _getCellCheckWidth : function( item, columnIndex, config ) {
      var result = config.itemCellCheckWidth[ columnIndex ];
      if( this._isTreeColumn( columnIndex, config ) ) {
        var offset = this._getCellCheckLeft( item, columnIndex, config );
        result = this._correctWidth( result, offset, columnIndex, config );
      }
      return result;
    },

    _getItemTextLeft : function( item, columnIndex, config ) {
      var result = config.itemTextLeft[ columnIndex ];
      if( this._isTreeColumn( columnIndex, config ) ) {
        result = this._correctOffset( result, item, config );
      }
      return result;
    },

    _getItemTextWidth : function( item, columnIndex, config ) {
      var result = config.itemTextWidth[ columnIndex ];
      if( this._isTreeColumn( columnIndex, config ) ) {
        var offset = this._getItemTextLeft( item, columnIndex, config );
        result = this._correctWidth( result, offset, columnIndex, config );
      }
      return result;
    },

    _getCellPadding : function( config ) {
      var manager = rwt.theme.AppearanceManager.getInstance();
      return manager.styleFrom( config.baseAppearance + "-cell", {} ).padding;
    },

    _correctOffset : function( offset, item, config ) {
      return offset + this._getIndentionOffset( item.getLevel() + 1, config );
    },

    _correctWidth : function( width, offset, column, config ) {
      var result = width;
      var columnEnd = config.itemLeft[ column ] + config.itemWidth[ column ];
      var elementEnd = offset + result;
      if( elementEnd > columnEnd ) {
        result = Math.max( 0, columnEnd - offset );
      }
      return result;
    },

    _getAlignment : function( column, config ) {
      return config.alignment[ column ] ? config.alignment[ column ] : "left";
    },

    _getIndentionOffset : function( level, config ) {
      // NOTE [tb] : Shoud actually add the isTreeColumns own offset, assumes 0 now.
      return config.indentionWidth * level;
    },

    _getColumnCount : function( config ) {
      return Math.max( 1, config.columnCount );
    },

    _isTreeColumn : function( columnIndex, config ) {
      return columnIndex === config.treeColumn;
    }

  }

} );

}( rwt.util._RWTQuery ));

/*******************************************************************************
 * Copyright (c) 2009, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.qx.Class.define( "rwt.widgets.Menu", {
  extend : rwt.widgets.base.Popup,
  include : rwt.animation.VisibilityAnimationMixin,

  construct : function() {
    this.base( arguments );
    this._openTimer = new rwt.client.Timer( 250 );
    this._closeTimer = new rwt.client.Timer( 250 );
    this._layout = new rwt.widgets.base.VerticalBoxLayout();
    this._preItem = null;
    this._menuLayoutScheduled = false;
    this._opener = null;
    this._mnemonics = false;
    this._hoverItem = null;
    this._openItem = null;
    this._itemsHiddenFlag = false;
    this.setAppearance( "menu" );
    this._maxCellWidths = [ null, null, null, null, null ];
    this._layout.set( {
      top : 0,
      right : 0,
      bottom : 0,
      left : 0,
      anonymous : true
    } );
    this.add( this._layout );
    this.addEventListener( "mousedown", this._onMouseDown );
    this.addEventListener( "mouseup", this._onMouseUp );
    this.addEventListener( "mouseout", this._onMouseOut );
    this.addEventListener( "mouseover", this._onMouseOver );
    this.addEventListener( "keypress", this._onKeyPress );
    this.addEventListener( "keydown", this._onKeyDown );
    this._openTimer.addEventListener( "interval", this._onOpenTimer, this );
    this._closeTimer.addEventListener( "interval", this._onCloseTimer, this );
    this.addToDocument();
  },

  destruct : function() {
    // needed if menu is disposed while scheduled to be shown (beforeAppear already called):
    rwt.widgets.util.MenuManager.getInstance().remove( this );
    this._makeInactive();
    this._disposeObjects( "_openTimer", "_closeTimer", "_preItem", "_animation" );
    this._disposeFields( "_layout", "_opener", "_hoverItem", "_openItem" );
  },

  statics : {

    menuDetectedByKey : function( evt ) {
      if( evt.getKeyIdentifier() === "Apps" ) {
        rwt.widgets.Menu.contextMenuHandler( evt );
      }
    },

    menuDetectedByMouse : function( evt ) {
      if( evt.getButton() === rwt.event.MouseEvent.C_BUTTON_RIGHT ) {
        rwt.widgets.Menu.contextMenuHandler( evt );
      }
    },

    contextMenuHandler : function( event ) {
      var control = rwt.widgets.util.WidgetUtil.getControl( event.getTarget() );
      var contextMenu = control ? control.getContextMenu() : null;
      if( contextMenu != null ) {
        event.stopPropagation();
        event.preventDefault();
        var pageX = rwt.event.MouseEvent.getPageX();
        var pageY = rwt.event.MouseEvent.getPageY();
        contextMenu.setLocation( pageX, pageY );
        contextMenu.setOpener( control );
        contextMenu.show();
      }
    },

    getAllowContextMenu : function( target, domTarget ) {
      var result = false;
      switch( target.classname ) {
        case "rwt.widgets.Label":
        case "rwt.widgets.Text":
        case "rwt.widgets.base.GridRowContainer":
        case "rwt.widgets.ListItem":
        case "rwt.widgets.base.BasicText":
        case "qx.ui.form.TextArea":
          // NOTE: "enabled" can be "inherit", so it is not always a boolean
          if( target.getEnabled() !== false ) {
            if( rwt.widgets.Menu._hasNativeMenu( domTarget ) ) {
              result = target.getContextMenu() == null;
            }
          }
        break;
      }
      return result;
    },


    _hasNativeMenu : function( element ) {
      var result;
      var tagName = typeof element.tagName == "string" ? element.tagName.toLowerCase() : "";
      if( tagName === "a" ) {
        result = element.getAttribute( "href" ) && element.getAttribute( "target" ) !== "_rwt";
      } else {
        result = tagName === "input" || tagName === "textarea";
      }
      return result;
    }

  },

  members : {

    /////////
    // Opener

    setOpener : function( value ) {
      this._opener = value;
    },

    getOpener : function() {
      return this._opener;
    },

    setMnemonics : function( value ) {
      if( this._mnemonics !== value ) {
        this._mnemonics = value;
        var items = this._layout.getChildren();
        for( var i = 0; i < items.length; i++ ) {
          if( items[ i ].renderText ) {
            items[ i ].renderText();
          }
        }
      }
    },

    getMnemonics : function() {
      return this._mnemonics;
    },

    /////////
    // Layout

    addMenuItemAt : function( menuItem, index ) {
      // seperator does not have this function:
      if( menuItem.setParentMenu ) {
        // it is essential that this happens before the menuItem is added
        menuItem.setParentMenu( this );
      }
      var position = index;
      if( this._preItem && this._preItem !== menuItem ) {
        position++;
      }
      this._layout.addAt( menuItem, position );
    },

    scheduleMenuLayout : function() {
      if( this._menuLayoutScheduled !== true ) {
        this._menuLayoutScheduled = true;
        var children = this._layout.getChildren();
        var length = children.length;
        for( var i = 0; i < length; i++ ) {
          children[ i ]._invalidatePreferredInnerWidth();
          children[ i ].addToQueue( "layoutX" );
        }
        this.addToQueue( "menuLayout" );
      }
    },

    _layoutPost : function( changes ) {
      this.base( arguments, changes );
      if( changes.menuLayout ) {
        this._menuLayoutScheduled = false;
        if( this.isSeeable() ) {
          this._afterAppear(); // recomputes the location
        }
      }
    },

    getMaxCellWidth : function( cell ) {
      if( this._maxCellWidths[ cell ] == null ) {
        var max = 0;
        var children = this._layout.getChildren();
        var length = children.length;
        for( var i = 0; i < length; i++ ) {
          if( children[ i ].getPreferredCellWidth ) {
            max = Math.max( max, children[ i ].getPreferredCellWidth( cell ) );
          }
        }
        this._maxCellWidths[ cell ] = max;
      }
      if( cell === 0 && this._maxCellWidths[ 0 ] === 0 && this.getMaxCellWidth( 1 ) === 0 ) {
        this._maxCellWidths[ cell ] = 13;
      }
      return this._maxCellWidths[ cell ];
    },

    invalidateMaxCellWidth : function( cell ) {
      this._maxCellWidths[ cell ] = null;
    },

    invalidateAllMaxCellWidths : function() {
      for( var i = 0; i < 5; i++ ) {
        this._maxCellWidths[ i ] = null;
      }
    },

    // needed for the menu-manager:
    isSubElement : function( vElement, vButtonsOnly ) {
      var result = false;
      if (    ( vElement.getParent() === this._layout )
           || ( ( !vButtonsOnly ) && ( vElement === this ) ) ) {
        result = true;
      }
      if( !result ) {
        var a = this._layout.getChildren(), l=a.length;
        for ( var i = 0; i < l; i++ ) {
          if (    this.hasSubmenu( a[ i ] )
               && a[ i ].getMenu().isSubElement( vElement, vButtonsOnly ) )
          {
            result = true;
          }
        }
      }
      return result;
    },

    ////////
    // Hover

    setHoverItem : function( value, fromKeyEvent ) {
      var newHover = value ? value : this._openItem;
      if( this._hoverItem && this._hoverItem != newHover ) {
        this._hoverItem.removeState( "over" );
      }
      if( newHover ) {
        newHover.addState( "over" );
      }
      this._hoverItem = newHover;
      if( !fromKeyEvent ) {
        // handle open timer
        this._openTimer.setEnabled( false );
        if( this.hasSubmenu( newHover ) && ( this._openItem != newHover ) ) {
          this._openTimer.setEnabled( true );
        }
        // handle close timer
        if( this._openItem ) {
          if( this._openItem == newHover || newHover == null ) {
            this._closeTimer.setEnabled( false );
          } else if( newHover != null ) {
            this._closeTimer.setEnabled( true );
          }
        }
      }
      this.dispatchSimpleEvent( "changeHoverItem" );
    },

    getHoverItem : function() {
      return this._hoverItem;
    },

    hoverFirstItem : function( reversed ) {
      if( this._isDisplayable && !this._itemsHiddenFlag ) {
        this.setHoverItem( null, true );
        if( reversed ) {
          this._hoverPreviousItem();
        } else {
          this._hoverNextItem();
        }
      }
      this.toggleState( "hoverFristItem", !this._isDisplayable || this._itemsHiddenFlag );
    },

    _hoverNextItem : function() {
      // About _hoverNext/Previous:
      // the index used for the array of visible children can have
      // "-1" as a valid value (as returned by indexOf), meaning a position
      // between the last and the first item. This is value is needed when no
      // item is hovered or the index-position is wrapping around.
      var current;
      var next = null;
      var children = this._layout.getVisibleChildren();
      var index = children.indexOf( this._hoverItem );
      var startIndex = index;
      do {
        index++;
        if( index > children.length ) {
          index = -1;
        }
        current = index >= 0 ? children[ index ] : null;
        if(   current
           && current.isEnabled()
           && current.classname == "rwt.widgets.MenuItem" )
        {
          next = current;
        }
      } while( !next && ( index != startIndex ) );
      this.setHoverItem( next, true );
    },

    _hoverPreviousItem : function() {
      var current;
      var prev = null;
      var children = this._layout.getVisibleChildren();
      var index = children.indexOf( this._hoverItem );
      var startIndex = index;
      do {
        index--;
        if( index < -1 ) {
          index = children.length;
        }
        current = index >= 0 ? children[ index ] : null;
        if(   current
           && current.isEnabled()
           && current.classname == "rwt.widgets.MenuItem" )
        {
          prev = current;
        }
      } while( !prev && ( index != startIndex ) );
      this.setHoverItem( prev, true );
    },

    //////////////////
    // Pop-Up handling

    // overwritten:
    _makeActive : function() {
      this.setCapture( true );
    },

    // overwritten:
    _makeInactive : function() {
      this.setCapture( false );
    },

    _beforeAppear : function() {
      // original qooxdoo code: (1 line)
      rwt.widgets.base.Parent.prototype._beforeAppear.call( this );
      rwt.widgets.util.MenuManager.getInstance().add( this );
      this.bringToFront();
      this._makeActive();
      this._menuShown();
      rwt.widgets.util.MnemonicHandler.getInstance().deactivate();
    },

    _beforeDisappear : function() {
      // original qooxdoo code: (1 line)
      rwt.widgets.base.Parent.prototype._beforeDisappear.call( this );
      rwt.widgets.util.MenuManager.getInstance().remove( this );
      this._makeInactive();
      this.setOpenItem( null );
      this.setHoverItem( null );
      if( this._opener instanceof rwt.widgets.MenuItem ) {
        var parentMenu = this._opener.getParentMenu();
        if( parentMenu instanceof rwt.widgets.MenuBar ) {
          this._opener.removeState( "pressed" );
          if( parentMenu.getOpenItem() == this._opener ) {
            parentMenu.setOpenItem( null );
          }
        }
      }
      this._menuHidden();
    },

    //////////
    // Submenu

    hasSubmenu : function( item ) {
      return item && item.getMenu && item.getMenu();
    },

   _onOpenTimer : function() {
      this._openTimer.stop();
      this.setOpenItem( this._hoverItem );
      // fix for bug 299350
      this._closeTimer.stop();
    },

    _onCloseTimer : function() {
      this._closeTimer.stop();
      this.setOpenItem( null );
    },

    openByMnemonic : function( item ) {
      this.setOpenItem( item, true );
      this.setHoverItem( null, true );
    },

    setOpenItem : function( item, byMnemonic ) {
      if( this._openItem && this._openItem.getMenu() ) {
        this._openItem.setSubMenuOpen( false );
        var oldMenu = this._openItem.getMenu();
        oldMenu.hide();
        if( this.getVisibility() ) {
          this._makeActive();
        }
      }
      this._openItem = item;
      // in theory an item could have lost it's assigned menu (by eval-code)
      // since the timer has been started/the item opend, so check for it
      if( item && item.getMenu() && item.getEnabled() ) {
        var subMenu = item.getMenu();
        item.setSubMenuOpen( true );
        subMenu.setOpener( item );
        var itemNode = item.getElement();
        var thisNode = this.getElement();
        // the position is relative to the document, therefore we need helper
        subMenu.setTop( rwt.html.Location.getTop( itemNode ) - 2 );
        subMenu.setLeft(   rwt.html.Location.getLeft( thisNode )
                         + thisNode.offsetWidth
                         - 3 );
        subMenu.setMnemonics( byMnemonic === true );
        subMenu.show();
        if( byMnemonic ) {
          subMenu.hoverFirstItem();
        }
      }
    },

    /////////////////
    // Event-handling

    _onMouseOut : function( event ) {
      var target = event.getOriginalTarget();
      if( this.contains( target ) ) {
        var related = event.getRelatedTarget();
        if( target === this || ( related !== this && !this.contains( related ) ) ) {
          this.setHoverItem( null );
        }
      } else {
        // This is a capture widget, re-dispatch on original
        target._dispatchEvent( event );
        event.stopPropagation();
      }
    },

    _onMouseOver : function( event ) {
      var target = event.getOriginalTarget();
      if( this.contains( target ) ) {
        if( target instanceof rwt.widgets.MenuItem ) {
          this.setHoverItem( target );
        }
        this._unhoverSubMenu();
      } else {
        // This is a capture widget, re-dispatch on original
        target._dispatchEvent( event );
        event.stopPropagation();
      }
    },

    _onMouseDown : function( event ) {
      this._unhoverSubMenu();
      var target = event.getOriginalTarget();
      if( !this.contains( target ) ) {
        // This is a capture widget, re-dispatch on original
        rwt.event.EventHandlerUtil.handleFocusedChild( target );
        target._dispatchEvent( event );
        event.stopPropagation();
      }
    },

    _onMouseUp : function( event ) {
      var target = event.getOriginalTarget();
      if( this.contains( target ) ) {
        if( target instanceof rwt.widgets.MenuItem ) {
          target.execute();
        }
      } else {
        // This is a capture widget, re-dispatch on original
        target._dispatchEvent( event );
        event.stopPropagation();
      }
    },

    _unhoverSubMenu : function() {
      if( this._openItem ) {
        var subMenu = this._openItem.getMenu();
        subMenu.setOpenItem( null );
        subMenu.setHoverItem( null );
      }
    },

    _onKeyDown :function( event ) {
      if( this._mnemonics ) {
        var keyCode = event.getKeyCode();
        var isChar =    !isNaN( keyCode )
                     && rwt.event.EventHandlerUtil.isAlphaNumericKeyCode( keyCode );
        if( isChar ) {
          var event = {
            "type" : "trigger",
            "charCode" : keyCode,
            "success" : false
          };
          var items = this._layout.getChildren();
          for( var i = 0; i < items.length; i++ ) {
            if( items[ i ].handleMnemonic ) {
              items[ i ].handleMnemonic( event );
            }
          }
        }
      }
    },

    _onKeyPress : function( event ) {
      switch( event.getKeyIdentifier() ) {
        case "Up":
          this._handleKeyUp( event );
        break;
        case "Down":
          this._handleKeyDown( event );
        break;
        case "Left":
          this._handleKeyLeft( event );
        break;
        case "Right":
          this._handleKeyRight( event );
        break;
        case "Enter":
          this._handleKeyEnter( event );
        break;
      }
    },

    _handleKeyUp : function( event ) {
      if( this._openItem ) {
        this._openItem.getMenu()._hoverPreviousItem();
      } else {
        this._hoverPreviousItem();
      }
      event.preventDefault();
      event.stopPropagation();
    },

    _handleKeyDown : function( event ) {
      if( this._openItem ) {
        this._openItem.getMenu()._hoverNextItem();
      } else {
        this._hoverNextItem();
      }
      event.preventDefault();
      event.stopPropagation();
    },

    _handleKeyLeft : function( event ) {
      if( this._opener instanceof rwt.widgets.MenuItem ) {
        var parentMenu = this._opener.getParentMenu();
        if( parentMenu instanceof rwt.widgets.Menu ) {
          var hover = this._opener;
          parentMenu.setOpenItem( null );
          parentMenu.setHoverItem( hover, true );
          event.preventDefault();
          event.stopPropagation();
        }
      }
    },

    _handleKeyRight : function( event ) {
      if( this.hasSubmenu( this._hoverItem ) ) {
        this._onOpenTimer();
        this.setHoverItem( null, true );
        this._openItem.getMenu().hoverFirstItem();
        event.preventDefault();
        event.stopPropagation();
      }
    },

    _handleKeyEnter : function( event ) {
      if( this.hasSubmenu( this._hoverItem ) ) {
        this._onOpenTimer();
        this.setHoverItem( null, true );
        this._openItem.getMenu().hoverFirstItem();
      } else if( this._hoverItem ){
        this._hoverItem.execute();
        rwt.widgets.util.MenuManager.getInstance().update();
      }
      event.preventDefault();
      event.stopPropagation();
    },

    ////////////////
    // Client-Server

    _menuShown : function() {
      if( !rwt.remote.EventUtil.getSuspended() ) {
        var remoteObject = rwt.remote.Connection.getInstance().getRemoteObject( this );
        if( remoteObject.isListening( "Show" ) ) {
          // create preliminary item
          if( this._preItem == null ) {
            this._preItem = new rwt.widgets.MenuItem( "push" );
            this._preItem.setText( "..." );
            this._preItem.setEnabled( false );
            this.addMenuItemAt( this._preItem, 0 );
          }
          // hide all but the preliminary item
          var items = this._layout.getChildren();
          for( var i = 0; i < items.length; i++ ) {
            var item = items[ i ];
            item.setDisplay( false );
          }
          this._preItem.setDisplay( true );
          this._itemsHiddenFlag = true;
          if( this.getWidth() < 60 ) {
            this.setWidth( 60 );
          }
          //this.setDisplay( true ); //wouldn't be called if display was false
          // send event
          remoteObject.notify( "Show" );
        } else {
          var display = this._layout.getChildren().length !== 0;
          //no items and no listener to add some:
          this.setDisplay( display );
        }
      }
    },

    _menuHidden : function() {
      if( !rwt.remote.EventUtil.getSuspended() ) {
        rwt.remote.Connection.getInstance().getRemoteObject( this ).notify( "Hide" );
      }
    },

    unhideItems : function( reveal ) {
      if( reveal ) {
        var items = this._layout.getChildren();
        for( var i = 0; i < items.length; i++ ) {
          items[ i ].setDisplay( true );
        }
        if( this._preItem ) {
          this._preItem.setDisplay( false );
        }
        this._itemsHiddenFlag = false;
      } else {
        this.hide();
      }
    },

    // Called to open a popup menu from server side
    showMenu : function( menu, x, y ) {
      if( menu != null ) {
        menu._renderAppearance();
        menu.setLocation( x, y );
        menu.show();
      }
    }

  }

} );

/*******************************************************************************
 * Copyright (c) 2011, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.remote.HandlerRegistry.add( "rwt.widgets.Menu", {

  factory : function( properties ) {
    var result;
    // TODO [tb] : split into Menu and MenuBar, or unify parent handling
    if( properties.style.indexOf( "BAR" ) != -1 ) {
      result = new rwt.widgets.MenuBar();
      rwt.remote.HandlerUtil.callWithTarget( properties.parent, function( parent ) {
        result.setParent( parent );
      } );
    } else {
      result = new rwt.widgets.Menu();
    }
    rwt.remote.HandlerUtil.addStatesForStyles( result, properties.style );
    return result;
  },

  destructor : rwt.remote.HandlerUtil.getWidgetDestructor(),

  getDestroyableChildren : rwt.remote.HandlerUtil.getDestroyableChildrenFinder(),

  properties : [
    "bounds",
    "enabled",
    "customVariant"
  ],

  propertyHandler : {
    "bounds" : function( widget, value ) {
      if( widget.hasState( "rwt_BAR" ) ) {
        widget.setLeft( value[ 0 ] );
        widget.setTop( value[ 1 ] );
        widget.setWidth( value[ 2 ] );
        widget.setHeight( value[ 3 ] );
      }
    }
  },

  events : [ "Show", "Hide" ],

  listeners : [ "Help" ],

  listenerHandler : {
    "Help" : rwt.remote.HandlerUtil.getControlListenerHandler( "Help" )
  },

  methods : [
    "unhideItems",
    "showMenu"
  ],

  methodHandler : {
    "unhideItems" : function( widget, args ) {
      if( !widget.hasState( "rwt_BAR" ) ) {
        widget.unhideItems( args.reveal );
      }
    },
    "showMenu" : function( widget, args ) {
      if( widget.hasState( "rwt_POP_UP" ) ) {
        widget.showMenu( widget, args.x, args.y );
      }
    }
  }

} );

/*******************************************************************************
 * Copyright (c) 2002, 2015 Innoopract Informationssysteme GmbH and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Innoopract Informationssysteme GmbH - initial API and implementation
 *    EclipseSource - ongoing development
 ******************************************************************************/

namespace( "rwt.remote" );

(function() {

var self;

rwt.remote.EventUtil = {

  _suspended : false,

  setSuspended : function( value ) {
    self._suspended = value;
  },

  getSuspended : function() {
    return self._suspended;
  },

  DOUBLE_CLICK_TIME : 500,

  _capturingWidget : null,
  _lastMouseDown : {
    widget : null,
    button : "",
    x : -1,
    y : -1,
    mouseUpCount : 0
  },
  _shiftKey : false,
  _ctrlKey : false,
  _altKey : false,
  _metaKey : false,
  _button : rwt.event.MouseEvent.C_BUTTON_NONE,

  eventTimestamp : function() {
    var init = rwt.runtime.System.getInstance();
    return ( new Date().getTime() - init.getStartupTime() ) % 0x7fffffff;
  },

  widgetDefaultSelected : function( event ) {
    self.notifyDefaultSelected( event.getTarget() );
  },

  widgetSelected : function( event ) {
    var left = event.getTarget().getLeft();
    var top = event.getTarget().getTop();
    var width = event.getTarget().getWidth();
    var height = event.getTarget().getHeight();
    self.notifySelected( event.getTarget(), left, top, width, height );
  },

  notifySelected : function( target ) {
    if( !self.getSuspended() && !target.isDisposed() ) {
      var connection = rwt.remote.Connection.getInstance();
      var properties = self._createSelectionProperties.apply( this, arguments );
      connection.getRemoteObject( target ).notify( "Selection", properties );
    }
  },

  notifyDefaultSelected : function( target ) {
    if( !self.getSuspended() && !target.isDisposed() ) {
      var connection = rwt.remote.Connection.getInstance();
      var properties = self._createSelectionProperties.apply( this, arguments );
      connection.getRemoteObject( target ).notify( "DefaultSelection", properties );
    }
  },

  _createSelectionProperties : function() {
    var properties;
    if( arguments.length === 2 ) {
      properties = arguments[ 1 ];
    } else {
      properties = {
        "x" : arguments[ 1 ],
        "y" : arguments[ 2 ],
        "width" : arguments[ 3 ],
        "height" : arguments[ 4 ],
        "detail" : arguments[ 5 ]
      };
    }
    self.addButtonToProperties( properties );
    self.addModifierToProperties( properties );
    return properties;
  },

  addButtonToProperties : function( properties, event ) {
    var button = event ? event.getButton() : self._button;
    switch( button ) {
      case rwt.event.MouseEvent.C_BUTTON_LEFT:
        properties.button = 1;
        break;
      case rwt.event.MouseEvent.C_BUTTON_MIDDLE:
        properties.button = 2;
        break;
      case rwt.event.MouseEvent.C_BUTTON_RIGHT:
        properties.button = 3;
        break;
    }
  },

  addModifierToProperties : function( properties, event ) {
    var isMac = rwt.client.Client.getPlatform() === "mac";
    var commandKey = isMac && ( event ? event.metaKey : self._metaKey ) === true;
    properties.shiftKey = event ? event.shiftKey : self._shiftKey;
    properties.ctrlKey = ( event ? event.ctrlKey : self._ctrlKey ) || commandKey;
    properties.altKey = event ? event.altKey : self._altKey;
  },

  focusGained : function( event ) {
    if( !self.getSuspended() ) {
      var remoteObject = rwt.remote.Connection.getInstance().getRemoteObject( event.getTarget() );
      remoteObject.notify( "FocusIn" );
    }
  },

  focusLost : function( event ) {
    if( !self.getSuspended() ) {
      var remoteObject = rwt.remote.Connection.getInstance().getRemoteObject( event.getTarget() );
      remoteObject.notify( "FocusOut" );
    }
  },

  ///////////////////////
  // Mouse event handling

  mouseDown : function( event ) {
    if( !self.getSuspended() && self._isRelevantMouseEvent( this, event ) ) {
      // disabled capturing as it interferes with Combo capturing
      // see https://bugs.eclipse.org/bugs/show_bug.cgi?id=262171
      // from now on, redirect mouse event to this widget
      // this.setCapture( true );
      self._capturingWidget = this;
      // Collect request parameters and send
      self._notifyMouseListeners( this, event, "MouseDown" );
    }
  },

  mouseUp : function( event ) {
    if( !self.getSuspended() && self._isRelevantMouseEvent( this, event ) ) {
      // disabled capturing as it interferes with Combo capturing
      // see https://bugs.eclipse.org/bugs/show_bug.cgi?id=262171
      // release mouse event capturing
      // this.setCapture( false );
      self._capturingWidget = null;
      // Add mouse-up request parameter
      self._notifyMouseListeners( this, event, "MouseUp" );
    }
  },

  mouseDoubleClick : function( event ) {
    if( !self.getSuspended() && self._isRelevantMouseEvent( this, event ) ) {
      // disabled capturing as it interferes with Combo capturing
      // see https://bugs.eclipse.org/bugs/show_bug.cgi?id=262171
      // from now on, redirect mouse event to this widget
      // this.setCapture( true );
      self._capturingWidget = this;
      // Add parameters for double-click event
      if( self._isDoubleClick( this, event ) ) {
        self._clearLastMouseDown();
        self._notifyMouseListeners( this, event, "MouseDoubleClick" );
      } else {
        // Store relevant data of current event to detect double-clicks
        var lastMouseDown = self._lastMouseDown;
        lastMouseDown.widget = this;
        lastMouseDown.button = event.getButton();
        lastMouseDown.x = event.getPageX();
        lastMouseDown.y = event.getPageY();
        lastMouseDown.mouseUpCount = 0;
        rwt.client.Timer.once( self._clearLastMouseDown, this, self.DOUBLE_CLICK_TIME );
      }
    }
  },

  mouseUpCounter : function( event ) {
    if( !self.getSuspended() && self._isRelevantMouseEvent( this, event ) ) {
      // disabled capturing as it interferes with Combo capturing
      // see https://bugs.eclipse.org/bugs/show_bug.cgi?id=262171
      // release mouse event capturing
      // this.setCapture( false );
      self._capturingWidget = null;
      // increase number of mouse-up events since last stored mouse down
      self._lastMouseDown.mouseUpCount += 1;
    }
  },

  /**
   * Determines whether the event is relevant (i.e. should be sent) for the
   * given widget.
   * @param widget - the listening widget
   * @param event - the mouse event
   */
  _isRelevantMouseEvent : function( widget, event ) {
    var result = true;
    if( widget !== self._capturingWidget && widget !== event.getOriginalTarget() ) {
      // find parent control and ensure that it is the same as the widget-
      // parameter. Otherwise the mouse event is ignored.
      var widgetManager = rwt.remote.WidgetManager.getInstance();
      var target = event.getOriginalTarget();
      var control = widgetManager.findEnabledControl( target );
      result = widget === control;
    }
    return result;
  },

  _clearLastMouseDown : function() {
    var lastMouseDown = self._lastMouseDown;
    lastMouseDown.widget = null;
    lastMouseDown.button = "";
    lastMouseDown.mouseUpCount = 0;
    lastMouseDown.x = -1;
    lastMouseDown.y = -1;
  },

  _isDoubleClick : function( widget, event ) {
    var lastMouseDown = self._lastMouseDown;
    return    lastMouseDown.mouseUpCount === 1
           && lastMouseDown.widget === widget
           && lastMouseDown.button === rwt.event.MouseEvent.C_BUTTON_LEFT
           && lastMouseDown.button === event.getButton()
           && self._isCloseTo( lastMouseDown.x,
                               lastMouseDown.y,
                               event.getPageX(),
                               event.getPageY() );
  },

  _isCloseTo : function( lastX, lastY, x, y ) {
    return x >= lastX - 5 && x <= lastX + 5 && y >= lastY - 5 && y <= lastY + 5;
  },

  _notifyMouseListeners : function( widget, event, eventType ) {
    var properties = {
      "x" : event.getPageX(),
      "y" : event.getPageY(),
      "time" : self.eventTimestamp()
    };
    self.addButtonToProperties( properties, event );
    self.addModifierToProperties( properties );
    rwt.remote.Connection.getInstance().getRemoteObject( widget ).notify( eventType, properties );
  },

  helpRequested : function( event ) {
    if( event.getKeyIdentifier() === "F1" ) {
      // stop further handling and default handling by the browser
      event.stopPropagation();
      event.preventDefault();
      // send help request to server
      var widget = event.getTarget();
      var widgetManager = rwt.remote.WidgetManager.getInstance();
      var id = widgetManager.findIdByWidget( widget );
      if( id === null ) {
        // find parent control for the widget that received the event in case
        // it wasn't the control itself that received the event
        widget = widgetManager.findControl( widget );
        id = widgetManager.findIdByWidget( widget );
      }
      if( id != null ) {
        var remoteObject = rwt.remote.Connection.getInstance().getRemoteObject( widget );
        remoteObject.notify( "Help" );
      }
    }
  },

  menuDetectedByKey : function( event ) {
    if( event.getKeyIdentifier() === "Apps" ) {
      // stop further handling and default handling by the browser
      event.stopPropagation();
      event.preventDefault();
      var x = rwt.event.MouseEvent.getPageX();
      var y = rwt.event.MouseEvent.getPageY();
      self.sendMenuDetected( event.getTarget(), x, y );
    }
  },

  menuDetectedByMouse : function( event ) {
    if( event.getButton() === rwt.event.MouseEvent.C_BUTTON_RIGHT ) {
      // stop further handling and default handling by the browser
      event.stopPropagation();
      event.preventDefault();
      var x = event.getPageX();
      var y = event.getPageY();
      self.sendMenuDetected( event.getTarget(), x, y );
    }
  },

  sendMenuDetected : function( widget, x, y ) {
    if( !self.getSuspended() ) {
      // send menu detect request to server
      var widgetManager = rwt.remote.WidgetManager.getInstance();
      // find parent control for the widget that received the event in case
      // it wasn't the control itself that received the event
      while( widget != null && !widgetManager.isControl( widget ) ) {
        widget = widget.getParent ? widget.getParent() : null;
      }
      var id = widgetManager.findIdByWidget( widget );
      if( id != null ) {
        var remoteObject = rwt.remote.Connection.getInstance().getRemoteObject( widget );
        remoteObject.notify( "MenuDetect", { "x" : x, "y" : y } );
      }
    }
  }

};

self = rwt.remote.EventUtil;

}() );

/*******************************************************************************
 * Copyright (c) 2011, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

(function(){

namespace( "rwt.client" );

  rwt.widgets.util.ToolTipConfig = {

    getConfig : function( widget ) {
      if( widget.getParent() instanceof rwt.widgets.CoolBar ) {
        return this._getClickableConfig( widget );
      }
      switch( widget.classname ) {
        case "rwt.widgets.ControlDecorator":
          return this._quickConfig;
        case "rwt.widgets.Label":
          return this._getLabelConfig( widget );
        case "rwt.widgets.Button":
        case "rwt.widgets.TabItem":
        case "rwt.widgets.CTabItem":
          return this._getClickableConfig( widget );
        case "rwt.widgets.Text":
        case "rwt.widgets.Spinner":
        case "rwt.widgets.Combo":
        case "rwt.widgets.DateTimeDate":
        case "rwt.widgets.DateTimeTime":
          return this._fieldConfig;
        case "rwt.widgets.ToolItem":
          return this._getClickableConfig( widget );
        case "rwt.widgets.ProgressBar":
          return rwt.util.Objects.mergeWith( { "overlap" : 3 }, this._getBarConfig( widget ) );
        case "rwt.widgets.Scale":
        case "rwt.widgets.Slider":
          return rwt.util.Objects.mergeWith( { "overlap" : -2 }, this._getBarConfig( widget ) );
        case "rwt.widgets.base.GridRowContainer":
          return this._rowConfig;
        default:
          return this._defaultConfig;
      }

    },

    _getBarConfig : function( widget ) {
      if( widget.hasState( "rwt_VERTICAL" ) ) {
        return this._verticalBarConfig;
      } else {
        return this._horizontalBarConfig;
      }
    },

    _getClickableConfig : function( widget ) {
      if( widget.hasState( "rwt_VERTICAL" ) ) {
        return this._verticalClickableConfig;
      } else {
        var appearance = widget.getAppearance();
        var result = this._horizontalClickableConfig;
        if( appearance === "check-box" || appearance === "radio-button" ) {
          return rwt.util.Objects.mergeWith( { "overlap" : -1 }, result );
        } else {
          return result;
        }
      }
    },

    _getLabelConfig : function( widget ) {
      if( !widget._rawText ) {
        return this._quickConfig;
      } else {
        return this._fieldConfig;
      }
    },

    _defaultConfig : {
      "position" : "mouse",
      "appearOn" : "rest",
      "disappearOn" : "move",
      "appearDelay" : 1000,
      "disappearDelay" : 200,
      "autoHide" : true
    },

    _horizontalClickableConfig : {
      "position" : "horizontal-center",
      "appearOn" : "enter",
      "disappearOn" : "exit",
      "appearDelay" : 200,
      "disappearDelay" : 100,
      "autoHide" : true
    },

    _verticalClickableConfig : {
      "position" : "vertical-center",
      "appearOn" : "enter",
      "disappearOn" : "exit",
      "appearDelay" : 200,
      "disappearDelay" : 100,
      "autoHide" : true
    },

    _horizontalBarConfig : {
      "position" : "horizontal-center",
      "appearOn" : "enter",
      "disappearOn" : "exit",
      "appearDelay" : 200,
      "disappearDelay" : 100,
      "autoHide" : false
    },

    _verticalBarConfig : {
      "position" : "vertical-center",
      "appearOn" : "enter",
      "disappearOn" : "exit",
      "appearDelay" : 200,
      "disappearDelay" : 100,
      "autoHide" : false
    },

    _fieldConfig : {
      "position" : "align-left",
      "appearOn" : "rest",
      "disappearOn" : "exit",
      "appearDelay" : 500,
      "disappearDelay" : 200,
      "autoHide" : true
    },

    _quickConfig : {
      "position" : "horizontal-center",
      "appearOn" : "enter",
      "disappearOn" : "exit",
      "appearDelay" : 20,
      "disappearDelay" : 50,
      "autoHide" : false,
      "overlap" : -1
    },

    _rowConfig : {
      "position" : "align-left",
      "appearOn" : "rest",
      "disappearOn" : "exitTargetBounds",
      "appearDelay" : 700,
      "disappearDelay" : 100,
      "autoHide" : true
    }


  };

}());

/*******************************************************************************
 * Copyright (c) 2009, 2015 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.qx.Class.define( "rwt.widgets.base.WidgetToolTip", {

  extend : rwt.widgets.base.Popup,
  include : rwt.animation.VisibilityAnimationMixin,

  construct : function() {
    this.base( arguments );
    this._label = new rwt.widgets.base.MultiCellWidget( [ "label" ] );
    this._label.setParent( this );
    this._pointer = null;
    this._showTimer = new rwt.client.Timer();
    this._showTimer.addEventListener( "interval", this._onshowtimer, this );
    this._hideTimer = new rwt.client.Timer();
    this._hideTimer.addEventListener( "interval", this._onhidetimer, this );
    this._lastWidget = null;
    this._fallbackMode = false;
    this.addEventListener( "mouseover", this._onMouseOver );
    this.addEventListener( "mouseout", this._onMouseOver );
    this.addEventListener( "mouseup", this._onMouseUp );
    this._config = {};
    this.setRestrictToPageOnOpen( false );
  },

  statics : {

    getInstance : function() {
      return rwt.runtime.Singletons.get( rwt.widgets.base.WidgetToolTip );
    },

    setToolTipText : function( widget, value ) {
      if( value != null && value !== "" ) {
        var text = value;
        if( widget.getUserData( "toolTipMarkupEnabled" ) !== true ) {
          var EncodingUtil = rwt.util.Encoding;
          text = EncodingUtil.escapeText( text, false );
          text = EncodingUtil.replaceNewLines( text, "<br/>" );
        }
        widget.setToolTipText( text );
        widget.dispatchSimpleEvent( "updateToolTip", widget );
      } else {
        widget.setToolTipText( null );
      }
    }

  },

  properties : {

    appearance : {
      refine : true,
      init : "widget-tool-tip"
    },

    mousePointerOffsetX : {
      check : "Integer",
      init : 1
    },

    mousePointerOffsetY : {
      check : "Integer",
      init : 20
    },

    boundToWidget : {
      check : "rwt.widgets.base.Widget",
      apply : "_applyBoundToWidget",
      nullable : true,
      init : null
    },

    pointers : {
      nullable : true,
      init : null,
      themeable : true
    },

    textAlign : {
      check : [ "left", "center", "right" ],
      init : "center",
      themeable : true,
      apply : "_applyTextAlign"
    }

  },

  members : {
    _minZIndex : 1e7,
    _targetDistance : 4,

    updateText : function() {
      if( this.getBoundToWidget() ) {
        this._updateTextInternal();
        if( this.getText() && !this._showTimer.isEnabled() ) {
          this._onshowtimer();
        }
        if( !this.getText() ) {
          this._quickHide();
        }
      }
    },

    getLastWidget : function() {
      return this._lastWidget;
    },

    getFocusRoot : function() {
      return null; // prevent setting clientDocument as a focused widget
    },

    _applyElement : function( value, old ) {
      this.base( arguments, value, old );
    },

    _applyTextAlign : function( value ) {
      this._label.setHorizontalChildrenAlign( value );
    },

    _getPointerElement : function() {
      if( this._pointer == null ) {
        this._pointer = document.createElement( "div" );
        this._pointer.style.position = "absolute";
        rwt.html.Style.setBackgroundRepeat( this._pointer, "no-repeat" );
        rwt.html.Style.setPointerEvents( this._pointer, "none" );
        this.getElement().appendChild( this._pointer );
      }
      return this._pointer;
    },

    _applyBoundToWidget : function( value, old ) {
      if( value ) {
        this.setParent( rwt.widgets.base.ClientDocument.getInstance() );
        this._config = rwt.widgets.util.ToolTipConfig.getConfig( this.getBoundToWidget() );
        this._showTimer.setInterval( this._config.appearDelay || 1000 );
        this._hideTimer.setInterval( this._config.disappearDelay || 200 );
        this.setAutoHide( this._config.autoHide !== false );
      } else if( old ) {
        this._config = {};
      }
    },

    _beforeAppear : function() {
      this.base( arguments );
      this._stopShowTimer();
    },

    _beforeDisappear : function() {
      this.base( arguments );
      this._stopHideTimer();
    },

    _startShowTimer : function() {
      if(     this._allowQuickAppear()
          && ( this._config.appearOn === "enter" || this._lastWidget == this.getBoundToWidget() )  ) {
        this._onshowtimer();
      } else {
        if( !this._showTimer.getEnabled() ) {
          this._showTimer.start();
        }
      }
    },

    _allowQuickAppear : function() {
      var now = ( new Date() ).getTime();
      return this.isSeeable() || ( this._hideTimeStamp > 0 && ( now - this._hideTimeStamp ) < 300 );
    },

    _startHideTimer : function() {
      if( !this._hideTimer.getEnabled() ) {
        this._hideTimer.start();
      }
    },

    _stopShowTimer : function() {
      if( this._showTimer.getEnabled() ) {
        this._showTimer.stop();
      }
    },

    _stopHideTimer : function() {
      if( this._hideTimer.getEnabled() ) {
        this._hideTimer.stop();
      }
    },

    _onMouseOver : function( event ) {
      if( this._pointer && this._pointer === event.getDomTarget() ) {
        return;
      }
      if( this.getElement().getElementsByTagName( "a" ).length > 0 ) {
        return;
      }
      this._quickHide();
    },

    _onMouseUp : function() {
      rwt.client.Timer.once( function() {
        this._quickHide();
      }, this, 100 );
    },

    _quickHide : function() {
      if( this._disappearAnimation && this._disappearAnimation.isRunning() ) {
        this._disappearAnimation.skip();
      } else if( this._disappearAnimation && this._disappearAnimation.getDefaultRenderer().isActive() ) {
        this._disappearAnimation.getDefaultRenderer().setActive( false );
        this.hide();
        this._disappearAnimation.getDefaultRenderer().setActive( true );
      } else {
        this.hide();
      }
    },

    _handleMouseMove : function( event ) {
      if( this.getBoundToWidget() ) {
        if( this.isSeeable() && !this._hideTimer.getEnabled() ) {
          if( this._config.disappearOn === "move" || this._fallbackMode ) {
            this._startHideTimer();
          } else if( this._config.disappearOn === "exitTargetBounds" ) {
            var bounds = this._getTargetBounds();
            var x = event.getPageX();
            var y = event.getPageY();
            if(    ( x < bounds.left ) || ( x > ( bounds.left + bounds.width ) )
                || ( y < bounds.top ) || ( y > ( bounds.top + bounds.height ) ) )
            {
              this._startHideTimer();
            }
          }
        } else {
          if( this._config.appearOn === "rest" ) {
            this._showTimer.restart(); // TODO: ignore small movements for start?
          }
        }
      }
    },

    _onshowtimer : function() {
      this._lastWidget = this.getBoundToWidget();
      this._stopShowTimer();
      this._stopHideTimer();
      this._updateTextInternal();
      if( this.getText() ) {
        if(    this._allowQuickAppear()
            && this._appearAnimation
            && this._appearAnimation.getDefaultRenderer().isActive()
            && !this.isSeeable() )
        {
          this._appearAnimation.getDefaultRenderer().setActive( false );
          this.show();
          this._appearAnimation.getDefaultRenderer().setActive( true );
        } else {
          this.show();
        }
        rwt.widgets.base.Widget.flushGlobalQueues(); // render new dimension
        this._afterAppearLayout();
        rwt.widgets.base.Widget.flushGlobalQueues(); // render position
      } else if( this.getBoundToWidget().requestToolTipText ) {
        this.getBoundToWidget().requestToolTipText();
      }
    },

    _onhidetimer : function() {
      if( this._config.appearOn === "rest" ) {
        this._showTimer.start();
      }
      return this.hide();
    },

    _afterAppearLayout : function() {
      var targetBounds = this._getTargetBounds();
      this._fallbackMode = this._computeFallbackMode( targetBounds );
      var docDimension = this._getDocumentDimension();
      var selfDimension = this._getOwnDimension();
      var newPosition = this._getPositionAfterAppear( targetBounds, docDimension, selfDimension );
      this.setLeft( newPosition[ 0 ] );
      this.setTop( newPosition[ 1 ] );
      var selfInnerBounds = {
        left : newPosition[ 0 ] + this._cachedBorderLeft,
        top : newPosition[ 1 ] + this._cachedBorderTop,
        width : selfDimension.width - this._cachedBorderLeft - this._cachedBorderRight,
        height : selfDimension.height - this._cachedBorderTop - this._cachedBorderBottom
      };
      this._renderPointer( targetBounds, selfInnerBounds );
    },

    _renderPointer : function( target, self ) {
      var pointers = this.getPointers();
      var enabled =    this._config.position
                    && this._config.position !== "mouse" && pointers
                    && !this._fallbackMode;
      this._getPointerElement().style.display = "none";
      if( enabled ) {
        var direction = this._getDirection( target, self );
        if( direction === "up" && pointers[ 0 ] ) {
          this._renderPointerUp( target, self );
        } else if( direction === "down" && pointers[ 2 ] ) {
          this._renderPointerDown( target, self );
        } else if( direction === "left" && pointers[ 3 ] ) {
          this._renderPointerLeft( target, self );
        } else if( direction === "right" && pointers[ 1 ] ) {
          this._renderPointerRight( target, self );
        }
      }
    },

    _renderPointerUp : function( target, self ) {
      var pointer = this.getPointers()[ 0 ];
      var element = this._getPointerElement();
      rwt.html.Style.setBackgroundImage( element, pointer[ 0 ] );
      element.style.width = pointer[ 1 ] + "px";
      element.style.height = pointer[ 2 ] + "px";
      element.style.top = ( -1 * pointer[ 2 ] ) + "px";
      this._renderPointerHorizontalAlign( target, self, pointer );
      element.style.display = "";
    },

    _renderPointerDown : function( target, self ) {
      var pointer = this.getPointers()[ 2 ];
      var element = this._getPointerElement();
      rwt.html.Style.setBackgroundImage( element, pointer[ 0 ] );
      element.style.width = pointer[ 1 ] + "px";
      element.style.height = pointer[ 2 ] + "px";
      element.style.top = self.height + "px";
      this._renderPointerHorizontalAlign( target, self, pointer );
      element.style.display = "";
    },

    _renderPointerLeft : function( target, self ) {
      var pointer = this.getPointers()[ 3 ];
      var element = this._getPointerElement();
      var targetCenter = this._getBoundsCenter( target );
      rwt.html.Style.setBackgroundImage( element, pointer[ 0 ] );
      element.style.width = pointer[ 1 ] + "px";
      element.style.height = pointer[ 2 ] + "px";
      element.style.left = ( -1 * pointer[ 1 ] ) + "px";
      element.style.top = Math.round( targetCenter.top - self.top - pointer[ 2 ] / 2 ) + "px";
      element.style.display = "";
    },

    _renderPointerRight : function( target, self ) {
      var pointer = this.getPointers()[ 1 ];
      var element = this._getPointerElement();
      var targetCenter = this._getBoundsCenter( target );
      rwt.html.Style.setBackgroundImage( element, pointer[ 0 ] );
      element.style.width = pointer[ 1 ] + "px";
      element.style.height = pointer[ 2 ] + "px";
      element.style.left = self.width + "px";
      element.style.top = Math.round( targetCenter.top - self.top - pointer[ 2 ] / 2 ) + "px";
      element.style.display = "";
    },

    _renderPointerHorizontalAlign : function( target, self, pointer ) {
      var element = this._getPointerElement();
      if( this._config.position === "align-left" ) {
        var targetedLeft =   target.left
                           + this._targetDistance
                           + this._cachedBorderLeft
                           + this.getPaddingLeft();
        element.style.left = Math.round( targetedLeft - self.left ) + "px";
      } else {
        var targetCenter = this._getBoundsCenter( target );
        element.style.left = Math.round( targetCenter.left - self.left - pointer[ 1 ] / 2 ) + "px";
      }
    },

    _getDirection : function( target, self ) {
      var targetBetweenSelfX = target.left >= self.left && target.left <= ( self.left + self.width );
      var selfBetweenTargetX = self.left >= target.left && self.left <= ( target.left + target.width );
      if( targetBetweenSelfX || selfBetweenTargetX ) {
        return self.top > target.top ? "up" : "down";
      } else {
        return self.left > target.left ? "left" : "right";
      }
    },

    _getBoundsCenter : function( bounds ) {  // may return float!
      return {
        left : bounds.left + bounds.width / 2,
        top : bounds.top + bounds.height / 2
      };
    },

    _updateTextInternal : function() {
      this._label.setCellContent( 0, this.getBoundToWidget().getToolTipText() );
    },

    _computeFallbackMode : function( target ) {
      var doc = this._getDocumentDimension();
      var right = target.left + target.width;
      var bottom = target.top + target.height;
      if( target.left < 0 || target.top < 0 || right > doc.width || bottom > doc.height ) {
        return true;
      }
      var display = this.getElement().style.display;
      this.getElement().style.display = "none";
      var targetElements = [
        document.elementFromPoint( target.left + target.width / 2 , target.top + 1 ),
        document.elementFromPoint( right - 1, target.top + target.height / 2 ),
        document.elementFromPoint( target.left + target.width / 2, bottom - 1 ),
        document.elementFromPoint( target.left + 1, target.top + target.height / 2 )
      ];
      this.getElement().style.display = display;
      var boundWidget = this.getBoundToWidget();
      for( var i = 0; i < 4; i++ ) {
        var widget = rwt.event.EventHandlerUtil.getOriginalTargetObject( targetElements[ i ] );
        if(    widget == null
            || !( boundWidget === widget || boundWidget.contains( widget ) ) )
        {
          return true;
        }
      }
      return false; // all four edges are visible on screen
    },

    getText : function() {
      return this._label.getCellContent( 0 );
    },

    _getPositionAfterAppear : function( target, doc, self ) {
      var result;
      if( !this._fallbackMode ) {
        switch( this._config.position ) {
          case "horizontal-center":
            result = this._positionHorizontalCenter( target, doc, self );
          break;
          case "align-left":
            result = this._positionAlignLeft( target, doc, self );
          break;
          case "vertical-center":
            result = this._positionVerticalCenter( target, doc, self );
          break;
          default:
            result = this._positionMouseRelative( target, doc, self );
          break;
        }
      } else {
        result = this._positionMouseRelative( target, doc, self );
      }
      result[ 0 ] = Math.max( 0, Math.min( result[ 0 ], doc.width - self.width ) );
      result[ 1 ] = Math.max( 0, Math.min( result[ 1 ], doc.height - self.height ) );
      return result;
    },

    _positionMouseRelative : function() {
      return [
        rwt.event.MouseEvent.getPageX() + this.getMousePointerOffsetX(),
        rwt.event.MouseEvent.getPageY() + this.getMousePointerOffsetY()
      ];
    },

    _positionHorizontalCenter : function( target, doc, self ) {
      var left = this._getHorizontalOffsetCentered( target, self, doc );
      var top = this._getVerticalOffsetAutoByAbsolutePosition( target, self, doc );
      return [ left, top ];
    },

    _positionAlignLeft : function( target, doc, self ) {
      var left = this._getHorizontalOffsetAlignLeft( target, self, doc );
      var top = this._getVerticalOffsetAutoByAbsolutePosition( target, self, doc );
      return [ left, top ];
    },

    _positionVerticalCenter : function( target, doc, self ) {
      var left = this._getHorizontalOffsetAuto( target, self, doc );
      var top = this._getVerticalOffsetCentered( target, self, doc );
      return [ left, top ];
    },

    _getVerticalOffsetAutoByAbsolutePosition : function( target, self ) {
      var top = this._getVerticalOffsetTop( target, self );
      if( top < 30 ) {
        top = this._getVerticalOffsetBottom( target, self );
      }
      return top;
    },

    _getVerticalOffsetTop : function( target, self ) {
      return target.top - self.height - this._getTargetDistance( "down" );
    },

    _getVerticalOffsetBottom : function( target ) {
      return target.top + target.height + this._getTargetDistance( "up" );
    },

    _getHorizontalOffsetCentered : function( target, self ) {
      return Math.round( target.left + ( target.width / 2 ) - self.width / 2 );
    },

    _getHorizontalOffsetAlignLeft : function( target ) {
      return target.left + this._targetDistance;
    },

    _getHorizontalOffsetAuto : function( target, self, doc ) {
      var leftSpace = target.left;
      var rightSpace = doc.width - leftSpace - target.width;
      if( leftSpace > rightSpace ) {
        return target.left - self.width - this._getTargetDistance( "right" );
      } else {
        return target.left + target.width + this._getTargetDistance( "left" );
      }
    },

    _getVerticalOffsetCentered : function( target, self ) {
      return Math.round( target.top + ( target.height / 2 ) - self.height / 2 );
    },

    _getTargetBounds : function() {
      var widget = this.getBoundToWidget();
      var location = rwt.html.Location.get( widget.getElement() );
      var result = {
        "left" : location.left,
        "top" : location.top,
        "width" : widget.getBoxWidth(),
        "height" : widget.getBoxHeight()
      };
      if( widget.getToolTipTargetBounds ) {
        var innerBounds = widget.getToolTipTargetBounds();
        result.left += innerBounds.left;
        result.top += innerBounds.top;
        result.width = innerBounds.width;
        result.height = innerBounds.height;
      }
      return result;
    },

    _getDocumentDimension : function() {
      var doc = rwt.widgets.base.ClientDocument.getInstance();
      return { "width" : doc.getClientWidth(), "height" : doc.getClientHeight() };
    },

    _getOwnDimension : function() {
      return { "width" : this.getBoxWidth(), "height" : this.getBoxHeight() };
    },

    _getTargetDistance : function( direction ) {
      var overlap = typeof this._config.overlap === "number" ? this._config.overlap : 4;
      var pointers = this.getPointers();
      if( direction === "up" && pointers && pointers[ 0 ] ) {
        return pointers[ 0 ][ 2 ] - overlap;
      } else if( direction === "down" && pointers && pointers[ 2 ] ) {
        return pointers[ 2 ][ 2 ] - overlap;
      } else if( direction === "left" && pointers && pointers[ 3 ] ) {
        return pointers[ 3 ][ 1 ] - overlap;
      } else if( direction === "right" && pointers && pointers[ 1 ] ) {
        return pointers[ 1 ][ 1 ] - overlap;
      } else {
        return this._targetDistance;
      }
    }


  },

  destruct : function() {
    this._disposeObjects("_showTimer", "_hideTimer", "_label");
  }

} );

/*******************************************************************************
 * Copyright (c) 2007, 2014 Innoopract Informationssysteme GmbH and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Innoopract Informationssysteme GmbH - initial API and implementation
 *    EclipseSource - ongoing development
 ******************************************************************************/

/**
 * Store for theme values that cannot be kept in a qooxdoo theme. The store is
 * filled from the server at startup.
 */
rwt.qx.Class.define( "rwt.theme.ThemeStore", {

  extend : rwt.qx.Object,

  statics : {

    getInstance : function() {
      return rwt.runtime.Singletons.get( rwt.theme.ThemeStore );
    }

  },

  construct : function() {
    this._values = {
      dimensions : {},
      boxdims : {},
      images : {},
      gradients : {},
      fonts : {},
      colors : {},
      borders : {},
      cursors : {},
      animations : {},
      shadows : {}
    };
    this._cssValues = {};
    this._statesMap = {
      "*" : {
        "hover" : "over"
      },
      "DateTime-Calendar-Day" : {
        "unfocused" : "parent_unfocused"
      },
      "List-Item" : {
        "unfocused" : "parent_unfocused"
      },
      "Text" : {
        "read-only" : "readonly"
      },
      "TreeItem" : {
        "unfocused" : "parent_unfocused"
      },
      "Tree-RowOverlay" : {
        "unfocused" : "parent_unfocused"
      },
      "TreeColumn" : {
        "hover" : "mouseover"
      },
      "Shell" : {
        "inactive" : "!active"
      },
      "Shell-Titlebar" : {
        "inactive" : "!active"
      },
      "Shell-MinButton" : {
        "inactive" : "!active"
      },
      "Shell-MaxButton" : {
        "inactive" : "!active"
      },
      "Shell-CloseButton" : {
        "inactive" : "!active"
      },
      "TableColumn" : {
        "hover" : "mouseover"
      },
      "TableItem" : {
        "unfocused" : "parent_unfocused"
      },
      "Table-RowOverlay" : {
        "unfocused" : "parent_unfocused"
      },
      "TabItem" : {
        "selected" : "checked",
        "first" : "firstChild",
        "last" : "lastChild",
        "bottom" : "barBottom"
      }
    };
    this._namedColors = {};
  },

  members : {

    setCurrentTheme : function( themeId ) {
      this._currentTheme = themeId;
    },

    getCurrentTheme : function() {
      return this._currentTheme;
    },

    setFallbackTheme : function( themeId ) {
      this.fallbackTheme = themeId;
    },

    getFallbackTheme : function() {
      return this.fallbackTheme;
    },

    /////////////
    // Server API

    defineValues : function( values ) {
      for( var type in this._values ) {
        if( type in values ) {
          for( var key in values[ type ] ) {
            if( !( key in this._values[ type ] ) ) {
              this._values[ type ][ key ] = values[ type ][ key ];
            }
          }
        }
      }
    },

    setThemeCssValues : function( theme, values, isFallback ) {
      this._cssValues[ theme ] = values;
      if( isFallback ) {
        this.fallbackTheme = theme;
      }
      this._fillNamedColors( theme );
    },

    /////////////
    // Client API

    getColor : function( element, states, property, theme ) {
      var key = this._getCssValue( element, states, property, theme );
      var result = this._values.colors[ key ];
      if( result instanceof Array ) {
        result = "#" + rwt.util.Colors.rgbToHexString( result );
      }
      return result;
    },

    getAlpha : function( element, states, property, theme ) {
      var key = this._getCssValue( element, states, property, theme );
      var color = this._values.colors[ key ];
      var result = 1;
      if( color instanceof Array ) {
        result = color[ 3 ];
      } else if( color === "transparent" ) {
        result = 0;
      }
      return result;
    },

    getNamedColor : function( name ) {
      var result = this._namedColors[ name ];
      return result ? result : name;
    },

    getDimension : function( element, states, property, theme ) {
      var key = this._getCssValue( element, states, property, theme );
      return this._values.dimensions[ key ];
    },

    getBoxDimensions : function( element, states, property, theme ) {
      var key = this._getCssValue( element, states, property, theme );
      return this._values.boxdims[ key ];
    },

    getBoolean : function( element, states, property, theme ) {
      return this._getCssValue( element, states, property, theme );
    },

    getFloat : function( element, states, property, theme ) {
      return parseFloat( this._getCssValue( element, states, property, theme ) );
    },

    getIdentifier : function( element, states, property, theme ) {
      return this._getCssValue( element, states, property, theme );
    },

    getImage : function( element, states, property, theme ) {
      var result;
      var key = this._getCssValue( element, states, property, theme );
      var imageArray = this._values.images[ key ];
      if( imageArray != null ) {
        // TODO [rh] remove hard-coded path (first segment is defined by
        //      resource-manager)
        result = "rwt-resources/themes/images/" + key;
      } else {
        // TODO [rst] Handle null values - currently, both null and the string
        // "undefined" lead to a js error for icon property
        result = rwt.theme.ThemeValues.NONE_IMAGE;
      }
      return result;
    },

    getSizedImage : function( element, states, property, theme ) {
      var key = this._getCssValue(  element, states, property, theme );
      var imageArray = this._values.images[ key ];
      var result;
      if( imageArray != null ) {
        // TODO [tb] : Revise hardcoded path
        result = [ "rwt-resources/themes/images/" + key ].concat( imageArray );
      } else {
        result = rwt.theme.ThemeValues.NONE_IMAGE_SIZED;
      }
      return result;
    },

    getCursor : function( element, states, property, theme ) {
      var key = this._getCssValue( element, states, property, theme );
      var result = this._values.cursors[ key ];
      if( key === null ) {
        result = "rwt-resources/themes/cursors/" + key;
      }
      return result;
    },

    getAnimation : function( element, states, property, theme ) {
      var key = this._getCssValue( element, states, property, theme );
      return this._values.animations[ key ];
    },

    getFont : function( element, states, property, theme ) {
      var key = this._getCssValue( element, states, property, theme );
      var value = this._values.fonts[ key ];
      if( !( value instanceof rwt.html.Font ) ) {
        var font = new rwt.html.Font();
        font.setSize( value.size );
        font.setFamily( value.family );
        font.setBold( value.bold );
        font.setItalic( value.italic );
        this._values.fonts[ key ] = font;
      }
      return this._values.fonts[ key ];
    },

    getBorder : function( element, states, property, theme ) {
      var key = this._createCompleteBorderKey( element, states, theme );
      var radiiKey = this._getCssValue( element, states, "border-radius", theme );
      var radii = this._values.boxdims[ radiiKey ];
      var rounded = radii != null && ( radii.join( "" ) !== "0000" );
      if( rounded ) {
        key += "#" + radiiKey;
      }
      var border = this._values.borders[ key ];
      if( !border || !( border instanceof rwt.html.Border ) ) {
        var top = this.getBorderEdge( element, states, "border-top", theme );
        var right = this.getBorderEdge( element, states, "border-right", theme );
        var bottom = this.getBorderEdge( element, states, "border-bottom", theme );
        var left = this.getBorderEdge( element, states, "border-left", theme );
        var widths
          = [ top.getWidthTop(), right.getWidthTop(), bottom.getWidthTop(), left.getWidthTop() ];
        var colors
          = [ top.getColorTop(), right.getColorTop(), bottom.getColorTop(), left.getColorTop() ];
        var styles
          = [ top.getStyleTop(), right.getStyleTop(), bottom.getStyleTop(), left.getStyleTop() ];
        border = new rwt.html.Border( widths, styles, colors, rounded ? radii : undefined );
        this._values.borders[ key ] = border;
      }
      return border;
    },

    getBorderEdge : function( element, states, property, theme ) {
      var border;
      var key = this._getCssValue( element, states, property, theme );
      var value = this._values.borders[ key ];
      var resolved = value instanceof rwt.html.Border;
      var radiiKey = this._getCssValue( element, states, "border-radius", theme );
      var radii = this._values.boxdims[ radiiKey ];
      if( radii != null && ( radii.join( "" ) !== "0000" ) ) {
        var roundedBorderKey = key + "#" + radiiKey;
        border = this._values.borders[ roundedBorderKey ];
        if( !border ) {
          var width = resolved ? value.getWidthTop() : value.width;
          var style = resolved ? value.getStyleTop() : value.style;
          var color = resolved ? value.getColorTop() : value.color;
          border = new rwt.html.Border( width, style, color, radii );
          this._values.borders[ roundedBorderKey ] = border;
        }
      }
      if( !border ) {
        if( resolved ) {
          border = value;
        } else {
          border = new rwt.html.Border( value.width, value.style, value.color );
          this._values.borders[ key ] = border;
        }
      }
      return border;
    },

    getNamedBorder : function( name ) {
      var key = "_" + name;
      var result = this._values.borders[ key ];
      if( !result ) {
        var borderDef = rwt.theme.BorderDefinitions.getDefinition( name );
        if( borderDef ) {
          var color = this._resolveNamedColors( borderDef.color );
          var innerColor = this._resolveNamedColors( borderDef.innerColor );
          result = new rwt.html.Border( borderDef.width, "complex", color, innerColor );
          this._values.borders[ key ] = result;
        } else {
          result = null;
        }
      }
      return result;
    },

    getShadow : function( element, states, property, theme ) {
      var key = this._getCssValue( element, states, property, theme );
      return this._values.shadows[ key ];
    },

    getGradient : function( element, states, property, theme ) {
      var result = null;
      var key = this._getCssValue( element, states, property, theme );
      var value = this._values.gradients[ key ];
      if( value ) {
        // TODO [if] remove this check when values are rendered only once
        if( value.colors && value.percents ) {
          var gradient = [];
          for( var i = 0; i < value.colors.length; i++ ) {
            gradient[ i ] = [ value.percents[ i ] / 100, value.colors[ i ] ];
          }
          gradient.horizontal = !value.vertical;
          this._values.gradients[ key ] = gradient;
        }
        result = this._values.gradients[ key ];
      }
      return result;
    },

    ////////////
    // Internals

    _getCssValue : function( element, states, property, theme ) {
      var result;
      if( theme == null ) {
        theme = this._currentTheme;
      }
      if(    this._cssValues[ theme ] !== undefined
          && this._cssValues[ theme ][ element ] !== undefined
          && this._cssValues[ theme ][ element ][ property ] !== undefined )
      {
        var values = this._cssValues[ theme ][ element ][ property ];
        var found = false;
        for( var i = 0; i < values.length && !found; i++ ) {
          if( this._matches( states, element, values[ i ][ 0 ] ) ) {
            result = values[ i ][ 1 ];
            found = true;
          }
        }
      }
      if( result === undefined && theme != this.fallbackTheme ) {
        result = this._getCssValue( element, states, property, this.fallbackTheme );
      }
      return result;
    },

    _matches : function( states, element, constraints ) {
      var result = true;
      for( var i = 0; i < constraints.length && result; i++ ) {
        var cond = constraints[ i ];
        if( cond.length > 0 ) {
          var c = cond.charAt( 0 );
          if( c == "." ) {
            result = "variant_" + cond.substr( 1 ) in states;
          } else if( c == ":" ) {
            var state = this._translateState( cond.substr( 1 ), element );
            if( state.charAt( 0 ) == "!" ) {
              result = ! ( state.substr( 1 ) in states );
            } else {
              result = state in states;
            }
          } else if( c == "[" ) {
            result = "rwt_" + cond.substr( 1 ) in states;
          }
        }
      }
      return result;
    },

    _translateState : function( state, element ) {
      var result = state;
      if( element in this._statesMap && state in this._statesMap[ element ] ) {
        result = this._statesMap[ element ][ state ];
      } else if( state in this._statesMap[ "*" ] ) {
        result = this._statesMap[ "*" ][ state ];
      }
      return result;
    },

    _resolveNamedColors : function( colorArr ) {
      var result = null;
      if( colorArr ) {
        result = [];
        for( var i = 0; i < colorArr.length; i++ ) {
          result[ i ] = this.getNamedColor( colorArr[ i ] );
        }
      }
      return result;
    },

    // Fills a map with named colors necessary for border-definitions
    _fillNamedColors : function( theme ) {
      this._namedColors[ "darkshadow" ]
        = this.getColor( "Display", {}, "rwt-darkshadow-color", theme );
      this._namedColors[ "highlight" ]
        = this.getColor( "Display", {}, "rwt-highlight-color", theme );
      this._namedColors[ "lightshadow" ]
        = this.getColor( "Display", {}, "rwt-lightshadow-color", theme );
      this._namedColors[ "shadow" ]
        = this.getColor( "Display", {}, "rwt-shadow-color", theme );
      this._namedColors[ "thinborder" ]
        = this.getColor( "Display", {}, "rwt-thinborder-color", theme );
      // TODO [rst] eliminate these properties
      this._namedColors[ "selection-marker" ]
        = this.getColor( "Display", {}, "rwt-selectionmarker-color", theme );
      this._namedColors[ "background" ]
        = this.getColor( "*", {}, "background-color", theme );
      this._namedColors[ "foreground" ]
        = this.getColor( "*", {}, "color", theme );
      this._namedColors[ "info.foreground" ]
        = this.getColor( "Widget-ToolTip", {}, "color", theme );
    },

    _createCompleteBorderKey : function( element, states, theme ) {
      var topKey = this._getCssValue( element, states, "border-top", theme );
      var rightKey = this._getCssValue( element, states, "border-right", theme );
      var bottomKey = this._getCssValue( element, states, "border-bottom", theme );
      var leftKey = this._getCssValue( element, states, "border-left", theme );
      if( topKey === rightKey && topKey === bottomKey && topKey === leftKey ) {
        return topKey;
      }
      return topKey + "#" + rightKey + "#" + bottomKey + "#" + leftKey;
    }

  }

} );

/*******************************************************************************
 * Copyright (c) 2012, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.remote.HandlerRegistry.add( "rwt.theme.ThemeStore", {

  factory : function() {
    return rwt.theme.ThemeStore.getInstance();
  },

  service : true,

  methods : [
    "loadActiveTheme",
    "loadFallbackTheme"
  ],

  methodHandler : {
    "loadActiveTheme" : function( object, params ) {
      var request = new rwt.remote.Request( params.url, "GET", "application/json" );
      request.setAsynchronous( false );
      request.setSuccessHandler( function( event ) {
        var result = JSON.parse( event.responseText );
        object.defineValues( result.values );
        object.setThemeCssValues( params.url, result.theme, false );
        object.setCurrentTheme( params.url );
      } );
      request.send();
    },
    "loadFallbackTheme" : function( object, params ) {
      var request = new rwt.remote.Request( params.url, "GET", "application/json" );
      request.setAsynchronous( false );
      request.setSuccessHandler( function( event ) {
        var result = JSON.parse( event.responseText );
        object.defineValues( result.values );
        object.setThemeCssValues( params.url, result.theme, true );
      } );
      request.send();
    }
  }

} );

/*******************************************************************************
 * Copyright (c) 2009, 2015 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

(function($){

var $labelTemplate = $( "<div>" ).css( {
  position : "absolute",
  overflow : "hidden",
  whiteSpace : "nowrap"
} );

var $imageTemplate = $( "<div>" ).css( {
  position : "absolute",
  backgroundRepeat : "no-repeat"
} );

rwt.qx.Class.define( "rwt.widgets.base.MultiCellWidget",  {

  extend : rwt.widgets.base.Terminator,

  /**
   * param cells: an array of cell types to define widget structure.
   *              Valid types are "image" and "label".
   *              Examples:
   *                [ "image" ]
   *                [ "image", "image", "label", "image" ]
   */
  construct : function( cells ) {
    this.base( arguments );
    this.$el = $( this );
    // cellData for a single cell is:
    // [ type, content, width, height, computedWidth, computedHeight, visible ]
    this.__cellData = null;
    this.$cells = null;
    this.__cellCount = null;
    this.__styleRegExp = /([a-z])([A-Z])/g;
    this.__createCellData( cells );
    this.__paddingCache = [ 0, 0, 0, 0 ];
    this.__fontCache = {};
    this.__colorCache = "";
    this._flexibleCell = -1;
    this._expandFlexCell = false;
    this.initWidth();
    this.initHeight();
    this.addToQueue( "createContent" );
    this.setOverflow( "hidden" );
    this.initSelectable();
    this.initCursor();
    this.initTextColor();
    this.initHorizontalChildrenAlign();
  },

  destruct : function() {
    this._disposeObjectDeep( "__cellData", 0 );
    this._disposeObjectDeep( "$cells", 0 );
    this._disposeObjectDeep( "__paddingCache", 0 );
    this._disposeObjectDeep( "_fontCache", 0 );
  },

  properties : {

    spacing : {
      check : "Integer",
      init : 4,
      themeable : true,
      apply : "_applySpacing",
      event : "changeSpacing"
    },

    vertical : {
      init : false,
      apply : "_applyVertical",
      themeable : true
    },

    horizontalChildrenAlign : {
      check : [ "left", "center", "right" ],
      init : "center",
      themeable : true,
      apply : "_applyHorizontalChildrenAlign"
    },

    verticalChildrenAlign : {
      check : [ "top", "middle", "bottom" ],
      init : "middle",
      themeable : true,
      apply : "_applyVerticalChildrenAlign"
    },

    textOverflow : {
      check : [ "clip", "ellipsis" ],
      init : "clip",
      themeable : true,
      apply : "_applyTextOverflow"
    },

    wordWrap : {
      check : "Boolean",
      init: false,
      apply : "_applyWordWrap"
    },

    /////////////////////////////////
    // refined properties from Widget

    selectable : {
      refine : true,
      init : false
    },

    textColor : {
      refine : true,
      init : "#000000"
    },

    cursor : {
      refine : true,
      init : "default"
    },

    allowStretchX : {
      refine : true,
      init : false
    },

    allowStretchY : {
      refine : true,
      init : false
    },

    appearance : {
      refine : true,
      init : "atom"
    },

    width : {
      refine : true,
      init : "auto"
    },

    height : {
      refine : true,
      init : "auto"
    }

  },

  members : {

    // TODO [tb] : clean up api (private/public, order)

    ///////////////////////
    // LAYOUT : public api

    /**
     * This is either the URL (image) or the text (label)
     */
    setCellContent : function( cell, value ) {
      this.__updateComputedCellDimension( cell );
      if( this._cellHasContent( cell ) != ( value != null ) ) {
        this._invalidatePreferredInnerWidth();
        this.addToQueue( "createContent" );
      } else {
        this.addToQueue( "updateContent" );
      }
      this.__cellData[ cell ][ 1 ] = value;
    },

    /**
     * The dimensions for the cell. Is mandatory for images (or 0x0 will
     * be assumed), optional for labels. Set a dimension to "null" to use the
     * computed value.
     */
    setCellDimension : function( cell, width, height ) {
      this.setCellWidth( cell, width );
      this.setCellHeight( cell, height );
    },

    /**
     * Setting visibility for a cell to false causes the element to have display:none,
     * but still to be created and layouted.
     */
    setCellVisible : function( cell, value ) {
      this.__cellData[ cell ][ 6 ] = value;
      if( this.$cells[ cell ] ) {
        this.$cells[ cell ].css( "display", value ? "" : "none" );
      }
    },

    isCellVisible : function( cell ) {
      return this.__cellData[ cell ][ 6 ];
    },

    getCellNode : function( cell ) {
      return this.$cells[ cell ] ? this.$cells[ cell ].get( 0 ) : null;
    },

    getCellContent : function( cell ) {
      return this.__cellData[ cell ][ 1 ];
    },

    setCellWidth : function( cell, width ) {
      if( this._getCellWidth( cell ) !== width ) {
        this._setCellWidth( cell, width );
        this._invalidatePreferredInnerWidth();
        this._scheduleLayoutX();
      }
    },

    setCellHeight : function( cell, height ) {
      this._setCellHeight( cell, height );
      this._invalidatePreferredInnerWidth();
      this._invalidatePreferredInnerHeight();
      this._scheduleLayoutY();
    },

    setFlexibleCell : function( value ) {
      this._flexibleCell = value;
    },

    getFlexibleCell : function() {
      return this._flexibleCell;
    },

    expandFlexCell : function( expand ) {
      if( typeof expand === "boolean" ) {
        this._expandFlexCell = expand;
      }
      return this._expandFlexCell;
    },

    // NOTE : Only needed by Tests
    getCellDimension : function( cell ) {
      var width = this.getCellWidth( cell );
      var height = this.getCellHeight( cell );
      return [ width, height ];
    },

    /**
     * Returns the user-set value for width if it exists, else the computed
     */
    getCellWidth : function( cell, ignoreFlexible ) {
      var cellEntry = this.__cellData[ cell ];
      var isFlexible = this._flexibleCell === cell && ignoreFlexible !== true;
      var width = ( cellEntry[ 2 ] != null ? cellEntry[ 2 ] : cellEntry[ 4 ] );
      if( width == null || ( isFlexible && cellEntry[ 3 ] === null ) ) {
        var computed = this.__computeCellDimension( cellEntry );
        width = computed[ 0 ];
      }
      if( isFlexible ) {
        width = this._adjustCellWidth( cell, width );
      }
      return width;
    },

    /**
     * Returns the user-set value for height if it exists, else the computed
     */
    getCellHeight : function( cell, ignoreFlexible ) {
      var cellEntry = this.__cellData[ cell ];
      var isFlexible = this._flexibleCell === cell && ignoreFlexible !== true;
      var height = ( cellEntry[ 3 ] != null ? cellEntry[ 3 ] : cellEntry[ 5 ] );
      if( height == null || ( isFlexible && cellEntry[ 3 ] === null ) ) {
        var wrapWidth = isFlexible && this.getWordWrap() ? this.getCellWidth( cell ) : null;
        var computed = this.__computeCellDimension( cellEntry, wrapWidth );
        height = computed[ 1 ];
      }
      if( isFlexible ) {
        height = this._adjustCellHeight( cell, height );
      }
      return height;
    },

    /*
    ---------------------------------------------------------------------------
      DOM/HTML
    ---------------------------------------------------------------------------
    */

    _applyElement : function( value, old ) {
      this.base( arguments, value, old );
      if( value ) {
        this._createSubElements();
        var font = this.getFont();
        if( font ) {
          font.render( this );
        } else {
          rwt.html.Font.reset( this );
        }
      }
    },

    _createSubElements : function() {
      for( var i = 0; i < this.__cellCount; i++ ) {
        var hasContent = this._cellHasContent( i );
        var hasNode = this.getCellNode( i ) != null;
        if( !hasNode && hasContent ) {
          if( this._isTextCell( i ) ) {
            this.__setCellNode( i, $labelTemplate.clone() );
          } else if( this._isImageCell( i ) ) {
            this.__setCellNode( i, $imageTemplate.clone() );
          }
        } else if( hasNode && !hasContent ) {
          this.$cells[ i ].css( "display", "none" );
        } else if( hasNode && hasContent && this.isCellVisible( i ) ) {
          this.$cells[ i ].css( "display", "" );
        }
      }
      if( !this.getEnabled() ) {
        this._applyEnabled( false );
      }
      if( this.getTextOverflow() !== "clip" ) {
        this._applyTextOverflow( this.getTextOverflow() );
      }
      if( this.getWordWrap() ) {
        this._applyWordWrap( true );
      }
    },

    /*
    ---------------------------------------------------------------------------
      LAYOUT : _apply methods
    ---------------------------------------------------------------------------
    */

    _applyVertical : function() {
      this._scheduleLayoutX();
      this._scheduleLayoutY();
    },

    _applySpacing : function() {
      this._invalidatePreferredInnerWidth();
      this._scheduleLayoutX();
    },

    _applyHorizontalChildrenAlign : function( value ) {
      this._scheduleLayoutX();
      this.setStyleProperty( "textAlign", value );
    },

    _applyVerticalChildrenAlign : function() {
      this._scheduleLayoutY();
    },

    _applyPaddingTop : function( value ) {
      this.addToLayoutChanges( "paddingTop" );
      this.__paddingCache[ 0 ] = value;
      this._invalidateFrameHeight();
    },

    _applyPaddingRight : function( value ) {
      this.addToLayoutChanges( "paddingRight" );
      this.__paddingCache[ 1 ] = value;
      this._invalidateFrameWidth();
    },

    _applyPaddingBottom : function( value ) {
      this.addToLayoutChanges( "paddingBottom" );
      this.__paddingCache[ 2 ] = value;
      this._invalidateFrameHeight();
    },

    _applyPaddingLeft : function( value ) {
      this.addToLayoutChanges( "paddingLeft" );
      this.__paddingCache[ 3 ] = value;
      this._invalidateFrameWidth();
    },

    _applyEnabled : function( value, old ) {
      this.base( arguments, value, old );
      this._styleAllImagesEnabled();
    },

    _applyTextOverflow : function( value ) {
      for( var i = 0; i < this.__cellCount; i++ ) {
        if( this._isTextCell( i ) && this.$cells[ i ] ) {
          this.$cells[ i ].css( "textOverflow", value === "clip" ? "" : value );
        }
      }
    },

    _applyWordWrap : function( value  ) {
      if( this._flexibleCell !== -1 && this.$cells[ this._flexibleCell ] ) {
        this.$cells[ this._flexibleCell ].css( "whiteSpace", value ? "" : "nowrap" );
      }
    },

    /*
    ---------------------------------------------------------------------------
      LAYOUT : internals
    ---------------------------------------------------------------------------
    */

    _scheduleLayoutX : function() {
      this.addToQueue( "layoutX" );
      this._afterScheduleLayoutX();
    },

    _scheduleLayoutY : function() {
      this.addToQueue( "layoutY" );
      this._afterScheduleLayoutY();
    },

    _afterScheduleLayoutX : rwt.util.Functions.returnTrue,

    _afterScheduleLayoutY : rwt.util.Functions.returnTrue,

    _beforeComputeInnerWidth : rwt.util.Functions.returnTrue,

    _beforeComputeInnerHeight : rwt.util.Functions.returnTrue,

    _beforeRenderLayout : rwt.util.Functions.returnTrue,

    _afterRenderLayout : rwt.util.Functions.returnTrue,

    _cellHasContent : function( cell ) {
      var content = this.__cellData[ cell ][ 1 ];
      return content != null;
    },

    _isImageCell : function( cell ) {
      var type = this.__cellData[ cell ][ 0 ];
      return type == "image";
    },

    _isTextCell : function( cell ) {
      var type = this.__cellData[ cell ][ 0 ];
      return type == "label";
    },

    _setCellWidth : function( cell, width ) {
      this.__cellData[ cell ][ 2 ] = width;
    },

    _getCellWidth : function( cell ) {
      return this.__cellData[ cell ][ 2 ];
    },

    _setCellHeight : function( cell, height ) {
      this.__cellData[ cell ][ 3 ] = height;
    },

    __setCellNode : function( cell, $node ) {
      this.$cells[ cell ] = $node;
      if( $node !== null && !this.isCellVisible( cell ) ) {
        $node.css( "display", "none" );
      }
      if( $node !== null ) {
        this.$el.append( $node );
      }
    },

    __cellHasNode : function( cell ) {
      return this.$cells[ cell ] != null;
    },

    __createCellData : function( cells ) {
      var data = [];
      var nodes = [];
      this.__cellCount = cells.length;
      for( var i = 0; i < this.__cellCount; i++ ) {
        nodes[ i ] = null;
        data[ i ] = [ cells[ i ], null, null, null, null, null, true ];
      }
      this.$cells = nodes;
      this.__cellData = data;
    },

    __updateComputedCellDimension : function( cell ) {
      var cellEntry = this.__cellData[ cell ];
      cellEntry[ 4 ] = null; //delete computedWidth
      cellEntry[ 5 ] = null; //delete computedHeight
      if( cellEntry[ 2 ] == null ) { //uses computed width
        this._invalidatePreferredInnerWidth();
        this._scheduleLayoutX();
      }
      if( cellEntry[ 3 ] == null ) { //usses computedheight
        this._invalidatePreferredInnerHeight();
        this._scheduleLayoutY();
      }
    },

    // TODO: calculate in actual cell node directly when possible
    __computeCellDimension : function( cellEntry, wrapWidth ) {
      var dimension;
      if( cellEntry[ 0 ] == "label" && cellEntry[ 1 ] != null ) {
        var calc = rwt.widgets.util.FontSizeCalculation;
        dimension = calc.computeTextDimensions( cellEntry[ 1 ], this.__fontCache, wrapWidth );
      } else {
        dimension = [ 0, 0 ];
      }
      cellEntry[ 4 ] = dimension[ 0 ];
      cellEntry[ 5 ] = dimension[ 1 ];
      return dimension;
    },

    _isWidthEssential : rwt.util.Functions.returnTrue,
    _isHeightEssential : rwt.util.Functions.returnTrue,

    _computePreferredInnerWidth : function() {
      if( this.getVertical() ) {
        return this._getContentSizeOrthogonalDir();
      }
      return this._getContentSizeFlowDir( "ignoreFlexible" );
    },

    _computePreferredInnerHeight : function() {
      if( this.getVertical() ) {
        return this._getContentSizeFlowDir( "ignoreFlexible" );
      }
      return this._getContentSizeOrthogonalDir();
    },

    _adjustCellWidth : function( cell, preferredCellWidth ) {
      // NOTE: Will assume current width as valid, not to be used for widget size calculation
      var inner = this._getAvailableInnerWidth();
      var contentWidth = this._getContentSizeFlowDir( "skipFlexible" );
      var maxCellWidth = Math.max( 0, inner - contentWidth );
      var result;
      if( preferredCellWidth > maxCellWidth || this._expandFlexCell ) {
        result = maxCellWidth;
      } else {
        result = preferredCellWidth;
      }
      return result;
    },

    _getContentSizeFlowDir : function( hint ) {
      var vertical = this.getVertical();
      if( vertical ) {
        this._beforeComputeInnerHeight();
      } else {
        this._beforeComputeInnerWidth();
      }
      var ignoreFlexible = hint === "ignoreFlexible";
      var skipFlexible = hint === "skipFlexible";
      var visibleCells = 0;
      var result = 0;
      for( var i = 0; i < this.__cellCount; i++ ) {
        if( this.cellIsDisplayable( i ) ) {
          visibleCells++;
          if( !skipFlexible || ( i !== this._flexibleCell ) ) {
            result += vertical ? this.getCellHeight( i, ignoreFlexible ) : this.getCellWidth( i, ignoreFlexible );
          }
        }
      }
      result += Math.max( 0, visibleCells - 1 ) * this.getSpacing();
      return result;
    },

    _getContentSizeOrthogonalDir : function() {
      var vertical = this.getVertical();
      if( vertical ) {
        this._beforeComputeInnerWidth();
      } else {
        this._beforeComputeInnerHeight();
      }
      var result = 0;
      for( var i = 0; i < this.__cellCount; i++ ) {
        result = Math.max( result, vertical ? this.getCellWidth( i, true ) : this.getCellHeight( i, true ) );
      }
      return result;
    },

    _adjustCellHeight : function( cell, preferredCellHeight ) {
      var inner = this.getInnerHeight();
      var result;
      if( preferredCellHeight > inner ) {
        result = inner;
      } else {
        result = preferredCellHeight;
      }
      return result;
    },

    cellIsDisplayable : function( cell ) {
      return this._flexibleCell === cell || ( this.getCellWidth( cell ) > 0 );
    },

    renderPadding : function() { },

    _layoutPost : function( changes ) {
      if( changes.createContent ){
        this._createSubElements();
      }
      if( changes.updateContent || changes.createContent ) {
        this._updateAllImages();
        this._updateAllLabels();
      }
      changes.layoutX = changes.width || changes.layoutX || changes.frameWidth || changes.initial;
      changes.layoutY =    changes.height
                        || changes.layoutY
                        || changes.frameHeight
                        || changes.initial
                        || ( changes.layoutX && this._flexibleCell != -1 );
      this._beforeRenderLayout( changes );
      var vertical = this.getVertical();
      if( ( changes.layoutY && vertical ) || ( changes.layoutX && !vertical ) ) {
        this._renderLayoutFlowDir();
      }
      if( ( changes.layoutX && vertical ) || ( changes.layoutY && !vertical ) ) {
        this._renderLayoutOrthDir();
      }
      this._afterRenderLayout( changes );
      this.base( arguments, changes );
    },

    // NOTE: Currently no support for top/bottom alignment or flex-cells in vertical mode (we don't need it)
    _renderLayoutFlowDir : function() {
      var space = this.getSpacing();
      var vertical = this.getVertical();
      var offset = this._getFirstCellOffset( vertical );
      for( var i = 0; i < this.__cellCount; i++ ) {
        if( this.cellIsDisplayable( i ) ) {
          var size = vertical ? this.getCellHeight( i ) : this.getCellWidth( i );
          if( this._cellHasContent( i ) ) {
            this.$cells[ i ].css( vertical ? "top" : "left", offset );
            this.$cells[ i ].css( vertical ? "height" : "width", Math.max( 0, size ) );
          }
          offset += ( size + space );
        }
      }
    },

    _getFirstCellOffset : function( vertical ) {
      var align = vertical ? this.getVerticalChildrenAlign() : this.getHorizontalChildrenAlign();
      var content = this._getContentSizeFlowDir();
      var inner = vertical ? this.getInnerHeight() : this._getAvailableInnerWidth();
      switch( align ) {
        case "left":
          return this.__paddingCache[ 3 ];
        case "center":
          return Math.round( this.__paddingCache[ 3 ] + inner / 2 - content / 2 );
        case "middle":
          return Math.round( this.__paddingCache[ 0 ] + inner / 2 - content / 2 );
        case "right":
          return this.__paddingCache[ 3 ] + inner - content;
      }
    },

    _renderLayoutOrthDir : function() {
      var vertical = this.getVertical();
      for( var i = 0; i < this.__cellCount; i++ ) {
        if( this._cellHasContent( i ) ) {
          this._renderCellLayoutOrthDir( i, vertical );
        }
      }
    },

    // NOTE: Currently no support for left/right alignment in vertical mode (we don't need it)
    _renderCellLayoutOrthDir : function( cell, vertical ) {
      var align = vertical ? this.getHorizontalChildrenAlign() : this.getVerticalChildrenAlign();
      var pad = this.__paddingCache;
      var inner = vertical ? this._getAvailableInnerWidth() : this.getInnerHeight();
      var cellSize = vertical ? this.getCellWidth( cell ) : this.getCellHeight( cell );
      var offset = null;
      switch( align ) {
        case "top":
          offset = pad[ 0 ];
        break;
        case "middle":
          offset = Math.round( pad[ 0 ] + inner * 0.5 - cellSize * 0.5 );
        break;
        case "center":
          offset = Math.round( pad[ 3 ] + inner * 0.5 - cellSize * 0.5 );
        break;
        case "bottom":
          offset = pad[ 0 ] + inner - cellSize;
        break;
      }
      this.$cells[ cell ].css( vertical ? "left" : "top", offset );
      this.$cells[ cell ].css( vertical ? "width" : "height", cellSize );
    },

    _getAvailableInnerWidth : function() {
      return this.getInnerWidth();
    },

    /*
    ---------------------------------------------------------------------------
      IMAGE
    ---------------------------------------------------------------------------
    */

    _updateAllImages : function() {
      for( var i = 0; i < this.__cellCount; i++ ) {
        if( this._isImageCell( i ) && this._cellHasContent( i ) ) {
          this._updateImage( i );
        }
      }
    },

    _styleAllImagesEnabled : function() {
      for( var i = 0; i < this.__cellCount; i++ ) {
        if( this._isImageCell( i ) && this.__cellHasNode( i ) ) {
          this._updateImage( i );
        }
      }
    },

    _updateImage : function( cell ) {
      this.$cells[ cell ].css( {
        opacity : this.getEnabled() ? 1 : 0.3,
        backgroundImage : this.getCellContent( cell )
      } );
    },

    /*
    ---------------------------------------------------------------------------
      LABEL
    ---------------------------------------------------------------------------
    */

    _applyFont : function( value ) {
      this._styleFont( value );
    },

    _styleFont : function( font ) {
      if( font ) {
        font.render( this );
        font.renderStyle( this.__fontCache );
      } else {
        rwt.html.Font.reset( this );
        rwt.html.Font.resetStyle( this.__fontCache );
      }
      for( var i = 0; i < this.__cellCount; i++ ) {
        if( this._isTextCell( i ) && this._cellHasContent( i ) ) {
          this.__updateComputedCellDimension( i );
        }
      }
    },

    _updateAllLabels : function() {
      for( var i = 0; i < this.__cellCount; i++ ) {
        if( this._isTextCell( i ) && this._cellHasContent( i ) ) {
          this._updateLabel( i );
        }
      }
    },

    _updateLabel : function( cell ) {
      this.$cells[ cell ].html( this.getCellContent( cell ) );
    }

  }

} );

}( rwt.util._RWTQuery ));

/*******************************************************************************
 * Copyright (c) 2004, 2014 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource, and others.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/


/**
 * @appearance tab-item
 * @state checked Set by {@link #checked}
 * @state over
 */
rwt.qx.Class.define( "rwt.widgets.TabItem", {

  extend : rwt.widgets.base.MultiCellWidget,

  include : rwt.widgets.util.OverStateMixin,

  construct : function() {
    this.base( arguments, [ "image", "label" ] );
    this.initChecked();
    this.initTabIndex();
    this._rawText = null;
    this._mnemonicIndex = null;
    this.addEventListener( "mousedown", this._onmousedown );
    this.addEventListener( "keydown", this._onkeydown );
    this.addEventListener( "keypress", this._onkeypress );
  },

  properties : {

    appearance : {
      refine : true,
      init : "tab-item"
    },

    tabIndex : {
      refine : true,
      init : 1
    },

    /** If this tab is the currently selected/active one */
    checked : {
      check :"Boolean",
      init : false,
      apply : "_applyChecked",
      event : "changeChecked"
    },

    /** The attached page of this tab */
    page : {
      check : "rwt.widgets.base.TabFolderPage",
      apply : "_applyPage",
      nullable : true
    },

    /**
     * The assigned rwt.widgets.util.RadioManager which handles the switching between registered
     * buttons
     */
    manager : {
      check  : "rwt.widgets.util.RadioManager",
      nullable : true,
      apply : "_applyManager"
    },

    /**
     * The name of the radio group. All the radio elements in a group (registered by the same
     * manager) have the same name (and could have a different value).
     */
    name : {
      check : "String",
      apply : "_applyName"
    }

  },

  members : {

    setText : function( value ) {
      this._rawText = value;
      this._mnemonicIndex = null;
      this._applyText( false );
    },

    setImage : function( value ) {
      if( value === null ) {
        this.setCellContent( 0, null );
        this.setCellDimension( 0, 0, 0 );
      } else {
        this.setCellContent( 0, value[ 0 ] );
        this.setCellDimension( 0, value[ 1 ], value[ 2 ] );
      }
    },

    setMnemonicIndex : function( value ) {
      this._mnemonicIndex = value;
      var mnemonicHandler = rwt.widgets.util.MnemonicHandler.getInstance();
      if( ( typeof value === "number" ) && ( value >= 0 ) ) {
        mnemonicHandler.add( this, this._onMnemonic );
      } else {
        mnemonicHandler.remove( this );
      }
    },

    getMnemonicIndex : function() {
      return this._mnemonicIndex;
    },

    computeBadgePosition : function( size ) {
      return [
        ( size[ 1 ] * -1 ) + this.getPaddingTop() + 1,
        Math.round( this.getPaddingRight() / 2 ),
        "auto",
        "auto"
      ];
    },

    _applyText : function( mnemonic ) {
      if( this._rawText ) {
        var mnemonicIndex = mnemonic ? this._mnemonicIndex : undefined;
        var text = rwt.util.Encoding.escapeText( this._rawText, mnemonicIndex );
        this.setCellContent( 1, text );
      } else {
        this.setCellContent( 1, null );
      }
    },

    _onMnemonic : function( event ) {
      switch( event.type ) {
        case "show":
          this._applyText( true );
        break;
        case "hide":
          this._applyText( false );
        break;
        case "trigger":
          var charCode = this._rawText.toUpperCase().charCodeAt( this._mnemonicIndex );
          if( event.charCode === charCode ) {
            this.setChecked( true );
            event.success = true;
          }
        break;
      }
    },

    _onkeydown : function( event ) {
      var identifier = event.getKeyIdentifier();
      if( identifier === "Enter" || identifier === "Space" ) {
        // there is no toggeling, just make it checked
        this.setChecked( true );
      }
    },

    _onkeypress : function( event ) {
      switch( event.getKeyIdentifier() ) {
        case "Left":
          var vPrev = this.getPreviousActiveSibling();
          if ( vPrev && vPrev !== this ) {
            // we want to enable the outline border, because
            // the user used the keyboard for activation
            delete rwt.widgets.util.FocusHandler.mouseFocus;
            // focus previous tab
            vPrev.setFocused( true );
            // and naturally make it also checked
            vPrev.setChecked( true );
          }
        break;
        case "Right":
          var vNext = this.getNextActiveSibling();
          if( vNext && vNext !== this ) {
            // we want to enable the outline border, because
            // the user used the keyboard for activation
            delete rwt.widgets.util.FocusHandler.mouseFocus;
            // focus next tab
            vNext.setFocused( true );
            // and naturally make it also checked
            vNext.setChecked( true );
          }
        break;
      }
    },

    _renderAppearance : function() {
      if( this.getView() ) {
        this.toggleState( "firstChild", this.isFirstVisibleChild() );
        this.toggleState( "lastChild", this.isLastVisibleChild() );
        this.toggleState( "alignLeft", this.getView().getAlignTabsToLeft() );
        this.toggleState( "alignRight", !this.getView().getAlignTabsToLeft() );
        this.toggleState( "barTop", this.getView().getPlaceBarOnTop() );
        this.toggleState( "barBottom", !this.getView().getPlaceBarOnTop() );
      }
      this.base( arguments );
    },

    getView : function() {
      var parent = this.getParent();
      return parent ? parent.getParent() : null;
    },

    _applyManager : function( value, old ) {
      if( old ) {
        old.remove( this );
      }
      if( value ) {
        value.add( this );
      }
    },

    _applyParent : function( value, old ) {
      this.base( arguments, value, old );
      if ( old ) {
        old.getManager().remove( this );
      }
      if( value ) {
        value.getManager().add( this );
      }
    },

    _applyPage : function( value, old ) {
      if( old ) {
        old.setButton( null );
      }
      if( value ) {
        value.setButton( this );
        if( this.getChecked() ) {
          value.show();
        } else {
          value.hide();
        }
      }
    },

    _applyChecked : function( value ) {
      if( this._hasParent ) {
        var vManager = this.getManager();
        if( vManager ) {
          vManager.handleItemChecked( this, value );
        }
      }
      this.toggleState( "checked", value );
      var vPage = this.getPage();
      if( vPage ) {
        if( this.getChecked() ) {
          vPage.show();
        } else {
          vPage.hide();
        }
      }
      this.setZIndex( value ? 1 : 0 );
      this.addToQueue( "updateBadgePosition" );
    },

    _applyName : function( value ) {
      if( this.getManager() ) {
        this.getManager().setName( value );
      }
    },

    _onmousedown : function() {
      this.setChecked( true );
    }

  },

  destruct : function() {
    this.setMnemonicIndex( null );
  }

} );

/*******************************************************************************
 *  Copyright: 2004, 2014 1&1 Internet AG, Germany, http://www.1und1.de,
 *                        and EclipseSource
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v1.0 which accompanies this
 * distribution, and is available at http://www.eclipse.org/legal/epl-v10.html
 *
 *  Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

rwt.qx.Class.define("rwt.widgets.ListItem", {

  extend : rwt.widgets.base.MultiCellWidget,

  construct : function() {
    this.base( arguments, [ "label" ] );
    this.setHorizontalChildrenAlign( "left" );
    // Fix for Bug 396835 - [List][Combo] Lists can scroll over maximum in IE7/8
    this.setContainerOverflow( false );
  },

  properties : {

    appearance : {
      refine : true,
      init : "list-item"
    },

    width : {
      refine : true,
      init : null
    },

    allowStretchX : {
      refine : true,
      init : true
    }

  },

  members : {

    setLabel : function( value ) {
      this.setCellContent( 0, value );
    },

    getLabel : function() {
      return this.getCellContent( 0 );
    },

    matchesString : function( value ) {
      var content;
      var el = this.getCellNode( 0 );
      if( el ) {
        content = el.innerText || el.textContent;
      } else {
        content = this.getLabel();
      }
      var input = ( typeof value === "string" ) ? value.toLowerCase() : "";
      content = ( typeof content === "string" ) ? content.toLowerCase() : "";
      return input !== "" && content.indexOf( input ) === 0;
    },

    // overwritten:
    getCellHeight : function() {
      return this.getHeight() - this.getPaddingTop();
    },

    // overwritten:
    getCellWidth : function() {
      return this.getWidth() - this.getPaddingLeft() - this.getPaddingRight();
    }

  }
} );

/*******************************************************************************
 * Copyright (c) 2009, 2014 Innoopract Informationssysteme GmbH and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Innoopract Informationssysteme GmbH - initial API and implementation
 *    EclipseSource - ongoing development
 ******************************************************************************/

rwt.qx.Class.define( "rwt.widgets.util.MenuManager", {

  extend : rwt.util.ObjectManager,

  statics : {

    getInstance : function() {
      return rwt.runtime.Singletons.get( rwt.widgets.util.MenuManager );
    }

  },

  members :  {

    // Note: This function is called on alle mousedown and mouseup events,
    //       and also on "esc" and "tab" key-events and on window-blur.
    update : function( target, eventType ) {
      var menus = this.getAll();
      var isMouseDown = eventType == "mousedown";
      var isMouseUp = eventType == "mouseup";
      var isMouseEvent = isMouseDown || isMouseUp;
      var eventHasTarget = target != null;
      var targetHasMenu =    eventHasTarget
                          && target.getMenu
                          && target.getMenu() != null;
      var targetMenuBar = this._getMenuBar( target );

      for ( var hash in menus ) {
        var menu = menus[ hash ];
        var hide = false;
        // 1. AutoHide supported?
        if ( menu.getAutoHide() ) {
          // Gathering data
          var targetIsOpener = menu.getOpener() === target;
          var isContextMenu =
            !( menu.getOpener() instanceof rwt.widgets.MenuItem );
          var notSameMenuBar = targetMenuBar != this._getMenuBar( menu );
          // 2. Global event like keydown or blur?
          if ( !eventHasTarget || !isMouseEvent ) {
            hide = true;
          }
          // 3. Click on another menubar?
          if( isMouseDown && notSameMenuBar ) {
            hide = true;
          }
          // 4. Click on the opener of a context menu?
          if( isMouseDown && isContextMenu && targetIsOpener ) {
            hide = true;
          }
          // Ignore other events that are handled by the menu itself
          if( !targetHasMenu && !targetIsOpener ) {
            // 5. mousedown somwhere outside the menu
            if ( isMouseDown && !menu.isSubElement( target ) ) {
              hide = true;
            }
            // 6. Execute of an menuItem
            if ( isMouseUp && menu.isSubElement( target, true ) && target.isEnabled() ) {
              hide = true;
            }
          }
        }
        if( hide ) {
          menu.hide();
        }
      }
    },

    _getMenuBar : function( widget ) {
      var menu = null;
      var menuBar = null;
      if( widget instanceof rwt.widgets.MenuItem ) {
        menu = widget.getParentMenu();
      } else {
        if(    widget instanceof rwt.widgets.Menu
            || widget instanceof rwt.widgets.MenuBar
        ) {
          menu = widget;
        }
      }
      while ( menuBar == null && menu != null ) {
        if( menu instanceof rwt.widgets.MenuBar ) {
          menuBar = menu;
        } else {
          var hasOpener =
            menu.getOpener() instanceof rwt.widgets.MenuItem;
            menu = hasOpener ? menu.getOpener().getParentMenu() : null;
        }
      }
      return menuBar;
    }

  }
} );

/*******************************************************************************
 * Copyright (c) 2009, 2014 Innoopract Informationssysteme GmbH.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Innoopract Informationssysteme GmbH - initial API and implementation
 *    EclipseSource - ongoing development
 ******************************************************************************/

rwt.qx.Class.define("rwt.widgets.MenuItem",  {
  extend : rwt.widgets.base.MultiCellWidget,

  construct : function( menuItemType ) {
    this.base( arguments, [ "image", "image", "label", "label", "image" ] );
    this._selected = false;
    this._parentMenu = null;
    this._rawText = null;
    this._mnemonicIndex = null;
    this._subMenu = null;
    this._subMenuOpen = false;
    this._preferredCellWidths = null;
    this.set( {
      width : "auto",
      horizontalChildrenAlign : "left",
      verticalChildrenAlign : "middle"
    } );
    this.addEventListener( "changeFont", this._onFontChange );
    this.addState( menuItemType );
    switch( menuItemType ){
      case "push" :
       this._isSelectable = false;
       this._isDeselectable = false;
      break;
      case "check":
       this._isSelectable = true;
       this._isDeselectable = true;
      break;
      case "cascade":
       this._isSelectable = false;
       this._isDeselectable = false;
      break;
      case "radio":
       this._isSelectable = true;
       this.setNoRadioGroup( false );
       rwt.widgets.util.RadioButtonUtil.registerExecute( this );
      break;
    }
    this._preferredCellWidths = [ 0, 0, 0, 0, 13 ];
    if( this._isSelectable ) {
      this.setCellContent( 0, "" );
    }
  },

  destruct : function() {
    this.setMnemonicIndex( null );
    this._disposeFields( "_parentMenu", "_subMenu" );
  },

  properties : {

    selectionIndicator : {
      apply : "_applySelectionIndicator",
      nullable : true,
      themeable : true
    },

    arrow : {
      apply : "_applyArrow",
      nullable : true,
      themeable : true
    },

    appearance : {
      refine : true,
      init : "menu-item"
    },

    tabIndex : {
      refine : true,
      init : 1
    }

  },

  members : {

   setText : function( value ) {
      this._rawText = value;
      this._mnemonicIndex = null;
      this.renderText();
    },

    setAccelerator : function( value ) {
      var acc = null;
      if( value ) {
        // assuming a tab is rendered as four spaces
        acc = rwt.util.Encoding.escapeText( value );
        acc = rwt.util.Encoding.replaceWhiteSpaces( "    " + acc );
      }
      this.setCellContent( 3, acc );
      this.setCellDimension( 3, null, null ); // force to recompute the width
      this._setPreferredCellWidth( 3, this.getCellWidth( 3 ) );
    },

    setMnemonicIndex : function( value ) {
      this._mnemonicIndex = value;
      if( this._parentMenu instanceof rwt.widgets.MenuBar ) {
        var mnemonicHandler = rwt.widgets.util.MnemonicHandler.getInstance();
        if( ( typeof value === "number" ) && ( value >= 0 ) ) {
          mnemonicHandler.add( this, this._onMnemonic );
        } else {
          mnemonicHandler.remove( this );
        }
      } else if( value != null && this._isMnemonicMenu() ) {
        this.renderText();
      }
    },

    renderText : function() {
      this._applyText( this._isMnemonicMenu() );
    },

    _isMnemonicMenu : function() {
      return this._parentMenu != null && this._parentMenu.getMnemonics();
    },

    getMnemonicIndex : function() {
      return this._mnemonicIndex;
    },

    handleMnemonic : function( event ) {
      this._onMnemonic( event );
    },

    _applyText : function( mnemonic ) {
      if( this._rawText ) {
        var mnemonicIndex = mnemonic ? this._mnemonicIndex : undefined;
        var text = rwt.util.Encoding.escapeText( this._rawText, mnemonicIndex );
        this._setText( text );
      } else {
        this._setText( null );
      }
    },

    _afterRenderLayout : function( changes ) {
      if( changes.createContent && this.getCellNode( 3 ) ) {
        this.getCellNode( 3 ).style.textAlign = "right";
      }
    },

    _onMnemonic : function( event ) {
      switch( event.type ) {
        case "show":
          this._applyText( true );
        break;
        case "hide":
          this._applyText( false );
        break;
        case "trigger":
          if( this._rawText ) {
            var charCode = this._rawText.toUpperCase().charCodeAt( this._mnemonicIndex );
            if( event.charCode === charCode ) {
              if( this.hasState( "cascade" ) ) {
                this._parentMenu.openByMnemonic( this );
              } else {
                this.execute();
                rwt.widgets.util.MenuManager.getInstance().update();
              }
              event.success = true;
            }
          }
        break;
      }
    },

    setParentMenu : function( menu ) {
      this._parentMenu = menu;
    },

    getParentMenu : function() {
      return this._parentMenu;
    },

    setSubMenuOpen : function( bool ) {
      this._subMenuOpen = bool;
    },

    setMenu : function( menu ) {
      this._subMenu = menu;
      this.dispatchSimpleEvent( "subMenuChanged" );
    },

    getMenu : function() {
      return this._subMenu;
    },

    _applySelectionIndicator : function( value ) {
      //never remove cell-node
      var url = value ? value[ 0 ] : null;
      var width = value ? value[ 1 ] : 0;
      var height = value ? value[ 2 ] : 0;
      if( url == null ) {
        var content = this._isSelectable ? "" : null;
        this.setCellContent( 0, content );
      } else {
        this.setCellContent( 0, url );
      }
      this.setCellHeight( 0, height );
      this._setPreferredCellWidth( 0, width );
    },

    _setPreferredCellWidth : function( cell, width ) {
      this._preferredCellWidths[ cell ] = width;
      if( this._parentMenu instanceof rwt.widgets.Menu ) {
        this._parentMenu.invalidateMaxCellWidth( cell );
      }
      this._scheduleLayoutX();
    },

    _afterScheduleLayoutX : function() {
      if( this._parentMenu instanceof rwt.widgets.Menu ) {
        this._parentMenu.scheduleMenuLayout();
      }
    },

    getPreferredCellWidth : function( cell ) {
      return this._preferredCellWidths[ cell ];
    },

    setImage : function( value, width, height ) {
      this.setCellContent( 1, value );
      this.setCellHeight( 1, height );
      this._setPreferredCellWidth( 1, width );
    },

    _setText : function( value ) {
      this.setCellContent( 2, value );
      this.setCellDimension( 2, null, null ); // force to recompute the width
      this._setPreferredCellWidth( 2, this.getCellWidth( 2 ) );
    },

    _onFontChange : function() {
      this.setCellDimension( 2, null, null );
      this._setPreferredCellWidth( 2, this.getCellWidth( 2 ) );
    },

    _applyArrow : function( value ) {
      var url = value ? value[ 0 ] : null;
      var width = value ? value[ 1 ] : 13;
      var height = value ? value[ 2 ] : 0;
      this.setCellContent( 4, url );
      this.setCellHeight( 4, height );
      this._setPreferredCellWidth( 4, width );
    },

    _beforeComputeInnerWidth : function() {
      if( this._parentMenu instanceof rwt.widgets.Menu ) {
        for( var i = 0; i < 5; i++ ) {
          this._setCellWidth( i, this._parentMenu.getMaxCellWidth( i ) );
        }
      }
    },

    _beforeAppear : function() {
      this.base( arguments );
      if( this._parentMenu instanceof rwt.widgets.Menu ) {
        this._parentMenu.invalidateAllMaxCellWidths();
        this._parentMenu.scheduleMenuLayout();
      }
    },

    setSubMenu : function( value ) {
      this._subMenu = value;
      this.createDispatchEvent( "subMenuChanged" );
    },

    setNoRadioGroup : function( value ) {
      if( this.hasState( "radio") ) {
        this._noRadioGroup = value;
        this._isDeselectable = value;
      }
    },

    getNoRadioGroup : function() {
      return this._noRadioGroup;
    },

    // TODO [tb] "execute", "setSelection", "_notifySelected" and possibly more
    // could be shared between Button, MenuItem and (future) ToolItem.
    // Then, also the corrosponding LCA-methods could be shared
    execute : function() {
      if( this.isEnabled() ) {
        this.base( arguments );
        if( this._isSelectable ) {
          this.setSelection( !( this._selected && this._isDeselectable ) );
        } else {
          this._notifySelected();
        }
      }
    },

    setSelection : function( value ) {
      var wasSelected = this._selected;
      var selectionChanged = this._selected != value;
      if( selectionChanged ) {
        this._selected = value;
        this.toggleState( "selected", value );
        if( !rwt.remote.EventUtil.getSuspended() ) {
          var server = rwt.remote.Connection.getInstance();
          server.getRemoteObject( this ).set( "selection", this._selected );
        }
      }
      if( selectionChanged || wasSelected ) {
        this._notifySelected();
      }
    },

    _notifySelected : function() {
      if( this._shouldSendEvent() ) {
        rwt.remote.EventUtil.notifySelected( this );
      }
    },

    _shouldSendEvent : function() {
      return !this.hasState( "cascade" );
    }

  }

});

/*******************************************************************************
 * Copyright (c) 2011, 2015 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.remote.HandlerRegistry.add( "rwt.widgets.MenuItem", {

  factory : function( properties ) {
    var result;
    rwt.remote.HandlerUtil.callWithTarget( properties.parent, function( menu ) {
      var styleMap = rwt.remote.HandlerUtil.createStyleMap( properties.style );
      var onMenuBar = menu.hasState( "rwt_BAR" );
      var menuItemType = "push";
      if( styleMap.CASCADE ) {
        menuItemType = "cascade";
      } else if( styleMap.CHECK && !onMenuBar ) {
        menuItemType = "check";
      } else if( styleMap.RADIO && !onMenuBar ) {
        menuItemType = "radio";
      }
      if( styleMap.SEPARATOR ) {
        result = new rwt.widgets.MenuItemSeparator();
      } else {
        result = new rwt.widgets.MenuItem( menuItemType );
        result.setNoRadioGroup( menu.hasState( "rwt_NO_RADIO_GROUP" ) );
        if( onMenuBar ) {
          result.addState( "onMenuBar" );
        }
      }
      menu.addMenuItemAt( result, properties.index );
      rwt.remote.HandlerUtil.addDestroyableChild( menu, result );
      result.setUserData( "protocolParent", menu );
    } );
    rwt.remote.HandlerUtil.addStatesForStyles( result, properties.style );
    return result;
  },

  destructor : rwt.remote.HandlerUtil.getWidgetDestructor(),

  properties : [
    "menu",
    "enabled",
    "text",
    "mnemonicIndex",
    "image",
    "selection",
    "customVariant",
    "data"
  ],

  propertyHandler : {
    "data" : rwt.remote.HandlerUtil.getControlPropertyHandler( "data" ),
    "menu" : function( widget, value ) {
      if( !widget.hasState( "rwt_SEPARATOR" ) ) {
        rwt.remote.HandlerUtil.callWithTarget( value, function( menu ) {
          widget.setMenu( menu );
        } );
      }
    },
    "text" : function( widget, value ) {
      if( !widget.hasState( "rwt_SEPARATOR" ) ) {
        var text = value;
        // Strip accelerator text
        var index = text.indexOf( "\t" );
        var accelerator = null;
        if( index != -1 ) {
          accelerator = text.substring( index + 1 );
          text = text.substring( 0, index );
        }
        widget.setText( text );
        widget.setAccelerator( accelerator );
      }
    },
    "image" : function( widget, value ) {
      if( !widget.hasState( "rwt_SEPARATOR" ) ) {
        if( value === null ) {
          widget.setImage( value );
        } else {
          widget.setImage.apply( widget, value );
        }
      }
    },
    "selection" : function( widget, value ) {
      if( !widget.hasState( "rwt_SEPARATOR" ) ) {
        widget.setSelection( value );
      }
    }
  },

  events : [ "Selection" ],

  listeners : [ "Help" ],

  listenerHandler : {
    "Help" : rwt.remote.HandlerUtil.getControlListenerHandler( "Help" )
  }

} );

/*******************************************************************************
 * Copyright (c) 2002, 2013 Innoopract Informationssysteme GmbH and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipsevent.org/legal/epl-v10.html
 *
 * Contributors:
 *    Innoopract Informationssysteme GmbH - initial API and implementation
 *    EclipseSource - ongoing development
 ******************************************************************************/


/**
 * This class contains static functions for radio buttons
 */
rwt.qx.Class.define( "rwt.widgets.util.RadioButtonUtil", {

  statics : {

    registerExecute : function( button ) {
      button.addEventListener( "execute", this._onSelection, this );
    },

    registerKeypress : function( button ) {
      button.addEventListener( "keypress", this._onKeypress, this );
    },

    _onKeypress : function( event ) {
      var widget = event.getTarget();
      switch( event.getKeyIdentifier() ) {
        case "Left":
        case "Up":
          this._setNextOrPrevious( widget, "previous" );
          event.preventDefault();
          event.stopPropagation();
          break;
        case "Right":
        case "Down":
          this._setNextOrPrevious( widget, "next" );
          event.preventDefault();
          event.stopPropagation();
          break;
        case "Home":
        case "End":
        case "PageDown":
        case "PageUp":
          event.preventDefault();
          event.stopPropagation();
        break;
      }
    },

    _onSelection : function( event ) {
      this._unselectSiblings( event.getTarget() );
    },

    _isRadioElement : function( widget ) {
      return widget.hasState( "radio" );
    },

    _getRadioGroup: function( widget ) {
      var group = [];
      if( !widget.getNoRadioGroup() ) {
        var siblings = widget.getParent().getChildren();
        var length = siblings.length;
        // For Radio-Buttons all Radio-items of the group count,
        // else the group is bounded by any non-radio items
        if( widget.classname == "rwt.widgets.Button" ) {
          for( var i = 0; i < length; i++ ) {
            if( this._isRadioElement( siblings[ i ] ) ) {
              group.push( siblings[ i ] );
            }
          }
        } else {
          var isCurrentGroup = false;
          var i = 0;
          while( i < length && ( !isCurrentGroup || this._isRadioElement( siblings[ i ] ) ) ) {
            if( !isCurrentGroup ) {
              isCurrentGroup = siblings[ i ] == widget;
            }
            if( this._isRadioElement( siblings[ i ] ) ) {
              group.push( siblings[ i ] );
            } else {
              group = [];
            }
            i++;
          }
        }
      }
      return group;
    },

    // Set the "checked" property and focus on the following (next or previous)
    // radio button of the same group, after a corresponding key press.
    _setNextOrPrevious : function( widget, command ) {
      var allRadioButtons = this._getRadioGroup( widget );
      if( allRadioButtons.length > 0 ) {
        var currentRbIndex;
        for( var j = 0; j < allRadioButtons.length; j++ ) {
          if( allRadioButtons[ j ] == widget ) {
            currentRbIndex = j;
          }
        }
        // assign a value to 'nextSelectedRbIndex',
        // in case the 'command' is unrecognizable
        var nextSelectedRbIndex = currentRbIndex;
        if ( command == "next" ) {
          do {
            nextSelectedRbIndex++;
            if( nextSelectedRbIndex >= allRadioButtons.length ) {
              nextSelectedRbIndex = 0;
            }
          } while( !allRadioButtons[ nextSelectedRbIndex ].getEnabled() );
        }
        if ( command == "previous" ) {
          do {
            nextSelectedRbIndex--;
            if( nextSelectedRbIndex < 0 ) {
              nextSelectedRbIndex = allRadioButtons.length - 1;
            }
          } while( !allRadioButtons[ nextSelectedRbIndex ].getEnabled() );
        }
        if( nextSelectedRbIndex !== currentRbIndex ) {
          var nextRb = allRadioButtons[ nextSelectedRbIndex ];
          this._unselectSiblings( nextRb );
          nextRb.setSelection( true );
          nextRb.setFocused( true );
        }
      }
    },

    _unselectSiblings : function( widget ) {
      var group = this._getRadioGroup( widget );
      for( var i = 0; i < group.length; i++ ) {
        if( group[ i ] !== widget ) {
          group[ i ].setSelection( false );
        }
      }
    }

  }

} );

/*******************************************************************************
 * Copyright (c) 2009, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.qx.Class.define( "rwt.widgets.MenuBar", {
  extend : rwt.widgets.base.HorizontalBoxLayout,

  construct : function() {
    this.base( arguments );
    this._hoverItem = null;
    this._openItem = null;
    this._active = false;
    this._mnemonics = false;
    this.setAppearance( "toolbar" );
    this.addEventListener( "mousedown", this._onMouseDown );
    this.addEventListener( "mouseup", this._onMouseUp );
    this.addEventListener( "mouseover", this._onMouseOver );
    this.addEventListener( "mouseout", this._onMouseOut );
    this.addEventListener( "keydown", this._onKeyDown );
    this.addEventListener( "keypress", this._onKeyPress );
  },

  destruct : function() {
    this._hoverItem = null;
    this._openItem = null;
    this._active = false;
    this._mnemonics = false;
    rwt.widgets.util.MenuManager.getInstance().remove( this );
    this.setActive( false );
  },

  members : {

    setActive : function( active ) {
      if( this.isDisposed() ) {
        return;
      }
      if( this._active != active ) {
        this._active = active;
        if( active ) {
          this._activate();
        } else {
          this._deactivate();
        }
      }
    },

    getActive : function() {
      return this._active;
    },

    setMnemonics : function( value ) {
      if( this.isDisposed() ) {
        return;
      }
      if( this._mnemonics !== value ) {
        this._mnemonics = value;
        var items = this.getChildren();
        for( var i = 0; i < items.length; i++ ) {
          if( items[ i ].renderText ) {
            items[ i ].renderText();
          }
        }
      }
    },

    getMnemonics : function() {
      return this._mnemonics;
    },

    addMenuItemAt : function( menuItem, index ) {
      // separator does not have this function:
      if( menuItem.setParentMenu ) {
        // it is essential that this happens before the menuItem is added
        menuItem.setParentMenu( this );
      }
      this.addAt( menuItem, index );
    },

    setHoverItem : function( item ) {
      var newHover = item ? item : this._openItem;
      if( this._hoverItem != null && this._hoverItem != item ) {
        this._hoverItem.removeState( "over" );
      }
      if( newHover != null ) {
        newHover.addState( "over" );
        if( this._openItem != null && this._openItem != newHover ) {
          this.setOpenItem( newHover );
        }
      }
      this._hoverItem = newHover;
    },

    openByMnemonic : function( item ) {
      this.setOpenItem( item, true );
      this.setHoverItem( null, true );
    },

    setOpenItem : function( item, byMnemonic ) {
      var oldItem = this._openItem;
      if( oldItem != null && oldItem.getMenu() != null ) {
        oldItem.setSubMenuOpen( false );
        oldItem.getMenu().hide();
      }
      if( item != null && item != oldItem && item.getMenu() != null && item.getEnabled() ) {
        this._openItem = item;
        this.setActive( true );
        item.addState( "pressed" );
        var subMenu = item.getMenu();
        item.setSubMenuOpen( true );
        subMenu.setOpener( item );
        var itemNode = item.getElement();
        // the position is relative to the document, therefore we need helper
        subMenu.setTop( rwt.html.Location.getTop( itemNode ) + itemNode.offsetHeight );
        subMenu.setLeft( rwt.html.Location.getLeft( itemNode ) );
        subMenu.setMnemonics( byMnemonic === true );
        subMenu.show();
      } else {
        this._openItem = null;
      }
      this.dispatchSimpleEvent( "changeOpenItem" );
    },

    getOpenItem : function() {
      return this._openItem;
    },

    getOpener : rwt.util.Functions.returnNull,

    // from original Menu, needed for the menu-manager:
    isSubElement : function( vElement, vButtonsOnly ) {
      var result = false;
      if (    ( vElement.getParent() === this )
           || ( ( !vButtonsOnly ) && ( vElement === this ) ) ) {
        result = true;
      }
      if( !result ) {
        var a = this.getChildren(), l=a.length;
        for ( var i = 0; i < l; i++ ) {
          if (    this.hasSubmenu( a[ i ] )
               && a[ i ].getMenu().isSubElement( vElement, vButtonsOnly ) )
          {
            result = true;
          }
        }
      }
      return result;
    },

    hasSubmenu : function( item ) {
      return item && item.getMenu && item.getMenu();
    },

    //Overwritten, called by MenuManager
    hide : function() {
      this.setActive( false );
    },

    getAutoHide : rwt.util.Functions.returnTrue,

    // Overwritten to prevent this from being ever focused
    getFocusRoot : function() {
      return null;
    },

    _activate : function() {
      rwt.widgets.util.MenuManager.getInstance().add( this );
      if( this._openItem == null ) {
        this.setHoverItem( this.getFirstChild() );
      }
      this.setCapture( true );
    },

    _deactivate : function() {
      rwt.widgets.util.MenuManager.getInstance().remove( this );
      this.setMnemonics( false );
      this.setOpenItem( null );
      this.setHoverItem( null );
      this.setCapture( false );
    },

    _onKeyDown :function( event ) {
      if( this._mnemonics ) {
        var keyCode = event.getKeyCode();
        var isChar =    !isNaN( keyCode )
                     && rwt.event.EventHandlerUtil.isAlphaNumericKeyCode( keyCode );
        if( isChar ) {
          var event = {
            "type" : "trigger",
            "charCode" : keyCode,
            "success" : false
          };
          var items = this.getChildren();
          for( var i = 0; i < items.length; i++ ) {
            if( items[ i ].handleMnemonic ) {
              items[ i ].handleMnemonic( event );
            }
          }
        }
      }
    },

    _onKeyPress : function( event ) {
      switch( event.getKeyIdentifier() ) {
        case "Up":
          this._handleKeyUp( event );
        break;
        case "Down":
          this._handleKeyDown( event );
        break;
        case "Left":
          this._handleKeyLeft( event );
        break;
        case "Right":
          this._handleKeyRight( event );
        break;
      }
    },

    _handleKeyDown : function( event ) {
      if( this.hasSubmenu( this._hoverItem ) ) {
        this.setOpenItem( this._hoverItem );
        this._openItem.getMenu().hoverFirstItem();
        event.preventDefault();
        event.stopPropagation();
      }
    },

    _handleKeyUp : function( event ) {
      if( this.hasSubmenu( this._hoverItem ) ) {
        this.setOpenItem( this._hoverItem );
        this._openItem.getMenu().hoverFirstItem( true );
        event.preventDefault();
        event.stopPropagation();
      }
    },

    _handleKeyRight : function() {
      if( this._hoverItem ) {
        var next = this._hoverItem.getNextSibling();
        if( next ) {
          this.setHoverItem( next );
        }
      }
    },

    _handleKeyLeft : function() {
      if( this._hoverItem ) {
        var next = this._hoverItem.getPreviousSibling();
        if( next ) {
          this.setHoverItem( next );
        }
      }
    },

    _onMouseOver : function( event ) {
      var target = event.getOriginalTarget();
      if( this.contains( target ) ) {
        var hoverItem = target == this ? null : target;
        this.setHoverItem( hoverItem );
      } else {
        // This is a capture widget, re-dispatch on original
        target._dispatchEvent( event );
        event.stopPropagation();
      }
    },

    _onMouseOut : function( event ) {
      var target = event.getOriginalTarget();
      if( this.contains( target ) ) {
        var related = event.getRelatedTarget();
        if( target == this || !this.contains( related ) ) {
          this.setHoverItem( null );
        }
      } else {
        // This is a capture widget, re-dispatch on original
        target._dispatchEvent( event );
        event.stopPropagation();
      }
    },

    _onMouseDown : function( event ) {
      var target = event.getOriginalTarget();
      if( this.contains( target ) ) {
        if( target != this ) {
          this.setOpenItem( target );
        }
      } else {
        // This is a capture widget, re-dispatch on original
        target._dispatchEvent( event );
        event.stopPropagation();
      }
    },

    _onMouseUp : function( event ) {
      var target = event.getOriginalTarget();
      if( this.contains( target ) ) {
        if( target instanceof rwt.widgets.MenuItem ) {
          target.execute();
        }
      } else {
        // This is a capture widget, re-dispatch on original
        target._dispatchEvent( event );
        event.stopPropagation();
      }
    }

  }

});


/*******************************************************************************
 * Copyright (c) 2009, 2014 Innoopract Informationssysteme GmbH and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Innoopract Informationssysteme GmbH - initial API and implementation
 *    EclipseSource - ongoing development
 ******************************************************************************/

namespace( "rwt.remote" );

rwt.remote.DNDSupport = function() {
  this._dragSources = {};
  this._dropTargets = {};
  this._eventQueue = {};
  this._requestScheduled = false;
  this._currentDragControl = null;
  this._currentDropControl = null;
  this._currentTargetElement = null;
  this._currentMousePosition = { x : 0, y : 0 };
  this._actionOverwrite = null;
  this._dataTypeOverwrite = null;
  this._dropFeedbackRenderer = null;
  this._dropFeedbackFlags = 0;
  this._dragFeedbackWidget = null;
  this._blockDrag = false;
};

rwt.remote.DNDSupport.getInstance = function() {
  return rwt.runtime.Singletons.get( rwt.remote.DNDSupport );
};

rwt.remote.DNDSupport.prototype = {

  /////////////
  // dragSource

  registerDragSource : function( dragSource ) {
    var control = dragSource.control;
    control.addEventListener( "dragstart", this._dragStartHandler, this );
    control.addEventListener( "dragend", this._dragEndHandler, this );
    this._dragSources[ control.toHashCode() ] = dragSource;
  },

  setDragSourceTransferTypes : function( widget, transferTypes ) {
    this._getDragSource( widget ).dataTypes = transferTypes;
  },

  deregisterDragSource : function( dragSource ) {
    var control = dragSource.control;
    control.removeEventListener( "dragstart", this._dragStartHandler, this );
    control.removeEventListener( "dragend", this._dragEndHandler, this );
    delete this._dragSources[ control.toHashCode() ];
  },

  isDragSource : function( widget ) {
    return typeof this._getDragSource( widget ) != "undefined";
  },

  isDropTarget : function( widget ) {
    return typeof this._getDropTarget( widget ) != "undefined";
  },

  _dragStartHandler : function( event ) {
    var wm = rwt.remote.WidgetManager.getInstance();
    var target = event.getCurrentTarget();
    var control = wm.findControl( event.getTarget() );
    if( control == target && !this._blockDrag ) {
      var dataTypes = this._getDragSource( target ).dataTypes;
      if( dataTypes.length > 0 ) {
        for( var i = 0; i < dataTypes.length; i++ ) {
          event.addData( dataTypes[ i ], true );
        }
        this._actionOverwrite = null;
        this._currentDragControl = target;
        var dndHandler = rwt.event.DragAndDropHandler.getInstance();
        dndHandler.clearActions();
        var doc = rwt.widgets.base.ClientDocument.getInstance();
        doc.addEventListener( "elementOver", this._onMouseOver, this );
        doc.addEventListener( "keydown", this._onKeyEvent, this );
        doc.addEventListener( "keyup", this._onKeyEvent, this );
        this.setCurrentTargetElement( event.getOriginalTarget() );
        // fix for bug 296348
        rwt.widgets.util.WidgetUtil._fakeMouseEvent( this._currentTargetElement, "mouseout" );
        var sourceElement = dndHandler.__dragCache.sourceElement;
        var feedbackWidget = this._getFeedbackWidget( control, sourceElement );
        // Note: Unlike SWT, the feedbackWidget can not be rendered behind
        // the cursor, i.e. with a negative offset, as the widget would
        // get all the mouse-events instead of a potential drop-target.
        dndHandler.setFeedbackWidget( feedbackWidget, 10, 20 );
        event.startDrag();
        event.stopPropagation();
      }
      this._sendDragSourceEvent( target, "DragStart", event.getMouseEvent() );
    }
  },

  _dragEndHandler : function( event ) {
    var target = event.getCurrentTarget();
    var mouseEvent = event.getMouseEvent();
    // fix for Bug 301544: block new dragStarts until request is send
    this._blockDrag = true;
    this._sendDragSourceEvent( target, "DragEnd", mouseEvent );
    this._cleanUp();
    event.stopPropagation();
  },

  _sendDragSourceEvent : function( widget, type, qxDomEvent ) {
    var x = 0;
    var y = 0;
    if( qxDomEvent instanceof rwt.event.MouseEvent ) {
      x = qxDomEvent.getPageX();
      y = qxDomEvent.getPageY();
    }
    var event = {};
    event[ "widget" ] = this._getDragSource( widget );
    event[ "eventName" ] = type;
    event[ "param" ] = {
      "x" : x,
      "y" : y,
      "time" : rwt.remote.EventUtil.eventTimestamp()
    };
    this._eventQueue[ type ] = event;
    var connection = rwt.remote.Connection.getInstance();
    if( !this._requestScheduled ) {
      connection.addEventListener( "send", this._onSend, this );
      this._requestScheduled = true;
    }
    connection.send();
  },

  /////////////
  // dropTarget

  registerDropTarget : function( dropTarget ) {
    var control = dropTarget.control;
    control.addEventListener( "dragover", this._dragOverHandler, this );
    control.addEventListener( "dragmove", this._dragMoveHandler, this );
    control.addEventListener( "dragout", this._dragOutHandler, this );
    control.addEventListener( "dragdrop", this._dragDropHandler, this );
    this._dropTargets[ control.toHashCode() ] = dropTarget;
    control.setSupportsDropMethod( rwt.util.Functions.returnTrue );
  },

  setDropTargetTransferTypes : function( widget, transferTypes ) {
    widget.setDropDataTypes( transferTypes );
  },

  deregisterDropTarget : function( dropTarget ) {
    var control = dropTarget.control;
    control.setDropDataTypes( [] );
    control.removeEventListener( "dragover", this._dragOverHandler, this );
    control.removeEventListener( "dragmove", this._dragMoveHandler, this );
    control.removeEventListener( "dragout", this._dragOutHandler, this );
    control.removeEventListener( "dragdrop", this._dragDropHandler, this );
    delete this._dropTargets[ control.toHashCode() ];
    control.setSupportsDropMethod( null );
  },

  _dragOverHandler : function( event ) {
    var target = event.getCurrentTarget();
    var mouseEvent = event.getMouseEvent();
    this._currentDropControl = target;
    var action = this._computeCurrentAction( mouseEvent, target );
    this._setAction( action, null );
    this._sendDropTargetEvent( target, "DragEnter", mouseEvent, action );
    event.stopPropagation();
  },

  _dragMoveHandler : function( event ) {
    var target = event.getCurrentTarget();
    var mouseEvent = event.getMouseEvent();
    this._currentMousePosition.x = mouseEvent.getPageX();
    this._currentMousePosition.y = mouseEvent.getPageY();
    var action = this._computeCurrentAction( mouseEvent, target );
    this._setAction( action, mouseEvent );
    this._sendDropTargetEvent( target, "DragOver", mouseEvent, action );
    event.stopPropagation();
  },

  _dragOutHandler : function( event ) {
    var target = event.getCurrentTarget();
    var mouseEvent = event.getMouseEvent();
    if( this._currentTargetElement !== mouseEvent.getDomTarget() ) {
      this._onMouseOver( mouseEvent );
    }
    var dndHandler = rwt.event.DragAndDropHandler.getInstance();
    dndHandler.clearActions();
    this.setFeedback( target, null, 0 );
    this._currentDropControl = null;
    this._actionOverwrite = null;
    this._dataTypeOverwrite = null;
    if( this._isEventScheduled( "DragEnter" ) ) {
      this._cancelEvent( "DragEnter" );
      this._cancelEvent( "DragOver" );
    } else {
      this._sendDropTargetEvent( target, "DragLeave", mouseEvent, "none" );
    }
    event.stopPropagation();
  },

  _dragDropHandler : function( event ) {
    var target = event.getCurrentTarget();
    var mouseEvent = event.getMouseEvent();
    var action = this._computeCurrentAction( mouseEvent, target );
    this._sendDropTargetEvent( target, "DropAccept", mouseEvent, action );
    event.stopPropagation();
  },

  _sendDropTargetEvent : function( widget, type, qxDomEvent, action ) {
    var item = this._getCurrentItemTarget();
    var itemId = item != null ? rwt.remote.ObjectRegistry.getId( item ) : null;
    var x = 0;
    var y = 0;
    if( qxDomEvent instanceof rwt.event.MouseEvent ) {
      x = qxDomEvent.getPageX();
      y = qxDomEvent.getPageY();
    } else {
      x = this._currentMousePosition.x;
      y = this._currentMousePosition.y;
    }
    var source = rwt.remote.ObjectRegistry.getId( this._currentDragControl );
    var time = rwt.remote.EventUtil.eventTimestamp();
    var operation = action == "alias" ? "link" : action;
    var event = {};
    event[ "widget" ] = this._getDropTarget( widget );
    event[ "eventName" ] = type;
    event[ "param" ] = {
      "x" : x,
      "y" : y,
      "item" : itemId,
      "operation" : operation,
      "feedback" : this._dropFeedbackFlags,
      "dataType" : this._dataTypeOverwrite,
      "source" : source,
      "time" : time
    };
    this._eventQueue[ type ] = event;
    if( !this._requestScheduled ) {
      var connection = rwt.remote.Connection.getInstance();
      connection.addEventListener( "send", this._onSend, this );
      this._requestScheduled = true;
      rwt.client.Timer.once( connection.send, connection, 200 );
    }
  },

  _isEventScheduled : function( type ) {
    return typeof this._eventQueue[ type ] != "undefined";
  },

  _cancelEvent : function( type ) {
    delete this._eventQueue[ type ];
  },

  _setPropertyRetroactively : function( widget, property, value ) {
    for( var type in this._eventQueue ) {
      var event = this._eventQueue[ type ];
      if( event[ "widget" ].control === widget ) {
        event[ "param" ][ property ] = value;
      }
    }
  },

  _attachEvents : function() {
    var connection = rwt.remote.Connection.getInstance();
    var order = this._getEventOrder( this._eventQueue );
    for( var i = 0; i < order.length; i++ ) {
      var event = this._eventQueue[ order[ i ] ];
      if( event ) {
        connection.getRemoteObject( event.widget ).notify( event.eventName, event.param );
      }
    }
    this._eventQueue = {};
  },

  _getEventOrder : function( events ) {
    var order;
    if( this._isLeaveBeforeEnter( events ) ) {
      order = [ "DragStart", "DragLeave", "DragEnter", "DragOperationChanged", "DragOver",
                "DropAccept", "DragEnd" ];
    } else {
      order = [ "DragStart", "DragEnter", "DragOperationChanged", "DragOver", "DragLeave",
                "DropAccept", "DragEnd" ];
    }
    return order;
  },

  _isLeaveBeforeEnter : function( events ) {
    var leave = events[ "DragLeave" ];
    var enter = events[ "DragEnter" ];
    return leave && enter && leave[ "param" ].time <= enter[ "param" ].time;
  },

  _getCurrentItemTarget : function() {
    var result = null;
    var target = this._getCurrentFeedbackTarget();
    if( target instanceof rwt.widgets.base.GridRow ) {
      var tree = this._currentDropControl;
      result = tree._rowContainer.findItemByRow( target );
    } else {
      result = target;
    }
    return result;
  },

  //////////
  // actions

  _setAction : function( newAction, sourceEvent ) {
    // NOTE: using setCurrentAction would conflict with key events
    var dndHandler = rwt.event.DragAndDropHandler.getInstance();
    var oldAction = dndHandler.getCurrentAction();
    if( oldAction != newAction ) {
      dndHandler.clearActions();
      dndHandler.setAction( newAction );
      if( sourceEvent != null ) {
        this._sendDropTargetEvent( this._currentDropControl,
                                   "DragOperationChanged",
                                   sourceEvent,
                                   newAction );
      }
    }
  },

  _operationsToActions : function( operations ) {
    var result = {};
    for( var i = 0; i < operations.length; i++ ) {
      var action = this._toAction( operations[ i ] );
      result[ action ] = action != null;
    }
    return result;
  },

  _toAction : function( operation ) {
    var result;
    switch( operation ) {
      case "DROP_MOVE":
        result = "move";
      break;
      case "DROP_COPY":
        result = "copy";
      break;
      case "DROP_LINK":
        result = "alias";
      break;
      default:
        result = operation;
      break;
    }
    return result;
  },

  _computeCurrentAction : function( domEvent, target ) {
    var result;
    if( this._actionOverwrite != null ) {
      result = this._actionOverwrite;
    } else {
      result = "move";
      var shift = domEvent.isShiftPressed();
      var ctrl = domEvent.isCtrlPressed();
      var alt = domEvent.isAltPressed();
      if( ctrl && !shift && !alt ) {
        result = "copy";
      } else if( alt && !shift && !ctrl ) {
        result = "alias";
      } else if( !alt && shift && ctrl ) {
        result = "alias";
      }
      var dropActions = this._getDropTarget( target ).actions;
      var dragActions = this._getDragSource( this._currentDragControl ).actions;
      if( !dragActions[ result ] || !dropActions[ result ] ) {
        result = "none";
      }
    }
    return result;
  },

  ///////////
  // feedback

  // TODO [tb] : allow overwrite using DropTarget.setDropTargetEffect?
  /*
   * Creates a feedback-renderer matching the given widget,
   * "implementing" the following interface:
   *  setFeedback : function( feedbackMap )
   *  renderFeedback : function( target )
   *  isFeedbackNode : function( node )
   */
  _createFeedback : function( widget ) {
    if( this._dropFeedbackRenderer == null ) {
      if( widget instanceof rwt.widgets.Grid ) {
        this._dropFeedbackRenderer = new rwt.widgets.util.GridDNDFeedback( widget );
      }
    }
  },

  _renderFeedback : function() {
    if( this._dropFeedbackRenderer != null ) {
      var target = this._getCurrentFeedbackTarget();
      this._dropFeedbackRenderer.renderFeedback( target );
    }
  },

  _getCurrentFeedbackTarget : function() {
    var result = null;
    if( this._currentDropControl instanceof rwt.widgets.Grid ) {
      var element = this._currentTargetElement;
      result = this._currentDropControl.getRowContainer().findRowByElement( element );
    }
    return result;
  },

  // TODO [tb] : allow overwrite using DragSourceEvent.image?
  _getFeedbackWidget : function( sourceControl, sourceElement ) {
    if( this._dragFeedbackWidget == null ) {
      this._dragFeedbackWidget = new rwt.widgets.base.MultiCellWidget( [ "image", "label" ] );
      this._dragFeedbackWidget.setOpacity( 0.7 );
      this._dragFeedbackWidget.setEnabled( false );
      this._dragFeedbackWidget.setPadding( 2 );
    }
    if( sourceControl instanceof rwt.widgets.Grid ) {
      var row = sourceControl.getRowContainer().findRowByElement( sourceElement );
      if( row ) {
        this._configureTreeRowFeedback( row );
        return this._dragFeedbackWidget;
      }
    }
    return null;
  },

  _configureTreeRowFeedback : function( row ) {
    var widget = this._dragFeedbackWidget;
    var tree = this._currentDragControl;
    var item = tree._rowContainer.findItemByRow( row );
    if( item != null ) {
      var config = tree.getRenderConfig();
      var image = item.getImage( config.treeColumn );
      if( image != null ) {
        widget.setCellContent( 0, image[ 0 ] );
        var imageWidth = config.itemImageWidth[ config.treeColumn ];
        widget.setCellDimension( 0, imageWidth, row.getHeight() );
      }
      var backgroundColor = item.getCellBackground( config.treeColumn );
      var textColor = item.getCellForeground( config.treeColumn );
      widget.setBackgroundColor( backgroundColor );
      widget.setTextColor( textColor );
      var text = item.getText( config.treeColumn );
      widget.setCellContent( 1, rwt.util.Encoding.escapeText( text, false ) );
      widget.setFont( config.font );
    }
  },

  _resetFeedbackWidget : function() {
    if( this._dragFeedbackWidget != null ) {
      this._dragFeedbackWidget.setParent( null );
      this._dragFeedbackWidget.setFont( null );
      this._dragFeedbackWidget.setCellContent( 0, null );
      this._dragFeedbackWidget.setCellDimension( 0, null, null );
      this._dragFeedbackWidget.setCellContent( 1, null );
      this._dragFeedbackWidget.setBackgroundColor( null );
    }
  },

  ///////////////
  // eventhandler

  _onSend : function() {
    this._attachEvents();
    this._requestScheduled = false;
    this._blockDrag = false;
    rwt.remote.Connection.getInstance().removeEventListener( "send", this._onSend, this );
  },

  _onMouseOver : function( event ) {
    var target = event.getDomTarget();
    if( this._dropFeedbackRenderer != null ) {
      if( !this._dropFeedbackRenderer.isFeedbackNode( target ) ) {
        this.setCurrentTargetElement( target );
      }
    } else {
      this.setCurrentTargetElement( target );
    }
  },

  setCurrentTargetElement : function( target ) {
    this._currentTargetElement = target;
    this._renderFeedback();
  },

  _onKeyEvent : function( event ) {
    if( event.getType() == "keyup" && event.getKeyIdentifier() == "Alt" ) {
      // NOTE: This combination causes problems with future dom events,
      // so instead we cancel the operation.
      this._sendDragSourceEvent( this._currentDragControl, "DragEnd", event );
      this.cancel();
    } else if( this._currentDropControl != null ) {
      var dndHandler = rwt.event.DragAndDropHandler.getInstance();
      var action = this._computeCurrentAction( event, this._currentDropControl );
      this._setAction( action, event );
      dndHandler._renderCursor();
    }
  },

  /////////
  // helper

  _cleanUp : function() {
    // fix for bug 296348
    var widgetUtil = rwt.widgets.util.WidgetUtil;
    widgetUtil._fakeMouseEvent( this._currentTargetElement, "elementOver" );
    widgetUtil._fakeMouseEvent( this._currentTargetElement, "mouseover" );
    this.setCurrentTargetElement( null );
    if( this._currentDropControl != null) {
      this.setFeedback( this._currentDropControl, null, 0 );
      this._currentDropControl = null;
    }
    var dndHandler = rwt.event.DragAndDropHandler.getInstance();
    dndHandler.setFeedbackWidget( null );
    this._resetFeedbackWidget();
    this._currentDragControl = null;
    this._dataTypeOverwrite = null;
    this._currentMousePosition.x = 0;
    this._currentMousePosition.y = 0;
    var doc = rwt.widgets.base.ClientDocument.getInstance();
    doc.removeEventListener( "elementOver", this._onMouseOver, this );
    doc.removeEventListener( "keydown", this._onKeyEvent, this );
    doc.removeEventListener( "keyup", this._onKeyEvent, this );
  },

  _getDragSource : function( control ) {
    return this._dragSources[ control.toHashCode() ];
  },

  _getDropTarget : function( control ) {
    return this._dropTargets[ control.toHashCode() ];
  },

  //////////////////
  // server response

  cancel : function() {
    if( this._currentDragControl != null ) {
      var dndHandler = rwt.event.DragAndDropHandler.getInstance();
      dndHandler.globalCancelDrag();
      this._cleanUp();
    }
  },

  setOperationOverwrite : function( widget, operation ) {
    if( widget == this._currentDropControl ) {
      var action = this._toAction( operation );
      var dndHandler = rwt.event.DragAndDropHandler.getInstance();
      this._actionOverwrite = action;
      this._setAction( action, null );
      dndHandler._renderCursor();
    }
    this._setPropertyRetroactively( widget, "operation", operation );
  },

  /*
   * feedback is an array of strings with possible values
   * "select", "before", "after", "expand" and "scroll", while
   * flags is the "feedback"-field of SWTs dropTargetEvent,
   * representing the same information as an integer.
   */
  setFeedback : function( widget, feedback, flags ) {
    if( widget == this._currentDropControl ) {
      if( feedback != null ) {
        this._createFeedback( widget );
        if( this._dropFeedbackRenderer != null ) {
          var feedbackMap = {};
          for( var i = 0; i < feedback.length; i++ ) {
            feedbackMap[ feedback[ i ] ] = true;
          }
          this._dropFeedbackRenderer.setFeedback( feedbackMap );
          this._renderFeedback();
        }
      } else if( this._dropFeedbackRenderer != null ) {
        this._dropFeedbackRenderer.dispose();
        this._dropFeedbackRenderer = null;
      }
      this._dropFeedbackFlags = flags;
    }
  },

  setDataType : function( widget, type ) {
    if( widget == this._currentDropControl ) {
      this._dataTypeOverwrite = type;
    }
    this._setPropertyRetroactively( widget, "dataType", type );
  }

};

/*******************************************************************************
 * Copyright (c) 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

namespace( "rwt.widgets" );

rwt.widgets.DragSource = function( control, operations ) {
  this.control = control;
  this.actions = rwt.remote.DNDSupport.getInstance()._operationsToActions( operations );
  this.dataTypes = [];
  rwt.remote.DNDSupport.getInstance().registerDragSource( this );
};

rwt.widgets.DragSource.prototype = {

  dispose : function() {
    rwt.remote.DNDSupport.getInstance().deregisterDragSource( this );
  },

  setTransfer : function( transferTypes ) {
    rwt.remote.DNDSupport.getInstance().setDragSourceTransferTypes( this.control, transferTypes );
  }

};

/*******************************************************************************
 * Copyright (c) 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

namespace( "rwt.widgets" );

(function() {
  var callWithElement = rwt.widgets.util.WidgetUtil.callWithElement;

  rwt.widgets.DropTarget = function( control, operations ) {
    this.control = control;
    this.actions = rwt.remote.DNDSupport.getInstance()._operationsToActions( operations );
    rwt.remote.DNDSupport.getInstance().registerDropTarget( this );
    this._onDragEvent = rwt.util.Functions.bind( this._onDragEvent, this );
  };

  rwt.widgets.DropTarget.prototype = {

    dispose : function() {
      rwt.remote.DNDSupport.getInstance().deregisterDropTarget( this );
    },

    setTransfer : function( transferTypes ) {
      rwt.remote.DNDSupport.getInstance().setDropTargetTransferTypes( this.control, transferTypes );
    },

    changeFeedback : function( feedback, flags ) {
      rwt.remote.DNDSupport.getInstance().setFeedback( this.control, feedback, flags );
    },

    changeDetail : function( detail ) {
      rwt.remote.DNDSupport.getInstance().setOperationOverwrite( this.control, detail );
    },

    changeDataType : function( dataType ) {
      rwt.remote.DNDSupport.getInstance().setDataType( this.control, dataType );
    },

    setFileDropEnabled : function( enabled ) {
      if( rwt.client.Client.supportsFileDrop() ) {
        var listener = this._onDragEvent;
        callWithElement( this.control, function( element ) {
          if( enabled ) {
            element.addEventListener( "dragenter", listener, false );
            element.addEventListener( "dragover", listener, false );
            element.addEventListener( "drop", listener, false );
          } else {
            element.removeEventListener( "dragenter", listener, false );
            element.removeEventListener( "dragover", listener, false );
            element.removeEventListener( "drop", listener, false );
          }
        } );
      }
    },

    _onDragEvent : function( event ) {
      try {
        if( this._isDraggingFiles( event ) ) {
          // NOTE: Feedback effects are currenlty only respected by webkit, will ignore for now
          rwt.event.EventHandlerUtil.stopDomEvent( event );
          event.stopPropagation();
          if( event.type === "drop" ) {
            this._sendDropAccept( event );
          }
        }
      } catch( ex ) {
        rwt.runtime.ErrorHandler.processJavaScriptError( ex );
      }
    },

    _sendDropAccept : function( event ) {
      var remoteObject = rwt.remote.Connection.getInstance().getRemoteObject( this );
      remoteObject.notify( "DropAccept", {
        "x" : event.pageX,
        "y" : event.pageY,
        "time" : rwt.remote.EventUtil.eventTimestamp(),
        "operation" : "move",
        "feedback" : 0,
        "files" : this._getFiles( event )
      } );
    },

    _isDraggingFiles : function( event ) {
      var types = event.dataTransfer.types;
      return types.indexOf ? ( types.indexOf( "Files" ) !== -1 ) : types.contains( "Files" );
    },

    _getFiles : function( event ) {
      var fileUploader = rwt.client.FileUploader.getInstance();
      var files = event.dataTransfer.files;
      var result = {};
      for( var i = 0; i < files.length; i++ ) {
        var file = files.item( i );
        var fileId = fileUploader.addFile( file );
        result[ fileId ] = {
          "type" : file.type,
          "size" : file.size,
          "name" : file.name
        };
      }
      return result;
    }

  };

}());

/*******************************************************************************
 * Copyright (c) 2011, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.remote.HandlerRegistry.add( "rwt.widgets.DropTarget", {

  factory : function( properties ) {
    var control = rwt.remote.ObjectRegistry.getObject( properties.control );
    var result = new rwt.widgets.DropTarget( control, properties.style );
    rwt.remote.HandlerUtil.addDestroyableChild( control, result );
    return result;
  },

  destructor : function( target ) {
    rwt.remote.HandlerUtil.removeDestroyableChild( target.control, target );
    target.dispose();
  },

  properties : [ "transfer", "fileDropEnabled" ],

  events : [ "DragEnter", "DragOver", "DragLeave", "DragOperationChanged", "DropAccept" ],

  methods : [ "changeFeedback", "changeDetail", "changeDataType" ],

  methodHandler : {
    "changeFeedback" : function( target, properties ) {
      target.changeFeedback( properties.feedback, properties.flags );
    },
    "changeDetail" : function( target, properties ) {
      target.changeDetail( properties.detail );
    },
    "changeDataType" : function( target, properties ) {
      target.changeDataType( properties.dataType );
    }
  }

} );

/*******************************************************************************
 * Copyright (c) 2011, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.remote.HandlerRegistry.add( "rwt.widgets.DragSource", {

  factory : function( properties ) {
    var control = rwt.remote.ObjectRegistry.getObject( properties.control );
    var result = new rwt.widgets.DragSource( control, properties.style );
    rwt.remote.HandlerUtil.addDestroyableChild( control, result );
    return result;
  },

  destructor : function( source ) {
    rwt.remote.HandlerUtil.removeDestroyableChild( source.control, source );
    source.dispose();
  },

  properties : [ "transfer" ],

  events : [ "DragStart", "DragEnd" ],

  methods : [ "cancel" ],

  methodHandler : {
    "cancel" : function() {
      rwt.remote.DNDSupport.getInstance().cancel();
    }
  }

} );

/*******************************************************************************
 * Copyright (c) 2007, 2014 Innoopract Informationssysteme GmbH and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Innoopract Informationssysteme GmbH - initial API and implementation
 *    EclipseSource - ongoing development
 ******************************************************************************/

/**
 * An adapter class for accessing theme values.
 * Values for the widget state given in the construtor are selected if available.
 */
rwt.qx.Class.define( "rwt.theme.ThemeValues", {

  extend : rwt.qx.Object,

  /**
   * Creates a new ThemeValues instance for the variant defined in the given
   * widget states.
   */
  construct : function( states ) {
    if( states === undefined ) {
      throw new Error( "no states given" );
    }
    this._states = states;
    this._store = rwt.theme.ThemeStore.getInstance();
  },

  statics : {
    NONE_IMAGE : null,
    NONE_IMAGE_SIZED : [ null, 0, 0 ]
  },

  members : {

    getCssBorder : function( element, key ) {
      if( key === "border" ) {
        return this._store.getBorder( element, this._states, key );
      }
      return this._store.getBorderEdge( element, this._states, key );
    },

    getCssNamedBorder : function( name ) {
      return this._store.getNamedBorder( name );
    },

    getCssColor : function( element, key ) {
      return this._store.getColor( element, this._states, key );
    },

    getCssAlpha : function( element, key ) {
      return this._store.getAlpha( element, this._states, key );
    },

    getCssNamedColor : function( name ) {
      return this._store.getNamedColor( name );
    },

    getCssFont : function( element, key ) {
      return this._store.getFont( element, this._states, key );
    },

    getCssDimension : function( element, key ) {
      return this._store.getDimension( element, this._states, key );
    },

    getCssBoxDimensions : function( element, key ) {
      return this._store.getBoxDimensions( element, this._states, key );
    },

    getCssBoolean : function( element, key ) {
      return this._store.getBoolean( element, this._states, key );
    },

    getCssFloat : function( element, key ) {
      return this._store.getFloat( element, this._states, key );
    },

    getCssIdentifier : function( element, key ) {
      return this._store.getIdentifier( element, this._states, key );
    },

    getCssImage : function( element, key ) {
      return this._store.getImage( element, this._states, key );
    },

    getCssSizedImage : function( element, key ) {
      return this._store.getSizedImage( element, this._states, key );
    },

    getCssGradient : function( element, key ) {
      return this._store.getGradient( element, this._states, key );
    },

    getCssCursor : function( element, key ) {
      return this._store.getCursor( element, this._states, key );
    },

    getCssAnimation : function( element, key ) {
      return this._store.getAnimation( element, this._states, key );
    },

    getCssShadow : function( element, key ) {
      return this._store.getShadow( element, this._states, key );
    },

    mergeBorders : function( border, borderTop, borderRight, borderBottom, borderLeft ) {
      if( border == null ) {
        throw new Error( "Unable to merge borders. Base border is null" );
      }
      var result = border;
      var changed = false;
      var borderColors = border.getColors();
      var borderWidths = border.getWidths();
      var borderStyles = border.getStyles();
      if( borderTop != null && borderTop.getWidthTop() !== 0 ) {
        changed = true;
        borderColors[ 0 ] = borderTop.getColorTop();
        borderWidths[ 0 ] = borderTop.getWidthTop();
        borderStyles[ 0 ] = borderTop.getStyleTop();
      }
      if( borderRight != null && borderRight.getWidthRight() !== 0 ) {
        changed = true;
        borderColors[ 1 ] = borderRight.getColorRight();
        borderWidths[ 1 ] = borderRight.getWidthRight();
        borderStyles[ 1 ] = borderRight.getStyleRight();
      }
      if( borderBottom != null && borderBottom.getWidthBottom() !== 0 ) {
        changed = true;
        borderColors[ 2 ] = borderBottom.getColorBottom();
        borderWidths[ 2 ] = borderBottom.getWidthBottom();
        borderStyles[ 2 ] = borderBottom.getStyleBottom();
      }
      if( borderLeft != null && borderLeft.getWidthLeft() !== 0 ) {
        changed = true;
        borderColors[ 3 ] = borderLeft.getColorLeft();
        borderWidths[ 3 ] = borderLeft.getWidthLeft();
        borderStyles[ 3 ] = borderLeft.getStyleLeft();
      }
      if( changed ) {
        // TODO: Border radii are ingnored during the merge.
        result = new rwt.html.Border( borderWidths, borderStyles, borderColors );
      }
      return result;
    }

  }
} );

/*******************************************************************************
 * Copyright (c) 2010, 2015 Innoopract Informationssysteme GmbH and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Innoopract Informationssysteme GmbH - initial API and implementation
 *    EclipseSource - ongoing development
 ******************************************************************************/

rwt.qx.Class.define( "rwt.widgets.Grid", {

  extend : rwt.widgets.base.Parent,

  construct : function( argsMap ) {
    this.base( arguments );
    this._rootItem = new rwt.widgets.GridItem();
    this._hasMultiSelection = false;
    this._leadItem = null;
    this._topItemIndex = 0;
    this._topItem = null;
    this._selection = [];
    this._focusItem = null;
    this._renderQueue = {};
    this._resizeLine = null;
    this._selectionTimestamp = null;
    this._selectionOffsetX = null;
    this._delayedSelection = false;
    this._sortDirection = null;
    this._sortColumn = null;
    this._hasFixedColumns = false;
    this._headerHeight = 0;
    this._footerHeight = 0;
    this._itemHeight = 16;
    this._rowContainer = rwt.widgets.util.GridUtil.createTreeRowContainer( argsMap );
    this._columns = {};
    this._horzScrollBar = new rwt.widgets.base.ScrollBar( true );
    this._vertScrollBar = new rwt.widgets.base.ScrollBar( false );
    this._vertScrollBar.setAutoThumbSize( false );
    this._header = null;
    this._footer = null;
    this.add( this._rowContainer );
    this.add( this._horzScrollBar );
    this.add( this._vertScrollBar );
    this._config = this._rowContainer.getRenderConfig();
    this.setCursor( "default" );
    this.setOverflow( "hidden" );
    rwt.widgets.base.Widget.disableScrolling( this ); // see bugs 279460 and 364739
    rwt.widgets.util.ScrollBarsActivator.install( this );
    this._configureScrollBars();
    this._registerListeners();
    this._parseArgsMap( argsMap );
  },

  destruct : function() {
    this._rootItem.removeEventListener( "update", this._onItemUpdate, this );
    this._rootItem.dispose();
    this._rootItem = null;
    this._rowContainer = null;
    this._header = null;
    this._footer = null;
    this._horzScrollBar = null;
    this._vertScrollBar = null;
    this._leadItem = null;
    this._focusItem = null;
    this._sortColumn = null;
    this._resizeLine = null;
  },

  members : {

    /////////////////////////////////
    // Contructor & Subwidget helpers

    _createHeader : function() {
      this._header = new rwt.widgets.base.GridHeader( {
        "appearance" : this.getAppearance(),
        "splitContainer" : this._hasFixedColumns
      } );
      this.add( this._header );
      this._header.addEventListener( "showResizeLine", this._onShowResizeLine, this );
      this._header.addEventListener( "hideResizeLine", this._onHideResizeLine, this );
      this._header.setTop( 0 );
      this._header.setLeft( 0 );
      this._header.setScrollLeft( this._horzScrollBar.getValue() );
      this._scheduleColumnUpdate();
    },

    _createFooter : function() {
      this._footer = new rwt.widgets.base.GridHeader( {
        "appearance" : this.getAppearance(),
        "splitContainer" : this._hasFixedColumns,
        "footer" : true
      } );
      this.add( this._footer );
      this._footer.setLeft( 0 );
      this._footer.setScrollLeft( this._horzScrollBar.getValue() );
      this._scheduleColumnUpdate();
    },

    _configureScrollBars : function() {
      var dragBlocker = function( event ) { event.stopPropagation(); };
      this._horzScrollBar.setZIndex( 1e8 );
      this._horzScrollBar.setVisibility( false );
      this._horzScrollBar.setLeft( 0 );
      this._horzScrollBar.addEventListener( "dragstart", dragBlocker );
      this._vertScrollBar.setZIndex( 1e8 );
      this._vertScrollBar.setVisibility( false );
      this._vertScrollBar.setIncrement( 1 );
      this._vertScrollBar.addEventListener( "dragstart", dragBlocker );
    },

    _registerListeners : function() {
      this._rootItem.addEventListener( "update", this._onItemUpdate, this );
      this.addEventListener( "mousedown", this._onMouseDown, this );
      this.addEventListener( "mouseup", this._onMouseUp, this );
      this.addEventListener( "click", this._onClick, this );
      this.addEventListener( "mouseout", this._onMouseOut, this );
      this.addEventListener( "keypress", this._onKeyPress, this );
      this.addEventListener( "focusin", this._onFocusIn, this );
      this._rowContainer.addEventListener( "mousewheel", this._onClientAreaMouseWheel, this );
      this._horzScrollBar.addEventListener( "changeValue", this._onHorzScrollBarChangeValue, this );
      this._vertScrollBar.addEventListener( "changeValue", this._onVertScrollBarChangeValue, this );
      this._rowContainer.setSelectionProvider( this.isItemSelected, this );
      this._rowContainer.addEventListener( "appear", this._onChangeSeeable );
      this._rowContainer.addEventListener( "disappear", this._onChangeSeeable );
    },

    _parseArgsMap : function( map ) {
      if( map.noScroll ) {
        this._rowContainer.removeEventListener( "mousewheel", this._onClientAreaMouseWheel, this );
      }
      this._config.hideSelection = !!map.hideSelection;
      this._hasMultiSelection = !!map.multiSelection;
      this._config.fullSelection = !!map.fullSelection;
      this._config.markupEnabled = map.markupEnabled;
      this._hasFixedColumns = map.splitContainer;
      this._config.baseAppearance = map.appearance;
      this._config.rowTemplate = map.rowTemplate;
      if( !map.fullSelection ) {
        this._config.selectionPadding = map.selectionPadding;
      }
      if( map.check ) {
        this._config.hasCheckBoxes = true;
        this._config.checkBoxLeft = map.checkBoxMetrics[ 0 ];
        this._config.checkBoxWidth = map.checkBoxMetrics[ 1 ];
      }
      if( typeof map.indentionWidth === "number" ) {
        this._config.indentionWidth = map.indentionWidth;
      }
      if( this._config.rowTemplate ) {
        this.addState( "rowtemplate" );
      }
      this._rowContainer.setBaseAppearance( map.appearance );
      this.setAppearance( map.appearance );
    },

    ///////////////////////////
    // API for server - general

    setItemCount : function( value ) {
      this._rootItem.setItemCount( value );
    },

    setHeaderVisible : function( value ) {
      if( value && this._header == null ) {
        this._createHeader();
      } else if( !value ) {
        this._header.destroy();
        this._header = null;
      }
      this._layoutX();
      this._layoutY();
    },

    setFooterVisible : function( value ) {
      if( value && this._footer == null ) {
        this._createFooter();
      } else if( !value ) {
        this._footer.destroy();
        this._footer = null;
      }
      this._scheduleUpdate( "scrollHeight" );
      this._layoutX();
      this._layoutY();
    },

    setHeaderHeight : function( value ) {
      this._headerHeight = value;
      this._layoutX();
      this._layoutY();
    },

    setFooterHeight : function( value ) {
      this._footerHeight = value;
      this._scheduleUpdate( "scrollHeight" );
      this._layoutX();
      this._layoutY();
    },

    setItemHeight : function( height ) {
      this._itemHeight = height;
      this._rowContainer.setRowHeight( height );
      this._rootItem.setDefaultHeight( height );
      this._updateScrollThumbHeight();
      this._scheduleUpdate( "scrollHeight" );
    },

    setColumnCount : function( count ) {
      this._config.columnCount = count;
      this._scheduleUpdate();
      this._updateScrollWidth();
    },

    setItemMetrics : function( columnIndex,
                               left,
                               width,
                               imageLeft,
                               imageWidth,
                               textLeft,
                               textWidth,
                               checkLeft,
                               checkWidth )
    {
      this._config.itemLeft[ columnIndex ] = left;
      this._config.itemWidth[ columnIndex ] = width;
      this._config.itemImageLeft[ columnIndex ] = imageLeft;
      this._config.itemImageWidth[ columnIndex ] = imageWidth;
      this._config.itemTextLeft[ columnIndex ] = textLeft;
      this._config.itemTextWidth[ columnIndex ] = textWidth;
      if( !isNaN( checkLeft ) ) {
        this._config.itemCellCheckLeft[ columnIndex ] = checkLeft;
        this._config.itemCellCheckWidth[ columnIndex ] = checkWidth;
      }
      this._scheduleUpdate();
      this._updateScrollWidth();
    },

    setTreeColumn : function( columnIndex ) {
      this._config.treeColumn = columnIndex;
    },

    scrollItemIntoView : function( item ) {
      this._disableRender = true;
      this._scrollIntoView( item.getFlatIndex(), item );
      delete this._disableRender;
    },

    setTopItemIndex : function( index ) {
      this._disableRender = true;
      this._setTopItemIndex( index );
      delete this._disableRender;
    },

    getTopItemIndex : function() {
      return this._topItemIndex;
    },

    setScrollLeft: function( value ) {
      this._horzScrollBar.setValue( value );
    },

    selectItem : function( item ) {
      this._selectItem( item, false );
      this._scheduleItemUpdate( item );
    },

    deselectItem : function( item ) {
      this._deselectItem( item, false );
      this._scheduleItemUpdate( item );
    },

    setFocusItem : function( item ) {
      this._focusItem = item;
      this.dispatchSimpleEvent( "focusItemChanged" );
    },

    getFocusItem : function() {
      return this._focusItem;
    },

    setSortDirection : function( direction ) {
      this._sortDirection = direction;
      if( this._sortColumn !== null ) {
        this._sortColumn.setSortDirection( this._sortDirection );
      }
    },

    setSortColumn : function( column ) {
      if( this._sortColumn !== null ) {
        this._sortColumn.setSortDirection( "none" );
      }
      this._sortColumn = column;
      if( this._sortColumn !== null ) {
        this._sortColumn.setSortDirection( this._sortDirection );
      }
    },

    setScrollBarsVisible : function( horzVisible, vertVisible ) {
      this._horzScrollBar.setVisibility( horzVisible );
      this._vertScrollBar.setVisibility( vertVisible );
      this._layoutX();
      this._layoutY();
    },

    getVerticalBar : function() {
      return this._vertScrollBar;
    },

    getHorizontalBar : function() {
      return this._horzScrollBar;
    },

    isVerticalBarVisible : function() {
      return this._vertScrollBar.getVisibility();
    },

    isHorizontalBarVisible : function() {
      return this._horzScrollBar.getVisibility();
    },

    setAlignment : function( column, value ) {
      this._config.alignment[ column ] = value;
      this._scheduleUpdate();
    },

    setWordWrap : function( column, value ) {
      this._config.wordWrap[ column ] = value;
      this._scheduleUpdate();
    },

    setAutoHeight : function( value ) {
      this._config.autoHeight = value;
      this._scheduleUpdate();
    },

    setCellCheck : function( column, value ) {
      this._config.itemCellCheck[ column ] = value;
      this._scheduleUpdate();
    },

    setLinesVisible : function( value ) {
      this._config.linesVisible = value;
      this.toggleState( "linesvisible", value );
      this._rowContainer.updateRowLines();
      this._scheduleUpdate();
    },

    setAlwaysHideSelection : function( value ) {
      this._config.alwaysHideSelection = value;
      this._scheduleUpdate();
    },

    //////////////
    // Overwritten

    addState : function( state ) {
      this.base( arguments, state );
      if( state.slice( 0, 8 ) === "variant_" ) {
        this._config.variant = state;
      }
    },

    removeState : function( state ) {
      if( this._config.variant === state ) {
        this._config.variant = null;
      }
      this.base( arguments, state );
    },

    ///////////////////////////////////////////////
    // API for Tests, DND, TreeUtil and TableColumn

    getRenderConfig : function() {
      return this._config;
    },

    getRootItem : function() {
      return this._rootItem;
    },

    isFocusItem : function( item ) {
      return this._focusItem === item;
    },

    isItemSelected : function( item ) {
      return this._selection.indexOf( item ) != -1;
    },

    getSelection : function() {
      return this._selection.slice( 0 );
    },

    getRowContainer : function() {
      return this._rowContainer;
    },

    getTableHeader : function() {
      return this._header;
    },

    getFooter : function() {
      return this._footer;
    },

    update : function() {
      this._scheduleUpdate();
    },

    addColumn : function( column ) {
      //this.getTableHeader().addColumn( column );
      this._columns[ column.toHashCode() ] = column;
      column.addEventListener( "update", this._scheduleColumnUpdate, this );
      this._scheduleColumnUpdate();
    },

    setColumnOrder : function( columnOrder ) {
      this._columnOrder = columnOrder;
    },

    getColumnOrder : function() {
      return this._columnOrder;
    },

    removeColumn : function( column ) {
      //this.getTableHeader().removeColumn( column );
      delete this._columns[ column.toHashCode() ];
      column.removeEventListener( "update", this._scheduleColumnUpdate, this );
      this._scheduleColumnUpdate();
    },

    ////////////////
    // event handler

    _onItemUpdate : function( event ) {
      var item = event.target;
      if( event.msg === "collapsed" ) {
        if(    this._focusItem
            && ( this._focusItem.isDisposed() || this._focusItem.isChildOf( item ) )
        ) {
          this.setFocusItem( item );
        }
      } else if( event.msg === "remove" ) {
        this._scheduleUpdate( "checkDisposedItems" );
      } else if( event.msg === "height" ) {
        this._enableAltScrolling();
        this._scheduleUpdate( "scrollHeight" );
      }
      if( !event.rendering ) {
        this._renderItemUpdate( item, event );
      }
      return false;
    },

    _beforeAppear : function() {
      this.base( arguments );
      this._scheduleColumnUpdate();
    },

    _afterInsertDom : function() {
      this.base( arguments );
      if( this._config.autoHeight ) {
        this._rowContainer.renderRowHeight();
      }
    },

    _onChangeSeeable : function() {
      this._config.seeable = this.isSeeable();
    },

    _scheduleColumnUpdate : function() {
      rwt.widgets.base.Widget.addToGlobalWidgetQueue( this );
      this._scheduleUpdate();
    },

    flushWidgetQueue : function() {
      this._updateColumns();
    },

    _onVertScrollBarChangeValue : function() {
      this._updateTopItemIndex();
    },

    _updateTopItemIndex : function() {
      this._topItemIndex = this._vertScrollBar.getValue();
      this._topItem = null;
      if( this._allowRender() ) {
        this._updateTopItem( true );
      } else {
        this._scheduleUpdate( "topItem" );
      }
      this.dispatchSimpleEvent( "topItemChanged" );
    },

    _onHorzScrollBarChangeValue : function() {
      this._rowContainer.setScrollLeft( this._horzScrollBar.getValue() );
      if( this._header ) {
        this._header.setScrollLeft( this._horzScrollBar.getValue() );
      }
      if( this._footer ) {
        this._footer.setScrollLeft( this._horzScrollBar.getValue() );
      }
      this.dispatchSimpleEvent( "scrollLeftChanged" );
    },

    _onMouseDown : function( event ) {
      this._delayedSelection = false;
      if( !this._checkAndProcessHyperlink( event ) ) {
        var row = this._rowContainer.findRowByElement( event.getDomTarget() );
        if( row ) {
          this._onRowMouseDown( row, event );
        }
      }
    },

    _onMouseUp : function( event ) {
      if( this._delayedSelection ) {
        this._onMouseDown( event );
      } else {
        this._checkAndProcessHyperlink( event );
      }
    },

    _onClick : function( event ) {
      this._checkAndProcessHyperlink( event );
    },

    _onRowMouseDown : function( row, event ) {
      var item = this._rowContainer.findItemByRow( row );
      if( item != null ) {
        var identifier = row.identify( event.getDomTarget() );
        if( identifier[ 0 ] === "expandIcon" && item.hasChildren() ) {
          this._onExpandClick( item );
        } else if( identifier[ 0 ] === "checkBox" || identifier[ 0 ] === "cellCheckBox" ) {
          this._toggleCheckSelection( item, identifier[ 1 ] );
        } else if( identifier[ 0 ] === "selectableCell" ) {
          this._fireSelectionChanged( item, "cell", null, identifier[ 1 ] );
        } else if( identifier[ 0 ] === "treeColumn" || this._acceptsGlobalSelection() ) {
          this._onSelectionClick( event, item );
        }
      }
    },

    _acceptsGlobalSelection : function() {
      return this._config.fullSelection || this._config.rowTemplate;
    },

    _checkAndProcessHyperlink : function( event ) {
      var hyperlink = null;
      var target = event.getOriginalTarget();
      if( this._config.markupEnabled && target instanceof rwt.widgets.base.GridRowContainer ) {
        hyperlink = this._findHyperlink( event );
        if( hyperlink !== null && this._isRWTHyperlink( hyperlink ) ) {
          event.setDefaultPrevented( true );
          if( event.getType() === "click" ) {
            var row = this._rowContainer.findRowByElement( event.getDomTarget() );
            var item = this._rowContainer.findItemByRow( row );
            var text = hyperlink.getAttribute( "href" );
            if( !text ) {
              text = hyperlink.innerHTML;
            }
            this._fireSelectionChanged( item, "hyperlink", null, text );
          }
        }
      }
      return hyperlink !== null;
    },

    _findHyperlink : function( event ) {
      var targetNode = event.getDomTarget();
      var tagName = targetNode.tagName.toLowerCase();
      while( tagName !== 'a' && tagName !== 'div' ) {
        targetNode = targetNode.parentNode;
        tagName = targetNode.tagName.toLowerCase();
      }
      return tagName === 'a' ? targetNode : null;
    },

    _isRWTHyperlink : function( hyperlink ) {
      return hyperlink.getAttribute( "target" ) === "_rwt";
    },

    _onExpandClick : function( item ) {
       var expanded = !item.isExpanded();
       if( !expanded ) {
         this._deselectVisibleChildren( item );
       }
       item.setExpanded( expanded );
    },

    _onSelectionClick : function( event, item ) {
      // NOTE: Using a listener for "dblclick" does not work because the
      //       item is re-rendered on mousedown which prevents the dom-event.
      var doubleClick = this._isDoubleClicked( event, item );
      if( doubleClick ) {
        this._fireSelectionChanged( item, "defaultSelection" );
      } else if( !this._hasMultiSelection ) {
        this._singleSelectItem( event, item );
      } else if( !this._delayMultiSelect( event, item ) ) {
        this._multiSelectItem( event, item );
      }
    },

    _delayMultiSelect : function( event, item ) {
      if( this._isDragSource() && this.isItemSelected( item ) && event.getType() === "mousedown" ) {
        this._delayedSelection = true;
      }
      return this._delayedSelection;
    },

    _onMouseOut : function() {
      this._delayedSelection = false;
    },

    _onClientAreaMouseWheel : function( event ) {
      var delta = event.getWheelDelta();
      var direction = Math.abs( delta ) / delta;
      var change = Math.ceil( Math.abs( delta ) * 2 ) * direction;
      var orgValue = this._vertScrollBar.getValue();
      this._vertScrollBar.setValue( orgValue - change );
      var newValue = this._vertScrollBar.getValue();
      this._vertScrollBar.setValue( newValue ); // See Bug 396309
      if( newValue !== orgValue ) {
        event.preventDefault();
        event.stopPropagation();
      }
    },

    _onKeyPress : function( event ) {
      if( this._focusItem != null ) {
        switch( event.getKeyIdentifier() ) {
          case "Enter":
            this._handleKeyEnter( event );
          break;
          case "Space":
            this._handleKeySpace( event );
          break;
          case "Up":
            this._handleKeyUp( event );
          break;
          case "Down":
            this._handleKeyDown( event );
          break;
          case "PageUp":
            this._handleKeyPageUp( event );
          break;
          case "PageDown":
            this._handleKeyPageDown( event );
          break;
          case "Home":
            this._handleKeyHome( event );
          break;
          case "End":
            this._handleKeyEnd( event );
          break;
          case "Left":
            this._handleKeyLeft( event );
          break;
          case "Right":
            this._handleKeyRight( event );
          break;
        }
      }
      this._stopKeyEvent( event );
    },

    _stopKeyEvent : function( event ) {
      switch( event.getKeyIdentifier() ) {
        case "Up":
        case "Down":
        case "Left":
        case "Right":
        case "Home":
        case "End":
        case "PageUp":
        case "PageDown":
          event.preventDefault();
          event.stopPropagation();
        break;
      }
    },

    // TODO [tb] : handle by event via TableHeader instead of direct call
    _onShowResizeLine : function( event ) {
      var x = event.position;
      if( this._resizeLine === null ) {
        this._resizeLine = new rwt.widgets.base.Terminator();
        this._resizeLine.setAppearance( "table-column-resizer" );
        this.add( this._resizeLine );
        rwt.widgets.base.Widget.flushGlobalQueues();
      }
      var top = this._rowContainer.getTop();
      this._resizeLine._renderRuntimeTop( top );
      var left = x - 2 - this._horzScrollBar.getValue();
      this._resizeLine._renderRuntimeLeft( left );
      this._resizeLine._renderRuntimeHeight( this._rowContainer.getHeight() );
      this._resizeLine.removeStyleProperty( "visibility" );
    },

    _onHideResizeLine : function() {
      this._resizeLine.setStyleProperty( "visibility", "hidden" );
    },

    _handleKeyEnter : function() {
      this._fireSelectionChanged( this._focusItem, "defaultSelection" );
    },

    _handleKeySpace : function( event ) {
      if( event.isCtrlPressed() || !this.isItemSelected( this._focusItem ) ) {
        // NOTE: When space does not change the selection, the SWT Tree still fires an selection
        //       event, while the Table doesnt. Table behavior is used since it makes more sense.
        var itemIndex = this._focusItem.getFlatIndex();
        this._handleKeyboardSelect( event, this._focusItem, itemIndex );
      }
      if( this._config.hasCheckBoxes ) {
        this._toggleCheckSelection( this._focusItem );
      }
    },

    _handleKeyUp : function( event ) {
      var item = this._focusItem.getPreviousItem();
      if( item != null ) {
        var itemIndex = item.getFlatIndex();
        this._handleKeyboardSelect( event, item, itemIndex );
      }
    },

    _handleKeyDown : function( event ) {
      var item = this._focusItem.getNextItem();
      if( item != null ) {
        var itemIndex = item.getFlatIndex();
        this._handleKeyboardSelect( event, item, itemIndex );
      }
    },

    _handleKeyPageUp : function( event ) {
      var oldOffset = this._focusItem.getOffset();
      var diff = this._getClientAreaHeight();
      var newOffset = Math.max( 0, oldOffset - diff );
      var item = this._rootItem.findItemByOffset( newOffset );
      if( newOffset !== 0 ) {
        item = item.getNextItem();
      }
      var itemIndex = item.getFlatIndex();
      this._handleKeyboardSelect( event, item, itemIndex );
    },

    _handleKeyPageDown : function( event ) {
      var oldOffset = this._focusItem.getOffset();
      var diff = this._getClientAreaHeight();
      var max = this.getRootItem().getOffsetHeight() - 1;
      var newOffset = Math.min( max, oldOffset + diff );
      var item = this._rootItem.findItemByOffset( newOffset );
      if( newOffset !== max ) {
        item = item.getPreviousItem();
      }
      var itemIndex = item.getFlatIndex();
      this._handleKeyboardSelect( event, item, itemIndex );
    },

    _handleKeyHome : function( event ) {
      var item = this.getRootItem().getChild( 0 );
      this._handleKeyboardSelect( event, item, 0 );
    },

    _handleKeyEnd : function( event ) {
      var item = this.getRootItem().getLastChild();
      var itemIndex = this.getRootItem().getVisibleChildrenCount() - 1;
      this._handleKeyboardSelect( event, item, itemIndex );
    },

    _handleKeyLeft : function( event ) {
      if( this._focusItem.isExpanded() ) {
        this._focusItem.setExpanded( false );
      } else if( !this._focusItem.getParent().isRootItem() ) {
        var item = this._focusItem.getParent();
        var itemIndex = item.getFlatIndex();
        this._handleKeyboardSelect( event, item, itemIndex, true );
      }
    },

    _handleKeyRight : function( event ) {
      if( this._focusItem.hasChildren() ) {
        if( !this._focusItem.isExpanded() ) {
          this._focusItem.setExpanded( true );
        } else {
          var item = this._focusItem.getChild( 0 );
          var itemIndex = item.getFlatIndex();
          this._handleKeyboardSelect( event, item, itemIndex, true );
        }
      }
    },

    _handleKeyboardSelect : function( event, item, itemIndex, suppressMulti ) {
      if( this._hasMultiSelection && !suppressMulti ) {
        this._multiSelectItem( event, item );
      } else {
        this._singleSelectItem( event, item );
      }
      this._scrollIntoView( itemIndex, item );
    },

    _onFocusIn : function() {
      if( this._focusItem === null ) {
        var firstItem = this._rootItem.getChild( 0 );
        if( firstItem ) {
          this.setFocusItem( firstItem );
        }
      }
    },

    /////////////////
    // render content

    _updateColumns : function() {
      this._updateScrollWidth();
      if( this._header != null ) {
        this._header.renderColumns( this._columns );
      }
      if( this._footer != null ) {
        this._footer.renderColumns( this._columns );
      }
    },

    _renderItemUpdate : function( item, event ) {
      if( item.isDisplayable() ) {
        switch( event.msg ) {
          case "expanded":
          case "collapsed":
            this._topItem = null;
            this._scheduleUpdate( "scrollHeight" );
          break;
          case "add":
          case "remove":
            // NOTE: the added/removed item is a child of this item
            if( item.isExpanded() ) {
              this._scheduleUpdate( "scrollHeight" );
            } else {
              this._scheduleItemUpdate( item );
            }
            this._topItem = null;
          break;
          case "content":
            this._scheduleItemUpdate( item );
          break;
          default:
            if( this._allowRender() ) {
              this._rowContainer.renderItem( item );
            } else {
              this._scheduleItemUpdate( item );
            }
          break;
        }
      }
    },

    /**
     * This will schedule the entire content of the tree (visible rows and gridlines)
     * to be re-rendered. Additional tasks my be executed depending on "task" parameter.
     * Is only used within a server-response or when expanding/collapsing. Not used
     * when user is scrolling.
     */
    _scheduleUpdate : function( task ) {
      if( task !== undefined ) {
        this.addToQueue( task );
      }
      this._renderQueue[ "allItems" ] = true;
      this.addToQueue( "updateRows" );
    },

    /**
     * Optimized version of _scheduleUpdate. Used when server only changes specific items.
     */
    _scheduleItemUpdate : function( item ) {
      this._renderQueue[ item.toHashCode() ] = item;
      this.addToQueue( "updateRows" );
    },

    _layoutPost : function( changes ) {
      this.base( arguments, changes );
      if( changes[ "checkDisposedItems" ] ) {
        this._checkDisposedItems();
      }
      if( changes[ "scrollHeight" ] ) {
        this._updateScrollHeight();
      }
      if( changes[ "scrollHeight" ] || changes[ "topItem" ] ) {
        this._updateTopItem( false );
      }
      if( changes[ "updateRows" ] ) {
        if( this._renderQueue[ "allItems" ] ) {
          this._rowContainer.renderAll();
        } else {
          this._rowContainer.renderItemQueue( this._renderQueue );
        }
        this._renderQueue = {};
      }
    },

    ////////////
    // scrolling

    _enableAltScrolling : function() {
      if( !this._altScrollingEnabled ) {
        this._altScrollingEnabled = true;
        this._vertScrollBar.setThumb( 1 );
      }
    },

    _updateScrollHeight : function() {
      var max = this.getRootItem().getVisibleChildrenCount();
      if( this._altScrollingEnabled ) {
        max = max - this._getLastPageRowCount() + 1;
        this._setVerticalScrollBarVisible( max > 1 );
      }
      if( !this._vertScrollBar.getDisposed() && ( this._vertScrollBar.getMaximum() !== max ) ) {
        this._vertScrollBar.setMaximum( max );
      }
    },

    _getLastPageRowCount : function() {
      var availableHeight = this._getClientAreaHeight();
      var item = this.getRootItem().getLastChild();
      var result = 0;
      while( item && availableHeight > 0 ) {
        availableHeight -= item.getOwnHeight();
        if( availableHeight > 0 ) {
          result++;
          item = item.getPreviousItem();
        }
      }
      return result;
    },

    _updateScrollThumbHeight : function() {
      if( !this._altScrollingEnabled ) {
        var value = Math.max( 1, Math.floor( this._getClientAreaHeight() / this._itemHeight ) );
        this._vertScrollBar.setThumb( value );
      }
    },

    _setVerticalScrollBarVisible : function( value ) {
      var oldValue = this._vertScrollBar.getVisibility();
      if( value !== oldValue ) {
        this._vertScrollBar.setVisibility( value );
        this._layoutX();
      }
    },

    /**
     * NOTE: If render is true, the content will be updated immediately. The rendering
     * assumes that no other parameter than topItem have changed and may optimize accordingly.
     */
    _updateTopItem : function( render ) {
      this._rowContainer.setTopItem( this._getTopItem(), this._topItemIndex, render );
    },

    _updateScrollWidth : function() {
      var width = this._getItemWidth();
      this._rowContainer.setRowWidth( this._getRowWidth() );
      if( !this._horzScrollBar.getDisposed() ) {
        this._horzScrollBar.setMaximum( width );
      }
      if( this._header ) {
        this._header.setScrollWidth( width + this._getVerticalBarWidth() );
      }
      if( this._footer ) {
        this._footer.setScrollWidth( width + this._getVerticalBarWidth() );
      }
    },

    _scrollIntoView : function( index, item ) {
      if( index < this._topItemIndex ) {
        this._setTopItemIndex( index );
      } else if( index > this._topItemIndex ) {
        var topItem = this._getTopItem();
        var topItemOffset = topItem.getOffset();
        var itemOffset = item.getOffset();
        var pageSize = this._getClientAreaHeight() - item.getOwnHeight();
        if( itemOffset > topItemOffset + pageSize ) {
          var newTopOffset = itemOffset - pageSize - 1;
          var newTopItem = this.getRootItem().findItemByOffset( newTopOffset );
          var newTopIndex = newTopItem.getFlatIndex() + 1;
          this._setTopItemIndex( newTopIndex );
        }
      }
      if( this._allowRender() ) {
        rwt.widgets.base.Widget.flushGlobalQueues();
      }
    },

    _setTopItemIndex : function( index ) {
      this._updateScrollHeight();
      this._vertScrollBar.setValue( index );
    },

    //////////////
    // Fire events

    _fireSelectionChanged : function( item, type, index, text ) {
      var data = {
        "item" : item,
        "type" : type,
        "index" : typeof index === "number" ? index : undefined,
        "text" : text != null ? text : undefined
      };
      this.dispatchSimpleEvent( "selectionChanged", data );
    },

    _isDoubleClicked : function( event, item ) {
      var result = false;
      var mousedown = event.getType() === "mousedown";
      var leftClick = event.getButton() === "left";
      if( leftClick && mousedown && this.isFocusItem( item ) && this._selectionTimestamp != null ) {
        var stamp = new Date();
        var offset = event.getPageX();
        var timeDiff = rwt.remote.EventUtil.DOUBLE_CLICK_TIME;
        var offsetDiff = 8;
        if (    stamp.getTime() - this._selectionTimestamp.getTime() < timeDiff
             && Math.abs( this._selectionOffsetX - offset ) < offsetDiff )
        {
          result = true;
        }
      }
      if( mousedown && leftClick && !result ) {
        this._selectionTimestamp = new Date();
        this._selectionOffsetX = event.getPageX();
      } else if( mousedown ) {
        this._selectionTimestamp = null;
      }
      return result;
    },

    ////////////////////
    // focus & selection

    _singleSelectItem : function( event, item ) {
      if( event.isCtrlPressed() && this.isItemSelected( item ) ) {
        // NOTE: Apparently in SWT this is only supported by Table, not Tree.
        //       No reason not to support it in RAP though.
        this._ctrlSelectItem( item );
      } else {
        this._exclusiveSelectItem( item );
      }
    },

    _multiSelectItem : function( event, item ) {
      if( event instanceof rwt.event.MouseEvent && event.isRightButtonPressed() ) {
        if( !this.isItemSelected( item ) ) {
          this._exclusiveSelectItem( item );
        }
      } else if( event.isCtrlPressed() ) {
        if( event instanceof rwt.event.KeyEvent && item != this._focusItem  ) {
          this.setFocusItem( item );
        } else {
          this._ctrlSelectItem( item );
        }
      } else if( event.isShiftPressed() ) {
        if( this._focusItem != null ) {
          this._shiftSelectItem( item );
        } else {
          this._exclusiveSelectItem( item );
        }
      } else {
        this._exclusiveSelectItem( item );
      }
    },

    _exclusiveSelectItem : function( item ) {
      this.deselectAll();
      this._leadItem = null;
      this._selectItem( item, true );
      this._fireSelectionChanged( item, "selection" );
      this.setFocusItem( item );
    },

    _ctrlSelectItem : function( item ) {
      if( !this.isItemSelected( item ) ) {
        this._selectItem( item, true );
      } else {
        this._deselectItem( item, true );
      }
      this._fireSelectionChanged( item, "selection" );
      this.setFocusItem( item );
    },

    _shiftSelectItem : function( item ) {
      this.deselectAll();
      var currentItem = this._leadItem != null ? this._leadItem : this._focusItem;
      this._leadItem = currentItem;
      var targetItem = item;
      var startIndex = currentItem.getFlatIndex();
      var endIndex = targetItem.getFlatIndex();
      if( startIndex > endIndex ) {
        var temp = currentItem;
        currentItem = targetItem;
        targetItem = temp;
      }
      this._selectItem( currentItem, true );
      while( currentItem !== targetItem ) {
        currentItem = currentItem.getNextItem();
        this._selectItem( currentItem, true );
      }
      this._fireSelectionChanged( item, "selection" );
      this.setFocusItem( item );
    },

    _selectItem : function( item, render ) {
      if( !this.isItemSelected( item ) ) {
        this._selection.push( item );
      }
      if( render ) {
        this._rowContainer.renderItem( item );
      }
    },

    _deselectItem : function( item, render ) {
      if( this.isItemSelected( item ) ) {
        this._selection.splice( this._selection.indexOf( item ), 1 );
      }
      if( render ) {
        this._rowContainer.renderItem( item );
      }
    },

    deselectAll : function() {
      this._checkDisposedItems();
      var oldSelection = this._selection;
      this._selection = [];
      for( var i = 0; i < oldSelection.length; i++ ) {
        this._rowContainer.renderItem( oldSelection[ i ] );
      }
    },

    _toggleCheckSelection : function( item, cell ) {
      if( item.isCached() ) {
        if( isNaN( cell ) ) {
          item.setChecked( !item.isChecked() );
          this._fireSelectionChanged( item, "check" );
        } else if( item.isCellCheckable( cell ) ) {
          item.toggleCellChecked( cell );
          this._fireSelectionChanged( item, "cellCheck", cell );
        }
      }
    },

    _deselectVisibleChildren : function( item ) {
      var currentItem = item.getNextItem();
      var finalItem = item.getNextItem( true );
      while( currentItem !== finalItem ) {
        this._deselectItem( currentItem, false );
        currentItem = currentItem.getNextItem();
      }
    },

    _applyFocused : function( newValue, oldValue ) {
      this.base( arguments, newValue, oldValue );
      this._config.focused = newValue;
      this._scheduleUpdate();
    },

    _applyEnabled : function( newValue, oldValue ) {
      this.base( arguments, newValue, oldValue );
      this._config.enabled = newValue;
      this._scheduleUpdate();
    },

    _checkDisposedItems : function() {
      // NOTE : FocusItem might already been fixed by the server. But since this is not
      //        always the case (depending on the server-side widget), we also do it here.
      if( this._focusItem && this._focusItem.isDisposed() ) {
        this._focusItem = null;
      }
      if( this._leadItem && this._leadItem.isDisposed() ) {
        this._leadItem = null;
      }
      var i = 0;
      while( i < this._selection.length ) {
        if( this._selection[ i ].isDisposed() ) {
          this._deselectItem( this._selection[ i ], false );
        } else {
          i++;
        }
      }
    },

    ////////////////////////////
    // internal layout & theming

    _applyTextColor : function( newValue, oldValue ) {
      this.base( arguments, newValue, oldValue );
      this._config.textColor = newValue;
      this._scheduleUpdate();
    },

    _applyFont : function( newValue, oldValue ) {
      this.base( arguments, newValue, oldValue );
      this._config.font = newValue;
      this._scheduleUpdate();
    },

    _applyBackgroundColor : function( newValue ) {
      this._rowContainer.setBackgroundColor( newValue );
    },

    _applyBackgroundImage : function( newValue ) {
      this._rowContainer.setBackgroundImage( newValue );
    },

    _applyWidth : function( newValue, oldValue ) {
      this.base( arguments, newValue, oldValue );
      this._layoutX();
    },

    _applyHeight : function( newValue, oldValue ) {
      this.base( arguments, newValue, oldValue );
      this._layoutY();
    },

    _applyBorder : function( newValue, oldValue ) {
      this.base( arguments, newValue, oldValue );
      this._layoutX();
      this._layoutY();
    },

    _layoutX : function() {
      var width = Math.max( 0, this.getWidth() - this.getFrameWidth() );
      if( this._header ) {
        this._header.setWidth( width );
      }
      if( this._footer ) {
        this._footer.setWidth( width );
      }
      if( this._vertScrollBar.getVisibility() ) {
        this._vertScrollBar.setLeft( width - this._vertScrollBar.getWidth() );
      }
      this._horzScrollBar.setWidth( width - this._getVerticalBarWidth() );
      this._rowContainer.setWidth( width );
      this._updateScrollWidth();
      this._scheduleUpdate();
    },

    _layoutY : function() {
      var headerHeight = this._header ? this._headerHeight : 0;
      var footerHeight = this._footer ? this._footerHeight : 0;
      var top = headerHeight;
      var height = this.getHeight() - this.getFrameHeight() - headerHeight - footerHeight;
      height = Math.max( 0, height );
      if( this._header ) {
        this._header.setHeight( this._headerHeight );
      }
      if( this._footer ) {
        this._footer.setHeight( this._footerHeight );
        this._footer.setTop( top + height );
      }
      if( this._horzScrollBar.getVisibility() ) {
        this._horzScrollBar.setTop( top + height + footerHeight - this._getHorizontalBarHeight() );
      }
      this._vertScrollBar.setHeight( height + footerHeight - this._getHorizontalBarHeight() );
      this._vertScrollBar.setTop( top );
      this._rowContainer.setTop( top );
      this._rowContainer.setHeight( height );
      this._updateScrollThumbHeight();
      this._scheduleUpdate( "scrollHeight" );
    },

    _getItemWidth : function() {
      var result = 0;
      if( this._config.rowTemplate ) {
        result = this._rowContainer.getWidth();
      } else if( this._config.itemLeft.length > 0 ) {
        var columnCount = Math.max( 1, this._config.columnCount );
        for( var i = 0; i < columnCount; i++ ) {
          result = Math.max( result, this._config.itemLeft[ i ] + this._config.itemWidth[ i ] );
        }
      }
      return result;
    },

    _getRowWidth : function() {
      var width = this._rowContainer.getWidth();
      return Math.max( this._getItemWidth() + this._getVerticalBarWidth(), width );
    },

    /////////
    // helper

    _allowRender : function() {
      return !this._disableRender && !rwt.remote.EventUtil.getSuspended() && this.isSeeable();
    },

    _isDragSource : function() {
      return this.hasEventListeners( "dragstart" );
    },

    _getTopItem : function() {
      if( this._topItem === null ) {
        this._topItem = this._rootItem.findItemByFlatIndex( this._topItemIndex );
      }
      return this._topItem;
    },

    _getHorizontalBarHeight : function() {
      return this._horzScrollBar.getVisibility() ? this._horzScrollBar.getHeight() : 0;
    },

    _getVerticalBarWidth : function() {
      return this._vertScrollBar.getVisibility() ? this._vertScrollBar.getWidth() : 0;
    },

    _getClientAreaHeight : function() {
      var height = this._rowContainer.getHeight();
      return this._footer ? height : height - this._getHorizontalBarHeight();
    },

    ////////////////////////
    // Cell tooltip handling

    setEnableCellToolTip : function( value ) { // protocol name
      this.setCellToolTipsEnabled( value );
    },

    setCellToolTipsEnabled : function( value ) {
      this._rowContainer.setCellToolTipsEnabled( value );
      rwt.widgets.util.GridCellToolTipSupport.setEnabled( this, value );
    },

    getCellToolTipsEnabled : function() {
      return this._rowContainer.getCellToolTipsEnabled();
    },

    setCellToolTipText : function( value ) {
      var text = value;
      if( this.getUserData( "toolTipMarkupEnabled" ) !== true ) {
        var EncodingUtil = rwt.util.Encoding;
        text = EncodingUtil.escapeText( text, false );
        text = EncodingUtil.replaceNewLines( text, "<br/>" );
      }
      rwt.widgets.util.GridCellToolTipSupport.showToolTip( text );
    }

  }

} );

/*******************************************************************************
 * Copyright (c) 2011, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.remote.HandlerRegistry.add( "rwt.widgets.ScrollBar", {

  factory : function( properties ) {
    // NOTE : In this case the parent HAS to be already created by the protocol
    var styleMap = rwt.remote.HandlerUtil.createStyleMap( properties.style );
    var parent = rwt.remote.ObjectRegistry.getObject( properties.parent );
    var result;
    if( styleMap.HORIZONTAL ) {
      result = parent.getHorizontalBar();
    } else {
      result = parent.getVerticalBar();
    }
    rwt.remote.HandlerUtil.addDestroyableChild( parent, result );
    result.setUserData( "protocolParent", parent );
    return result;
  },

  destructor : function( widget ) {
    var parent = widget.getUserData( "protocolParent" );
    if( parent ) {
      rwt.remote.HandlerUtil.removeDestroyableChild( parent, widget );
    }
  },

  properties : [
    "visibility"
  ],

  propertyHandler : {
    "visibility" : function( widget, value ) {
      var parent = widget.getParent();
      // NOTE : use parent.getXXXBarVisible because "visibility" or "display" my be used
      // TODO [tb] : alwas use display
      if( widget.isHorizontal() ) {
        parent.setScrollBarsVisible( value, parent.isVerticalBarVisible() );
      } else {
        parent.setScrollBarsVisible( parent.isHorizontalBarVisible(), value );
      }
    }
  },

  listeners : rwt.remote.HandlerUtil.extendControlListeners( [
    "Selection"
  ] ),

  listenerHandler : {},

  methods : []

} );

/*******************************************************************************
 * Copyright (c) 2011, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

/*jshint nonew:false */
rwt.remote.HandlerRegistry.add( "rwt.widgets.Grid", {

  factory : function( properties ) {
    var styleMap = rwt.remote.HandlerUtil.createStyleMap( properties.style );
    var rowTemplate =   properties.rowTemplate
                      ? new rwt.widgets.util.Template( properties.rowTemplate )
                      : null;
    var forceFullSelection = ( properties.appearance === "table" ) && !rowTemplate;
    var configMap = {
      appearance : properties.appearance,
      noScroll : styleMap.NO_SCROLL,
      multiSelection : styleMap.MULTI,
      check : styleMap.CHECK,
      // TODO: Remove this check when bug 355408: [Table] Always uses FULL_SELECTION is fixed
      fullSelection :  forceFullSelection ? true : styleMap.FULL_SELECTION,
      hideSelection : styleMap.HIDE_SELECTION,
      checkBoxMetrics : properties.checkBoxMetrics,
      selectionPadding : properties.selectionPadding,
      indentionWidth : properties.indentionWidth,
      splitContainer : properties.splitContainer,
      markupEnabled : properties.markupEnabled,
      rowTemplate : rowTemplate
    };
    var result = new rwt.widgets.Grid( configMap );
    rwt.remote.HandlerUtil.addStatesForStyles( result, properties.style );
    result.setUserData( "isControl", true );
    rwt.remote.HandlerUtil.setParent( result, properties.parent );
    new rwt.widgets.util.GridSynchronizer( result );
    return result;
  },

  destructor : function( widget ) {
    var destroyItems = widget.getRootItem().getUncachedChildren();
    for( var i = 0; i < destroyItems.length; i++ ) {
      destroyItems[ i ].dispose();
    }
    rwt.remote.HandlerUtil.getControlDestructor()( widget );
  },

  getDestroyableChildren : function( widget ) {
    var result = widget.getRootItem().getCachedChildren();
    return result.concat( rwt.remote.HandlerUtil.getDestroyableChildrenFinder()( widget ) );
  },

  properties : rwt.remote.HandlerUtil.extendControlProperties( [
    "itemCount",
    "itemHeight",
    "itemMetrics",
    // NOTE : Client currently requires itemMetrics before columnCount
    "columnCount",
    "treeColumn",
    "fixedColumns",
    "headerHeight",
    "headerVisible",
    "footerHeight",
    "footerVisible",
    "linesVisible",
    "topItemIndex",
    "scrollLeft",
    "selection",
    "focusItem",
    "sortDirection",
    "sortColumn",
    "alwaysHideSelection",
    "enableCellToolTip",
    "cellToolTipText",
    "columnOrder",
    "autoHeight"
  ] ),

  propertyHandler : rwt.remote.HandlerUtil.extendControlPropertyHandler( {
    "itemMetrics" : function( widget, value ) {
      for( var i = 0; i < value.length; i++ ) {
        widget.setItemMetrics.apply( widget, value[ i ] );
      }
    },
    "fixedColumns" : function( widget, value ) {
      rwt.widgets.util.GridUtil.setFixedColumns( widget, value );
    },
    "focusItem" : function( widget, value ) {
      rwt.remote.HandlerUtil.callWithTarget( value, function( item ) {
        widget.setFocusItem( item );
      } );
    },
    "selection" : function( widget, value ) {
      widget.deselectAll();
      var applySelection = function( item ) {
        widget.selectItem( item );
      };
      for( var i = 0; i < value.length; i++ ) {
        rwt.remote.HandlerUtil.callWithTarget( value[ i ], applySelection );
      }
    },
    "columnOrder" : function( widget, value ) {
      rwt.remote.HandlerUtil.callWithTargets( value, function( order ) {
        widget.setColumnOrder( order );
      } );
    },
    "sortColumn" : function( widget, value ) {
      rwt.remote.HandlerUtil.callWithTarget( value, function( column ) {
        widget.setSortColumn( column );
      } );
    },
    "scrollBarsVisible" : function( widget, value ) {
      widget.setScrollBarsVisible( value[ 0 ], value[ 1 ] );
    }
  } ),

  events : [ "Selection", "DefaultSelection", "Expand", "Collapse", "SetData" ],

  listeners : rwt.remote.HandlerUtil.extendControlListeners( [] ),

  listenerHandler : rwt.remote.HandlerUtil.extendControlListenerHandler( {} )

} );

/*******************************************************************************
 * Copyright (c) 2010, 2014 Innoopract Informationssysteme GmbH and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Innoopract Informationssysteme GmbH - initial API and implementation
 *    EclipseSource - ongoing development
 ******************************************************************************/

rwt.qx.Class.define( "rwt.widgets.GridItem", {

  extend : rwt.qx.Target,
  include : rwt.widgets.util.HtmlAttributesMixin,

  construct : function( parent, index, placeholder ) {
    // Dispose is only needed to remove items from the tree and widget manager.
    // Since it holds no references to the dom, it suffices to dispose tree.
    this._autoDispose = false;
    this.base( arguments );
    this._parent = parent;
    this._level = -1;
    this._height = null;
    this._children = [];
    this._indexCache = {};
    this._visibleChildrenCount = 0;
    this._expandedItems = {};
    this._customHeightItems = {};
    this._texts = placeholder ? [ "..." ] : [];
    this._images = [];
    this._cached = !placeholder;
    this._font = null;
    this._cellFonts = [];
    this._foreground = null;
    this._cellForegrounds = [];
    this._background = null;
    this._cellBackgrounds = [];
    this._checked = false;
    this._grayed = false;
    this._cellChecked = [];
    this._cellGrayed = [];
    this._cellCheckable = [];
    this._variant = null;
    if( this._parent != null ) {
      this._level = this._parent.getLevel() + 1;
      this._parent._add( this, index );
    }
    this._expanded = this.isRootItem();
    this.addEventListener( "update", this._onUpdate, this );
    if( this.isRootItem() ) {
      this._rootItem = this;
      this._height = 16;
    } else {
      this._rootItem = parent.getRootItem();
    }
  },

  destruct : function() {
    if( this._parent != null && !this._parent.isDisposed() ) {
      this._parent._remove( this );
    }
    this._parent = null;
    this._height = null;
    this._children = null;
    this._indexCache = null;
    this._expandedItems = null;
    this._customHeightItems = null;
    this._texts = null;
    this._images = null;
    this._font = null;
    this._cellFonts = null;
    this._foreground = null;
    this._cellForegrounds = null;
    this._background = null;
    this._cellBackgrounds = null;
    this._cellChecked = null;
    this._cellGrayed = null;
    this._cellCheckable = null;
    this._rootItem = null;
  },

  statics : {

    createItem : function( parent, index ) {
      var parentItem = this._getItem( parent );
      var result;
      if( parentItem.isChildCreated( index ) && !parentItem.isChildCached( index ) ) {
        result = parentItem.getChild( index );
        result.markCached();
      } else {
        result = new rwt.widgets.GridItem( parentItem, index, false );
      }
      return result;
    },

    _getItem : function( treeOrItem ) {
      var result;
      if( treeOrItem instanceof rwt.widgets.Grid ) {
        result = treeOrItem.getRootItem();
      } else {
        result = treeOrItem;
      }
      return result;
    }

  },

  members : {

    setItemCount : function( value ) {
      var msg = this._children.length > value ? "remove" : "add";
      this._children.length = value;
      this._update( msg );
    },

    setIndex : function( value ) {
      var siblings = this._parent._children;
      if( siblings.indexOf( this ) !== value ) {
        var target = siblings[ value ];
        siblings[ value ] = this;
        if( target && !target.isCached() ) {
          target.dispose();
        }
      }
    },

    clear : function() {
      // TODO [tb] : children?
      this._cached = false;
      this._checked = false;
      this._grayed = false;
      this._texts = [ "..." ];
      this._images = [];
      this._background = null;
      this._foreground = null;
      this._font = null;
      this._cellBackgrounds = [];
      this._cellForegrounds = [];
      this._cellFonts = [];
      this._variant = null;
    },

    isCached : function() {
      return this._cached;
    },

    markCached : function() {
      this._cached = true;
      this._texts = [];
    },

    setTexts : function( texts ) {
      this._texts = texts;
      this._update( "content" );
    },

    getText : function( column ) {
      return this._texts[ column ] || "";
    },

    hasText : function( column ) {
      return !!this._texts[ column ];
    },

    setFont : function( font ) {
      this._font = font;
      this._update( "content" );
    },

    getCellFont : function( column ) {
      var result = this._cellFonts[ column ];
      return typeof result === "string" && result !== "" ? result : this._font;
    },

    setCellFonts : function( fonts ) {
      this._cellFonts = fonts;
      this._update( "content" );
    },

    setForeground : function( color ) {
      this._foreground = color;
      this._update( "content" );
    },

    getCellForeground : function( column ) {
      var result = this._cellForegrounds[ column ];
      return typeof result === "string" ? result : this._foreground;
    },

    setCellForegrounds : function( colors ) {
      this._cellForegrounds = colors;
      this._update( "content" );
    },

    setBackground : function( color ) {
      this._background = color;
      this._update( "content" );
    },

    getCellBackground : function( column ) {
      var result = this._cellBackgrounds[ column ];
      return typeof result === "string" ? result : null;
    },

    getBackground : function() {
      return this._background;
    },

    setCellBackgrounds : function( colors ) {
      this._cellBackgrounds = colors;
      this._update( "content" );
    },

    setImages : function( images ) {
      this._images = images;
      this._update( "content" );
    },

    getImage : function( column ) {
      var result = this._images[ column ];
      return result || null;
    },

    setChecked : function( value ) {
      this._checked = value;
      this._update( "check" );
    },

    isChecked : function() {
      return this._checked;
    },

    setGrayed : function( value ) {
      this._grayed = value;
      this._update( "check" );
    },

    isGrayed : function() {
      return this._grayed;
    },

    setCellChecked : function( value ) {
      this._cellChecked = value;
      this._update( "check" );
    },

    toggleCellChecked : function( cell ) {
      this._cellChecked[ cell ] = !this._cellChecked[ cell ];
      this._update( "check" );
    },

    getCellChecked : function() {
      return this._cellChecked;
    },

    isCellChecked : function( column ) {
      return this._cellChecked[ column ];
    },

    setCellGrayed : function( value ) {
      this._cellGrayed = value;
      this._update( "check" );
    },

    isCellGrayed : function( column ) {
      return this._cellGrayed[ column ];
    },

    setCellCheckable : function( value ) {
      this._cellCheckable = value;
      this._update( "check" );
    },

    isCellCheckable : function( column ) {
      return this._cellCheckable[ column ] === undefined ? true : this._cellCheckable[ column ];
    },

    setVariant : function( variant ) {
      this._variant = variant;
    },

    getVariant : function() {
      return this._variant;
    },

    setDefaultHeight : function( value ) {
      if( !this.isRootItem() ) {
        throw new Error( "Can only set default item height on root item" );
      }
      this._height = value;
    },

    setHeight : function( value, rendering ) {
      if( this.isRootItem() ) {
        throw new Error( "Can not set item height on root item" );
      }
      if( this._height === value ) {
        return;
      }
      this._height = value;
      if( value !== null ) {
        this._parent._addToCustomHeightItems( this );
      } else {
        this._removeFromCustomHeightItems( this );
      }
      this._update( "height", null, rendering );
    },

    getHeight : function() {
      return this._height;
    },

    getDefaultHeight : function() {
      var result;
      if( this.isRootItem() ) {
        result = this._height;
      } else {
        result = this.getRootItem().getDefaultHeight();
      }
      return result;
    },

    //////////////////////////
    // relationship management

    isRootItem : function() {
      return this._level < 0;
    },

    getRootItem : function() {
      return this._rootItem;
    },

    getLevel : function() {
      return this._level;
    },

    getParent : function() {
      return this._parent;
    },

    setExpanded : function( value ) {
      if( this._expanded != value ) {
        this._expanded = value;
        this._update( value ? "expanded" : "collapsed" );
        if( value ) {
          this._parent._addToExpandedItems( this );
        } else {
          this._parent._removeFromExpandedItems( this );
        }
      }
    },

    isExpanded : function() {
      return this._expanded;
    },

    isDisplayable : function() {
      var result = false;
      if( this.isRootItem() || this._parent.isRootItem() ) {
        result = true;
      } else {
        result = this._parent.isExpanded() && this._parent.isDisplayable();
      }
      return result;
    },

    hasChildren : function() {
      return this._children.length > 0;
    },

    getChildrenLength : function() {
      return this._children.length;
    },

    isChildCreated : function( index ) {
      return this._children[ index ] !== undefined;
    },

    isChildCached : function( index ) {
      return this._children[ index ].isCached();
    },

    getCachedChildren : function() {
      var result = [];
      for( var i = 0; i < this._children.length; i++ ) {
        if( this.isChildCreated( i ) && this.isChildCached( i ) ) {
          result.push( this._children[ i ] );
        }
      }
      return result;
    },

    getUncachedChildren : function() {
      var result = [];
      for( var i = 0; i < this._children.length; i++ ) {
        if( this.isChildCreated( i ) && !this.isChildCached( i ) ) {
          result.push( this._children[ i ] );
        }
      }
      return result;
    },

    getOffsetHeight : function() {
      var result = this.getOwnHeight();
      if( this.isExpanded() && this.hasChildren() ) {
        var lastChild = this.getLastChild();
        result += this._getChildOffset( lastChild );
        result += lastChild.getOffsetHeight();
      }
      return result;
    },

    hasCustomHeight : function() {
      return this._height !== null;
    },

    getOwnHeight : function() {
      var result = 0;
      if( !this.isRootItem() ) {
        result = this._height !== null ? this._height : this.getDefaultHeight();
      }
      return result;
    },

    getVisibleChildrenCount : function() { // TODO [tb] : rather "itemCount"
      if( this._visibleChildrenCount == null ) {
        this._computeVisibleChildrenCount();
      }
      return this._visibleChildrenCount;
    },

    getChild : function( index ) {
      var result;
      // Note: Check for index range first to avoid weird behavior in IE8 - bug 429741
      if( index >= 0 && index < this._children.length ) {
        result = this._children[ index ];
        if( !result ) {
          result = new rwt.widgets.GridItem( this, index, true );
        }
      }
      return result;
    },

    getLastChild : function() {
      return this.getChild( this._children.length - 1 );
    },

    indexOf : function( item ) {
      var hash = item.toHashCode();
      if( this._indexCache[ hash ] === undefined ) {
        this._indexCache[ hash ] = this._children.indexOf( item );
      }
      return this._indexCache[ hash ];
    },

    /**
     * Returns true if the given item is one of the parents of this item (recursive).
     */
    isChildOf : function( parent ) {
      var result = this._parent === parent;
      if( !result && !this._parent.isRootItem() ) {
        result = this._parent.isChildOf( parent );
      }
      return result;
    },

    /**
     * Returns the item that at the given vertical offset in pixel. The offset starts below
     * this item. The returned items occupies an area that includes the position defined by the
     * given offset. Its exact offset may by different. Negative offset is now allowed.
     */
    findItemByOffset : function( targetOffset ) {
      // TODO [tb] : cache results
      var itemHeight = this.getDefaultHeight();
      var waypoints = this._getDifferingHeightIndicies();
      if( waypoints[ 0 ] === 0 ) {
        waypoints.shift();
      }
      var currentOffset = 0;
      var currentIndex = 0;
      var result = null;
      var finished = false;
      if( targetOffset < 0 || this.getChildrenLength() === 0 ) {
        finished = true;
      }
      while( !finished ) {
        var currentItem = this.getChild( currentIndex );
        var currentItemHeight = currentItem.getOffsetHeight();
        var nextIndex = waypoints.shift();
        var nextOffset =   currentOffset
                         + currentItemHeight
                         + ( nextIndex - currentIndex - 1 ) * itemHeight;
        if( targetOffset < currentOffset + currentItemHeight ) {
          // case: target in current item
          if( targetOffset < currentOffset + currentItem.getOwnHeight() ) {
            result = currentItem;
          } else {
            var localOffset = targetOffset - currentOffset - currentItem.getOwnHeight();
            result = currentItem.findItemByOffset( localOffset );
          }
          finished = true;
        } else if( nextIndex === undefined || nextOffset > targetOffset ) {
          // case: target after current item, before next waypoint (or no more waypoint)
          var offsetDiff = targetOffset - currentOffset - currentItemHeight;
          var targetIndex = currentIndex + 1 + Math.floor( offsetDiff / itemHeight );
          result = this.getChild( targetIndex );
          finished = true;
        } else {
         // case: target in or after next waypoint
          currentIndex = nextIndex;
          currentOffset = nextOffset;
        }
      }
      return result;
    },

    /**
     * Finds the item at the given index, counting all visible children.
     */
    findItemByFlatIndex : function( index ) {
      var expanded = this._getExpandedIndicies();
      var localIndex = index;
      var result = null;
      var success = false;
      while( !success && localIndex >= 0) {
        var expandedIndex = expanded.shift();
        if( expandedIndex === undefined || expandedIndex >= localIndex ) {
          result = this.getChild( localIndex );
          if( result ) {
            this._indexCache[ result.toHashCode() ] = localIndex;
          }
          success = true;
        } else {
          var childrenCount = this.getChild( expandedIndex ).getVisibleChildrenCount();
          var offset = localIndex - expandedIndex; // Items between current item and target item
          if( offset <= childrenCount ) {
            result = this.getChild( expandedIndex ).findItemByFlatIndex( offset - 1 );
            success = true;
            if( result == null ) {
              throw new Error( "getItemByFlatIndex failed" );
            }
          } else {
            localIndex -= childrenCount;
          }
        }
      }
      return result;
    },

    /**
     * Returns the offset of this items top to the top of the entire visible item tree in pixel.
     * Root item is excluded, as it is not displayed.
     */
    getOffset : function() {
      var result = 0;
      if( !this._parent.isRootItem() ) {
        result += this._parent.getOffset() + this._parent.getOwnHeight();
      }
      result += this._parent._getChildOffset( this );
      return result;
    },

    /**
     * Returns the offset of a child in pixel relative to this item (its parent),
     * excluding the height of child and parent themselves (just the distance between)
     */
    _getChildOffset : function( item ) {
      var localIndex = this.indexOf( item );
      var result = localIndex * this.getDefaultHeight();
      var indicies = this._getDifferingHeightIndicies();
      while( indicies.length > 0 && localIndex > indicies[ 0 ] ) {
        var index = indicies.shift();
        result -= this.getDefaultHeight();
        result += this._children[ index ].getOffsetHeight();
      }
      return result;
    },

    /**
     * Gets the index relative to the root-item, counting all visible items inbetween.
     */
    getFlatIndex : function() {
      var localIndex = this._parent.indexOf( this );
      var result = localIndex;
      var expanded = this._parent._getExpandedIndicies();
      while( expanded.length > 0 && localIndex > expanded[ 0 ] ) {
        var expandedIndex = expanded.shift();
        result += this._parent._children[ expandedIndex ].getVisibleChildrenCount();
      }
      if( !this._parent.isRootItem() ) {
        result += this._parent.getFlatIndex() + 1;
      }
      return result;
    },

    hasPreviousSibling : function() {
      var index = this._parent.indexOf( this ) - 1 ;
      return index >= 0;
    },

    hasNextSibling : function() {
      var index = this._parent.indexOf( this ) + 1 ;
      return index < this._parent.getChildrenLength();
    },

    getPreviousSibling : function() {
      var index = this._parent.indexOf( this ) - 1 ;
      return this._parent.getChild( index );
    },

    getNextSibling : function() {
      var index = this._parent.indexOf( this ) + 1 ;
      var item = this._parent.getChild( index );
      this._parent._indexCache[ item.toHashCode() ] = index;
      return item;
    },

    /**
     * Returns the next visible item, which my be the first child,
     * the next sibling or the next sibling of the parent.
     */
    getNextItem : function( skipChildren ) {
      var result = null;
      if( !skipChildren && this.hasChildren() && this.isExpanded() ) {
        result = this.getChild( 0 );
      } else if( this.hasNextSibling() ) {
        result = this.getNextSibling();
      } else if( this.getLevel() > 0 ) {
        result = this._parent.getNextItem( true );
      }
      return result;
    },

    /**
     * Returns the previous visible item, which my be the previous sibling,
     * the previous siblings last child, or the parent.
     */
    getPreviousItem : function() {
      var result = null;
      if( this.hasPreviousSibling() ) {
        result = this.getPreviousSibling();
        while( result.hasChildren() && result.isExpanded() ) {
          result = result.getLastChild();
        }
      } else if( this.getLevel() > 0 ) {
        result = this._parent;
      }
      return result;
    },

    /////////////////////////
    // API for other TreeItem

    _add : function( item, index ) {
      if( this._children[ index ] ) {
        this._children.splice( index, 0, item );
        this._children.pop();
        this._update( "add", item );
      } else {
        this._children[ index ] = item;
      }
    },

    _remove : function( item ) {
      if( item.isExpanded() ) {
        delete this._expandedItems[ item.toHashCode() ];
      }
      if( item.hasCustomHeight() ) {
        delete this._customHeightItems[ item.toHashCode() ];
      }
      var index = this._children.indexOf( item );
      if( index !== -1 ) {
        this._children.splice( index, 1 );
        this._children.push( undefined );
      }
      this._update( "remove", item );
    },

    _addToExpandedItems : function( item ) {
      this._expandedItems[ item.toHashCode() ] = item;
    },

    _removeFromExpandedItems : function( item ) {
      delete this._expandedItems[ item.toHashCode() ];
    },

    _addToCustomHeightItems : function( item ) {
      this._customHeightItems[ item.toHashCode() ] = item;
    },

    _removeFromCustomHeightItems : function( item ) {
      delete this._customHeightItems[ item.toHashCode() ];
    },

    //////////////////////////////
    // support for event-bubbling:

    getEnabled : function() {
      return true;
    },

    _update : function( msg, related, rendering ) {
      var event = {
        "msg" : msg,
        "related" : related,
        "rendering" : rendering,
        "target" : this
      };
      this.dispatchSimpleEvent( "update", event, true );
      delete event.target;
      delete event.related;
      delete event.msg;
    },

    _onUpdate : function( event ) {
      if( event.msg !== "content" && event.msg !== "check" ) {
        this._visibleChildrenCount = null;
        this._indexCache = {};
      }
    },

    /////////
    // Helper

    _computeVisibleChildrenCount : function() {
      // NOTE: Caching this value speeds up creating and scrolling the tree considerably
      var result = 0;
      if( this.isExpanded() || this.isRootItem() ) {
       result = this._children.length;
        for( var i = 0; i < this._children.length; i++ ) {
          if( this.isChildCreated( i ) ) {
            result += this.getChild( i ).getVisibleChildrenCount();
          }
        }
      }
      this._visibleChildrenCount = result;
    },

    _getDifferingHeightIndicies : function() {
      var result = [];
      for( var key in this._expandedItems ) {
        result.push( this.indexOf( this._expandedItems[ key ] ) );
      }
      for( var key in this._customHeightItems ) {
        if( !this._expandedItems[ key ] ) { // prevent duplicates
          result.push( this.indexOf( this._customHeightItems[ key ] ) );
        }
      }
      // TODO [tb] : result could be cached
      return result.sort( function( a, b ){ return a - b; } );
    },

    _getExpandedIndicies : function() {
      var result = [];
      for( var key in this._expandedItems ) {
        result.push( this.indexOf( this._expandedItems[ key ] ) );
      }
      // TODO [tb] : result could be cached
      return result.sort( function( a, b ){ return a - b; } );
    },

    toString : function() {
      return "TreeItem " + this._texts.join();
    }

  }

} );

/*******************************************************************************
 * Copyright (c) 2011, 2015 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.remote.HandlerRegistry.add( "rwt.widgets.GridItem", {

  factory : function( properties ) {
    var result;
    rwt.remote.HandlerUtil.callWithTarget( properties.parent, function( parent ) {
      result = rwt.widgets.GridItem.createItem( parent, properties.index );
    } );
    return result;
  },

  destructor : function( item ) {
    var destroyItems = item.getUncachedChildren();
    for( var i = 0; i < destroyItems.length; i++ ) {
      destroyItems[ i ].dispose();
    }
    item.dispose();
  },

  getDestroyableChildren : function( widget ) {
    return widget.getCachedChildren();
  },

  properties : [
    "itemCount",
    "texts",
    "images",
    "background",
    "foreground",
    "font",
    "cellBackgrounds",
    "cellForegrounds",
    "cellFonts",
    "expanded",
    "checked",
    "grayed",
    "cellChecked",
    "cellGrayed",
    "cellCheckable",
    "customVariant",
    "height",
    "index",
    "data"
  ],

  propertyHandler : {
    "data" : rwt.remote.HandlerUtil.getControlPropertyHandler( "data" ),
    "background" : function( widget, value ) {
      if( value === null ) {
        widget.setBackground( null );
      } else {
        widget.setBackground( rwt.util.Colors.rgbToRgbString( value ) );
      }
    },
    "foreground" : function( widget, value ) {
      if( value === null ) {
        widget.setForeground( null );
      } else {
        widget.setForeground( rwt.util.Colors.rgbToRgbString( value ) );
      }
    },
    "font" : function( widget, value ) {
      if( value === null ) {
        widget.setFont( null );
      } else {
        var font = rwt.html.Font.fromArray( value ).toCss();
        widget.setFont( font );
      }
    },
    "cellBackgrounds" : function( widget, value ) {
      var backgrounds = [];
      for( var i = 0; i < value.length; i++ ) {
        if( value[ i ] === null ) {
          backgrounds[ i ] = null;
        } else {
          backgrounds[ i ] = rwt.util.Colors.rgbToRgbString( value[ i ] );
        }
      }
      widget.setCellBackgrounds( backgrounds );
    },
    "cellForegrounds" : function( widget, value ) {
      var foregrounds = [];
      for( var i = 0; i < value.length; i++ ) {
        if( value[ i ] === null ) {
          foregrounds[ i ] = null;
        } else {
          foregrounds[ i ] = rwt.util.Colors.rgbToRgbString( value[ i ] );
        }
      }
      widget.setCellForegrounds( foregrounds );
    },
    "cellFonts" : function( widget, value ) {
      var fonts = [];
      for( var i = 0; i < value.length; i++ ) {
        if( value[ i ] === null ) {
          fonts[ i ] = "";
        } else {
          var font = rwt.html.Font.fromArray( value[ i ] );
          fonts[ i ] = font.toCss();
        }
      }
      widget.setCellFonts( fonts );
    },
    "customVariant" : function( widget, value ) {
      widget.setVariant( value );
    }
  },

  methods : [ "clear" ]

} );

/*******************************************************************************
 * Copyright (c) 2009, 2014 Innoopract Informationssysteme GmbH.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Innoopract Informationssysteme GmbH - initial API and implementation
 *    EclipseSource - ongoing development
 ******************************************************************************/

rwt.qx.Class.define( "rwt.widgets.util.GridDNDFeedback", {
  extend : rwt.qx.Object,

  construct : function( tree ) {
    this.base( arguments );
    this._tree = tree;
    this._feedback = null;
    this._currentRow = null;
    this._insertIndicator = null;
    this._expandTimer = null;
    this._scrollTimer = null;
  },

  destruct : function() {
    this._renderFeedback( this._currentRow, false );
    if( this._expandTimer != null ) {
      this._expandTimer.dispose();
      this._expandTimer = null;
    }
    if( this._scrollTimer != null ) {
      this._scrollTimer.dispose();
      this._scrollTimer = null;
    }
    this._tree = null;
    this._feedback = null;
    this._insertIndicator = null;
    this._currentRow = null;
  },

  members : {

    /////////
    // Public

    setFeedback : function( feedbackMap ) {
      this._renderFeedback( this._currentRow, false );
      this._feedback = feedbackMap;
      this._renderFeedback( this._currentRow, true );
    },

    renderFeedback : function( target ) {
      this._renderFeedback( this._currentRow, false );
      this._renderFeedback( target, true );
      this._currentRow = target;
    },

    isFeedbackNode : function( node ) {
      var result = false;
      if( this._insertIndicator != null && this._insertIndicator == node ) {
        result = true;
      }
      return result;
    },

    ////////////
    // Internals

    _renderFeedback : function( row, value ) {
      if( this._feedback != null && row != null ) {
        if( this._feedback[ "FEEDBACK_SELECT" ] ) {
          this._renderFeedbackSelect( row, value );
        } else if( this._feedback[ "FEEDBACK_INSERT_BEFORE" ] ) {
          this._renderFeedbackBefore( row, value );
        } else if( this._feedback[ "FEEDBACK_INSERT_AFTER" ] ) {
          this._renderFeedbackAfter( row, value );
        }
        if( this._feedback[ "FEEDBACK_EXPAND" ] ) {
          this._renderFeedbackExpand( row, value );
        }
        if( this._feedback[ "FEEDBACK_SCROLL" ] ) {
          this._renderFeedbackScroll( row, value );
        }
      }
    },

    _renderFeedbackSelect : function( row, value ) {
      row.setState( "dnd_selected", value );
      var item = this._tree._rowContainer.findItemByRow( row );
      this._tree._rowContainer.renderItem( item );
    },

    _renderFeedbackBefore : function( row, value ) {
      if( value ) {
        // draw insert-indicator above row (1px heigher)
        var location = this._getRowLocation( row );
        location.y--;
        this._showInsertIndicator( location.x, location.y );
      } else {
        this._hideInsertIndicator();
      }
    },

    _renderFeedbackAfter : function( row, value ) {
      if( value ) {
        // draw insert-indicator below row (1px heigher)
        var location = this._getRowLocation( row );
        var height = row.getHeight();
        location.y = location.y + ( height - 1 );
        this._showInsertIndicator( location.x, location.y );
      } else {
        this._hideInsertIndicator();
      }
    },

    _renderFeedbackExpand : function( row, value ) {
      var item = this._tree._rowContainer.findItemByRow( row );
      if( item != null && item.hasChildren() ) {
        if( value && !item.isExpanded() ) {
          this._startExpandTimer();
        } else {
          this._stopExpandTimer();
        }
      }
    },

    _renderFeedbackScroll : function( row, value ) {
      if( value ) {
        this._startScrollTimer();
      } else {
        this._stopScrollTimer();
      }
    },

    _getRowLocation : function( row ) {
      var location = { x : 0, y : 0 };
      var node = row.$el.get( 0 );
      var treeNode = this._tree._getTargetNode();
      while( node != treeNode ) {
        location.x += node.offsetLeft;
        location.y += node.offsetTop;
        node = node.parentNode;
      }
      return location;
    },

    /////////
    // Helper

    _showInsertIndicator : function( x, y ) {
      if( this._insertIndicator == null ) {
        var div = document.createElement( "div" );
        div.style.position = "absolute";
        div.style.borderTopStyle = "solid";
        div.style.borderTopColor = "black";
        div.style.borderTopWidth = "2px";
        div.style.zIndex = 100000;
        div.style.height = "2px";
        this._insertIndicator = div;
      }
      var width = this._tree.getWidthValue() - ( x + 6 );
      this._insertIndicator.style.left = x + "px";
      this._insertIndicator.style.top = y + "px";
      this._insertIndicator.style.width = width + "px";
      var treeNode = this._tree._getTargetNode();
      treeNode.appendChild( this._insertIndicator );
    },

    _hideInsertIndicator : function() {
      var treeNode = this._tree._getTargetNode();
      treeNode.removeChild( this._insertIndicator );
    },

    _startExpandTimer : function() {
      if( this._expandTimer == null ) {
        this._expandTimer = new rwt.client.Timer( 750 );
        this._expandTimer.addEventListener( "interval",
                                            this._onExpandTimer,
                                            this );
      }
      this._expandTimer.setEnabled( true );
    },

    _stopExpandTimer : function() {
      if( this._expandTimer != null ) {
        this._expandTimer.stop();
      }
    },

    _onExpandTimer : function() {
      this._stopExpandTimer();
      var item = this._tree._rowContainer.findItemByRow( this._currentRow );
      item.setExpanded( true );
    },

    _startScrollTimer : function() {
      if( this._scrollTimer == null ) {
        this._scrollTimer = new rwt.client.Timer( 250 );
        this._scrollTimer.addEventListener( "interval", this._onScrollTimer, this );
      }
      this._scrollTimer.setEnabled( true );
    },

    _stopScrollTimer : function() {
      if( this._scrollTimer != null ) {
        this._scrollTimer.stop();
      }
    },

    _getScrollDirection : function( row ) {
      var result = 0;
      var rowIndex = this._tree._rowContainer.getRowIndex( row );
      if( rowIndex === 0 ) {
        result = -1;
      } else if( rowIndex >= this._tree._rowContainer.getRowCount() - 2 ) {
        result = 1;
      }
      return result;
    },

    _onScrollTimer : function() {
      this._stopScrollTimer();
      var offset = this._getScrollDirection( this._currentRow );
      if( offset !== 0 ) {
        var item = this._tree._rowContainer.findItemByRow( this._currentRow );
        if( item != null ) {
          var newItem = offset > 0 ? item.getNextItem() : item.getPreviousItem();
          if( newItem != null ) {
            var newTopIndex = this._tree._topItemIndex + offset;
            this._tree._setTopItemIndex( newTopIndex );
            var newRow = this._tree._rowContainer.findRowByItem( newItem );
            var oldRow = this._currentRow;
            var wrapper = function() {
              this._targetUpdateCheck( oldRow, newRow );
            };
            rwt.client.Timer.once( wrapper, this, 1 );
          }
        }
      }
    },

    _targetUpdateCheck : function( oldRow, newRow ) {
      if( !this.isDisposed() ) {
        // TODO [tb] : this is not a good way to check for scrolling, as the tree can theoretically
        //             scroll without changing the row order.
        if( newRow != this._currentRow && oldRow == this._currentRow ) {
          var dndSupport = rwt.remote.DNDSupport.getInstance();
          dndSupport.setCurrentTargetElement( newRow.$el.get( 0 ) );
        }
      }
    }

  }

} );


/*******************************************************************************
 * Copyright (c) 2009, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/


namespace( "rwt.widgets.util" );

rwt.widgets.util.GridCellToolTipSupport = {

  _cell : [ null, null, null ],
  _requestedCell : null,

  setEnabled : function( grid, value ) {
    if( value ) {
      grid.addEventListener( "renderCellToolTip", this._onRender, grid );
    } else {
      grid.removeEventListener( "renderCellToolTip", this._onRender, grid );
    }
  },

  showToolTip : function( text ) {
    if( this._isValidToolTip( text ) ) {
      var grid = this._cell[ 0 ];
      var item = rwt.remote.ObjectRegistry.getObject( this._cell[ 1 ] );
      var row = grid.getRowContainer().findRowByItem( item, this._cell[ 2 ] );
      if( row ) {
        grid.getRowContainer().setToolTipText( text );
        rwt.widgets.base.WidgetToolTip.getInstance().updateText();
        grid.getRowContainer().setToolTipText( "" );
      }
    }
  },

  getCurrentToolTipTargetBounds : function( row ) {
    var grid = this._cell[ 0 ];
    var container = grid.getRowContainer();
    var splitOffset = container.getSplitOffset ? container.getSplitOffset( this._cell[ 2 ] ) : 0;
    return {
      left : grid.getRenderConfig().itemLeft[ this._cell[ 2 ] ] - splitOffset,
      top : row.getTop(),
      height : row.getHeight(),
      width : grid.getRenderConfig().itemWidth[ this._cell[ 2 ] ]
    };
  },

  _onRender : function( row ) {
    var itemId = null;
    var columnIndex = -1;
    var item = this._rowContainer.findItemByRow( row );
    if( item ) {
      itemId = rwt.remote.ObjectRegistry.getId( this._rowContainer.getHoverItem() );
      var GridUtil = rwt.widgets.util.GridUtil;
      columnIndex = GridUtil.getColumnByPageX( this, rwt.event.MouseEvent.getPageX() );
    }
    rwt.widgets.util.GridCellToolTipSupport._setCell( this, itemId, columnIndex );
  },

  _setCell : function( grid, itemId, columnIndex ) {
    var cell = [ grid, itemId, columnIndex ];
    if( this._isValidCell( cell ) ) {
      this._cell = cell;
      var connection = rwt.remote.Connection.getInstance();
      connection.getRemoteObject( this._cell[ 0 ] ).call( "renderToolTipText", {
        "item" : this._cell[ 1 ],
        "column" : this._cell[ 2 ]
      } );
      this._requestedCell = this._cell;
    }
  },

  _isValidCell : function( cell ) {
    return    cell
           && cell[ 0 ] != null
           && cell[ 1 ] != null
           && cell[ 2 ] != -1;
  },

  _isValidToolTip : function( text ) {
    return    text
           && this._requestedCell
           && this._cell[ 0 ] === this._requestedCell[ 0 ]
           && this._cell[ 1 ] === this._requestedCell[ 1 ]
           && this._cell[ 2 ] === this._requestedCell[ 2 ];
  }

};

/*******************************************************************************
 * Copyright (c) 2011, 2014 Innoopract Informationssysteme GmbH and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Innoopract Informationssysteme GmbH - initial API and implementation
 *    EclipseSource - ongoing development
 ******************************************************************************/

rwt.qx.Class.define( "rwt.widgets.base.GridHeader", {

  extend : rwt.widgets.base.Parent,

  construct : function( argsMap ) {
    this.base( arguments );
    this.setOverflow( "hidden" );
    this.setZIndex( 2000 );
    this._fixedColumns = argsMap.splitContainer;
    this._scrollWidth = 0;
    this._scrollLeft = 0;
    this._footer = argsMap.footer ? true : false;
    this._baseAppearance = argsMap.appearance;
    this._dummyColumn = this._createDummyColumn();
    this._currentDragColumn = null;
    this._feedbackLabel = null;
    this._labelToColumnMap = {};
    this._columnToLabelMap = {};
    // TODO [tb] : Find a cleaner solution to block drag-events
    var dragBlocker = function( event ) { event.stopPropagation(); };
    this.addEventListener( "dragstart", dragBlocker );
  },

  destruct : function() {
    this._dummyColumn = null;
  },

  events: {
    "columnLayoutChanged" : "rwt.event.Event"
  },

  members : {

    setScrollLeft : function( value ) {
      this._scrollLeft = value;
      if( this._fixedColumns && !rwt.widgets.base.Widget._inFlushGlobalQueues ) {
        for( var i = 0; i < this._children.length; i++ ) {
          var column = this._getColumnByLabel( this._children[ i ] );
          if( column && column.isFixed() ) {
            this._renderLabelLeft( this._children[ i ], column );
          }
        }
        if( !rwt.remote.EventUtil.getSuspended() ) {
          rwt.widgets.base.Widget.flushGlobalQueues();
        }
      }
      // NOTE [tb] : order is important to prevent flickering in IE
      if( this.isSeeable() ) {
        this.base( arguments, value );
      }
    },

    setScrollWidth : function( value ) {
      this._scrollWidth = value;
      if( this.getVisibility() ) {
        this._renderDummyColumn();
      }
    },

    _onColumnDispose : function( event ) {
      var column = event.target;
      var label = this._getLabelByColumn( column );
      delete this._labelToColumnMap[ label.toHashCode() ];
      delete this._columnToLabelMap[ column.toHashCode() ];
      label.destroy();
    },

    renderColumns : function( columns ) {
      for( var key in columns ) {
        var column = columns[ key ];
        var label = this._getLabelByColumn( column );
        if( label ) {
          this._renderLabel( label, column );
        }
      }
      this._renderDummyColumn();
    },

    _renderLabel : function( label, column ) {
      this._renderLabelLeft( label, column );
      label.setVisibility( column.getVisibility() && column.getWidth() > 0 );
      if( this._footer ) {
        this._renderFooterLabel( label, column );
      } else {
        this._renderHeaderLabel( label, column );
      }
      label.setCustomVariant( column.getCustomVariant() );
      label.setHorizontalChildrenAlign( column.getAlignment() );
      label.setWordWrap( column.getHeaderWordWrap() );
    },

    _renderFooterLabel : function( label, column ) {
      label.setWidth( column.getFooterWidth() );
      label.setText( column.getFooterText() );
      label.setImage( column.getFooterImage() );
      if( column.getFooterFont() !== null ) {
        label.setFont( column.getFooterFont() );
      } else {
        label.resetFont();
      }
      var onTop = column.isFixed() || column.getFooterSpan() > 1;
      label.setZIndex( onTop ? 1e7 : 1 );
    },

    _renderHeaderLabel : function( label, column ) {
      label.setWidth( column.getWidth() );
      label.setHoverEffect( column.getMoveable() );
      label.clearHtmlAttributes();
      label.setHtmlAttributes( column.getHtmlAttributes() );
      if( column.getFont() !== null ) {
        label.setFont( column.getFont() );
      } else {
        label.resetFont();
      }
      label.setText( column.getText() );
      label.setImage( column.getImage() );
      label.setToolTipText( column.getToolTipText() );
      label.setSortIndicator( column.getSortDirection() );
      if( column.isGroup() ) {
        label.setChevron( column.isExpanded() ? "expanded" : "collapsed" );
      }
      this._renderLabelY( label, column );
      label.setZIndex( column.isFixed() ? 1e7 : 1 );
    },

    _renderLabelY : function( label, column ) {
      if( column.isGroup() ) {
        label.setTop( 0 );
        label.setHeight( column.getHeight() );
      } else if( column.getGroup() != null ) {
        var groupHeight = column.getGroup().getHeight();
        label.setTop( groupHeight );
        label.setHeight( this.getHeight() - groupHeight );
      } else {
        label.setTop( 0 );
        label.setHeight( "100%" );
      }
    },

    _renderLabelLeft : function( label, column ) {
      var offset = column.isFixed() ? this._scrollLeft : 0;
      label.setLeft( column.getLeft() + offset );
    },

    _onDummyRendered : function() {
      this.setScrollLeft( this._scrollLeft );
    },

    _fireUpdateEvent : function() {
      this.createDispatchEvent( "columnLayoutChanged" );
    },

    _renderDummyColumn : function() {
      var dummyLeft = this._getDummyColumnLeft();
      var totalWidth = Math.max( this._scrollWidth, this.getWidth() );
      var dummyWidth = Math.max( 0, totalWidth - dummyLeft );
      this._dummyColumn.setLeft( dummyLeft );
      this._dummyColumn.setWidth( dummyWidth );
    },

    _getDummyColumnLeft : function() {
      var columns = this._labelToColumnMap;
      var result = 0;
      for( var key in columns ) {
        if( columns[ key ].getVisibility() ) {
          var left = columns[ key ].getLeft() + columns[ key ].getWidth();
          result = Math.max( result, left );
        }
      }
      return result;
    },

    _onLabelSelected : function( event ) {
      var column = this._getColumnByLabel( event.target );
      column.handleSelectionEvent( event );
    },

    _onLabelMoveStart : function( event ) {
      var column = this._getColumnByLabel( event.target );
      return !this._footer && column.getMoveable();
    },

    _onLabelMoveEnd : function( event ) {
      var column = this._getColumnByLabel( event.target );
      column.setLeft( event.position );
    },

    _onShowDragFeedback : function( event ) {
      var column = this._getColumnByLabel( event.target );
      var widget = this._getDragFeedback( column );
      widget.setLeft( event.position );
    },

    _onHideDragFeedback : function( event ) {
      var label = event.target;
      var column = this._getColumnByLabel( label );
      var widget = this._getDragFeedback( column );
      var left = label.getLeft();
      if( event.snap ) {
        rwt.animation.AnimationUtil.snapTo( widget, 250, left, label.getTop(), true );
      } else {
        widget.setDisplay( false );
      }
      this._currentDragColumn = null;
    },

    _onLabelResizeStart : function( event ) {
      var column = this._getColumnByLabel( event.target );
      return !this._footer && column.getResizeable();
    },

    _onLabelResizeEnd : function( event ) {
      var column = this._getColumnByLabel( event.target );
      column.setWidth( event.width );
    },

    _getColumnByLabel : function( label ) {
      return this._labelToColumnMap[ label.toHashCode() ];
    },

    _getLabelByColumn : function( column ) {
      var result = this._columnToLabelMap[ column.toHashCode() ];
      if( !result ) {
        if( column.getVisibility() ) {
          result = this._createLabel( column );
        } else {
          result = null;
        }
      }
      return result;
    },

    _getDragFeedback : function( column ) {
      if( this._feedbackLabel === null ) {
        this._feedbackLabel = this._createFeedbackColumn();
      }
      if( this._currentDragColumn !== column ) {
        this._renderLabelY( this._feedbackLabel, column );
        this._feedbackLabel.setWidth( column.getWidth() );
        this._feedbackLabel.setCustomVariant( column.getCustomVariant() );
        this._feedbackLabel.setText( column.getText() );
        this._feedbackLabel.setImage( column.getImage() );
        this._feedbackLabel.setSortIndicator( column.getSortDirection() );
        this._feedbackLabel.setHorizontalChildrenAlign( column.getAlignment() );
        this._feedbackLabel.setDisplay( true );
        this._feedbackLabel.dispatchSimpleEvent( "cancelAnimations" );
        this._currentDragColumn = column;
      }
      return this._feedbackLabel;
    },

    _createLabel : function( column ) {
      var label = new rwt.widgets.base.GridColumnLabel( this._baseAppearance );
      if( this._footer ) {
        label.addState( "footer" );
      } else if( column.getResizeable() ) {
        label.setResizeCursor( "col-resize" );
      }
      if( column.isGroup() ) {
        label.addState( "group" );
      }
      label.setTop( 0 );
      label.setHeight( "100%" );
      this.add( label );
      this._labelToColumnMap[ label.toHashCode() ] = column;
      this._columnToLabelMap[ column.toHashCode() ] = label;
      label.addEventListener( "selected", this._onLabelSelected, this );
      label.addEventListener( "moveStart", this._onLabelMoveStart, this );
      label.addEventListener( "showDragFeedback", this._onShowDragFeedback, this );
      label.addEventListener( "hideDragFeedback", this._onHideDragFeedback, this );
      label.addEventListener( "moveEnd", this._onLabelMoveEnd, this );
      label.addEventListener( "resizeStart", this._onLabelResizeStart, this );
      label.addEventListener( "resizeEnd", this._onLabelResizeEnd, this );
      column.addEventListener( "dispose", this._onColumnDispose, this );
      return label;
    },

    _createDummyColumn : function() {
      var dummyColumn = new rwt.widgets.base.GridColumnLabel( this._baseAppearance );
      if( this._footer ) {
        dummyColumn.addState( "footer" );
      }
      dummyColumn.setTop( 0 );
      dummyColumn.setHeight( "100%" );
      dummyColumn.addState( "dummy" );
      dummyColumn.addEventListener( "flush", this._onDummyRendered, this );
      dummyColumn.addEventListener( "appear", this._onDummyRendered, this );
      dummyColumn.setEnabled( false );
      this.add( dummyColumn );
      return dummyColumn;
    },

    _createFeedbackColumn : function() {
      var feedback = new rwt.widgets.base.GridColumnLabel( this._baseAppearance );
      feedback.addState( "moving" );
      feedback.setTop( 0 );
      feedback.setHeight( "100%" );
      feedback.setEnabled( false );
      feedback.setZIndex( 1e8 );
      feedback.addState( "mouseover" ); // to make the label more visible, not ideal
      this.add( feedback );
      return feedback;
    }

  }

} );

/*******************************************************************************
 * Copyright (c) 2007, 2014 Innoopract Informationssysteme GmbH and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Innoopract Informationssysteme GmbH - initial API and implementation
 *    EclipseSource - ongoing development
 ******************************************************************************/

rwt.qx.Class.define( "rwt.widgets.GridColumn", {

  extend : rwt.qx.Target,
  include : rwt.widgets.util.HtmlAttributesMixin,

  construct : function( grid, isGroup ) {
    this.base( arguments );
    this._grid = grid;
    this._isGroup = isGroup ? true : false;
    this._index = 0;
    this._resizable = isGroup ? false : true;
    this._moveable = false;
    this._alignment = "left";
    this._wordWrap = false;
    this._headerWordWrap = false;
    this._group = null;
    this._left = 0;
    this._height = 0;
    this._visibility = true;
    this._expanded = true;
    this._width = 0;
    this._toolTip = null;
    this._customVariant = null;
    this._text = "";
    this._font = null;
    this._image = null;
    this._footerText = "";
    this._footerFont = null;
    this._footerImage = null;
    this._footerSpan = 1;
    this._sortDirection = null;
    this._check = false;
    this._grid.addColumn( this );
  },

  destruct : function() {
    this._grid.removeColumn( this );
    this.dispatchSimpleEvent( "dispose", { target : this } );
  },

  members : {

    setLeft : function( value ) {
      if( rwt.remote.EventUtil.getSuspended() ) {
        this._left = value;
        this._update();
      } else {
        this._sendMove( value );
      }
    },

    getLeft : function() {
      return this._left;
    },

    setWidth : function( value ) {
      if( rwt.remote.EventUtil.getSuspended() ) {
        this._width = value;
        this._update();
      } else {
        this._sendResize( value );
      }
    },

    getWidth : function() {
      return this._width;
    },

    setHeight : function( value ) {
      this._height = value;
      this._update();
    },

    getHeight : function() {
      return this._height;
    },

    setVisibility : function( value ) {
      this._visibility = value;
      this._update();
    },

    getVisibility : function() {
      return this._visibility;
    },

    setExpanded : function( value ) {
      this._expanded = value;
      this._update();
    },

    isExpanded : function() {
      return this._expanded;
    },

    setGroup : function( value ) {
      this._group = value;
    },

    getGroup : function() {
      return this._group;
    },

    setToolTipText : function( value ) {
      this._toolTip = value;
      this._update();
    },

    getToolTipText : function() {
      return this._toolTip;
    },

    setCustomVariant : function( value ) {
      this._customVariant = value;
      this._update();
    },

    getCustomVariant : function() {
      return this._customVariant;
    },

    setText : function( value ) {
      this._text = value;
      this._update();
    },

    getText : function() {
      return this._text;
    },

    setImage : function( value ) {
      this._image = value;
      this._update();
    },

    getImage : function( ) {
      return this._image;
    },

    setFont : function( value ) {
      this._font = value ? rwt.html.Font.fromArray( value ) : null;
      this._update();
    },

    getFont : function() {
      return this._font;
    },

    setFooterText : function( value ) {
      this._footerText = value;
      this._update();
    },

    getFooterText : function() {
      return this._footerText;
    },

    setFooterImage : function( value ) {
      this._footerImage = value;
      this._update();
    },

    getFooterImage : function( ) {
      return this._footerImage;
    },

    setFooterFont : function( value ) {
      this._footerFont = value ? rwt.html.Font.fromArray( value ) : null;
      this._update();
    },

    getFooterFont : function() {
      return this._footerFont;
    },

    setFooterSpan : function( span ) {
      this._footerSpan = span;
      this._update();
    },

    getFooterSpan : function() {
      return this._footerSpan;
    },

    getFooterWidth : function() {
      var result = this._width;
      if( this._footerSpan > 1 ) {
        var columnOrder = this._grid.getColumnOrder();
        var start = columnOrder.indexOf( this );
        for( var i = start + 1; i < start + this._footerSpan; i++ ) {
          if( columnOrder[ i ] ) {
            result += columnOrder[ i ].getWidth();
          }
        }
      }
      return result;
    },

    setIndex : function( value ) {
      this._grid.setAlignment( value, this._alignment );
      this._grid.setWordWrap( value, this._wordWrap );
      this._index = value;
      this._update();
    },

    getIndex : function() {
      return this._index;
    },

    setSortDirection : function( value ) {
      this._sortDirection = value;
      this._update();
    },

    getSortDirection : function() {
      return this._sortDirection;
    },

    setResizable : function( value ) {
      this._resizable = value;
    },

    getResizeable : function() {
      return this._resizable;
    },

    setMoveable : function( value ) {
      this._moveable = value;
    },

    getMoveable : function() {
      return this._moveable;
    },

    setCheck : function( value ) {
      this._grid.setCellCheck( this._index, value );
      this._check = value;
    },

    getCheck : function() {
      return this._check;
    },

    handleSelectionEvent : function( event ) {
      if( !rwt.remote.EventUtil.getSuspended() ) {
        if( this._isGroup && event.chevron ) {
          var remoteObject = rwt.remote.Connection.getInstance().getRemoteObject( this );
          remoteObject.set( "expanded", !this._expanded );
          remoteObject.notify( this._expanded ? "Collapse" : "Expand" );
        } else {
          rwt.remote.EventUtil.notifySelected( this );
        }
      }
    },

    setAlignment : function( value ) {
      this._grid.setAlignment( this._index, value );
      this._alignment = value;
      this._update();
    },

    getAlignment : function() {
      return this._alignment;
    },

    setWordWrap : function( value ) {
      this._grid.setWordWrap( this._index, value );
      this._wordWrap = value;
      this._update();
    },

    getWordWrap : function() {
      return this._wordWrap;
    },

    setHeaderWordWrap : function( value ) {
      this._headerWordWrap = value;
      this._update();
    },

    getHeaderWordWrap : function() {
      return this._headerWordWrap;
    },

    setFixed : function( value ) {
      this._fixed = value;
      this._update();
    },

    isFixed : function() {
      return this._fixed;
    },

    isGroup : function() {
      return this._isGroup;
    },

    _update : function() {
      this.dispatchSimpleEvent( "update" );
    },

    _sendResize : function( width ) {
      if( !rwt.remote.EventUtil.getSuspended() ) {
        var serverColumn = rwt.remote.Connection.getInstance().getRemoteObject( this );
        serverColumn.call( "resize", {
          "width" : width
        } );
      }
    },

    _sendMove : function( left ) {
      if( !rwt.remote.EventUtil.getSuspended() ) {
        var serverColumn = rwt.remote.Connection.getInstance().getRemoteObject( this );
        serverColumn.call( "move", {
          "left" : left
        } );
      }
    }

  }
} );

/*******************************************************************************
 * Copyright (c) 2007, 2015 Innoopract Informationssysteme GmbH and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Innoopract Informationssysteme GmbH - initial API and implementation
 *    EclipseSource - ongoing development
 ******************************************************************************/

rwt.qx.Class.define( "rwt.widgets.base.GridColumnLabel", {

  extend : rwt.widgets.base.MultiCellWidget,

  construct : function( baseAppearance ) {
    this.base( arguments, [ "image", "label", "image" ] );
    this._resizeStartX = 0;
    this._inResize = false;
    this._wasResizeOrMoveEvent = false;
    this._feedbackVisible = false;
    this._inMove = false;
    this._hoverEffect = false;
    this._offsetX = 0;
    this._initialLeft = 0;
    this._chevron = null;
    this.setAppearance( baseAppearance + "-column" );
    this._resizeCursor = null;
    this.setHorizontalChildrenAlign( "left" );
    this.setOverflow( "hidden" );
    this.setFlexibleCell( 1 );
    this.expandFlexCell( true );
    this.addEventListener( "elementOver", this._onElementOver, this );
    this.addEventListener( "elementOut", this._onElementOut, this );
    this.addEventListener( "mouseover", this._onMouseOver, this );
    this.addEventListener( "mousemove", this._onMouseMove, this );
    this.addEventListener( "mouseout", this._onMouseOut, this );
    this.addEventListener( "mousedown", this._onMouseDown, this );
    this.addEventListener( "mouseup", this._onMouseUp, this );
    this.addEventListener( "click", this._onClick, this );
  },

  members : {

    setLeft : function( value ) { // TODO : overwriting generated setter can cause stack overflows
      this.base( arguments, value );
      this._hideDragFeedback( true );
    },

    setText : function( value ) {
      var EncodingUtil = rwt.util.Encoding;
      var text = EncodingUtil.escapeText( value, false );
      text = EncodingUtil.replaceNewLines( text, "<br/>" );
      this.setCellContent( 1, text );
    },

    setImage : function( value ) {
      if( value === null ) {
        this.setCellContent( 0, null );
        this.setCellDimension( 0, 0, 0 );
      } else {
        this.setCellContent( 0, value[ 0 ] );
        this.setCellDimension( 0, value[ 1 ], value[ 2 ] );
      }
    },

    setHoverEffect : function( value ) {
      this._hoverEffect = value;
    },

    setResizeCursor : function( value ) {
      this._resizeCursor = value;
    },

    setSortIndicator : function( value ) {
      if( value ) {
        var manager = rwt.theme.AppearanceManager.getInstance();
        var states = {};
        states[ value ] = true;
        var styleMap = manager.styleFrom( this.getAppearance() + "-sort-indicator", states );
        var image = styleMap.backgroundImage;
        this.setCellContent( 2, image[ 0 ] );
        this.setCellDimension( 2, image[ 1 ], image[ 2 ] );
      } else {
        this.setCellContent( 2, null );
        this.setCellDimension( 2, 0, 0 );
      }
    },

    setChevron : function( value ) {
      this._chevron = value;
      this._updateChevronImage( false );
    },

    _onElementOver : function( event ) {
      if( this._chevron && event.getDomTarget() === this.getCellNode( 2 ) ) {
        this._updateChevronImage( true );
      }
    },

    _onElementOut : function( event ) {
      if( this._chevron && event.getDomTarget() === this.getCellNode( 2 ) ) {
        this._updateChevronImage( false );
      }
    },

    _updateChevronImage : function( hover ) {
      if( this._chevron ) {
        var manager = rwt.theme.AppearanceManager.getInstance();
        var states = {};
        states[ this._chevron ] = true;
        if( hover ) {
          states[ "mouseover" ] = true;
        }
        var styleMap = manager.styleFrom( this.getAppearance() + "-chevron", states );
        var image = styleMap.backgroundImage;
        this.setCellContent( 2, image[ 0 ] );
        this.setCellDimension( 2, image[ 1 ], image[ 2 ] );
      } else {
        this.setCellContent( 2, null );
        this.setCellDimension( 2, 0, 0 );
      }
    },

    _onMouseOver : function() {
      if( this._hoverEffect && !this._inMove && !this._inResize ) {
        this.addState( "mouseover" );
      }
    },

    _onMouseDown : function( evt ) {
      if( !this._inMove && !this._inResize && evt.getButton() === "left" ) {
        if( this._isResizeLocation( evt.getPageX() ) && this._allowResize() ) {
          this._inResize = true;
          var position = this.getLeft() + this.getWidth();
          this.dispatchSimpleEvent( "showResizeLine", { "position" : position }, true );
          this._resizeStartX = evt.getPageX();
          this.setCapture( true );
          evt.stopPropagation();
          evt.preventDefault();
          rwt.widgets.util.WidgetUtil._fakeMouseEvent( this, "mouseout" );
        } else if( this._allowMove() ) {
          this._inMove = true;
          this.setCapture( true );
          this._offsetX = evt.getPageX() - this.getLeft();
          this._initialLeft = evt.getPageX();
          evt.stopPropagation();
          evt.preventDefault();
          rwt.widgets.util.WidgetUtil._fakeMouseEvent( this, "mouseout" );
        }
      }
    },

    _onMouseMove : function( evt ) {
      if( this._inResize ) {
        var position = this.getLeft() + this._getResizeWidth( evt.getPageX() );
        // min column width is 5 px
        if( position < this.getLeft() + 5 ) {
          position = this.getLeft() + 5;
        }
        this.dispatchSimpleEvent( "showResizeLine", { "position" : position }, true );
      } else if( this._inMove ) {
        this.addState( "mouseover" );
        var left = evt.getPageX() - this._offsetX;
        this.dispatchSimpleEvent( "showDragFeedback", { "target" : this, "position" : left } );
        this._feedbackVisible = true;
      } else {
        if( this._isResizeLocation( evt.getPageX() ) ) {
          this.getTopLevelWidget().setGlobalCursor( this._resizeCursor );
        } else {
          this.getTopLevelWidget().setGlobalCursor( null );
        }
      }
      evt.stopPropagation();
      evt.preventDefault();
    },

    _onMouseUp : function( evt ) {
      var widgetUtil = rwt.widgets.util.WidgetUtil;
      if( this._inResize ) {
        this.dispatchSimpleEvent( "hideResizeLine", null, true ); // bubbles: handled by grid
        this.getTopLevelWidget().setGlobalCursor( null );
        this.setCapture( false );
        var newWidth = this._getResizeWidth( evt.getPageX() );
        this.dispatchSimpleEvent( "resizeEnd", {
          "target" : this,
          "width" : newWidth
        } );
        this._inResize = false;
        this._wasResizeOrMoveEvent = true;
        evt.stopPropagation();
        evt.preventDefault();
        widgetUtil._fakeMouseEvent( evt.getTarget(), "mouseover" );
      } else if( this._inMove ) {
        this._inMove = false;
        this.setCapture( false );
        this.removeState( "mouseover" );
        if( Math.abs( evt.getPageX() - this._initialLeft ) > 1 ) {
          this._wasResizeOrMoveEvent = true;
          // Fix for bugzilla 306842
          this.dispatchSimpleEvent( "moveEnd", {
            "target" : this,
            "position" : evt.getPageX() - this._offsetX
          } );
        } else {
          this._hideDragFeedback( false );
        }
        evt.stopPropagation();
        evt.preventDefault();
        widgetUtil._fakeMouseEvent( evt.getTarget(), "mouseover" );
      }
    },

    _onClick : function( evt ) {
       // Don't send selection event when the onClick was caused by resizing
      if( !this._wasResizeOrMoveEvent ) {
        var data = { "target" : this };
        if( this._chevron ) {
          data.chevron = evt.getDomTarget() === this.getCellNode( 2 );
          if( data.chevron ) {
            this.setChevron( "loading" );
          }
        }
        this.dispatchSimpleEvent( "selected", data );
      }
      this._wasResizeOrMoveEvent = false;
    },

    _onMouseOut : function( evt ) {
      if( !this._inMove ) {
        this.removeState( "mouseover" );
      }
      if( !this._inResize ) {
        this.getTopLevelWidget().setGlobalCursor( null );
        evt.stopPropagation();
        evt.preventDefault();
      }
    },

    _allowResize : function() {
      return this.dispatchSimpleEvent( "resizeStart", { "target" : this } );
    },

    _allowMove : function() {
      return this.dispatchSimpleEvent( "moveStart", { "target" : this } );
    },

    _hideDragFeedback : function( snap ) {
      if( this._feedbackVisible ) {
        this.dispatchSimpleEvent( "hideDragFeedback", {
          "target" : this,
          "snap" : snap
        } );
        this._feedbackVisible = false;
      }
    },

    /** Returns whether the given pageX is within the right 5 pixels of this
     * column */
    _isResizeLocation : function( pageX ) {
      var result = false;
      var columnRight = rwt.html.Location.getLeft( this.getElement() ) + this.getWidth();
      if( pageX >= columnRight - 5 && pageX <= columnRight ) {
        result = true;
      }
      return result;
    },

    /** Returns the width of the column that is currently being resized */
    _getResizeWidth : function( pageX ) {
      var delta = this._resizeStartX - pageX;
      return this.getWidth() - delta;
    }

  }
} );

/*******************************************************************************
 * Copyright (c) 2011, 2015 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.remote.HandlerRegistry.add( "rwt.widgets.GridColumn", {

  factory : function( properties ) {
    var result;
    rwt.remote.HandlerUtil.callWithTarget( properties.parent, function( parent ) {
      result = new rwt.widgets.GridColumn( parent );
      rwt.remote.HandlerUtil.addDestroyableChild( parent, result );
    } );
    return result;
  },

  destructor : function( column ) {
    rwt.remote.HandlerUtil.removeDestroyableChild( column._grid, column );
    column.dispose();
  },

  properties : [
    // Always set column index first
    "index",
    "left",
    "width",
    "text",
    "image",
    "font",
    "footerText",
    "footerImage",
    "footerFont",
    "toolTipMarkupEnabled",
    "toolTip",
    "resizable",
    "moveable",
    "alignment",
    "fixed",
    "group",
    "customVariant",
    "visibility",
    "check",
    "wordWrap",
    "headerWordWrap",
    "footerSpan",
    "data"
  ],

  propertyHandler : {
    "data" : rwt.remote.HandlerUtil.getControlPropertyHandler( "data" ),
    "toolTipMarkupEnabled" : rwt.remote.HandlerUtil.getControlPropertyHandler( "toolTipMarkupEnabled" ),
    "toolTip" : rwt.remote.HandlerUtil.getControlPropertyHandler( "toolTip" ),
    "group" : function( widget, value ) {
      rwt.remote.HandlerUtil.callWithTarget( value, function( group ) {
        widget.setGroup( group );
      } );
    }
  },

  events : [ "Selection" ]

} );

/*******************************************************************************
 * Copyright (c) 2011, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.remote.HandlerRegistry.add( "rwt.widgets.GridColumnGroup", {

  factory : function( properties ) {
    var result;
    rwt.remote.HandlerUtil.callWithTarget( properties.parent, function( parent ) {
      result = new rwt.widgets.GridColumn( parent, true );
      rwt.remote.HandlerUtil.addDestroyableChild( parent, result );
    } );
    return result;
  },

  destructor : function( column ) {
    rwt.remote.HandlerUtil.removeDestroyableChild( column._grid, column );
    column.dispose();
  },

  properties : [
    "left",
    "width",
    "height",
    "text",
    "image",
    "font",
    "expanded",
    "visibility",
    "customVariant",
    "headerWordWrap"
  ],

  events : [ "Expand", "Collapse" ]

} );

/*******************************************************************************
 * Copyright (c) 2007, 2014 Innoopract Informationssysteme GmbH and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Innoopract Informationssysteme GmbH - initial API and implementation
 *    EclipseSource - ongoing development
 ******************************************************************************/

rwt.qx.Class.define( "rwt.widgets.Browser", {

  extend : rwt.widgets.base.Iframe,

  construct : function() {
    this.base( arguments );
    this._browserFunctions = {};
    // TODO [rh] preliminary workaround to make Browser accessible by tab
    this.setTabIndex( 1 );
    this.setAppearance( "browser" );
    this.addEventListener( "create", this._onCreate, this );
  },

  properties : {

    asynchronousResult : {
      check : "Boolean",
      init : false
    },

    executedFunctionPending : {
      check : "Boolean",
      init : false
    },

    executedFunctionResult : {
      nullable : true,
      init : null
    },

    executedFunctionError : {
      check : "String",
      nullable : true,
      init : null
    }

  },

  statics : {

    getDomain : function( url ) {
      var domain = null;
      if( url !== null ) {
        var lowerCaseUrl = url.toLowerCase();
        // Accepted limitation: In case of other protocls this detection fails.
        var defaultPort;
        if( lowerCaseUrl.indexOf( "http://" ) === 0 ) {
          defaultPort = 80;
        } else if( lowerCaseUrl.indexOf( "https://" ) === 0 ) {
          defaultPort = 443;
        } else if( lowerCaseUrl.indexOf( "ftp://" ) === 0 ) {
          defaultPort = 21;
        } else if( lowerCaseUrl.indexOf( "ftps://" ) === 0 ) {
          defaultPort = 990;
        }
        if( defaultPort ) {
          domain = lowerCaseUrl.slice( lowerCaseUrl.indexOf( "://" ) + 3 );
          var pathStart = domain.indexOf( "/" );
          if( pathStart !== -1 ) {
            domain = domain.slice( 0, pathStart );
          }
          if( domain.indexOf( ":" ) === -1 ) {
            domain += ":" + defaultPort;
          }
        }
      }
      return domain;
    }

  },

  members : {

    syncSource : function() {
      if( this.isCreated() ) {
        this._syncSource();
      }
    },

    // overwritten
    _applySource : function() {
      // server syncs manually
    },

    // overwritten
    _applyEnabled : function( value, oldValue ) {
      this.base( arguments, value, oldValue );
      if( value ) {
        this.release();
      } else {
        this.block();
      }
    },

    // overwritten
    release : function() {
      if( this.getEnabled() ) {
        this.base( arguments );
      }
    },

    _onload : function( evt ) {
      // syncSource in destroy may cause unwanted load event when widget is about to be disposed
      if( !this._isInGlobalDisposeQueue && !this.isDisposed() ) {
        this.base( arguments, evt );
        if( this._isContentAccessible() ) {
          this._attachBrowserFunctions();
        }
        this._sendProgressEvent();
      }
    },

    _onCreate : function() {
      if( !this.getEnabled() ) {
        this.block();
      }
    },

    _sendProgressEvent : function() {
      // The IFrame destroy method does not mark the widget as disposed (or in dispose) immediately,
      // and getRemoteObject can fail if the widget has already been removed from ObjectRegistry
      if( rwt.remote.ObjectRegistry.containsObject( this ) ) {
        rwt.remote.Connection.getInstance().getRemoteObject( this ).notify( "Progress" );
      }
    },

    execute : function( script ) {
      // NOTE [tb] : For some very strange reason the access check must not be done directly
      // before the try-catch for the ipad to recognize the error is may throw.
      this._checkIframeAccess();
      var success = true;
      var result = null;
      try {
        result = this._parseEvalResult( this._eval( script ) );
      } catch( ex ) {
        success = false;
      }
      var connection = rwt.remote.Connection.getInstance();
      var id = rwt.remote.ObjectRegistry.getId( this );
      var method = success ? "evaluationSucceeded" : "evaluationFailed";
      var properties = success ? { "result" : result } : {};
      connection.getMessageWriter().appendCall( id, method, properties );
      if( this.getExecutedFunctionPending() ) {
        connection.sendImmediate( false );
      } else {
        connection.send();
      }
    },

    _srcInLocalDomain : function() {
      var src = this.getSource();
      var statics = rwt.widgets.Browser;
      var localDomain = statics.getDomain( document.URL );
      var srcDomain = statics.getDomain( src );
      var isSameDomain = localDomain === srcDomain;
      var isRelative = srcDomain === null;
      return isRelative || isSameDomain;
    },

    _isContentAccessible : function() {
      if( !this._isLoaded ) {
        return false;
      }
      var accessible = false;
      try {
        var src = this.getSource() || "";
        if( src.indexOf( "://" ) === -1 ) { // relative path?
          src = document.URL; // works since we only check that the domain matches
        }
        accessible = src.indexOf( this.getContentDocument().domain ) !== -1;
      } catch( ex ) {
        // ignore
      }
      return accessible;
    },

    _checkIframeAccess : function() {
      if( !this._isContentAccessible() ) {
        var isSameDomain = this._srcInLocalDomain();
        if( !isSameDomain ) {
          this._throwSecurityException( false );
        }
        if( this._isLoaded && isSameDomain ) {
          // not accessible when it appears it should be
          // => user navigated to external site.
          this._throwSecurityException( true );
        }
      }
    },

    _throwSecurityException : function( domainUnkown ) {
      var statics = rwt.widgets.Browser;
      var localDomain = statics.getDomain( document.URL );
      var srcDomain = domainUnkown ? null : statics.getDomain( this.getSource() );
      var msg = "SecurityRestriction:\nBrowser-Widget can not access ";
      msg +=   srcDomain !== null
             ? "\"" + srcDomain + "\""
             : "unkown domain";
      msg += " from \"" + localDomain + "\".";
      throw new Error( msg );
    },

    _eval : function( script ) {
      var win = this.getContentWindow();
      if( !win[ "eval" ] && win[ "execScript" ] ) {
        // Workaround for IE bug, see: http://www.thismuchiknow.co.uk/?p=25
        win.execScript( "null;", "JScript" );
      }
      return win[ "eval" ]( script );
    },

    _parseEvalResult : function( value ) {
      var result = null;
      var win = this.getContentWindow();
      // NOTE: This mimics the behavior of the evaluate method in SWT:
      if( value instanceof win.Function || value instanceof Function ) {
        result = this.toJSON( [ [] ] );
      } else if( value instanceof win.Array || value instanceof Array ) {
        result = this.toJSON( [ value ] );
      } else if( typeof value !== "object" && typeof value !== "function" ) {
        // above: some browser say regular expressions of the type "function"
        result = this.toJSON( [ value ] );
      }
      return result;
    },

    createFunction : function( name ) {
      this._browserFunctions[ name ] = true;
      this._checkIframeAccess();
      if( this.isLoaded() ) {
        try {
          this._createFunctionImpl( name );
          this._createFunctionWrapper( name );
        } catch( e ) {
          var msg = "Unable to create function: \"" + name + "\".\n" + e;
          if( rwt.remote.EventUtil.getSuspended() ) {
            throw msg;
          } else {
            rwt.runtime.ErrorHandler.processJavaScriptError( msg );
          }
        }
      }
    },

    _attachBrowserFunctions : function() {
      // NOTE: In case the user navigates to a page outside the domain,
      // this function will not be triggered due to the lack of a loading event.
      // That also means that this is the only case were creating a browser
      // function in a cross-domain scenario silently fails.
      for( var name in this._browserFunctions ) {
        this.createFunction( name );
      }
    },

    _createFunctionImpl : function( name ) {
      var win = this.getContentWindow();
      var connection = rwt.remote.Connection.getInstance();
      var id = rwt.remote.ObjectRegistry.getId( this );
      var that = this;
      win[ name + "_impl" ] = function() {
        var result = {};
        try {
          if( that.getExecutedFunctionPending() ) {
            result.error = "Unable to execute browser function \""
              + name
              + "\". Another browser function is still pending.";
          } else {
            var properties = {
              "name" : name,
              "arguments" : that.toJSON( arguments )
            };
            connection.getMessageWriter().appendCall( id, "executeFunction", properties );
            that.setExecutedFunctionResult( null );
            that.setExecutedFunctionError( null );
            that.setExecutedFunctionPending( true );
            that.setAsynchronousResult( false );
            connection.sendImmediate( false );
            if( that.getExecutedFunctionPending() ) {
              that.setAsynchronousResult( true );
            } else {
              var error = that.getExecutedFunctionError();
              if( error != null ) {
                result.error = error;
              } else {
                result.result = that.getExecutedFunctionResult();
              }
            }
          }
        } catch( ex ) {
          rwt.runtime.ErrorHandler.processJavaScriptError( ex );
        }
        return result;
      };
    },

    // [if] This wrapper function is a workaround for bug 332313
    _createFunctionWrapper : function( name ) {
      var script = [];
      script.push( "function " + name + "(){" );
      script.push( "  var result = " + name + "_impl.apply( window, arguments );" );
      script.push( "  if( result.error ) {" );
      script.push( "    throw new Error( result.error );" );
      script.push( "  }" );
      script.push( "  return result.result;" );
      script.push( "}");
      this._eval( script.join( "" ) );
    },

    destroyFunction :function( name ) {
      delete this._browserFunctions[ name ];
      var win = this.getContentWindow();
      if( win != null ) {
        try {
          var script = [];
          script.push( "delete window." +  name + ";" );
          script.push( "delete window." +  name + "_impl;" );
          this._eval( script.join( "" ) );
        } catch( e ) {
          throw new Error( "Unable to destroy function: " + name + " error: " + e );
        }
      }
    },

    setFunctionResult : function( name, result, error ) {
      this.setExecutedFunctionResult( result );
      this.setExecutedFunctionError( error );
      this.setExecutedFunctionPending( false );
    },

    toJSON : function( object ) {
      var result;
      var type = typeof object;
      if( object === null ) {
        result = object;
      } else if( type === "object" ) {
        result = [];
        for( var i = 0; i < object.length; i++ ) {
          result.push( this.toJSON( object[ i ] ) );
        }
      } else if( type === "function" ) {
        result = String( object );
      } else {
        result = object;
      }
      return result;
    },

    destroy : function() {
      this.base( arguments );
      // Needed for IE dipose fix in Iframe.js because _applySource is overwritten in Browser.js
      this.syncSource();
    }

  }

} );

/*******************************************************************************
 * Copyright (c) 2011, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.remote.HandlerRegistry.add( "rwt.widgets.Browser", {

  factory : function( properties ) {
    var result = new rwt.widgets.Browser();
    rwt.remote.HandlerUtil.addStatesForStyles( result, properties.style );
    result.setUserData( "isControl", true );
    rwt.remote.HandlerUtil.setParent( result, properties.parent );
    return result;
  },

  destructor : rwt.remote.HandlerUtil.getControlDestructor(),

  getDestroyableChildren : rwt.remote.HandlerUtil.getDestroyableChildrenFinder(),

  properties : rwt.remote.HandlerUtil.extendControlProperties( [
    "url",
    "functionResult"
  ] ),

  propertyHandler : rwt.remote.HandlerUtil.extendControlPropertyHandler( {
    "url" : function( widget, value ) {
      widget.setSource( value );
      widget.syncSource();
    },
    "functionResult" : function( widget, value ) {
      widget.setFunctionResult( value[ 0 ], value[ 1 ], value[ 2 ] );
    }
  } ),

  events : [ "Progress" ],

  listeners : rwt.remote.HandlerUtil.extendControlListeners( [] ),

  listenerHandler : rwt.remote.HandlerUtil.extendControlListenerHandler( {} ),

  methods : [
    "evaluate",
    "destroyFunctions",
    "createFunctions"
  ],

  methodHandler : {
    "evaluate" : function( widget, properties ) {
      widget.execute( properties.script );
    },
    "createFunctions" : function( widget, properties ) {
      var functions = properties.functions;
      for( var i = 0; i < functions.length; i++ ) {
        widget.createFunction( functions[ i ] );
      }
    },
    "destroyFunctions" : function( widget, properties ) {
      var functions = properties.functions;
      for( var i = 0; i < functions.length; i++ ) {
        widget.destroyFunction( functions[ i ] );
      }
    }
  }

} );

/*******************************************************************************
 * Copyright (c) 2007, 2014 Innoopract Informationssysteme GmbH and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Innoopract Informationssysteme GmbH - initial API and implementation
 *    EclipseSource - ongoing development
 ******************************************************************************/

rwt.qx.Class.define( "rwt.widgets.ExternalBrowser", {

  extend : rwt.qx.Object,

  statics : {

    getInstance : function() {
      return rwt.runtime.Singletons.get( rwt.widgets.ExternalBrowser );
    }

  },

  members : {
    // maps id's (aka window names) to window instances
    // key = id, value = window object
    _map : {},

    open : function( id, url, features ) {
      var escapedId = this._escapeId( id );
      var win = window.open( url, escapedId, features, true );
      if( win != null ) {
        win.focus();
        this._map[ escapedId ] = win;
      }
    },

    close : function( id ) {
      var escapedId = this._escapeId( id );
      var win = this._map[ escapedId ];
      if( win != null ) {
        win.close();
      }
      delete this._map[ escapedId ];
    },

    _escapeId : function( id ) {
      var result = id;
      result = result.replace( /_/g, "_0" );
      // IE does not accept '-' in popup-window names
      result = result.replace( /-/g, "_1" );
      result = result.replace( /\./g, "_" );
      // IE does not accept blanks in popup-window names
      result = result.replace( / /g, "__" );
      return result;
    }
  }
} );


/*******************************************************************************
 * Copyright (c) 2011, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.remote.HandlerRegistry.add( "rwt.widgets.ExternalBrowser", {

  factory : function() {
    return rwt.widgets.ExternalBrowser.getInstance();
  },

  destructor : rwt.util.Functions.returnTrue,

  methods : [
    "open",
    "close"
  ],

  methodHandler : {
    "open" : function( widget, args ) {
      var styleMap = rwt.remote.HandlerUtil.createStyleMap( args.style );
      var features = "dependent=1,scrollbars=1,resizable=1,";
      var status = "status=".concat( styleMap.STATUS ? 1 : 0, "," );
      var location = "location=".concat( styleMap.LOCATION_BAR ? 1 : 0, "," );
      var toolbar = "toolbar=".concat( styleMap.NAVIGATION_BAR ? 1 : 0, "," );
      var menubar = "menubar=".concat( styleMap.NAVIGATION_BAR ? 1 : 0 );
      features = features.concat( status, location, toolbar, menubar );
      widget.open( args.id, args.url, features );
    },
    "close" : function( widget, args ) {
      widget.close( args.id );
    }
  }

} );

/*******************************************************************************
 * Copyright (c) 2002, 2014 Innoopract Informationssysteme GmbH and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Innoopract Informationssysteme GmbH - initial API and implementation
 *    EclipseSource - ongoing development
 ******************************************************************************/

rwt.qx.Class.define( "rwt.widgets.util.FontSizeCalculation", {

  statics : {

    _wrapNode : null,
    _measureNode : null,
    _offset : rwt.client.Client.isZoomed() ? 1 : 0,

    measureItems : function( args ) {
      var items = args.items;
      var results = {};
      for( var i = 0; i < items.length; i++ ) {
        var item = items[ i ];
        var isMarkup = item[ 7 ];
        var size = this._measureItem( item, !isMarkup );
        var id = item[ 0 ];
        results[ id ] = size;
      }
      this._storeMeasurements( id, results );
    },

    _measureItem : function( item, escapeText ) {
      var text = escapeText ? this._escapeText( item[ 1 ] ) : item[ 1 ];
      var font = rwt.html.Font.fromArray( item.slice( 2, 6 ) );
      var fontProps = {};
      font.renderStyle( fontProps );
      var width = item[ 6 ] > 0 ? item[ 6 ] : null;
      return this.computeTextDimensions( text, fontProps, width );
    },

    computeTextDimensions : function( text, fontProps, wrapWidth ) {
      var textElement = this._getMeasureNode();
      var wrapElement = this._getWrapNode();
      var style = textElement.style;
      style.fontFamily = fontProps.fontFamily || "";
      style.fontSize = fontProps.fontSize || "";
      style.fontWeight = fontProps.fontWeight || "";
      style.fontStyle = fontProps.fontStyle || "";
      textElement.innerHTML = text;
      if( wrapWidth ) {
        wrapElement.style.width = wrapWidth + "px";
        wrapElement.style.whiteSpace = "normal";
        style.whiteSpace = "normal";
      } else {
        wrapElement.style.width = "auto";
        wrapElement.style.whiteSpace = "nowrap";
        style.whiteSpace = "nowrap";
      }
      return this._measureElement( textElement );
    },

    _measureElement : rwt.util.Variant.select( "qx.client", {
      "default" : function( element ) {
        var result;
        if( element.getBoundingClientRect ) {
          // See Bug 340841
          var bounds = element.getBoundingClientRect();
          // In FF 3.0.x getBoundingClientRect has no width/height properties
          if( bounds.width != null && bounds.height != null ) {
            result = [ Math.ceil( bounds.width ), Math.round( bounds.height ) ];
          } else {
            result = [ element.scrollWidth, element.scrollHeight ];
          }
        } else {
          result = [ element.scrollWidth, element.scrollHeight ];
        }
        return this._addOffset( result );
      },
      "trident" : function( element ) {
        var computed = window.getComputedStyle( element, null );
        var result = [
          Math.ceil( parseFloat( computed.width ) ), // Ensure Texts are not cut off or wrap
          Math.round( parseFloat( computed.height ) ) // Ensure vertical alignment looks right
        ];
        return this._addOffset( result );
      }
    } ),

    _addOffset : function( bounds ) {
      var x = bounds[ 0 ] > 0 ? bounds[ 0 ] + this._offset : 0;
      var y = bounds[ 1 ] > 0 ? bounds[ 1 ] + this._offset : 0;
      return [ x, y ];
    },

    _getMeasureNode : function() {
      var node = this._measureNode;
      if( !node ) {
        node = document.createElement( "div" );
        var style = node.style;
        style.width = style.height = "auto";
        style.visibility = "hidden";
        style.position = "absolute";
        style.margin = "0px";
        style.zIndex = "-1";
        this._getWrapNode().appendChild( node );
        this._measureNode = node;
      }
      return node;
    },

    _getWrapNode : function() {
      var node = this._wrapNode;
      if( !node ) {
        node = document.createElement( "div" );
        var style = node.style;
        style.width = style.height = "auto";
        style.visibility = "hidden";
        style.padding = "0px";
        style.position = "absolute";
        style.zIndex = "-1";
        document.body.appendChild( node );
        this._wrapNode = node;
      }
      return node;
    },

    _storeMeasurements : function( id, results ) {
      var remoteObject = rwt.remote.Connection.getInstance().getRemoteObject( this );
      remoteObject.call( "storeMeasurements", {
        "results" : results
      } );
    },

    _escapeText : function( text ) {
      var EncodingUtil = rwt.util.Encoding;
      var result = EncodingUtil.escapeText( text, true );
      result = EncodingUtil.replaceNewLines( result, "<br/>" );
      result = EncodingUtil.replaceWhiteSpaces( result );
      return result;
    }

  }
} );

/*******************************************************************************
 * Copyright (c) 2012, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.remote.HandlerRegistry.add( "rwt.client.TextSizeMeasurement", {

  factory : function() {
    return rwt.widgets.util.FontSizeCalculation;
  },

  service : true,

  methods : [
    "measureItems"
  ]

} );

/*******************************************************************************
 * Copyright (c) 2013, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.qx.Class.define( "rwt.widgets.Label", {

  extend : rwt.widgets.base.MultiCellWidget,

  include : rwt.widgets.util.OverStateMixin,

  construct : function( styles ) {
    this.base( arguments, this._CELLORDER );
    this.setVerticalChildrenAlign( "top" );
    this.setAlignment( "left" );
    this.setAppearance( "label-wrapper" );
    if( styles.WRAP ) {
      this.setFlexibleCell( 1 );
      this.setWordWrap( true );
    }
    this._markupEnabled = styles.MARKUP_ENABLED === true;
    this._rawText = null;
    this._mnemonicIndex = null;
  },

  destruct : function() {
    this.setMnemonicIndex( null );
  },

  members : {

    _CELLORDER : [ "image", "label" ],

    setAlignment : function( value ) {
      this.setHorizontalChildrenAlign( value );
    },

    setImage : function( image ) {
      if( image ) {
        this.setCellContent( 0, image[ 0 ] );
        this.setCellDimension( 0, image[ 1 ], image[ 2 ] );
      } else {
        this.setCellContent( 0, null );
        this.setCellDimension( 0, 0, 0 );
      }
    },

    setText : function( value ) {
      this._rawText = value;
      this._applyText( false );
      this._mnemonicIndex = null;
      this.dispatchSimpleEvent( "changeText", this ); // used by Synchronizer.js
    },

    setMnemonicIndex : function( value ) {
      this._mnemonicIndex = value;
      var mnemonicHandler = rwt.widgets.util.MnemonicHandler.getInstance();
      if( ( typeof value === "number" ) && ( value >= 0 ) ) {
        mnemonicHandler.add( this, this._onMnemonic );
      } else {
        mnemonicHandler.remove( this );
      }
    },

    getMnemonicIndex : function() {
      return this._mnemonicIndex;
    },

    _applyText : function( mnemonic ) {
      var text = this._rawText;
      if( text ) {
        if( !this._markupEnabled ) {
          var EncodingUtil = rwt.util.Encoding;
          var mnemonicIndex = mnemonic ? this._mnemonicIndex : undefined;
          // Order is important here: escapeText, replace line breaks
          text = EncodingUtil.escapeText( this._rawText, mnemonicIndex );
          text = EncodingUtil.replaceNewLines( text, "<br/>" );
          text = EncodingUtil.replaceWhiteSpaces( text ); // fixes bug 192634
        }
        this.setCellContent( 1, text );
      } else {
        this.setCellContent( 1, null );
      }
    },

    _onMnemonic : function( event ) {
      switch( event.type ) {
        case "show":
          this._applyText( true );
        break;
        case "hide":
          this._applyText( false );
        break;
        case "trigger":
          var charCode = this._rawText.toUpperCase().charCodeAt( this._mnemonicIndex );
          if( event.charCode === charCode ) {
            var focusWidget = this.getNextSibling();
            if( focusWidget && focusWidget.getVisibility() && focusWidget.getEnabled() ) {
              focusWidget.focus();
            }
            event.success = true;
          }
        break;
      }
    },

    setTopMargin : function( value ) {
      this.setPaddingTop( value );
    },

    setLeftMargin : function( value ) {
      this.setPaddingLeft( value );
    },

    setRightMargin : function( value ) {
      this.setPaddingRight( value );
    },

    setBottomMargin : function( value ) {
      this.setPaddingBottom( value );
    }

  }

} );

/*******************************************************************************
 * Copyright (c) 2009, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.qx.Class.define( "rwt.widgets.base.BasicButton", {

  extend : rwt.widgets.base.MultiCellWidget,

  construct : function( buttonType, noKeyControl ) {
    this.base( arguments, this._CELLORDER );
    this._selected = false;
    this._image = [ null, null, null ] ;
    this._hotImage = [ null, null, null ];
    this.addEventListener( "mouseover", this._onMouseOver );
    this.addEventListener( "mouseout", this._onMouseOut );
    this.addEventListener( "mousedown", this._onMouseDown );
    this.addEventListener( "mouseup", this._onMouseUp );
    if( !noKeyControl ) {
      this.addEventListener( "keydown", this._onKeyDown );
      this.addEventListener( "keyup", this._onKeyUp );
      this.addEventListener( "keypress", this._onKeyPress );
    }
    this.addState( buttonType );
    switch( buttonType ) {
      case "arrow":
      case "push":
        this._isSelectable = false;
        this._isDeselectable = false;
      break;
      case "toggle":
      case "check":
        this._isSelectable = true;
        this._isDeselectable = true;
      break;
      case "radio":
        this._isSelectable = true;
        this.setNoRadioGroup( false );
        rwt.widgets.util.RadioButtonUtil.registerExecute( this );
        rwt.widgets.util.RadioButtonUtil.registerKeypress( this );
      break;
    }

  },

  destruct : function() {
    if( this._animation != null ) {
      this._animation.dispose();
    }
    this._animation = null;
  },

  events: {
    "stateOverChanged" : "rwt.event.Event"
  },

  properties : {

    selectionIndicator : {
      apply : "_applySelectionIndicator",
      nullable : true,
      themeable : true
    },

    // TODO [tb] : non-ideal solution to provide theming support for image
    icon : {
      apply : "_applyIcon",
      nullable : true,
      themeable : true
    },

    animation : {
      check : "Object",
      nullable : false,
      init : null,
      apply : "_applyAnimation",
      themeable : true
    }

  },

  members : {
    _CELLORDER : [ "image", "image", "label" ],

    _applyIcon : function( newValue ) {
      this.setImage.apply( this, newValue );
    },

    setImage : function( value, width, height ) {
      this._image = [ value, width, height ];
      this._updateButtonImage();
    },

    getImage : function() {
      return this._image;
    },

    setHotImage : function( value, width, height ) {
      this._hotImage = [ value, width, height ];
      this._updateButtonImage();
    },

    _updateButtonImage : function() {
      var image =
          ( this._hotImage[ 0 ] != null && this.hasState( "over" ) )
        ? this._hotImage
        : this._image;
      var current = this.getCellContent( 1 );
      if( current != image[ 0 ] ) {
        this.setCellContent( 1, image[ 0 ] );
        this.setCellDimension( 1, image[ 1 ], image[ 2 ] );
      }
    },

    setText : function( value ) {
      this.setCellContent( 2, value );
    },

    _applySelectionIndicator : function( value ) {
      var url = value ? value[ 0 ] : null;
      var width = value ? value[ 1 ] : 0;
      var height = value ? value[ 2 ] : 0;
      this.setCellContent( 0, url );
      this.setCellDimension( 0, width, height );
    },

    setGrayed : function( value ) {
      this.toggleState( "grayed", value );
    },

    setNoRadioGroup : function( value ) {
      if( this.hasState( "radio") ) {
        this._noRadioGroup = value;
        this._isDeselectable = value;
      }
    },

    getNoRadioGroup : function() {
      return this._noRadioGroup;
    },

    execute : function() {
      this.base( arguments );
      if( this._isSelectable ) {
        this.setSelection( !( this._selected && this._isDeselectable ) );
      } else {
        this._notifySelected();
      }
    },

    setSelection : function( value ) {
      var wasSelected = this._selected;
      var selectionChanged = this._selected != value;
      if( selectionChanged ) {
        this._selected = value;
        this.toggleState( "selected", value );
        if( !rwt.remote.EventUtil.getSuspended() ) {
          var server = rwt.remote.Connection.getInstance();
          server.getRemoteObject( this ).set( "selection", this._selected );
        }
      }
      if( selectionChanged || wasSelected ) {
        this._notifySelected();
      }
    },

    _notifySelected : function() {
      // subclasses may overwrite
    },

    _onMouseOver : function( event ) {
      // [tb] Firefox can sometimes fire false "over" events.
      if ( event.getTarget() == this && !this.hasState( "over" ) ) {
        if( this.hasState( "abandoned" ) ) {
          this.removeState( "abandoned" );
          this.addState( "pressed" );
        }
        this.addState( "over" );
        this._updateButtonImage();
        this.createDispatchEvent( "stateOverChanged" );
      }
    },

    _onMouseOut : function( event ) {
      if ( event.getTarget() == this ) {
        this.removeState( "over" );
        this._updateButtonImage();
        if ( this.hasState( "pressed" ) ) {
          this.setCapture( true );
          this.removeState( "pressed" );
          this.addState( "abandoned" );
        }
        this.createDispatchEvent( "stateOverChanged" );
      }
    },

    _onMouseDown : function( event ) {
      if ( event.getTarget() == this && event.isLeftButtonPressed() ) {
        this.removeState( "abandoned" );
        this.addState( "pressed" );
      }
    },

    _onMouseUp : function() {
      this.setCapture( false );
      var hasPressed = this.hasState( "pressed" );
      var hasAbandoned = this.hasState( "abandoned" );
      if( hasPressed ) {
        this.removeState( "pressed" );
      }
      if ( hasAbandoned ) {
        this.removeState( "abandoned" );
      }
      if ( !hasAbandoned ) {
        this.addState( "over" );
        this._updateButtonImage();
        if ( hasPressed ) {
          this.execute();
        }
      }
    },

    _onKeyDown : function( event ) {
      switch( event.getKeyIdentifier() ) {
        case "Enter":
        case "Space":
          this.removeState( "abandoned" );
          this.addState( "pressed" );
          event.stopPropagation();
      }
    },

    _onKeyUp : function( event ) {
      switch( event.getKeyIdentifier() ) {
        case "Enter":
        case "Space":
          if ( this.hasState( "pressed" ) ) {
            this.removeState( "abandoned" );
            this.removeState( "pressed" );
            this.execute();
            event.preventDefault();
            event.stopPropagation();
          }
      }
    },

    _onKeyPress : function( event ) {
      switch( event.getKeyIdentifier() ) {
        case "Left":
        case "Up":
        case "Right":
        case "Down":
        case "PageUp":
        case "PageDown":
        case "End":
        case "Home":
        case "Enter":
        case "Space":
          event.preventDefault();
          event.stopPropagation();
      }
    },

    ////////////
    // Animation

    _applyAnimation : function( newValue ) {
      if( newValue[ "hoverIn" ] || newValue[ "hoverOut" ] ) {
        if( this._animation == null ) {
          this._animation = new rwt.animation.Animation();
          this._animation.addEventListener( "init",
                                            this._initAnimation,
                                            this );
        }
        this.addEventListener( "stateOverChanged",
                               this._animation.activateRendererOnce,
                               this._animation );
        this.addEventListener( "changeBackgroundGradient",
                               this._configureRenderer,
                               this );
        this._configureRenderer();
      } else if( this._animation != null ) {
        this.removeEventListener( "stateOverChanged",
                                  this._animation.activateRendererOnce,
                                  this._animation );
        this.removeEventListener( "changeBackgroundGradient",
                                  this._configureRenderer,
                                  this );
      }
    },

    _configureRenderer : function( event ) {
      if( !event || event.getValue() == null || event.getOldValue() == null ) {
        this._animation.skip();
        var renderer = this._animation.getDefaultRenderer( false );
        var renderType =   this.getBackgroundGradient() != null
                         ? "backgroundGradient"
                         : "backgroundColor";
        var animationType = rwt.animation.AnimationRenderer.ANIMATION_CHANGE;
        renderer.animate( this, renderType, animationType );
      }
    },

    _initAnimation : function() {
      if( this.hasState( "pressed" ) ) {
        this._animation.cancel();
      } else {
        var animation = this.getAnimation();
        if( this.hasState( "over" ) && animation[ "hoverIn" ] ) {
          this._animation.setProperties( animation[ "hoverIn" ] );
        } else if( !this.hasState( "over" ) && animation[ "hoverOut" ] ) {
          this._animation.setProperties( animation[ "hoverOut" ] );
        } else {
          this._animation.cancel();
        }
      }
    },

    _renderAppearance : function() {
      this.base( arguments );
      // TODO [tb] : Find a more elegant and generic way to do this.
      if( this._animation != null && !this._animation.isStarted() ) {
        this._animation.getDefaultRenderer().cancelActivateOnce();
      }
    }

  }
} );

/*******************************************************************************
 * Copyright (c) 2009, 2015 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

(function($){

rwt.qx.Class.define( "rwt.widgets.ToolItem", {

  extend : rwt.widgets.base.BasicButton,

  construct : function( itemType, vertical ) {
    this.base( arguments, itemType );
    this._isDropDown = false;
    this.setAppearance( "toolbar-button" );
    if( itemType == "dropDown" ) {
      this._isDropDown = true;
      this._isSelectable = false;
      this._isDeselectable = false;
      this._sendEvent = true;
      this.$dropDownArrow = $( "<div>" ).css({
        position: "absolute"
      });
      this.$separator = $( "<div>" ).css({
        position: "absolute",
        top: 0,
        right: 0,
        left: "auto",
        width: 1,
        height: "100%"
      });
    }
    if( vertical ) {
      this.addState( "rwt_VERTICAL" );
    }
    this._rawText = null;
    this._mnemonicIndex = null;
    this.removeEventListener( "keydown", this._onKeyDown );
    this.removeEventListener( "keyup", this._onKeyUp );
    this.addEventListener( "changeParent", this._onChangeParent, this );
  },

  destruct : function() {
    this.setMnemonicIndex( null );
  },

  properties : {

    dropDownArrow : {
      apply : "_applyDropDownArrow",
      nullable : true,
      themeable : true
    },

    separatorBorder : {
      nullable : true,
      init : null,
      apply : "_applySeparatorBorder",
      themeable : true
    }

  },

  members : {

    // overwritten:
    _onKeyPress : function( event ) {
      // give to toolBar for keyboard control (left/right keys):
      this.getParent().dispatchEvent( event );
      this.base( arguments, event );
    },

    setText : function( value ) {
      this._rawText = value;
      this._mnemonicIndex = null;
      this._applyText( false );
    },

    computeBadgePosition : function() {
      return [ 3, 3, "auto", "auto" ];
    },

    setMnemonicIndex : function( value ) {
      this._mnemonicIndex = value;
      var mnemonicHandler = rwt.widgets.util.MnemonicHandler.getInstance();
      if( ( typeof value === "number" ) && ( value >= 0 ) ) {
        mnemonicHandler.add( this, this._onMnemonic );
      } else {
        mnemonicHandler.remove( this );
      }
    },

    getMnemonicIndex : function() {
      return this._mnemonicIndex;
    },

    _applyText : function( mnemonic ) {
      if( this._rawText ) {
        var mnemonicIndex = mnemonic ? this._mnemonicIndex : undefined;
        var text = rwt.util.Encoding.escapeText( this._rawText, mnemonicIndex );
        this.setCellContent( 2, text );
      } else {
        this.setCellContent( 2, null );
      }
    },

    _onMnemonic : function( event ) {
      switch( event.type ) {
        case "show":
          this._applyText( true );
        break;
        case "hide":
          this._applyText( false );
        break;
        case "trigger":
          var charCode = this._rawText.toUpperCase().charCodeAt( this._mnemonicIndex );
          if( event.charCode === charCode ) {
            this.execute();
            event.success = true;
          }
        break;
      }
    },

    ////////////////////
    // Dropdown-support

    // overwritten:
    _onMouseDown : function( event ) {
      if ( event.getTarget() == this && event.isLeftButtonPressed() ) {
        this.removeState( "abandoned" );
        if( this._isDropDownClick( event ) ) {
          this._onDropDownClick();
        } else {
          this.addState( "pressed" );
        }
      }
    },

    _isDropDownClick : function( event ) {
      var result = false;
      if( this.$separator ) {
        result = event.getClientX() > this.$separator.offset().left;
      }
      return result;
    },

    _onDropDownClick : function() {
      if( this._sendEvent ) {
        rwt.remote.EventUtil.notifySelected( this, 0, 0, 0, 0, "arrow" );
      }
      this.dispatchSimpleEvent( "dropDownClicked" );
    },

    _applyDropDownArrow : function( value ) {
      if( this._isDropDown ) {
        var url = value ? value[ 0 ] : null;
        var width = value ? value[ 1 ] : 0;
        var height = value ? value[ 2 ] : 0;
        this.$dropDownArrow.css({
          backgroundImage: url,
          width: width,
          height: height,
          right: this.getSpacing()
        });
        this.$separator.css("right", width + this.getSpacing() * 2 );
      }
    },

    _applySeparatorBorder : function() {
      if( this._isDropDown ) {
        var border = this.getSeparatorBorder();
        this.$separator.css({
          borderLeftWidth: ( border.getWidthLeft() || 0 ) + "px",
          borderLeftStyle: border.getStyleLeft() || "none",
          borderLeftColor: border.getColorLeft() || ""
        });
      }
    },

    _createSubElements: function() {
      this.base( arguments );
      if( this._isDropDown ) {
        this.$dropDownArrow.appendTo( this );
        this.$separator.appendTo( this );
      }
    },

    // overwritten:
    _afterRenderLayout : function( changes ) {
      if( this._isDropDown && changes.layoutY ) {
        var innerHeight = this.getInnerHeight();
        var imageHeight = ( this.getDropDownArrow() || [ null, 0, 0 ] )[ 2 ];
        this.$dropDownArrow.css("top", Math.round( this.getPaddingTop() + innerHeight / 2 - imageHeight / 2) );
      }
    },

    // overwritten:
    _getAvailableInnerWidth : function() {
      if( !this._isDropDown ) {
        return this.getInnerWidth();
      }
      var imageWidth = ( this.getDropDownArrow() || [ null, 0, 0 ] )[ 1 ];
      return Math.max( 0, this.getInnerWidth() - imageWidth - 1 - this.getSpacing() * 2 );
    },

    // overwritten:
    _notifySelected : function() {
      rwt.remote.EventUtil.notifySelected( this );
    },

    _onChangeParent : function( event ) {
      var oldParent = event.getOldValue();
      var newParent = event.getValue();
      if( oldParent ) {
        this._toggleFirstLastState( oldParent );
      } else {
        this._toggleFirstLastState( newParent );
      }
      if( newParent ) {
        this.toggleState( "rwt_RIGHT", newParent.hasState( "rwt_RIGHT" ) );
        this.toggleState( "rwt_FLAT", newParent.hasState( "rwt_FLAT" ) );
      }
    },

    _toggleFirstLastState : function( parent ) {
      var first;
      var last;
      parent.forEachVisibleChild( function() {
        if( this instanceof rwt.widgets.ToolItem ) {
          this.toggleState( "first", false );
          this.toggleState( "last", false );
          if( !first ) {
            first = this;
          }
          last = this;
        }
      } );
      if( first ) {
        first.toggleState( "first", true );
        last.toggleState( "last", true );
      }
    }

  }

} );

}( rwt.util._RWTQuery ));

/*******************************************************************************
 * Copyright (c) 2002, 2014 Innoopract Informationssysteme GmbH and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Innoopract Informationssysteme GmbH - initial API and implementation
 *    EclipseSource - ongoing development
 ******************************************************************************/

rwt.qx.Class.define( "rwt.widgets.Group", {

  extend : rwt.widgets.base.Parent,

  construct : function() {
    this.base( arguments );
    this._frame = new rwt.widgets.base.Parent();
    this._frame.setAppearance( "group-box-frame" );
    this.add( this._frame );
    this._legend = new rwt.widgets.base.MultiCellWidget( [ "label" ] );
    this._legend.setAppearance( "group-box-legend" );
    this.add( this._legend );
    this.setOverflow( "hidden" );
    var themeValues = new rwt.theme.ThemeValues( {} );
    this._themeBackgroundColor = themeValues.getCssColor( "Group-Label", "background-color" );
    themeValues.dispose();
    this._legend.addEventListener( "mouseover", this._onMouseOver, this );
    this._legend.addEventListener( "mouseout", this._onMouseOut, this );
    // Disable scrolling (see bug 345903)
    rwt.widgets.base.Widget.disableScrolling( this );
  },

  destruct : function() {
    this._disposeObjects( "_legend", "_frame" );
    this.setMnemonicIndex( null );
  },

  properties : {

    appearance : {
      refine : true,
      init : "group-box"
    }

  },

  members : {

    setText : function( value ) {
      this._rawText = value;
      this._mnemonicIndex = null;
      this._applyText( false );
    },

    setMnemonicIndex : function( value ) {
      this._mnemonicIndex = value;
      var mnemonicHandler = rwt.widgets.util.MnemonicHandler.getInstance();
      if( ( typeof value === "number" ) && ( value >= 0 ) ) {
        mnemonicHandler.add( this, this._onMnemonic );
      } else {
        mnemonicHandler.remove( this );
      }
    },

    getMnemonicIndex : function() {
      return this._mnemonicIndex;
    },

    _onMnemonic : function( event ) {
      switch( event.type ) {
        case "show":
          this._applyText( true );
        break;
        case "hide":
          this._applyText( false );
        break;
        case "trigger":
          var charCode = this._rawText.toUpperCase().charCodeAt( this._mnemonicIndex );
          if( event.charCode === charCode ) {
            var widget = this._findFirstFocusableChild( this );
            if( widget != null ) {
              widget.focus();
            }
            event.success = true;
          }
        break;
      }
    },

    _applyText : function( mnemonic ) {
      var EncodingUtil = rwt.util.Encoding;
      if( this._rawText ) {
        var mnemonicIndex = mnemonic ? this._mnemonicIndex : undefined;
        var text = EncodingUtil.escapeText( this._rawText, mnemonicIndex );
        if( this.hasState( "rwt_WRAP" ) ) {
          text = EncodingUtil.replaceNewLines( text, "<br/>" );
        }
        this._setLegend( text );
      } else {
        this._setLegend( null );
      }
    },

    _getSubWidgets : function() {
      return [ this._legend, this._frame ];
    },

    _applyBackgroundColor : function( value, old ) {
      this.base( arguments, value, old );
      if( this._themeBackgroundColor === "undefined" ) {
        this._legend.setBackgroundColor( value );
      }
    },

    _applyFont : function( value, old ) {
      this.base( arguments, value, old );
      this._legend.setFont( value );
    },

    _onMouseOver : function() {
      this._legend.addState( "over" );
      this._frame.addState( "over" );
    },

    _onMouseOut : function() {
      this._legend.removeState( "over" );
      this._frame.removeState( "over" );
    },

    _layoutPost : function( changes ) {
      this.base( arguments, changes );
      this._frame._layoutPost( changes );
    },

    //////////////////
    // apply subelement IDs

    applyObjectId : function( id ) {
      this.base( arguments, id );
      this._legend.applyObjectId( id + "-label" );
    },

    _setLegend : function( text ) {
      if( text !== "" && text !== null ) {
        this._legend.setCellContent( 0, text );
        this._legend.setDisplay( true );
      } else {
        this._legend.setDisplay( false );
      }
    },

    _findFirstFocusableChild : function( parent ) {
      var ObjectRegistry = rwt.remote.ObjectRegistry;
      var WidgetUtil = rwt.widgets.util.WidgetUtil;
      var result = null;
      var ids = WidgetUtil.getChildIds( parent );
      for( var i = 0; i < ids.length && result === null; i++ ) {
        var child = ObjectRegistry.getObject( ids[ i ] );
        if( WidgetUtil.getChildIds( child ) ) {
          result = this._findFirstFocusableChild( child );
        } else if( child.isSeeable() && child.isEnabled() ) {
          result = child;
        }
      }
      return result;
    }

  }

} );

/*******************************************************************************
 * Copyright (c) 2011, 2013 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.remote.HandlerRegistry.add( "rwt.widgets.Group", {

  factory : function( properties ) {
    var result = new rwt.widgets.Group();
    rwt.remote.HandlerUtil.addStatesForStyles( result, properties.style );
    result.setUserData( "isControl", true );
    rwt.remote.HandlerUtil.setParent( result, properties.parent );
    return result;
  },

  destructor : rwt.remote.HandlerUtil.getControlDestructor(),

  getDestroyableChildren : rwt.remote.HandlerUtil.getDestroyableChildrenFinder(),

  properties : rwt.remote.HandlerUtil.extendControlProperties( [
    "text",
    "mnemonicIndex"
  ] ),

  propertyHandler : rwt.remote.HandlerUtil.extendControlPropertyHandler( {} ),

  listeners : rwt.remote.HandlerUtil.extendControlListeners( [] ),

  listenerHandler : rwt.remote.HandlerUtil.extendControlListenerHandler( {} )

} );

/*******************************************************************************
 * Copyright (c) 2002, 2014 Innoopract Informationssysteme GmbH and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Innoopract Informationssysteme GmbH - initial API and implementation
 *    EclipseSource - ongoing development
 ******************************************************************************/

rwt.qx.Class.define( "rwt.widgets.Shell", {

  extend : rwt.widgets.base.Window,

  include : rwt.animation.VisibilityAnimationMixin,

  construct : function( styles ) {
    this.base( arguments );
    this.setShowMinimize( styles.MIN === true );
    this.setAllowMinimize( styles.MIN === true  );
    this.setShowMaximize( styles.MAX === true  );
    this.setAllowMaximize(styles.MAX === true  );
    this.setShowClose( styles.CLOSE === true  );
    this.setAllowClose( styles.CLOSE === true  );
    this.setResizableWest( styles.RESIZE === true  );
    this.setResizableNorth( styles.RESIZE === true  );
    this.setResizableEast( styles.RESIZE === true  );
    this.setResizableSouth( styles.RESIZE === true  );
    this.setOverflow( "hidden" );
    // Note: This prevents a laoyut-glitch on the ipad:
    this.setRestrictToPageOnOpen( false );
    // TODO [rh] HACK to set mode on Label that shows the caption, _captionTitle
    //      is a 'protected' field on class Window
    this._captionTitle.setMode( "html" );
    this._activeControl = null;
    this._focusControl = null;
    this._parentShell = null;
    this._renderZIndex = true;
    this._sendBoundsTimer = new rwt.client.Timer( 0 );
    this._sendBoundsTimer.addEventListener( "interval", this._sendBounds, this );
    this._sendMoveFlag  = false;
    this._sendResizeFlag = false;
    this._sendResizeDelayed = false;
    this.addEventListener( "changeActiveChild", this._onChangeActiveChild );
    this.addEventListener( "changeFocusedChild", this._onChangeFocusedChild );
    this.addEventListener( "changeActive", this._onChangeActive );
    this.addEventListener( "changeLeft", this._onChangeLocation, this );
    this.addEventListener( "changeTop", this._onChangeLocation, this );
    this.addEventListener( "changeWidth", this._onChangeSize, this );
    this.addEventListener( "changeHeight", this._onChangeSize, this );
    this.addEventListener( "keydown", this._onKeydown );
    var req = rwt.remote.Connection.getInstance();
    req.addEventListener( "send", this._onSend, this );
    this.getCaptionBar().setWidth( "100%" );
    // [if] Listen for DOM event instead of qooxdoo event - see bug 294846.
    this.removeEventListener( "mousedown", this._onwindowmousedown );
    this.addEventListener( "create", this._onCreate, this );
    this.__onwindowmousedown = rwt.util.Functions.bind( this._onwindowmousedown, this );
    this.addToDocument();
  },

  statics : {
    TOP_LEFT : "topLeft",
    TOP_RIGHT : "topRight",
    BOTTOM_LEFT : "bottomLeft",
    BOTTOM_RIGHT : "bottomRight",
    CORNER_NAMES : [
      "topLeft",
      "topRight",
      "bottomLeft",
      "bottomRight"
    ],

    _onParentClose : function() {
      if( !rwt.remote.EventUtil.getSuspended() ) {
        this.doClose();
      }
    },

    reorderShells : function( vWindowManager ) {
      var shells = rwt.util.Objects.getValues( vWindowManager.getAll() );
      shells = shells.sort( rwt.widgets.Shell._compareShells );
      var vLength = shells.length;
      var upperModalShell = null;
      if( vLength > 0 ) {
        var vTop = shells[ 0 ].getTopLevelWidget();
        var vZIndex = rwt.widgets.Shell.MIN_ZINDEX;
        for( var i = 0; i < vLength; i++ ) {
          vZIndex += 10;
          shells[ i ].setZIndex( vZIndex );
          if( shells[ i ]._appModal && shells[ i ].getVisibility() && shells[ i ].getDisplay() ) {
            upperModalShell = shells[ i ];
          }
        }
        if( upperModalShell != null ) {
          this._copyStates( upperModalShell, vTop._getBlocker() );
          vTop._getBlocker().show();
          vTop._getBlocker().setZIndex( upperModalShell.getZIndex() - 1 );
        } else {
          vTop._getBlocker().hide();
        }
      }
      rwt.widgets.Shell._upperModalShell = upperModalShell;
    },

    _copyStates : function( source, target ) {
      target.__states = {};
      for( var state in source.__states ) {
        if( source._isRelevantState( state ) ) {
          target.addState( state );
        }
      }
      target._renderAppearance();
      rwt.widgets.base.Widget.removeFromGlobalLayoutQueue( target );
    },

    /*
     * Compares two Shells regarding their desired z-order.
     *
     * Result is
     * - positive if sh1 is higher
     * - negative if sh2 is higher
     * - zero if equal
     */
    _compareShells : function( sh1, sh2 ) {
      var result = 0;
      // check for dialog relationship
      if( sh1.isDialogOf( sh2 ) ) {
        result = 1;
      } else if( sh2.isDialogOf( sh1 ) ) {
        result = -1;
      }
      // compare by onTop property
      if( result === 0 ) {
        result = ( sh1._onTop ? 1 : 0 ) - ( sh2._onTop ? 1 : 0 );
      }
      // compare by appModal property
      if( result === 0 ) {
        result = ( sh1._appModal ? 1 : 0 ) - ( sh2._appModal ? 1 : 0 );
      }
      // compare by top-level parent's z-order
      if( result === 0 ) {
        var top1 = sh1.getTopLevelShell();
        var top2 = sh2.getTopLevelShell();
        result = top1.getZIndex() - top2.getZIndex();
      }
      // compare by actual z-order
      if( result === 0 ) {
        result = sh1.getZIndex() - sh2.getZIndex();
      }
      return result;
    },

    MIN_ZINDEX : 1e5,

    MAX_ZINDEX : 1e7
  },

  destruct : function() {
    this.setParentShell( null );
    var connection = rwt.remote.Connection.getInstance();
    connection.removeEventListener( "send", this._onSend, this );
    var document = rwt.widgets.base.ClientDocument.getInstance();
    document.removeEventListener( "windowresize", this._onWindowResize, this );
    if( this.isCreated() ) {
      this.getElement().removeEventListener( "mousedown", this.__onwindowmousedown, false );
    }
  },

  members : {

    destroy : function() {
      this.doClose();
      this.getWindowManager().remove( this );
      this.base( arguments );
    },

    _onCreate : function() {
      this.getElement().addEventListener( "mousedown", this.__onwindowmousedown, false );
      this.removeEventListener( "create", this._onCreate, this );
    },

    // [if] Override to prevent the new open shell to automaticaly become
    // an active shell (see bug 297167).
    _beforeAppear : function() {
      rwt.widgets.base.Parent.prototype._beforeAppear.call( this );
      rwt.widgets.util.PopupManager.getInstance().update();
      var activeWindow = this.getWindowManager().getActiveWindow();
      this.getWindowManager().add( this );
      this.getWindowManager().setActiveWindow( activeWindow );
    },

    setDefaultButton : function( value ) {
      if( this._defaultButton != null ) {
        this._defaultButton.removeState( "default" );
      }
      this._defaultButton = value;
      if( this._defaultButton != null ) {
        this._defaultButton.addState( "default" );
      }
    },

    getDefaultButton : function() {
      return this._defaultButton;
    },

    setParentShell : function( parentShell ) {
      var oldParentShell = this._parentShell;
      this._parentShell = parentShell;
      var listener = rwt.widgets.Shell._onParentClose;
      if( oldParentShell != null ) {
        oldParentShell.removeEventListener( "close", listener, this );
      }
      if( parentShell != null ) {
        parentShell.addEventListener( "close", listener, this );
      }
      this.dispatchSimpleEvent( "parentShellChanged" );
    },

    isDisableResize : function() {
      return this._disableResize ? true : false;
    },

    setActiveControl : function( control ) {
      this._activeControl = control;
    },

    /** To be called after rwt_XXX states are set */
    initialize : function() {
      this.setShowCaption( this.hasState( "rwt_TITLE" ) );
      this._onTop = ( this._parentShell != null && this._parentShell._onTop )
                    || this.hasState( "rwt_ON_TOP" );
      this._appModal =    this.hasState( "rwt_APPLICATION_MODAL" )
                       || this.hasState( "rwt_PRIMARY_MODAL" )
                       || this.hasState( "rwt_SYSTEM_MODAL" );
    },

    // TODO [rst] Find a generic solution for state inheritance
    addState : function( state ) {
      this.base( arguments, state );
      if( this._isRelevantState( state ) ) {
        this._captionBar.addState( state );
        this._captionTitle.addState( state );
        this._minimizeButton.addState( state );
        this._maximizeButton.addState( state );
        this._restoreButton.addState( state );
        this._closeButton.addState( state );
        var blocker = this._getClientDocumentBlocker();
        if( blocker != null ) {
          blocker.addState( state );
        }
      }
    },

    removeState : function( state ) {
      this.base( arguments, state );
      if( this._isRelevantState( state ) ) {
        this._captionBar.removeState( state );
        this._captionTitle.removeState( state );
        this._minimizeButton.removeState( state );
        this._maximizeButton.removeState( state );
        this._restoreButton.removeState( state );
        this._closeButton.removeState( state );
        var blocker = this._getClientDocumentBlocker();
        if( blocker != null ) {
          blocker.removeState( state );
        }
      }
    },

    _getClientDocumentBlocker : function() {
      var result = null;
      if(    this._appModal
          && rwt.widgets.Shell._upperModalShell == this )
      {
        result = this.getTopLevelWidget()._getBlocker();
      }
      return result;
    },

    _isRelevantState : function( state ) {
      return    state == "active"
             || state == "maximized"
             || state == "minimized"
             || state.substr( 0, 8 ) == "variant_"
             || state.substr( 0, 4 ) == "rwt_";
    },

    /**
     * Overrides rwt.widgets.base.Window#close()
     *
     * Called when user tries to close the shell.
     */
    close : function() {
      if( !rwt.remote.EventUtil.getSuspended() ) {
        rwt.remote.Connection.getInstance().getRemoteObject( this ).notify( "Close" );
      }
    },

    /**
     * Really closes the shell.
     */
    doClose : function() {
      // Note [rst]: Fixes bug 232977
      // Background: There are situations where a shell is disposed twice, thus
      // doClose is called on an already disposed shell at the second time
      if( !this.isDisposed() ) {
        this.hide();
        if( this.hasEventListeners( "close" ) ) {
          var event = new rwt.event.DataEvent( "close", this );
          this.dispatchEvent( event, true );
        }
        var wm = this.getWindowManager();
        rwt.widgets.Shell.reorderShells( wm );
      }
    },

    _onChangeActiveChild : function( evt ) {
      // Work around qooxdoo bug #254: the changeActiveChild is fired twice when
      // a widget was activated by keyboard (getData() is null in this case)
      var widget = this._getParentControl( evt.getValue() );
      if(    !rwt.remote.EventUtil.getSuspended()
          && widget != null
          && widget !== this._activeControl )
      {
        this._notifyDeactivate( this._activeControl, widget );
        var id = rwt.remote.WidgetManager.getInstance().findIdByWidget( widget );
        var remoteObject = rwt.remote.Connection.getInstance().getRemoteObject( this );
        remoteObject.set( "activeControl", id );
        this._notifyActivate( this._activeControl, widget );
        this._activeControl = widget;
      }
    },

    _notifyDeactivate : function( oldActive, newActive ) {
      var target = oldActive;
      while( target != null && !this._hasDeactivateListener( target ) ) {
        if( target.getParent ) {
          target = target.getParent();
        } else {
          target = null;
        }
      }
      if( target != null && !target.contains( newActive ) ) {
        var remoteObject = rwt.remote.Connection.getInstance().getRemoteObject( target );
        remoteObject.notify( "Deactivate" );
      }
    },

    _notifyActivate : function( oldActive, newActive ) {
      var target = newActive;
      while( target != null && !this._hasActivateListener( target ) ) {
        if( target.getParent ) {
          target = target.getParent();
        } else {
          target = null;
        }
      }
      if( target != null && !target.contains( oldActive ) ) {
        var remoteObject = rwt.remote.Connection.getInstance().getRemoteObject( target );
        remoteObject.notify( "Activate" );
      }
    },

    _hasDeactivateListener : function( widget ) {
      return widget.getUserData( "deactivateListener" ) === true;
    },

    _hasActivateListener : function( widget ) {
      return widget.getUserData( "activateListener" ) === true;
    },

    _onChangeFocusedChild : function() {
      if( rwt.remote.EventUtil.getSuspended() ) {
        this._focusControl = this.getFocusedChild();
      }
    },

    _onChangeActive : function( evt ) {
      // TODO [rst] This hack is a workaround for bug 345 in qooxdoo, remove this
      //      block as soon as the bug is fixed.
      //      See http://bugzilla.qooxdoo.org/show_bug.cgi?id=345
      if( !this.getActive() && !isFinite( this.getZIndex() ) ) {
        this.setZIndex( 1e8 );
      }
      // end of workaround
      if( !rwt.remote.EventUtil.getSuspended() && this.getActive() ) {
        rwt.remote.Connection.getInstance().getRemoteObject( this ).notify( "Activate" );
      }
      var active = evt.getValue();
      if( active ) {
        // workaround: Do not activate Shells that are blocked by a modal Shell
        var modalShell = rwt.widgets.Shell._upperModalShell;
        if( modalShell != null && modalShell.getZIndex() > this.getZIndex() ) {
          this.setActive( false );
          modalShell.setActive( true );
        }
        // end of workaround
      }
    },

    _applyMode : function( value, oldValue ) {
      var mode = value == null ? "normal" : value;
      rwt.remote.Connection.getInstance().getRemoteObject( this ).set( "mode", mode );
      var document = rwt.widgets.base.ClientDocument.getInstance();
      if( value == "maximized" ) {
        // User may change browser window size during long running request (before windowresize
        // listener is attached). Sync current shell bounds back to server - see bug 440948.
        this._sendBoundsTimer.start();
        document.addEventListener( "windowresize", this._onWindowResize, this );
      } else {
        document.removeEventListener( "windowresize", this._onWindowResize, this );
      }
      this.base( arguments, value, oldValue );
    },

    _onWindowResize : function() {
      this._sendResizeDelayed = true;
      this._sendResizeFlag = true;
      this._sendBounds();
    },

    _onChangeSize : function() {
      if( !rwt.remote.EventUtil.getSuspended() ) {
        this._sendResizeFlag = true;
        this._sendBoundsTimer.start();
      }
    },

    _onChangeLocation : function() {
      if( !rwt.remote.EventUtil.getSuspended() ) {
        this._sendMoveFlag = true;
        this._sendBoundsTimer.start();
      }
    },

    _sendBounds : function() {
      this._sendBoundsTimer.stop();
      var left = this._parseNumber( this.getLeft() );
      var top = this._parseNumber( this.getTop() );
      var height = this._parseNumber( this.getHeightValue() );
      var width = this._parseNumber( this.getWidthValue() );
      var remoteObject = rwt.remote.Connection.getInstance().getRemoteObject( this );
      remoteObject.set( "bounds", [ left, top, width, height ] );
      if( this._sendMoveFlag ) {
        remoteObject.notify( "Move", {} );
      }
      if( this._sendResizeFlag ) {
        remoteObject.notify( "Resize", {}, this._sendResizeDelayed ? 500 : undefined );
      }
      this._sendMoveFlag  = false;
      this._sendResizeFlag = false;
      this._sendResizeDelayed = false;
    },

    _parseNumber : function( value ) {
      var result = parseInt( value, 10 );
      return isNaN( result ) ? 0 : result;
    },

    _onKeydown : function( evt ) {
      var keyId = evt.getKeyIdentifier();
      if(    keyId == "Enter"
          && !evt.isShiftPressed()
          && !evt.isAltPressed()
          && !evt.isCtrlPressed()
          && !evt.isMetaPressed() )
      {
        var defButton = this.getDefaultButton();
        if( defButton != null && defButton.isSeeable() && defButton.getEnabled() ) {
          defButton.setFocused( true );
          defButton.execute();
        }
      } else if( keyId == "Escape" && this._parentShell != null ) {
        this.close();
      }
    },

    _onSend : function() {
      if( this.getActive() ) {
        var focusedChild = this.getFocusedChild();
        if( focusedChild != null && focusedChild != this._focusControl ) {
          this._focusControl = focusedChild;
          var widgetManager = rwt.remote.WidgetManager.getInstance();
          var focusedChildId = widgetManager.findIdByWidget( focusedChild );
          var server = rwt.remote.Connection.getInstance();
          var serverDisplay = server.getRemoteObject( rwt.widgets.Display.getCurrent() );
          serverDisplay.set( "focusControl", focusedChildId );
        }
      }
    },

    /**
     * Returns the parent Control for the given widget. If widget is a Control
     * itself, the widget is returned. Otherwise its parent is returned or null
     * if there is no parent
     */
    _getParentControl : function( widget ) {
      var widgetMgr = rwt.remote.WidgetManager.getInstance();
      var result = widget;
      while( result != null && !widgetMgr.isControl( result ) ) {
        if( result.getParent ) {
          result = result.getParent();
        } else {
          result = null;
        }
      }
      return result;
    },

    /**
     * Returns true if the receiver is a dialog shell of the given parent shell,
     * directly or indirectly.
     */
    isDialogOf : function( shell ) {
      var result = false;
      var parentShell = this._parentShell;
      while( !result && parentShell != null ) {
        result = shell === parentShell;
        parentShell = parentShell._parentShell;
      }
      return result;
    },

    /**
     * Returns the top-level shell if the receiver is a dialog or the shell
     * itself if it is a top-level shell.
     */
    getTopLevelShell : function() {
      var result = this;
      while( result._parentShell != null ) {
        result = result._parentShell;
      }
      return result;
    },

    /* TODO [rst] Revise when upgrading: overrides the _sendTo() function in
     *      superclass Window to allow for always-on-top.
     *      --> http://bugzilla.qooxdoo.org/show_bug.cgi?id=367
     */
    _sendTo : function() {
      rwt.widgets.Shell.reorderShells( this.getWindowManager() );
    },

    /*
     * Overwrites Popup#bringToFront
     */
    bringToFront : function() {
      var targetShell = this;
      while( targetShell._parentShell != null ) {
        targetShell = targetShell._parentShell;
      }
      this._setRenderZIndex( false );
      this.setZIndex( rwt.widgets.Shell.MAX_ZINDEX + 1 );
      targetShell.setZIndex( rwt.widgets.Shell.MAX_ZINDEX + 1 );
      rwt.widgets.Shell.reorderShells( this.getWindowManager() );
      this._setRenderZIndex( true );
    },

    _applyZIndex : function( newValue, oldValue ) {
      if( this._renderZIndex ) {
        this.base( arguments, newValue, oldValue );
      }
    },

    _setRenderZIndex : function( value ) {
       // Needed to prevent flickering during display-overlay animations.
      this._renderZIndex = value;
      if( value ) {
        this._applyZIndex( this.getZIndex() );
      }
    },

    /*
     * E X P E R I M E N T A L
     * (for future PRIMARY_MODAL support)
     */
    setBlocked : function( blocked ) {
      if( blocked ) {
        if( !this._blocker ) {
          this._blocker = new rwt.widgets.base.Parent();
          this._blocker.setAppearance( "client-document-blocker" );
          this.add( this._blocker );
        }
        this._blocker.setSpace( 0, 0, 10000, 10000 );
        this._blocker.setZIndex( 1000 );
      } else {
        if( this._blocker ) {
          this.remove( this._blocker );
          this._blocker.destroy();
          this._blocker = null;
        }
      }
    },

    setFullScreen : function( fullScreen ) {
      if( fullScreen ) {
        this._captionBar.setDisplay( false );
      } else {
        this._captionBar.setDisplay( this.hasState( "rwt_TITLE" ) );
      }
    }

  }
} );

/*******************************************************************************
 * Copyright (c) 2011, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.remote.HandlerRegistry.add( "rwt.widgets.Shell", {

  factory : function( properties ) {
    var adapterUtil = rwt.remote.HandlerUtil;
    var styles = adapterUtil.createStyleMap( properties.style );
    var result = new rwt.widgets.Shell( styles );
    adapterUtil.addStatesForStyles( result, properties.style );
    result.setUserData( "isControl", true );
    adapterUtil.callWithTarget( properties.parentShell, function( parentShell ) {
      if( parentShell ) {
        result.setParentShell( parentShell );
      }
      result.initialize();
    } );
    return result;
  },

  destructor : rwt.remote.HandlerUtil.getControlDestructor(),

  getDestroyableChildren : rwt.remote.HandlerUtil.getDestroyableChildrenFinder(),

  properties : rwt.remote.HandlerUtil.extendControlProperties( [
    "showMinimize",
    "allowMinimize",
    "showMaximize",
    "allowMaximize",
    "showClose",
    "allowClose",
    "resizable",
    "image",
    "text",
    "alpha",
    "active",
    "mode",
    "hasShellListener",
    "minimumSize",
    "defaultButton",
    "activeControl"
  ] ),

  propertyHandler : rwt.remote.HandlerUtil.extendControlPropertyHandler( {
    // Overwrites original bounds handler, see bug 306042 and 354597
    "bounds" : function( widget, value ) {
      if( !widget.isDisableResize() ) {
        widget.setLeft( value[ 0 ] );
        widget.setTop( value[ 1 ] );
        widget.setWidth( value[ 2 ] );
        widget.setHeight( value[ 3 ] );
      }
    },
    "alpha" : function( shell, alpha ) {
      shell.setOpacity( alpha / 255 );
    },
    "defaultButton" : function( shell, value ) {
      rwt.remote.HandlerUtil.callWithTarget( value, function( widget ) {
        shell.setDefaultButton( widget );
      } );
    },
    "activeControl" : function( shell, value ) {
      rwt.remote.HandlerUtil.callWithTarget( value, function( widget ) {
        shell.setActiveControl( widget );
      } );
    },
    "mode" : function( shell, value ) {
      var fullscreen = value === "fullscreen";
      shell.setMode( fullscreen ? "maximized" : value );
      shell.setFullScreen( fullscreen );
    },
    "minimumSize" : function( shell, value ) {
      shell.setMinWidth( value[ 0 ] );
      shell.setMinHeight( value[ 1 ] );
    },
    "text" : function( shell, value ) {
      var text = rwt.util.Encoding.escapeText( value, false );
      shell.setCaption( text );
    },
    "image" : function( shell, value ) {
      if( value === null ) {
        shell.setIcon( value );
      } else {
        shell.setIcon( value[ 0 ] );
      }
    },
    "visibility" : function( shell, value ) {
      if( value ) {
        shell.show();
      } else {
        shell.hide();
      }
      rwt.widgets.Shell.reorderShells( shell.getWindowManager() );
    }
  } ),

  events : [ "Activate", "Close", "Resize", "Move" ],

  listeners : rwt.remote.HandlerUtil.extendControlListeners( [] ),

  listenerHandler : rwt.remote.HandlerUtil.extendControlListenerHandler( {} )

} );

/*******************************************************************************
 * Copyright (c) 2002, 2014 Innoopract Informationssysteme GmbH and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Innoopract Informationssysteme GmbH - initial API and implementation
 *    EclipseSource - ongoing development
 ******************************************************************************/

(function(){

var $ = rwt.util.RWTQuery;

rwt.qx.Class.define( "rwt.widgets.ProgressBar", {
  extend : rwt.widgets.base.Parent,

  construct : function( vertical, indeterminate ) {
    this.base( arguments );
    this.$el = $( this );
    this._indet = indeterminate || false;
    this._vertical = vertical || false;
    this._minimum = 0;
    this._maximum = 100;
    this._selection = 0;
    this._createIndicator();
    this._createTimer();
    this.setOverflow( "hidden" );
    this.setState( "normal" );
    this.setAppearance( "progressbar" );
  },

  destruct : function() {
    if( this._timer != null ) {
      this._timer.dispose();
    }
    this._timer = null;
  },

  statics : {
    UNDETERMINED_SIZE : 40
  },

  properties : {

    indicatorColor : {
      nullable : true,
      init : null,
      apply : "_applyIndicatorColor",
      themeable : true
    },

    indicatorImage : {
      nullable : true,
      init : null,
      apply : "_applyIndicatorImage",
      themeable : true
    },

    indicatorGradient : {
      nullable : true,
      init : null,
      apply : "_applyIndicatorGradient",
      themeable : true
    },

    indicatorOpacity : {
      nullable : true,
      init : 1,
      apply : "_applyIndicatorOpacity",
      themeable : true
    }

  },

  members : {

    setMinimum : function( minimum ) {
      this._minimum = minimum;
      this.addToQueue( "indicatorSelection" );
      this.dispatchSimpleEvent( "minimumChanged" );
    },

    setMaximum : function( maximum ) {
      this._maximum = maximum;
      this.addToQueue( "indicatorSelection" );
      this.dispatchSimpleEvent( "maximumChanged" );
    },

    setSelection : function( selection ) {
      this._selection = selection;
      this.addToQueue( "indicatorSelection" );
      this.dispatchSimpleEvent( "selectionChanged", this );
      this.dispatchSimpleEvent( "updateToolTip", this );
    },

    getMinimum : function() {
      return this._minimum;
    },

    getMaximum : function() {
      return this._maximum;
    },

    getSelection : function() {
      return this._selection;
    },

    setState : function( state ) {
      if( state == "error" ) {
        this.removeState( "normal" );
        this.removeState( "paused" );
        this.addState( "error" );
      } else if( state == "paused" ) {
        this.removeState( "normal" );
        this.removeState( "error" );
        this.addState( "paused" );
      } else {
        this.removeState( "error" );
        this.removeState( "paused" );
        this.addState( "normal" );
      }
    },

    getToolTipTargetBounds : function() {
      if( this.isVertical() ) {
        return {
          "top" : this.getBoxHeight() - this._cachedBorderLeft - this._indicator.offsetHeight,
          "left" : 0,
          "width" : this.getBoxWidth(),
          "height" : 1
        };
      } else if( this.isIndeterminate() ) {
        return {
          "left" : 0,
          "top" : 0,
          "width" : this.getBoxWidth(),
          "height" : this.getBoxHeight()
        };
      } else {
        return {
          "left" : this._cachedBorderLeft + this._indicator.offsetWidth,
          "top" : 0,
          "width" : 1,
          "height" : this.getBoxHeight()
        };
      }
    },

    isIndeterminate : function() {
      return this._indet;
    },

    isHorizontal : function() {
      return !this._vertical;
    },

    isVertical : function() {
      return this._vertical;
    },

    _applyIndicatorColor : function( value ) {
      this.$indicator.css( "backgroundColor", value || "" );
    },

    _applyIndicatorImage : function( value ) {
      this.$indicator.css( "backgroundImage", value || "" );
    },

    _applyIndicatorGradient : function( value ) {
      this.$indicator.css( "backgroundGradient", value || "" );
    },

    _applyIndicatorOpacity : function( value ) {
      this.$indicator.css( "opacity", value || "" );
    },

    _onInterval : function() {
      if( this.isSeeable() ) {
        this._animPosition += 1;
        var max = this._vertical ? this.getHeight() : this.getWidth();
        if( this._animPosition > max ) { // we can reasonably ignore the border
          this._animPosition = rwt.widgets.ProgressBar.UNDETERMINED_SIZE * -1;
        }
        this._renderIndicatorSelection();
      }
    },

    _layoutPost : function( changes ) {
      if( changes.indicatorSelection || changes.initial ) {
        this._renderIndicatorSelection();
      }
    },

    _createIndicator : function() {
      this._indicator = document.createElement( "div" );
      this.$el.append( this._indicator );
      this.$indicator = $( this._indicator );
      this.$indicator.css( "position", "absolute" );
      if( this._vertical ) {
        this.$indicator.css( {
          "left" : 0,
          "top" : "auto",
          "width" : "100%"
        } );
      } else {
        this.$indicator.css( {
          "top" : 0 ,
          "height" : "100%",
          "bottom" : "auto"
        } );
      }
    },

    _createTimer : function() {
      if( this._indet ) {
        this._animPosition = rwt.widgets.ProgressBar.UNDETERMINED_SIZE * -1;
        this._timer = new rwt.client.Timer( 30 );
        this._timer.addEventListener( "interval", this._onInterval, this );
        this._timer.start();
      }
    },

    _renderIndicatorSelection : function() {
      var length = this._computeIndicatorCssLength();
      var offset = this._computeIndicatorCssOffset();
      if( this._vertical ) {
        this.$indicator.css( {
          "height" : length,
          "bottom" : offset
        } );
      } else {
        this.$indicator.css( {
          "width" : length,
          "left" : offset
        } );
      }
    },

    _computeIndicatorCssLength : function() {
      if( this.isIndeterminate() ) {
        return rwt.widgets.ProgressBar.UNDETERMINED_SIZE;
      }
      var selected = this._selection - this._minimum;
      var max = this._maximum - this._minimum;
      return Math.floor( 100 * selected / max ) + "%";
    },

    _computeIndicatorCssOffset : function() {
      return this.isIndeterminate() ? this._animPosition : 0;
    }

  }

} );

}());

/*******************************************************************************
 * Copyright (c) 2011, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.remote.HandlerRegistry.add( "rwt.widgets.ProgressBar", {

  factory : function( properties ) {
    var result = new rwt.widgets.ProgressBar(
      properties.style && properties.style.indexOf( "VERTICAL" ) !== -1,
      properties.style && properties.style.indexOf( "INDETERMINATE" ) !== -1
    );
    rwt.remote.HandlerUtil.addStatesForStyles( result, properties.style );
    result.setUserData( "isControl", true );
    rwt.remote.HandlerUtil.setParent( result, properties.parent );
    return result;
  },

  destructor : rwt.remote.HandlerUtil.getControlDestructor(),

  getDestroyableChildren : rwt.remote.HandlerUtil.getDestroyableChildrenFinder(),

  properties : rwt.remote.HandlerUtil.extendControlProperties( [
    // [if] Important: Order matters - minimum, maximum, selection
    "minimum",
    "maximum",
    /**
     * @name setSelection
     * @methodOf ProgressBar#
     * @description Sets the 'selection', which is the receiver's value, to the argument which
     * must be greater than or equal to zero.
     * @param {int} selection the new selection (must be zero or greater)
     */
    "selection",
    "state"
  ] ),

  propertyHandler : rwt.remote.HandlerUtil.extendControlPropertyHandler( {} ),

  listeners : rwt.remote.HandlerUtil.extendControlListeners( [] ),

  listenerHandler : rwt.remote.HandlerUtil.extendControlListenerHandler( {} ),

  methods: [ "addListener", "removeListener" ],

  methodHandler : rwt.remote.HandlerUtil.extendListenerMethodHandler( {} ),

  /**
   * @class RWT Scripting analoge to org.eclipse.swt.widgets.Progressbar
   * @name ProgressBar
   * @extends Control
   * @description The constructor is not public.
   * @since 2.2
   */
  scriptingMethods : rwt.remote.HandlerUtil.extendControlScriptingMethods(
    /** @lends ProgressBar.prototype */
  {
     /**
      * @description Returns the 'selection', which is the receiver's position.
      * @return {int} the selection
      */
     getSelection : function() {
      return this._selection;
    },
     /**
      * @description Returns the maximum value which the receiver will allow.
      * @return {int} the maximum
      */
     getMaximum : function() {
      return this._maximum;
    },
     /**
      * @description Returns the minimum value which the receiver will allow.
      * @return {int} the minimum
      */
     getMinimum : function() {
      return this._minimum;
    }
  } )

} );

/*******************************************************************************
 * Copyright (c) 2009, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.qx.Class.define( "rwt.widgets.Link", {

  extend : rwt.widgets.base.Terminator,

  construct : function() {
    this.base( arguments );
    this.setAppearance( "link" );
    this._text = "";
    this._hyperlinksHaveListeners = false;
    this._readyToSendChanges = true;
    this._focusedLinkIndex = -1;
    this._linksCount = 0;
    this.setSelectable( false );
    this.setHideFocus( true );
    this.__onMouseDown = rwt.util.Functions.bind( this._onMouseDown, this );
    this.__onMouseOver = rwt.util.Functions.bind( this._onMouseOver, this );
    this.__onMouseOut = rwt.util.Functions.bind( this._onMouseOut, this );
    this.__onKeyDown = rwt.util.Functions.bind( this._onKeyDown, this );
    this.addEventListener( "create", this._onCreate, this );
    this.addEventListener( "changeEnabled", this._onChangeEnabled, this );
    this.addEventListener( "keypress", this._onKeyPress );
    this.addEventListener( "focusout", this._onFocusOut );
  },

  destruct : function() {
    this._removeEventListeners();
    delete this.__onMouseDown;
    delete this.__onMouseOver;
    delete this.__onMouseOut;
    delete this.__onKeyDown;
  },

  members : {

    _onCreate : function() {
      this._renderText();
    },

    _applyTextColor : function( value, old ) {
      this.base( arguments, value, old );
      this._applyHyperlinksStyleProperties();
    },

    _onChangeEnabled : function() {
      this._applyHyperlinksStyleProperties();
      this._changeHyperlinksTabIndexProperty();
    },

    _getStates : function() {
      if( !this.__states ) {
        this.__states = {};
      }
      return this.__states;
    },

    addText : function( text ) {
      this._text += text;
    },

    addLink : function( text, index ) {
      var widgetManager = rwt.remote.WidgetManager.getInstance();
      var id = widgetManager.findIdByWidget( this ) + "#" + index;
      this._text += "<span tabIndex=\"1\" ";
      this._text += "id=\"" + id + "\"";
      this._text += ">";
      this._text += text;
      this._text += "</span>";
      this._linksCount++;
    },

    applyText : function() {
      this._renderText();
      if( this._linksCount === 0 ) {
        this.setTabIndex( null );
      } else {
        this.setTabIndex( 1 );
      }
    },

    clear : function() {
      this._removeEventListeners();
      this._text = "";
      this._linksCount = 0;
      this._focusedLinkIndex = -1;
    },

    _renderText : function() {
      if( this._isCreated ) {
        this._getTargetNode().innerHTML = this._text;
        this._applyHyperlinksStyleProperties();
        this._addEventListeners();
      }
    },

    _applyFont : function( value ) {
      if( value ) {
        value.render( this );
      } else {
        rwt.html.Font.reset( this );
      }
    },

    _applyHyperlinksStyleProperties : function() {
      var style = this._getHyperlinkStyle( false );
      var hyperlinks = this._getHyperlinkElements();
      for( var i = 0; i < hyperlinks.length; i++ ) {
        rwt.html.Style.setStyleProperty( hyperlinks[ i ], "color", style.textColor );
        rwt.html.Style.setTextShadow( hyperlinks[ i ], style.textShadow );
        rwt.html.Style.setStyleProperty( hyperlinks[ i ], "cursor", style.cursor );
        rwt.html.Style.setStyleProperty( hyperlinks[ i ], "textDecoration", style.textDecoration );
      }
    },

    _changeHyperlinksTabIndexProperty : function() {
      var hyperlinks = this._getHyperlinkElements();
      for( var i = 0; i < hyperlinks.length; i++ ) {
        if( this.isEnabled() ) {
          hyperlinks[ i ].tabIndex = "1";
        } else {
          hyperlinks[ i ].tabIndex = "-1";
        }
      }
    },

    // TODO [tb] : This is way more complicated than it needs to be.
    //             There is no need to work on DOM-level except when handling the event.
    _addEventListeners : function() {
      var hyperlinks = this._getHyperlinkElements();
      if( hyperlinks.length > 0 && !this._hyperlinksHaveListeners ) {
        for( var i = 0; i < hyperlinks.length; i++ ) {
          hyperlinks[ i ].addEventListener( "mousedown", this.__onMouseDown, false );
          hyperlinks[ i ].addEventListener( "mouseover", this.__onMouseOver, false );
          hyperlinks[ i ].addEventListener( "mouseout", this.__onMouseOut, false );
          hyperlinks[ i ].addEventListener( "keydown", this.__onKeyDown, false );
        }
        this._hyperlinksHaveListeners = true;
      }
    },

    _removeEventListeners : function() {
      var hyperlinks = this._getHyperlinkElements();
      if( hyperlinks.length > 0 && this._hyperlinksHaveListeners ) {
        for( var i = 0; i < hyperlinks.length; i++ ) {
          hyperlinks[ i ].removeEventListener( "mousedown", this.__onMouseDown, false );
          hyperlinks[ i ].removeEventListener( "mouseover", this.__onMouseOver, false );
          hyperlinks[ i ].removeEventListener( "mouseout", this.__onMouseOut, false );
          hyperlinks[ i ].removeEventListener( "keydown", this.__onKeyDown, false );
        }
        this._hyperlinksHaveListeners = false;
      }
    },

    _onMouseDown : function( event ) {
      try {
        if( this.isEnabled() && this._isLeftMouseButtonPressed( event ) ) {
          var index = this._getLinkIndex( event.target );
          this._setFocusedLink( index );
          if( this._readyToSendChanges ) {
            // [if] Fix for bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=252559
            this._readyToSendChanges = false;
            rwt.client.Timer.once( function() {
              this._sendChanges( index );
            }, this, rwt.remote.EventUtil.DOUBLE_CLICK_TIME );
          }
        }
      } catch( ex ) {
        rwt.runtime.ErrorHandler.processJavaScriptError( ex );
      }
    },

    _onMouseOver : function( event ) {
      try {
        var style = this._getHyperlinkStyle( true );
        rwt.html.Style.setStyleProperty( event.target, "textDecoration", style.textDecoration );
      } catch( ex ) {
        rwt.runtime.ErrorHandler.processJavaScriptError( ex );
      }
    },

    _onMouseOut : function( event ) {
      try {
        var style = this._getHyperlinkStyle( false );
        rwt.html.Style.setStyleProperty( event.target, "textDecoration", style.textDecoration );
      } catch( ex ) {
        rwt.runtime.ErrorHandler.processJavaScriptError( ex );
      }
    },

    _isLeftMouseButtonPressed : function( event ) {
      var result = false;
      if( event.which ) {
        result = ( event.which === 1 );
      } else if( event.button ) {
        result = ( event.button === 0 );
      }
      return result;
    },

    _onKeyDown : function( event ) {
      try {
        if( this.isEnabled() && event.keyCode === 13 ) {
          var index = this._getLinkIndex( event.target );
          this._sendChanges( index );
        }
      } catch( ex ) {
        rwt.runtime.ErrorHandler.processJavaScriptError( ex );
      }
    },

    _getLinkIndex : function( element ) {
      var id = element.id;
      var index = id.substr( id.lastIndexOf( "#" ) + 1 );
      return parseInt( index, 10 );
    },

    _getHyperlinkStyle : function( hover ) {
      var states = this._getStates();
      if( hover ) {
        states[ "over" ] = true;
      } else {
        delete states[ "over" ];
      }
      var manager = rwt.theme.AppearanceManager.getInstance();
      return manager.styleFrom( "link-hyperlink", states );
    },

    // Override of the _ontabfocus method from rwt.widgets.base.Widget
    _ontabfocus : function() {
      if( this._focusedLinkIndex === -1 && this._linksCount > 0 ) {
        this._setFocusedLink( 0 );
      }
    },

    _onKeyPress : function( event ) {
      if( this.isFocused() && event.getKeyIdentifier() === "Tab" && this._linksCount > 0 ) {
        var index = this._focusedLinkIndex;
        if( !event.isShiftPressed() && index >= 0 && index < this._linksCount - 1 ) {
          event.stopPropagation();
          event.preventDefault();
          this._setFocusedLink( index + 1 );
        } else if( !event.isShiftPressed() && index === -1 ) {
          event.stopPropagation();
          event.preventDefault();
          this._setFocusedLink( 0 );
        } else if( event.isShiftPressed() && index > 0 && index <= this._linksCount - 1 ) {
          event.stopPropagation();
          event.preventDefault();
          this._setFocusedLink( index - 1 );
        }
      }
    },

    _onFocusOut : function() {
      this._setFocusedLink( -1 );
    },

    _setFocusedLink : function( index ) {
      var hyperlink = this._getFocusedHyperlinkElement();
      if( hyperlink !== null ) {
        hyperlink.blur();
        hyperlink.style.outline = "none";
      }
      this._focusedLinkIndex = index;
      hyperlink = this._getFocusedHyperlinkElement();
      if( hyperlink !== null ) {
        hyperlink.focus();
        hyperlink.style.outline = "1px dotted";
      }
    },

    _getFocusedHyperlinkElement : function() {
      var result = null;
      var hyperlinks = this._getHyperlinkElements();
      var index = this._focusedLinkIndex;
      if( index >= 0 && index < hyperlinks.length ) {
        result = hyperlinks[ index ];
      }
      return result;
    },

    _getHyperlinkElements : function() {
      var result;
      var linkElement = this.getElement();
      if( linkElement ) {
        result = linkElement.getElementsByTagName( "span" );
      } else {
        result = [];
      }
      return result;
    },

    _sendChanges : function( index ) {
      rwt.remote.EventUtil.notifySelected( this, { "index" : index } );
      this._readyToSendChanges = true;
    }

  }

} );

/*******************************************************************************
 * Copyright (c) 2011, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.remote.HandlerRegistry.add( "rwt.widgets.Link", {

  factory : function( properties ) {
    var result = new rwt.widgets.Link();
    rwt.remote.HandlerUtil.addStatesForStyles( result, properties.style );
    result.setUserData( "isControl", true );
    rwt.remote.HandlerUtil.setParent( result, properties.parent );
    return result;
  },

  destructor : rwt.remote.HandlerUtil.getControlDestructor(),

  getDestroyableChildren : rwt.remote.HandlerUtil.getDestroyableChildrenFinder(),

  properties : rwt.remote.HandlerUtil.extendControlProperties( [
    "text"
  ] ),

  propertyHandler : rwt.remote.HandlerUtil.extendControlPropertyHandler( {
    "text" : function( widget, value ) {
      var EncodingUtil = rwt.util.Encoding;
      widget.clear();
      for (var i = 0; i < value.length; i++ ) {
        var text = EncodingUtil.escapeText( value[ i ][ 0 ], false );
        text = EncodingUtil.replaceNewLines( text, "<br/>" );
        var index = value[ i ][ 1 ];
        if( index !== null ) {
          widget.addLink( text, index );
        } else {
          widget.addText( text );
        }
      }
      widget.applyText();
    }
  } ),

  events : [ "Selection" ],

  listeners : rwt.remote.HandlerUtil.extendControlListeners( [] ),

  listenerHandler : rwt.remote.HandlerUtil.extendControlListenerHandler( {} )

} );

/*******************************************************************************
 * Copyright (c) 2004, 2014 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          and EclipseSource
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v1.0 which accompanies this
 * distribution, and is available at http://www.eclipse.org/legal/epl-v10.html
 *
 *  Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

( function( $ ) {

rwt.qx.Class.define( "rwt.widgets.base.Scrollable", {

  extend : rwt.widgets.base.Parent,

  construct : function( clientArea ) {
    this.base( arguments );
    this._ignoreScrollTo = [ -1, -1 ];
    this._clientArea = clientArea;
    this._horzScrollBar = new rwt.widgets.base.ScrollBar( true );
    this._vertScrollBar = new rwt.widgets.base.ScrollBar( false );
    this.$spacer = $( "<div>" ).css( {
      "position" : "absolute",
      "visibility" : "hidden",
      "width" : "1px",
      "height" : "1px"
    } );
    this._blockScrolling = false;
    this._internalChangeFlag = false;
    this.add( this._clientArea );
    this.add( this._horzScrollBar );
    this.add( this._vertScrollBar );
    rwt.widgets.util.ScrollBarsActivator.install( this );
    this._configureScrollBars();
    this._configureClientArea();
    this.__onscroll = rwt.util.Functions.bind( this._onscroll, this );
  },

  destruct : function() {
    var el = this._clientArea._getTargetNode();
    if( el ) {
      el.removeEventListener( "scroll", this.__onscroll, false );
      delete this.__onscroll;
    }
    this._clientArea = null;
    this._horzScrollBar = null;
    this._vertScrollBar = null;
    this.$spacer = null;
  },

  statics : {
    _nativeWidth : null,

    getNativeScrollBarWidth : function() {
      if( this._nativeWidth === null ) {
        var dummy = document.createElement( "div" );
        dummy.style.width = "100px";
        dummy.style.height = "100px";
        dummy.style.overflow = "scroll";
        dummy.style.visibility = "hidden";
        document.body.appendChild( dummy );
        this._nativeWidth = dummy.offsetWidth - dummy.clientWidth;
        document.body.removeChild( dummy );
      }
      return this._nativeWidth;
    }

  },

  members : {

    /////////
    // Public

    setScrollBarsVisible : function( horizontal, vertical ) {
      this._horzScrollBar.setDisplay( horizontal );
      this._vertScrollBar.setDisplay( vertical );
      this._clientArea.setStyleProperty( "overflowX", horizontal ? "scroll" : "hidden" );
      this._clientArea.setStyleProperty( "overflowY", vertical ? "scroll" : "hidden" );
      // Note: [if] Client area does not change its dimensions after show/hide scrollbars anymore.
      // To hide the native scrollbars schedule clientArea._layoutPost manually.
      this._clientArea.addToQueue( "layout" );
      this._syncSpacer();
      this._layoutX();
      this._layoutY();
    },

    setHBarSelection : function( value ) {
      this._internalChangeFlag = true;
      this._horzScrollBar.setValue( value );
      this._internalChangeFlag = false;
    },

    setVBarSelection : function( value ) {
      this._internalChangeFlag = true;
      this._vertScrollBar.setValue( value );
      this._internalChangeFlag = false;
    },

    setBlockScrolling : function( value ) {
      this._blockScrolling = value;
    },

    getVerticalBar : function() {
      return this._vertScrollBar;
    },

    getHorizontalBar : function() {
      return this._horzScrollBar;
    },

    isVerticalBarVisible : function() {
      return this._vertScrollBar.getDisplay();
    },

    isHorizontalBarVisible : function() {
      return this._horzScrollBar.getDisplay();
    },

    getHorizontalBarHeight : function() {
      return this._horzScrollBar.getDisplay() ? this._horzScrollBar.getHeight() : 0;
    },

    getVerticalBarWidth : function() {
      return this._vertScrollBar.getDisplay() ? this._vertScrollBar.getWidth() : 0;
    },

    /////////
    // Layout

    _configureClientArea : function() {
      this._clientArea.setStyleProperty( "overflowX", "scroll" );
      this._clientArea.setStyleProperty( "overflowY", "scroll" );
      this._clientArea.setLeft( 0 );
      this._clientArea.setTop( 0 );
      this._clientArea.addEventListener( "create", this._onClientCreate, this );
      this._clientArea.addEventListener( "appear", this._onClientAppear, this );
      // TOOD [tb] : Do this with an eventlistner after fixing Bug 327023
      this._clientArea._layoutPost = rwt.util.Functions.bind( this._onClientLayout, this );
    },

    _configureScrollBars : function() {
      var dragBlocker = function( event ) { event.stopPropagation(); };
      this._horzScrollBar.setZIndex( 1e8 );
      this._horzScrollBar.setLeft( 0 );
      this._horzScrollBar.addEventListener( "dragstart", dragBlocker );
      this._horzScrollBar.addEventListener( "changeValue", this._onHorzScrollBarChangeValue, this );
      this._horzScrollBar.addEventListener( "changeMaximum", this._syncSpacer, this );
      this._vertScrollBar.setZIndex( 1e8 );
      this._vertScrollBar.setTop( 0 );
      this._vertScrollBar.addEventListener( "dragstart", dragBlocker );
      this._vertScrollBar.addEventListener( "changeValue", this._onVertScrollBarChangeValue, this );
      this._vertScrollBar.addEventListener( "changeMaximum", this._syncSpacer, this );
    },

    _applyWidth : function( newValue, oldValue ) {
      this.base( arguments, newValue, oldValue );
      this._layoutX();
    },

    _applyHeight : function( newValue, oldValue ) {
      this.base( arguments, newValue, oldValue );
      this._layoutY();
    },

    _applyBorder : function( newValue, oldValue ) {
      this.base( arguments, newValue, oldValue );
      this._layoutX();
      this._layoutY();
    },

    _layoutX : function() {
      var clientWidth = this.getWidth() - this.getFrameWidth();
      this._clientArea.setWidth( clientWidth );
      this._vertScrollBar.setLeft( clientWidth - this._vertScrollBar.getWidth() );
      this._horzScrollBar.setWidth( clientWidth - this.getVerticalBarWidth() );
    },

    _layoutY : function() {
      var clientHeight = this.getHeight() - this.getFrameHeight();
      this._clientArea.setHeight( clientHeight );
      this._horzScrollBar.setTop( clientHeight - this._horzScrollBar.getHeight() );
      this._vertScrollBar.setHeight( clientHeight - this.getHorizontalBarHeight() );
    },

    _onClientCreate : function() {
      this._clientArea.prepareEnhancedBorder();
      this._clientArea.setContainerOverflow( false );
      var node = this._clientArea._getTargetNode();
      node.addEventListener( "scroll", this.__onscroll, false );
      this.$spacer.appendTo( node );
      $( node ).prop( "rwtScrollable", this );
      rwt.html.Scroll.disableScrolling( this._clientArea.getElement() );
    },

    _onClientLayout : ( function() {
      if( rwt.client.Client.isTrident() && rwt.client.Client.getMajor() === 9 ) {
        return function() {
          // NOTE [tb] : there is a bug in IE9 where the scrollbar is substracted from the inner
          //             size of an element, not added. Therefore add the barWidth twice.
          var barWidth = rwt.widgets.base.Scrollable.getNativeScrollBarWidth();
          var node = this._clientArea._getTargetNode();
          var el = this._clientArea.getElement();
          var width = parseInt( el.style.width, 10 );
          var height = parseInt( el.style.height, 10 );
          if( this._vertScrollBar.getDisplay() ) {
            width += ( 2 * barWidth );
          }
          if( this._horzScrollBar.getDisplay() ) {
            height += ( 2 * barWidth );
          }
          node.style.width = width + "px";
          node.style.height = height + "px";
        };
      } else {
        return function() {
          var barWidth = rwt.widgets.base.Scrollable.getNativeScrollBarWidth();
          var node = this._clientArea._getTargetNode();
          var el = this._clientArea.getElement();
          var width = parseInt( el.style.width, 10 );
          var height = parseInt( el.style.height, 10 );
          if( this._vertScrollBar.getDisplay() ) {
            width += barWidth;
          }
          if( this._horzScrollBar.getDisplay() ) {
            height += barWidth;
          }
          node.style.width = width + "px";
          node.style.height = height + "px";
        };
      }
    }() ),

    ////////////
    // Scrolling

    _onHorzScrollBarChangeValue : function() {
      if( this._isCreated ) {
        this._syncClientArea( true, false );
      }
      if( !this._internalChangeFlag ) {
        this.dispatchSimpleEvent( "userScroll", true );
      }
    },

    _onVertScrollBarChangeValue : function() {
      if( this._isCreated ) {
        this._syncClientArea( false, true );
      }
      if( !this._internalChangeFlag ) {
        this.dispatchSimpleEvent( "userScroll", false );
      }
    },

    _onClientAppear : function() {
      this._internalChangeFlag = true;
      this._syncClientArea( true, true );
      this._internalChangeFlag = false;
    },

    _onscroll : function( evt ) {
      try {
        var positionChanged =    this._ignoreScrollTo[ 0 ] !== this._clientArea.getScrollLeft()
                              || this._ignoreScrollTo[ 1 ] !== this._clientArea.getScrollTop();
        if( !this._internalChangeFlag && positionChanged ) {
          this._ignoreScrollTo = [ -1, -1 ];
          rwt.event.EventHandlerUtil.stopDomEvent( evt );
          var blockH = this._blockScrolling || !this._horzScrollBar.getDisplay();
          var blockV = this._blockScrolling || !this._vertScrollBar.getDisplay();
          this._internalChangeFlag = true;
          this._syncClientArea( blockH, blockV );
          this._internalChangeFlag = false;
          this._syncScrollBars();
          if( !this._blockScrolling ) {
            this.dispatchSimpleEvent( "scroll" );
          }
        }
      } catch( ex ) {
        rwt.runtime.ErrorHandler.processJavaScriptError( ex );
      }
    },

    _syncClientArea : function( horz, vert ) {
      if( horz && this._horzScrollBar != null ) {
        var scrollX = this._horzScrollBar.getValue();
        if( this._clientArea.getScrollLeft() !== scrollX ) {
          this._clientArea.setScrollLeft( scrollX );
        }
        var newScrollLeft = this._clientArea.getScrollLeft();
        this._ignoreScrollTo[ 0 ] = newScrollLeft;
        if( newScrollLeft !== scrollX ) {
          this.addToQueue( "hSync" );
        }
      }
      if( vert && this._vertScrollBar != null ) {
        var scrollY = this._vertScrollBar.getValue();
        if( this._clientArea.getScrollTop() !== scrollY ) {
          this._clientArea.setScrollTop( scrollY );
        }
        var newScrollTop = this._clientArea.getScrollTop();
        this._ignoreScrollTo[ 1 ] = newScrollTop;
        if( newScrollTop !== scrollY ) {
          this.addToQueue( "vSync" );
        }
      }
    },

    _layoutPost : function( changes ) {
      this.base( arguments, changes );
      if( changes.hSync || changes.vSync ) {
        // delay because this is still before the client area might get bigger in the display flush
        rwt.client.Timer.once( function() {
          this._internalChangeFlag = true;
          this._syncClientArea( changes.hSync, changes.vSync );
          this._internalChangeFlag = false;
        }, this, 0 );
      }
    },

    _syncScrollBars : function() {
      var scrollX = this._clientArea.getScrollLeft();
      this._horzScrollBar.setValue( scrollX );
      var scrollY = this._clientArea.getScrollTop();
      this._vertScrollBar.setValue( scrollY );
    },

    _syncSpacer : function() {
      this.$spacer.css( {
        "top" : this._vertScrollBar.getMaximum() + this.getHorizontalBarHeight(),
        "left" : this._horzScrollBar.getMaximum() + this.getVerticalBarWidth()
      } );
    }

  }

} );

}( rwt.util._RWTQuery ) );

/*******************************************************************************
 * Copyright (c) 2002, 2014 Innoopract Informationssysteme GmbH and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Innoopract Informationssysteme GmbH - initial API and implementation
 *    EclipseSource - ongoing development
 ******************************************************************************/

rwt.qx.Class.define( "rwt.widgets.ScrolledComposite", {
  extend : rwt.widgets.base.Scrollable,

  construct : function() {
    this.base( arguments, new rwt.widgets.base.Parent() );
    this.setScrollBarsVisible( false, false );
    this._clientArea.addEventListener( "mousewheel", this._onMouseWheel, this );
    this._clientArea.addEventListener( "keypress", this._onKeyPress, this );
    if( rwt.client.Client.supportsTouch() ) {
      this._clientArea.addEventListener( "mousedown", this._onTouch, this );
    }
    this.addEventListener( "userScroll", this._onUserScroll );
    this._content = null;
    this._requestTimerRunning = false;
    this._showFocusedControl = false;
    this._focusRoot = null;
    this.addEventListener( "changeParent", this._onChangeParent, this );
    this.setAppearance( "scrolledcomposite" );
  },

  members : {

    /////////
    // Public

    setShowFocusedControl : function( value ) {
      this._showFocusedControl = value;
    },

    setContent : function( widget ) {
      if( this._content != null ) {
        this._content.removeEventListener( "changeParent", this._onContentRemove, this );
        this._content.removeEventListener( "changeWidth", this._onContentResize, this );
        this._content.removeEventListener( "changeHeight", this._onContentResize, this );
        this._clientArea.remove( this._content );
      }
      this._content = widget;
      this._onContentResize();
      if( this._content != null ) {
        this._clientArea.add( this._content );
        this._content.addEventListener( "changeParent", this._onContentRemove, this );
        this._content.addEventListener( "changeWidth", this._onContentResize, this );
        this._content.addEventListener( "changeHeight", this._onContentResize, this );
      }
    },

    ///////////////
    // Eventhandler

    _onContentRemove : function() {
      this.setContent( null );
    },

    _onContentResize : function() {
      if(    this._content !== null
          && typeof this._content.getWidth() === "number"
          && typeof this._content.getHeight() === "number" )
      {
        var maxWidth = this._content.getWidth();
        var maxHeight = this._content.getHeight();
        this._horzScrollBar.setMaximum( maxWidth );
        this._vertScrollBar.setMaximum( maxHeight );
      }
    },

    _onChangeParent : function() {
      if( this._focusRoot != null ) {
        this._focusRoot.removeEventListener( "changeFocusedChild",
                                             this._onChangeFocusedChild,
                                             this );
      }
      this._focusRoot = this.getFocusRoot();
      if( this._focusRoot != null ) {
        this._focusRoot.addEventListener( "changeFocusedChild",
                                          this._onChangeFocusedChild,
                                          this );
      }
    },

    _onMouseWheel : function() {
      this.setBlockScrolling( false );
    },

    _onTouch : function() {
      this.setBlockScrolling( false );
    },

    _onKeyPress : function( evt ) {
      switch( evt.getKeyIdentifier() ) {
        case "Left":
        case "Up":
        case "Right":
        case "Down":
        case "PageUp":
        case "PageDown":
        case "End":
        case "Home":
          this.setBlockScrolling( false );
          evt.stopPropagation();
        break;
      }
    },

    _onUserScroll : function( horizontal ) {
      var server = rwt.remote.Connection.getInstance();
      var scrollbar = horizontal ? this._horzScrollBar : this._vertScrollBar;
      var remoteObject = server.getRemoteObject( this );
      var prop = horizontal ? "horizontalBar.selection" : "verticalBar.selection";
      remoteObject.set( prop, scrollbar.getValue() );
      if( scrollbar.getHasSelectionListener() ) {
        if( horizontal ) {
          server.onNextSend( this._sendHorizontalScrolled, this );
        } else {
          server.onNextSend( this._sendVerticalScrolled, this );
        }
        server.sendDelayed( 500 );
      }
    },

    _sendVerticalScrolled : function() {
      var server = rwt.remote.Connection.getInstance();
      server.getRemoteObject( this._vertScrollBar ).notify( "Selection" );
    },

    _sendHorizontalScrolled : function() {
      var server = rwt.remote.Connection.getInstance();
      server.getRemoteObject( this._horzScrollBar ).notify( "Selection" );
    },

    _onChangeFocusedChild : function( evt ) {
      var focusedChild = evt.getValue();
      this.setBlockScrolling( !this._showFocusedControl && focusedChild !== this );
    }

  }
} );

/*******************************************************************************
 * Copyright (c) 2011, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.remote.HandlerRegistry.add( "rwt.widgets.ScrolledComposite", {

  factory : function( properties ) {
    var result = new rwt.widgets.ScrolledComposite();
    rwt.remote.HandlerUtil.addStatesForStyles( result, properties.style );
    result.setUserData( "isControl", true );
    rwt.remote.HandlerUtil.setParent( result, properties.parent );
    return result;
  },

  destructor : rwt.remote.HandlerUtil.getControlDestructor(),

  getDestroyableChildren : rwt.remote.HandlerUtil.getDestroyableChildrenFinder(),

  properties : rwt.remote.HandlerUtil.extendControlProperties( [
    "origin",
    "content",
    "showFocusedControl"
  ] ),

  propertyHandler : rwt.remote.HandlerUtil.extendControlPropertyHandler( {
    // Override original bounds handler to set clipWidth and clipHeight
    "bounds" : function( widget, value ) {
      rwt.remote.HandlerUtil.getControlPropertyHandler( "bounds" )( widget, value );
      widget.setClipWidth( value[ 2 ] );
      widget.setClipHeight( value[ 3 ] );
    },
    // Order is important: origin before scrollBarsVisible
    "origin" : function( widget, value ) {
      widget.setHBarSelection( value[ 0 ] );
      widget.setVBarSelection( value[ 1 ] );
    },
    "content" : function( widget, value ) {
      rwt.remote.HandlerUtil.callWithTarget( value, function( content ) {
        widget.setContent( content );
      } );
    },
    "scrollBarsVisible" : function( widget, value ) {
      widget.setScrollBarsVisible( value[ 0 ], value[ 1 ] );
    }
  } ),

  listeners : rwt.remote.HandlerUtil.extendControlListeners( [] ),

  listenerHandler : rwt.remote.HandlerUtil.extendControlListenerHandler( {} )

} );

/*******************************************************************************
 * Copyright (c) 2009, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.qx.Class.define( "rwt.widgets.ToolBar", {

  extend : rwt.widgets.base.Parent,

  construct : function() {
    this.base( arguments );
    this._hoverItem = null;
    this.setAppearance( "toolbar" );
    this.setOverflow( "hidden" );
    this.initTabIndex();
    this.addEventListener( "focus", this._onFocus );
    this.addEventListener( "blur", this._onBlur );
    this.addEventListener( "mouseover", this._onMouseOver );
    this.addEventListener( "keypress", this._onKeyPress );
    this.addEventListener( "keydown", this._onKeyDown );
    this.addEventListener( "keyup", this._onKeyUp );
  },

  properties : {

    tabIndex : {
      refine : true,
      init : 1
    }

  },

  members : {

    _isRelevantEvent : function( event ) {
      var target = event.getTarget();
      return this._isToolItem( target ) || target === this;
    },

    _isToolItem : function( item ) {
      return item instanceof rwt.widgets.ToolItem && item.getParent() === this;
    },

    _onMouseOver : function( event ) {
      var target = event.getTarget();
      if( this._hoverItem != null && this._hoverItem != target ) {
        this._hoverItem = null;
      }
      if( this._isToolItem( target ) ) {
        this._hoverItem = target;
      }
    },

    _onFocus : function() {
      if( this._hoverItem == null ) {
        this._hoverItem = this.getFirstChild();
      }
      if( this._hoverItem != null ) {
        this._hoverItem.addState( "over" );
      }
    },

    _onBlur : function() {
      if( this._hoverItem != null ) {
        this._hoverItem.removeState( "over" );
      }
    },

    _onKeyPress : function( event ) {
      if( this._isRelevantEvent( event ) ) {
        switch( event.getKeyIdentifier() ) {
          case "Left":
            this._hoverNext( true );
          break;
          case "Right":
            this._hoverNext( false );
          break;
        }
      }
    },

    _onKeyDown : function( event ) {
      if( this._hoverItem != null && this._isRelevantEvent( event ) ) {
        this._hoverItem._onKeyDown( event );
      }
    },

    _onKeyUp : function( event ) {
      if( this._hoverItem != null && this._isRelevantEvent( event ) ) {
        this._hoverItem._onKeyUp( event );
      }
    },

    _hoverNext : function( backwards ) {
      if( this._hoverItem != null ) {
        var oldHoverItem = this._hoverItem;
        this._hoverItem.removeState( "over" );
        do {
          if( backwards ) {
            this._hoverItem = this._hoverItem.getPreviousSibling();
            if( this._hoverItem == null ) {
              this._hoverItem = this.getLastChild();
            }
          } else {
            this._hoverItem = this._hoverItem.getNextSibling();
            if( this._hoverItem == null ) {
              this._hoverItem = this.getFirstChild();
            }
          }
        } while( !( this._isToolItem( this._hoverItem ) && this._hoverItem.isEnabled() )
                 && this._hoverItem !== oldHoverItem );
        this._hoverItem.addState( "over" );
      }
    }

  }

} );

/*******************************************************************************
 * Copyright (c) 2011, 2012 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.remote.HandlerRegistry.add( "rwt.widgets.ToolBar", {

  factory : function( properties ) {
    var result = new rwt.widgets.ToolBar();
    rwt.remote.HandlerUtil.addStatesForStyles( result, properties.style );
    result.setUserData( "isControl", true );
    rwt.remote.HandlerUtil.setParent( result, properties.parent );
    return result;
  },

  destructor : rwt.remote.HandlerUtil.getControlDestructor(),

  getDestroyableChildren : rwt.remote.HandlerUtil.getDestroyableChildrenFinder(),

  properties : rwt.remote.HandlerUtil.extendControlProperties( [] ),

  propertyHandler : rwt.remote.HandlerUtil.extendControlPropertyHandler( {} ),

  listeners : rwt.remote.HandlerUtil.extendControlListeners( [] ),

  listenerHandler : rwt.remote.HandlerUtil.extendControlListenerHandler( {} )

} );

/*******************************************************************************
 * Copyright (c) 2011, 2015 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.remote.HandlerRegistry.add( "rwt.widgets.ToolItem", {

  factory : function( properties ) {
    var styleMap = rwt.remote.HandlerUtil.createStyleMap( properties.style );
    var type = "separator";
    if( styleMap.PUSH ) {
      type = "push";
    } else if( styleMap.CHECK ) {
      type = "check";
    } else if( styleMap.RADIO ) {
      type = "radio";
    } else if( styleMap.DROP_DOWN ) {
      type = "dropDown";
    }
    var result;
    rwt.remote.HandlerUtil.callWithTarget( properties.parent, function( toolbar ) {
      var vertical = toolbar.hasState( "rwt_VERTICAL" );
      if( type === "separator" ) {
        result = new rwt.widgets.ToolItemSeparator( toolbar.hasState( "rwt_FLAT" ), vertical );
      } else {
        result = new rwt.widgets.ToolItem( type, vertical );
        result.setNoRadioGroup( toolbar.hasState( "rwt_NO_RADIO_GROUP" ) );
      }
      toolbar.addAt( result, properties.index );
      rwt.remote.HandlerUtil.addDestroyableChild( toolbar, result );
      result.setUserData( "protocolParent", toolbar );
    } );
    rwt.remote.HandlerUtil.addStatesForStyles( result, properties.style );
    return result;
  },

  destructor : rwt.remote.HandlerUtil.getWidgetDestructor(),

  properties : [
    "bounds",
    "visible",
    "enabled",
    "customVariant",
    "toolTipMarkupEnabled",
    "toolTip",
    "text",
    "mnemonicIndex",
    "image",
    "hotImage",
    "control",
    "selection",
    "badge",
    "data"
  ],

  propertyHandler : {
    "data" : rwt.remote.HandlerUtil.getControlPropertyHandler( "data" ),
    "bounds" : rwt.remote.HandlerUtil.getControlPropertyHandler( "bounds" ),
    "visible" : function( widget, value ) {
      widget.setVisibility( value );
    },
    "toolTipMarkupEnabled" : rwt.remote.HandlerUtil.getControlPropertyHandler( "toolTipMarkupEnabled" ),
    "toolTip" : rwt.remote.HandlerUtil.getControlPropertyHandler( "toolTip" ),
    "image" : function( widget, value ) {
      if( value === null ) {
        widget.setImage( null );
      } else {
        widget.setImage( value[ 0 ], value[ 1 ], value[ 2 ] );
      }
    },
    "hotImage" : function( widget, value ) {
      if( value === null ) {
        widget.setHotImage( null );
      } else {
        widget.setHotImage( value[ 0 ], value[ 1 ], value[ 2 ] );
      }
    },
    "control" : function( widget, value ) {
      widget.setLineVisible( value === null );
    },
    "badge" : function( widget, value ) {
      rwt.widgets.util.Badges.setBadge( widget, value );
    }
  },

  events : [ "Selection" ]

} );

/*******************************************************************************
 * Copyright (c) 2008, 2014 Innoopract Informationssysteme GmbH and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Innoopract Informationssysteme GmbH - initial API and implementation
 *    EclipseSource - ongoing development
 ******************************************************************************/

/**
 * This class provides the client-side counterpart for
 * rwt.widgets.Scale.
 */
rwt.qx.Class.define( "rwt.widgets.Scale", {
  extend : rwt.widgets.base.Parent,

  construct : function( isHorizontal ) {
    this.base( arguments );
    this.setAppearance( "scale" );
    this._horizontal = isHorizontal;

    // Flag indicates that the next request can be sent
    this._readyToSendChanges = true;

    // Default values
    this._selection = 0;
    this._minimum = 0;
    this._maximum = 100;
    this._increment = 1;
    this._pageIncrement = 10;
    this._pxStep = 1.34;

    // Base line
    this._line = new rwt.widgets.base.Image();
    this._line.addState( this._horizontal ? "rwt_HORIZONTAL" : "rwt_VERTICAL" );
    this._line.setAppearance( "scale-line" );
    this._line.setResizeToInner( true );
    this._line.addEventListener( "mousedown", this._onLineMouseDown, this );
    this.add( this._line );

    // Thumb
    this._thumb = new rwt.widgets.base.BasicButton( "push", true );
    this._thumb.addState( this._horizontal ? "rwt_HORIZONTAL" : "rwt_VERTICAL" );
    this._thumb.setAppearance( "scale-thumb" );
    this._thumb.addEventListener( "mousedown", this._onThumbMouseDown, this );
    this._thumb.addEventListener( "mousemove", this._onThumbMouseMove, this );
    this._thumb.addEventListener( "mouseup", this._onThumbMouseUp, this );
    this.add( this._thumb );
    // Thumb offset
    this._thumbOffset = 0;

    // Add events listeners
    if( this._horizontal ) {
      this.addEventListener( "changeWidth", this._onChangeWidth, this );
    } else {
      this.addEventListener( "changeHeight", this._onChangeHeight, this );
    }
    this.addEventListener( "contextmenu", this._onContextMenu, this );
    this.addEventListener( "keypress", this._onKeyPress, this );
    this.addEventListener( "mousewheel", this._onMouseWheel, this );
  },

  destruct : function() {
    this._line.removeEventListener( "mousedown", this._onLineMouseDown, this );
    this._thumb.removeEventListener( "mousedown", this._onThumbMouseDown, this );
    this._thumb.removeEventListener( "mousemove", this._onThumbMouseMove, this );
    this._thumb.removeEventListener( "mouseup", this._onThumbMouseUp, this );
    if( this._horizontal ) {
      this.removeEventListener( "changeWidth", this._onChangeWidth, this );
    } else {
      this.removeEventListener( "changeHeight", this._onChangeHeight, this );
    }
    this.removeEventListener( "contextmenu", this._onContextMenu, this );
    this.removeEventListener( "keypress", this._onKeyPress, this );
    this.removeEventListener( "mousewheel", this._onMouseWheel, this );
    this._disposeObjects( "_line", "_thumb" );
    this._thumb = null;
  },

  statics : {
    PADDING : 8,
    SCALE_LINE_OFFSET : 9,
    THUMB_OFFSET : 9,
    HALF_THUMB : 5,

    _isNoModifierPressed : function( evt ) {
      return    !evt.isCtrlPressed()
             && !evt.isShiftPressed()
             && !evt.isAltPressed()
             && !evt.isMetaPressed();
    }
  },

  members : {

    _onChangeWidth : function() {
      this._line.setWidth( this.getWidth() - 2 * rwt.widgets.Scale.PADDING );
      this._updateStep();
      this._updateThumbPosition();
    },

    _onChangeHeight : function() {
      this._line.setHeight( this.getHeight() - 2 * rwt.widgets.Scale.PADDING );
      this._updateStep();
      this._updateThumbPosition();
    },

    _onContextMenu : function( evt ) {
      var menu = this.getContextMenu();
      if( menu != null ) {
        menu.setLocation( evt.getPageX(), evt.getPageY() );
        menu.setOpener( this );
        menu.show();
        evt.stopPropagation();
      }
    },

    _onKeyPress : function( evt ) {
      var keyIdentifier = evt.getKeyIdentifier();
      var sel = null;
      if( rwt.widgets.Scale._isNoModifierPressed( evt ) ) {
        switch( keyIdentifier ) {
          case "Left":
            sel = this._selection - this._increment;
            evt.preventDefault();
            evt.stopPropagation();
            break;
          case "Down":
            if( this._horizontal ) {
              sel = this._selection - this._increment;
            } else {
              sel = this._selection + this._increment;
            }
            evt.preventDefault();
            evt.stopPropagation();
            break;
          case "Right":
            sel = this._selection + this._increment;
            evt.preventDefault();
            evt.stopPropagation();
            break;
          case "Up":
            if( this._horizontal ) {
              sel = this._selection + this._increment;
            } else {
              sel = this._selection - this._increment;
            }
            evt.preventDefault();
            evt.stopPropagation();
            break;
          case "Home":
            sel = this._minimum;
            evt.preventDefault();
            evt.stopPropagation();
            break;
          case "End":
            sel = this._maximum;
            evt.preventDefault();
            evt.stopPropagation();
            break;
          case "PageDown":
            if( this._horizontal ) {
              sel = this._selection - this._pageIncrement;
            } else {
              sel = this._selection + this._pageIncrement;
            }
            evt.preventDefault();
            evt.stopPropagation();
            break;
          case "PageUp":
            if( this._horizontal ) {
              sel = this._selection + this._pageIncrement;
            } else {
              sel = this._selection - this._pageIncrement;
            }
            evt.preventDefault();
            evt.stopPropagation();
            break;
        }
        if( sel != null ) {
          this.setSelection( sel );
          this._scheduleSendChanges();
        }
      }
    },

    _onMouseWheel : function( evt ) {
      if( this.getFocused() ) {
        evt.preventDefault();
        evt.stopPropagation();
        var change = Math.round( evt.getWheelDelta() );
        this.setSelection( this._selection - change );
        this._scheduleSendChanges();
      }
    },

    _onLineMouseDown : function( evt ) {
      var pxSel;
      var mousePos;
      var sel;
      if( evt.isLeftButtonPressed() ){
        if( this._horizontal ) {
          pxSel = this._thumb.getLeft() + rwt.widgets.Scale.HALF_THUMB;
          mousePos = evt.getPageX() - rwt.html.Location.getLeft( this.getElement() );
        } else {
          pxSel = this._thumb.getTop() + rwt.widgets.Scale.HALF_THUMB;
          mousePos = evt.getPageY() - rwt.html.Location.getTop( this.getElement() );
        }
        if( mousePos > pxSel ) {
          sel = this._selection + this._pageIncrement;
        } else {
          sel = this._selection - this._pageIncrement;
        }
        this.setSelection( sel );
        this._scheduleSendChanges();
      }
    },

    _onThumbMouseDown : function( evt ) {
      var mousePos;
      if( evt.isLeftButtonPressed() ) {
        if( this._horizontal ) {
          mousePos = evt.getPageX() - rwt.html.Location.getLeft( this.getElement() );
          this._thumbOffset = mousePos - this._thumb.getLeft();
        } else {
          mousePos = evt.getPageY() - rwt.html.Location.getTop( this.getElement() );
          this._thumbOffset = mousePos - this._thumb.getTop();
        }
        this._thumb.setCapture(true);
      }
    },

    _onThumbMouseMove : function( evt ) {
      var mousePos;
      if( this._thumb.getCapture() ) {
        if( this._horizontal ) {
          mousePos = evt.getPageX() - rwt.html.Location.getLeft( this.getElement() );
        } else {
          mousePos = evt.getPageY() - rwt.html.Location.getTop( this.getElement() );
        }
        var sel = this._getSelectionFromThumbPosition( mousePos - this._thumbOffset );
        if( this._selection != sel ) {
          this.setSelection( sel );
          this._scheduleSendChanges();
        }
      }
    },

    _onThumbMouseUp : function() {
      this._thumb.setCapture( false );
    },

    _updateStep : function() {
      var padding =   rwt.widgets.Scale.PADDING
                    + rwt.widgets.Scale.HALF_THUMB;
      if( this._horizontal ) {
        this._pxStep = ( this.getWidth() - 2 * padding ) / ( this._maximum - this._minimum );
      } else {
        this._pxStep = ( this.getHeight() - 2 * padding ) / ( this._maximum - this._minimum );
      }
    },

    _updateThumbPosition : function() {
      var pos =   rwt.widgets.Scale.PADDING
                + this._pxStep * ( this._selection - this._minimum );
      if( this._horizontal ) {
        this._thumb.setLeft( Math.round( pos ) );
      } else {
        this._thumb.setTop( Math.round( pos ) );
      }
      this.dispatchSimpleEvent( "updateToolTip", this );
    },

    _getSelectionFromThumbPosition : function( position ) {
      var sel = ( position - rwt.widgets.Scale.PADDING ) / this._pxStep + this._minimum;
      return this._normalizeSelection( Math.round( sel ) );
    },

    _normalizeSelection : function( value ) {
      var result = value;
      if( value < this._minimum ) {
        result = this._minimum;
      }
      if( value > this._maximum ) {
        result = this._maximum;
      }
      return result;
    },

    _scheduleSendChanges : function() {
      if( this._readyToSendChanges ) {
        this._readyToSendChanges = false;
        rwt.client.Timer.once( this._sendChanges, this, 500 );
      }
    },

    _sendChanges : function() {
      if( !rwt.remote.EventUtil.getSuspended() ) {
        rwt.remote.Connection.getInstance().getRemoteObject( this ).set( "selection", this._selection );
        rwt.remote.EventUtil.notifySelected( this );
        this._readyToSendChanges = true;
      }
    },

    setSelection : function( value ) {
      this._selection = this._normalizeSelection( value );
      this._updateThumbPosition();
      this.dispatchSimpleEvent( "selectionChanged" );
    },

    setMinimum : function( value ) {
      this._minimum = value;
      this._updateStep();
      this._updateThumbPosition();
      this.dispatchSimpleEvent( "minimumChanged" );
    },

    setMaximum : function( value ) {
      this._maximum = value;
      this._updateStep();
      this._updateThumbPosition();
      this.dispatchSimpleEvent( "maximumChanged" );
    },

    setIncrement : function( value ) {
      this._increment = value;
    },

    setPageIncrement : function( value ) {
      this._pageIncrement = value;
    },

    getToolTipTargetBounds : function() {
      return {
        "left" : this._cachedBorderLeft + ( this._thumb.getLeft() || 0 ),
        "top" : this._cachedBorderLeft + ( this._thumb.getTop() || 0 ),
        "width" : this._thumb.getBoxWidth(),
        "height" : this._thumb.getBoxHeight()
      };
    },

    // overwritten:
    _visualizeFocus : function() {
      this.base( arguments );
      this._thumb.addState( "focused" );
    },

    // overwritten:
    _visualizeBlur : function() {
      this.base( arguments );
      this._thumb.removeState( "focused" );
    }

  }
} );

/*******************************************************************************
 * Copyright (c) 2011, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.remote.HandlerRegistry.add( "rwt.widgets.Scale", {

  factory : function( properties ) {
    var isHorizontal = properties.style.indexOf( "HORIZONTAL" ) != -1;
    var result = new rwt.widgets.Scale( isHorizontal );
    rwt.remote.HandlerUtil.addStatesForStyles( result, properties.style );
    result.setUserData( "isControl", true );
    rwt.remote.HandlerUtil.setParent( result, properties.parent );
    return result;
  },

  destructor : rwt.remote.HandlerUtil.getControlDestructor(),

  getDestroyableChildren : rwt.remote.HandlerUtil.getDestroyableChildrenFinder(),

  properties : rwt.remote.HandlerUtil.extendControlProperties( [
    "minimum",
    "maximum",
     /**
      * @name setSelection
      * @methodOf Scale#
      * @description Sets the 'selection', which is the receiver's value, to the argument which
      * must be greater than or equal to zero.
      * @param {int} selection the new selection (must be zero or greater)
      */
    "selection",
    "increment",
    "pageIncrement"
  ] ),

  propertyHandler : rwt.remote.HandlerUtil.extendControlPropertyHandler( {} ),

  events : [ "Selection" ],

  listeners : rwt.remote.HandlerUtil.extendControlListeners( [] ),

  listenerHandler : rwt.remote.HandlerUtil.extendControlListenerHandler( {} ),

  methods: [ "addListener", "removeListener" ],

  methodHandler : rwt.remote.HandlerUtil.extendListenerMethodHandler( {} ),

  /**
   * @class RWT Scripting analoge to org.eclipse.swt.widgets.Scale
   * @name Scale
   * @extends Control
   * @description The constructor is not public.
   * @since 2.2
   */
  scriptingMethods : rwt.remote.HandlerUtil.extendControlScriptingMethods(
    /** @lends Scale.prototype */
  {
     /**
      * @description Returns the 'selection', which is the receiver's position.
      * @return {int} the selection
      */
     getSelection : function() {
      return this._selection;
    },
     /**
      * @description Returns the maximum value which the receiver will allow.
      * @return {int} the maximum
      */
     getMaximum : function() {
      return this._maximum;
    },
     /**
      * @description Returns the minimum value which the receiver will allow.
      * @return {int} the minimum
      */
     getMinimum : function() {
      return this._minimum;
    }
  } )

} );

/*******************************************************************************
 * Copyright (c) 2009, 2012 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.qx.Class.define( "rwt.widgets.ToolItemSeparator", {
  extend : rwt.widgets.base.Parent,

  construct : function( flat, vertical ) {
    this.base( arguments );
    this._line = null;
    this._control = null;
    this._vertical = vertical;
    if( flat ) {
      this._line = new rwt.widgets.base.Terminator();
      if( vertical ) {
        this._line.addState( "vertical" );
      }
      this._line.setAppearance( "toolbar-separator-line" );
      this.add( this._line );
    }
    this.setStyleProperty( "fontSize", "0px" );
    this.setStyleProperty( "lineHeight", "0px" );
  },

  properties : {

    appearance : {
      refine : true,
      init : "toolbar-separator"
    }

  },

  members : {

    _applyWidth : function( newValue, oldValue ) {
      this.base( arguments, newValue, oldValue );
      if( this._line && !this._vertical ) {
        var lineWidth = this._line.getWidth();
        var center = newValue * 0.5;
        var lineLeft = Math.floor( center - ( lineWidth * 0.5 ) );
        this._line.setLeft( lineLeft );
      }
    },

    _applyHeight : function( newValue, oldValue ) {
      this.base( arguments, newValue, oldValue );
      if( this._line && this._vertical ) {
        var lineHeight = this._line.getHeight();
        var center = newValue * 0.5;
        var lineTop = Math.floor( center - ( lineHeight * 0.5 ) );
        this._line.setTop( lineTop );
      }
    },

    setLineVisible : function( value ) {
      if( this._line ) {
        this._line.setVisibility( value );
      }
    }

  }

} );

/*******************************************************************************
 * Copyright (c) 2007, 2014 Innoopract Informationssysteme GmbH and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Innoopract Informationssysteme GmbH - initial API and implementation
 *    EclipseSource - ongoing development
 ******************************************************************************/

namespace( "rwt.theme.BorderDefinitions" );


rwt.theme.BorderDefinitions = {

  getDefinition : function( name ) {
    return this._definitions[ name ];
  },

  _definitions : {

    ///////////////////////////
    // Names used in ThemeStore

    "inset" : {
      color : [ "shadow", "highlight", "highlight", "shadow" ],
      innerColor : [ "darkshadow", "lightshadow", "lightshadow", "darkshadow" ],
      width : 2
    },

    "thinInset" : {
      color : [ "shadow", "highlight", "highlight", "shadow" ],
      width : 1
    },

    "outset" : {
      color : [ "lightshadow", "darkshadow", "darkshadow", "lightshadow" ],
      innerColor : [ "highlight", "shadow", "shadow", "highlight" ],
      width : 2
    },

    "thinOutset" : {
      color : [ "highlight", "shadow", "shadow", "highlight" ],
      width : 1
    },

    "groove" : {
      color : [ "shadow", "highlight", "highlight", "shadow" ],
      innerColor : [ "highlight", "shadow", "shadow", "highlight" ],
      width : 2
    },

    "ridge" : {
      color : [ "highlight", "shadow", "shadow", "highlight" ],
      innerColor : [ "shadow", "highlight", "highlight", "shadow" ],
      width : 2
    },

    ////////////////////////////////////
    // Names also used in AppearanceBase

    "shadow" : {
      width : 1,
      color :  [ "shadow", "shadow", "shadow", "shadow" ]
    },

    "verticalDivider" : {
      width : [ 1, 0, 1, 0 ],
      color : [ "shadow", null, "highlight", null ]
    },

    "horizontalDivider" : {
      width : [ 0, 1, 0, 1 ],
      color : [ null, "shadow", null, "highlight" ]
    },

    "separator.shadowin.horizontal.border" : {
      width : [ 1, 0, 1, 0 ],
      color : [ "lightshadow", null, "highlight" ]
    },

    "separator.shadowin.vertical.border" : {
      width : [ 0, 1, 0, 1 ],
      color : [ null, "highlight", null, "lightshadow" ]
    },

    "separator.shadowout.horizontal.border" : {
      width : [ 1, 0, 1, 0 ],
      color : [ "highlight", null, "shadow", null ]
    },

    "separator.shadowout.vertical.border" : {
      width : [ 0, 1, 0, 1 ],
      color : [ null, "shadow", null, "highlight" ]
    }

  }

};

/*******************************************************************************
 * Copyright (c) 2009, 2015 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.qx.Class.define( "rwt.widgets.Combo", {
  extend : rwt.widgets.base.Parent,

  construct : function( isCCombo ) {
    this.base( arguments );
    this._editable = true;
    this._userSelection = true;
    this._listMinWidth = -1;
    this._field = new rwt.widgets.base.BasicText();
    this._field.setTabIndex( null );
    this._field.setAllowStretchY( true );
    this.add( this._field );
    this._button = new rwt.widgets.base.BasicButton( "push", true );
    this._button.setTabIndex( null );
    this._button.setHeight( "100%" );
    this.add( this._button );
    this.setHideFocus( true );
    var appearance = isCCombo ? "ccombo" : "combo";
    this.setAppearance( appearance );
    this._field.setAppearance( appearance + "-field" );
    this._button.setAppearance( appearance + "-button" );
    this._registerListeners();
  },

  destruct : function() {
    this._list.destroy();
    this._disposeObjects( "_field", "_button" );
  },

  members : {

    setItems : function( items ) {
      this._listMinWidth = -1;
      this._userSelection = false;
      this._list.setItems( items );
      this._userSelection = true;
      this.dispatchSimpleEvent( "itemsChanged" );
      if( this._list.getVisible() ) {
        this._list.setMinWidth( this._getListMinWidth() );
      }
    },

    setVisibleItemCount : function( value ) {
      this._list.setVisibleItemCount( value );
    },

    select : function( index ) {
      this._userSelection = false;
      this._list.setSelectionIndex( index );
      this._userSelection = true;
    },

    setEditable : function( value ) {
      this._editable = value;
      this._field.setReadOnly( !value );
    },

    setListVisible : function( value ) {
      if( value ) {
        this._list.setMinWidth( this._getListMinWidth() );
      }
      this._list.setVisible( value );
    },

    setText : function( value ) {
      if( this._editable ) {
        this._field.setValue( value );
      }
    },

    setTextSelection : function( selection ) {
      this._field.setSelection( selection );
    },

    setTextLimit : function( value ) {
      this._field.setMaxLength( value );
    },

    addState : function( state ) {
      this.base( arguments, state );
      if( state === "rwt_FLAT" ) {
        this._field.addState( state );
        this._button.addState( state );
      }
    },

    _getSubWidgets : function() {
      return [ this._field, this._button, this._list ];
    },

    _registerListeners : function() {
      this.addEventListener( "changeParent", this._onChangeParent, this );
      this.addEventListener( "mousedown", this._onMouseDown, this );
      this.addEventListener( "mousewheel", this._onMouseWheel, this );
      this.addEventListener( "keypress", this._onKeyPress, this );
      this._field.addEventListener( "input", this._onTextInput, this );
      this._field.addEventListener( "keypress", this._onTextKeyPress, this );
      this._field.addEventListener( "selectionChanged", this._onTextSelectionChange, this );
    },

    _onChangeParent : function() {
      // DropDown requires valid parent focus root when creating
      if( !this._list ) {
        var appearance = this.getAppearance() + "-list";
        this._list = new rwt.widgets.DropDown( this, false, appearance );
        this._list.setSelectionWrapping( false );
        var that = this;
        this._list.addListener( "Show", function( event ) {
          that._onListVisibleChanged( event );
        } );
        this._list.addListener( "Hide", function( event ) {
          that._onListVisibleChanged( event );
        } );
        this._list.addListener( "Selection", function( event ) {
          that._onListSelectionChanged( event );
        } );
      }
    },

    _applyFont : function( value, old ) {
      this.base( arguments, value, old );
      this._field.setFont( value );
    },

    _applyTextColor : function( value, old ) {
      this.base( arguments, value, old );
      this._field.setTextColor( value );
    },

    _applyCursor : function( value, old ) {
      this.base( arguments, value, old );
      this._field.setCursor( value );
      this._button.setCursor( value );
    },

    _ontabfocus : function() {
      this._showFocusIndicator();
      if( this._field.isCreated() ) {
        this._field.selectAll();
      }
    },

    _showFocusIndicator : function() {
      if( !this._editable ) {
        var cssSelector = ( this.getAppearance() === "combo" ? "" : "C" ) + "Combo-FocusIndicator";
        rwt.widgets.util.FocusIndicator.getInstance().show( this, cssSelector, null );
      }
    },

    _visualizeFocus : function() {
      if( this._field.isCreated() ) {
        this._field._visualizeFocus();
        this._field._renderSelection();
      }
      this.addState( "focused" );
    },

    _visualizeBlur : function() {
      if( this._field.isCreated() ) {
        // setting selection lenght to 0 needed for IE to deselect text
        this._field._setSelectionLength( 0 );
        this._field._visualizeBlur();
      }
      if( !this._editable ) {
        rwt.widgets.util.FocusIndicator.getInstance().hide( this );
      }
      this.removeState( "focused" );
    },

    _toggleListVisibility : function() {
      if( this._list.getVisible() ) {
        this._list.hide();
      } else {
        this._list.setMinWidth( this._getListMinWidth() );
        this._list.show();
      }
    },

    _getListMinWidth : function() {
      if( this._listMinWidth === -1 ) {
        var fontProps = {};
        this.getFont().renderStyle( fontProps );
        var calc = rwt.widgets.util.FontSizeCalculation;
        var items = this._list.getItems();
        for( var i = 0; i < this._list.getItemCount(); i++ ) {
          var text = this._escapeText( items[ i ] );
          var dimensions = calc.computeTextDimensions( text, fontProps );
          this._listMinWidth = Math.max( this._listMinWidth, dimensions[ 0 ] );
        }
      }
      return this._listMinWidth;
    },

    _escapeText : function( text ) {
      var Encoding = rwt.util.Encoding;
      var result = Encoding.escapeText( text, false );
      result = Encoding.replaceNewLines( result, "" );
      result = Encoding.replaceWhiteSpaces( result );
      return result;
    },

    _onMouseDown : function( event ) {
      var target = event.getTarget();
      if( event.isLeftButtonPressed() ) {
        if( target === this._field && this._field.getReadOnly() || target === this._button ) {
          this.setFocused( true );
          this._toggleListVisibility();
          event.preventDefault();
        }
      }
    },

    _onMouseWheel : function( event ) {
      if( !this._list.getVisible() && this.getFocused() && this._list.getItemCount() > 0 ) {
        this._scrollSelection( event.getWheelDelta() < 0 );
        event.preventDefault();
        event.stopPropagation();
      }
    },

    _onTextKeyPress : function( event ) {
      // Key press event propagation is disabled in BasicText.js. Redispatch the event.
      this.dispatchEvent( event );
    },

    _onKeyPress : function( event ) {
      var key = event.getKeyIdentifier();
      if( key === "Enter" ) {
        this._handleKeyEnter( event );
      } else if( key === "Up" || key === "Down" || key === "PageUp" || key === "PageDown" ) {
        this._handleKeyUpDown( event );
      }
      this._selectByFirstLetter( event );
      this._stopKeyEvent( event );
    },

    _handleKeyEnter : function( event ) {
      if( !this._list.getVisible() && event.getModifiers() === 0 ) {
        rwt.remote.EventUtil.notifyDefaultSelected( this );
      }
    },

    _handleKeyUpDown : function( event ) {
      if( event.isAltPressed() ) {
        this._toggleListVisibility();
      } else if( !this._list.getVisible() && this._list.getItemCount() > 0 ) {
        switch( event.getKeyIdentifier() ) {
          case "Up":
            this._scrollSelection( false );
          break;
          case "Down":
            this._scrollSelection( true );
          break;
          case "PageUp":
            this._scrollSelection( false, true );
          break;
          case "PageDown":
            this._scrollSelection( true, true );
          break;
        }
      }
    },

    _selectByFirstLetter : function( event ) {
      var charCode = event.getCharCode();
      if( charCode !== 0 && !event.isAltPressed() && !event.isCtrlPressed() ) {
        if( this._list.getVisible() || !this._editable ) {
          var startIndex = this._list.getSelectionIndex() + 1;
          var endIndex = this._list.getItemCount() - 1;
          var letter = String.fromCharCode( charCode );
          var selectionIndex = this._findIndexByFirstLetter( startIndex, endIndex, letter );
          if( selectionIndex === -1 ) {
            selectionIndex = this._findIndexByFirstLetter( 0, startIndex - 1, letter );
          }
          if( selectionIndex !== -1 ) {
            this._list.setSelectionIndex( selectionIndex );
          }
        }
      }
    },

    _findIndexByFirstLetter : function( startIndex, endIndex, letter ) {
      var items = this._list.getItems();
      for( var i = startIndex; i <= endIndex; i++ ) {
        if( items[ i ].slice( 0, 1 ).toLowerCase() === letter.toLowerCase() ) {
          return i;
        }
      }
      return -1;
    },

    _stopKeyEvent : function( event ) {
      switch( event.getKeyIdentifier() ) {
        case "Enter":
        case "Up":
        case "Down":
        case "PageUp":
        case "PageDown":
          event.preventDefault();
          event.stopPropagation();
        break;
      }
    },

    _scrollSelection : function( down, page ) {
      var index = this._list.getSelectionIndex();
      var itemCount = this._list.getItemCount();
      var visibleItems = this._list.getVisibleItemCount();
      if( index === -1 ) {
        index = 0;
      } else if( down ) {
        index = page ? index + visibleItems - 1 : index + 1;
        index = Math.min( itemCount - 1, index );
      } else {
        index = page ? index - visibleItems + 1 : index - 1;
        index = Math.max( 0, index );
      }
      if( index !== this._list.getSelectionIndex() ) {
        this._list.setSelectionIndex( index );
      }
    },

    _onTextInput : function() {
      if( this._editable ) {
        var remoteObject = rwt.remote.Connection.getInstance().getRemoteObject( this );
        remoteObject.set( "text", this._field.getComputedValue() );
        this._notifyModify( true );
        this._internalSelectionChanged = true;
        this._list.setSelectionIndex( -1 );
        this._internalSelectionChanged = false;
      }
    },

    _onListVisibleChanged : function() {
      var listVisible = this._list.getVisible();
      if( this._editable ) {
        this._field.setReadOnly( listVisible );
      }
      if( this.getFocused() ) {
        if( listVisible ) {
          this._field._visualizeBlur();
        } else if( this._editable ) {
          this._field._visualizeFocus();
        }
      }
      if( !rwt.remote.EventUtil.getSuspended() ) {
        var connection = rwt.remote.Connection.getInstance();
        connection.getRemoteObject( this ).set( "listVisible", listVisible );
      }
    },

    _onListSelectionChanged : function( event ) {
      if( !this._internalSelectionChanged ) {
        if( this._userSelection ) {
          this.setFocused( true );
        }
        this._field.setValue( event.index === -1 ? "" : event.text );
        if( this._field.isCreated() && this._userSelection ) {
          this._field.selectAll();
        }
        this._sendSelectionChanged( event );
        this.dispatchSimpleEvent( "selectionChanged" );
      }
    },

    _onTextSelectionChange : function() {
      if( !rwt.remote.EventUtil.getSuspended() ) {
        var remoteObject = rwt.remote.Connection.getInstance().getRemoteObject( this );
        remoteObject.set( "selection", this._field.getSelection() );
      }
    },

    _sendSelectionChanged : function( event ) {
      if( !rwt.remote.EventUtil.getSuspended() ) {
        var remoteObject = rwt.remote.Connection.getInstance().getRemoteObject( this );
        if( this._editable ) {
          remoteObject.set( "text", event.text );
        }
        remoteObject.set( "selectionIndex", event.index );
        rwt.remote.EventUtil.notifySelected( this );
        this._notifyModify();
      }
    },

    _notifyModify : function( delayed ) {
      var connection = rwt.remote.Connection.getInstance();
      if( connection.getRemoteObject( this ).isListening( "Modify" ) ) {
        connection.onNextSend( this._onSend, this );
        if( delayed ) {
          connection.sendDelayed( 500 );
        } else {
          connection.send();
        }
      }
    },

    _onSend : function() {
      if( !this.isDisposed() ) {
        rwt.remote.Connection.getInstance().getRemoteObject( this ).notify( "Modify", null, true );
      }
    },

    applyObjectId : function( id ) {
      this.base( arguments, id );
      this._list.applyObjectId( id + "-listbox" );
    }
  }

} );

/*******************************************************************************
 * Copyright (c) 2011, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.remote.HandlerRegistry.add( "rwt.widgets.Combo", {

  factory : function( properties ) {
    var result = new rwt.widgets.Combo( properties.ccombo );
    rwt.remote.HandlerUtil.addStatesForStyles( result, properties.style );
    result.setUserData( "isControl", true );
    rwt.remote.HandlerUtil.setParent( result, properties.parent );
    return result;
  },

  destructor : rwt.remote.HandlerUtil.getControlDestructor(),

  getDestroyableChildren : rwt.remote.HandlerUtil.getDestroyableChildrenFinder(),

  properties : rwt.remote.HandlerUtil.extendControlProperties( [
    "itemHeight",
    "visibleItemCount",
    "items",
    "listVisible",
    "selectionIndex",
    "editable",
    /**
     * @name setText
     * @methodOf Combo#
     * @description Sets the contents of the receiver's text field to the given string.
     * <p>
     * Note: The text field in a <code>Combo</code> is typically only capable of
     * displaying a single line of text. Thus, setting the text to a string
     * containing line breaks or other special characters will probably cause it
     * to display incorrectly.
     * </p>
     * @param {string} text the new text
     */
    "text",
    /**
     * @name setSelection
     * @methodOf Combo#
     * @description Sets the selection of the text to the range specified
     * by an array whose first value is the
     * character position representing the start of the selected
     * text, and whose second value is the character position
     * representing the end of the selection. An "empty" selection
     * is indicated by the values being identical.
     * <p>
     * Indexing is zero based.  The range of
     * a selection is from 0..N where N is
     * the number of characters in the widget.
     * </p><p>
     * Text selections are specified in terms of
     * caret positions.  In a text widget that
     * contains N characters, there are N+1 caret
     * positions, ranging from 0..N.  This differs
     * from other functions that address character
     * position such as getText () that use the
     * usual array indexing rules.
     * </p>
     *
     * @param {int[]} selection array representing the selection start and end
     */
    "selection",
    "textLimit"
  ] ),

  propertyHandler : rwt.remote.HandlerUtil.extendControlPropertyHandler( {
    "selectionIndex" : function( widget, value ) {
      widget.select( value );
    },
    "selection" : function( widget, value ) {
      widget.setTextSelection( value );
    }
  } ),

  events : [ "Selection", "DefaultSelection", "Modify" ],

  listeners : rwt.remote.HandlerUtil.extendControlListeners( [] ),

  listenerHandler : rwt.remote.HandlerUtil.extendControlListenerHandler( {} ),

  methods: [ "addListener", "removeListener" ],

  methodHandler : rwt.remote.HandlerUtil.extendListenerMethodHandler( {} ),

  /**
   * @class RWT Scripting analoge to org.eclipse.swt.widgets.Combo
   * @name Combo
   * @extends Control
   * @description The constructor is not public.
   * @since 2.2
   */
  scriptingMethods : rwt.remote.HandlerUtil.extendControlScriptingMethods(
    /** @lends Combo.prototype */
  {

    /**
     * @description  Returns the widget text.
     * @return {string} the widget text
     */
    getText : function() {
      return this._field.getValue();
    },
    /**
     * @description Returns an array whose first value is the
     * character position representing the start of the selected
     * text, and whose second value is the character position
     * representing the end of the selection. An "empty" selection
     * is indicated by the values being identical.
     * <p>
     * Indexing is zero based.  The range of a selection is from
     * 0..N where N is the number of characters in the widget.
     * </p>
     *
     * @return {int[]} array representing the selection start and end
     */
    getSelection : function() {
      return this._field.getSelection();
    }

  } )

} );

/*******************************************************************************
 * Copyright (c) 2009, 2014 Innoopract Informationssysteme GmbH and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Innoopract Informationssysteme GmbH - initial API and implementation
 *    EclipseSource - ongoing development
 ******************************************************************************/

rwt.qx.Class.define( "rwt.widgets.util.FocusIndicator", {

  extend : rwt.qx.Object,

  statics : {

    getInstance : function() {
      return rwt.runtime.Singletons.get( rwt.widgets.util.FocusIndicator );
    }

  },

  construct : function() {
    this.base( arguments );
    this._frame = null;
  },

  members : {

    _createFrame : function() {
      this._frame = document.createElement( "div" );
      this._frame.setAttribute( "id", "focusIndicator" ); // used by unit tests
      this._frame.style.position = "absolute";
      this._frame.style.fontSize = 0;
      this._frame.style.lineHeight = 0;
      this._frame.style.zIndex = 0;
    },

    _createTheme : function( widget, cssSelector, focusElement ) {
      var theme = null;
      var states = typeof widget.__states != "undefined" ? widget.__states : {};
      var tv = new rwt.theme.ThemeValues( states );
      var border = tv.getCssBorder( cssSelector, "border" );
      var opacity = tv.getCssFloat( cssSelector, "opacity" );
      var hasValidBorder = border instanceof rwt.html.Border;
      var margin = tv.getCssBoxDimensions( cssSelector, "margin" );
      var padding = tv.getCssBoxDimensions( cssSelector, "padding" );
      if( !padding ) {
        padding = [ 0, 0, 0, 0 ];
      }
      var paddingIsZero =    padding[ 0 ] === 0
                          && padding[ 1 ] === 0
                          && padding[ 2 ] === 0
                          && padding[ 3 ] === 0;
      var usePadding = !paddingIsZero && focusElement != null;
      if( hasValidBorder && ( margin != null || usePadding ) ) {
        var color = tv.getCssColor( cssSelector, "background-color" );
        theme = {
          "backgroundColor" : color != "undefined" ? color : "",
          "opacity" : opacity,
          "border" : border,
          "margin" : margin,
          "padding" : usePadding ? padding : null
        };
      }
      return theme;
    },

    show : function( widget, cssSelector, focusElement ) {
      this.hide();
      if( widget.isCreated() ) {
        var theme = this._createTheme( widget, cssSelector, focusElement );
        if( theme != null ) {
          var parentNode = widget._getTargetNode();
          if( this._frame == null ) {
            this._createFrame();
          }
          if( this._frame.parentNode != parentNode ) {
            if( parentNode.hasChildNodes() ) {
              var firstChild = parentNode.firstChild;
              parentNode.insertBefore( this._frame, firstChild );
            } else {
              parentNode.appendChild( this._frame );
            }
          }
          this._styleFocusIndicator( theme );
          this._layoutFocusIndicator( widget, theme, focusElement );
        }
      }
    },


    hide : function() {
      if( this._frame != null && this._frame.parentNode != null ) {
        this._frame.parentNode.removeChild( this._frame );
      }
    },

    _styleFocusIndicator : function( theme ) {
      // ignores complex borders and color-manager (for now):
      var border = theme[ "border" ];
      var style = this._frame.style;
      var edges = [ "Left", "Top", "Bottom", "Right" ];
      for( var i = 0; i < 4; i++ ) {
        var edge = edges[ i ];
        var borderColor = border[ "getColor" + edge ]();
        var borderStyle = border[ "getStyle" + edge ]();
        var borderWidth = border[ "getWidth" + edge ]();
        style[ "border" + edge + "Width" ] = borderWidth == null ? "0px" : borderWidth + "px";
        style[ "border" + edge + "Style" ] = borderStyle == null ? "none" : borderStyle;
        style[ "border" + edge + "Color" ] = borderColor == null ? "" : borderColor;
      }
      style.backgroundColor = theme[ "backgroundColor" ];
      this._styleFocusIndiactorOpacity( theme[ "opacity" ] );
    },

    _styleFocusIndiactorOpacity : function( value ) {
      var style = this._frame.style;
      var opacity = value == 1 ? "" : value;
      style.opacity = opacity;
      style.KhtmlOpacity = opacity;
      style.MozOpacity = opacity;
    },

    _layoutFocusIndicator : function( widget, theme, focusElement ) {
      // NOTE : It is assumed that a focusElement, if given, has
      //        valid css-bounds (top,left,width,height) set in "px".
      var bounds = [];
      if( theme[ "padding" ] != null ) {
        var padding = theme[ "padding" ];
        bounds[ 0 ] = parseInt( focusElement.style.left, 10 ) - padding[ 3 ];
        bounds[ 1 ] = parseInt( focusElement.style.top, 10 ) - padding[ 0 ];
        bounds[ 2 ] = parseInt( focusElement.style.width, 10 ) + padding[ 1 ] + padding[ 3 ];
        bounds[ 3 ] = parseInt( focusElement.style.height, 10 ) + padding[ 2 ] + padding[ 0 ];
      } else {
        var margin = theme[ "margin" ];
        // Fix for bug 312544
        widget._invalidateBoxWidth();
        widget._invalidateBoxHeight();
        var parentWidth = widget.getBoxWidth() - widget._cachedBorderLeft - widget._cachedBorderRight;
        var parentHeight =   widget.getBoxHeight()
                           - widget._cachedBorderTop
                           - widget._cachedBorderBottom;
        widget._invalidateBoxWidth();
        widget._invalidateBoxHeight();
        bounds[ 0 ] = margin[ 3 ];
        bounds[ 1 ] = margin[ 0 ];
        bounds[ 2 ] = parentWidth - ( margin[ 3 ] + margin[ 1 ] );
        bounds[ 3 ] = parentHeight - ( margin[ 0 ] + margin[ 2 ] );
        bounds[ 2 ] = Math.max( 0, bounds[ 2 ] );
        bounds[ 3 ] = Math.max( 0, bounds[ 3 ] );
      }
      this._frame.style.left = bounds[ 0 ] + "px";
      this._frame.style.top = bounds[ 1 ] + "px";
      this._frame.style.width = bounds[ 2 ] + "px";
      this._frame.style.height = bounds[ 3 ] + "px";
    }
  }

} );


/*******************************************************************************
 * Copyright (c) 2011, 2013 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.remote.HandlerRegistry.add( "rwt.widgets.GC", {

  factory : function( properties ) {
    var parent = rwt.remote.ObjectRegistry.getObject( properties.parent );
    var result = rwt.widgets.util.WidgetUtil.getGC( parent );
    rwt.remote.HandlerUtil.addDestroyableChild( parent, result );
    return result;
  },

  destructor : function( gc ) {
    rwt.remote.HandlerUtil.removeDestroyableChild( gc._control, gc );
    gc.dispose();
  },

  methods : [ "init", "draw" ],

  methodHandler : {
    "init" : function( gc, properties ) {
      gc.init(
        properties.width,
        properties.height,
        properties.font,
        properties.fillStyle,
        properties.strokeStyle
      );
    },
    "draw" : function( gc, properties ) {
      gc.draw( properties.operations );
    }
  }

} );

/*******************************************************************************
 * Copyright (c) 2010, 2015 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.qx.Class.define( "rwt.widgets.GC", {

  extend : rwt.qx.Object,

  construct : function( control ) {
    this.base( arguments );
    this._control = control;
    this._control.addEventListener( "create", this._onControlCreate, this );
    this._canvas = null;
    this._context = null;
    this._createCanvas();
    this._canvas.rwtObject = this; // like "rwtWidget" in Widget.js, useful for custom JS components
    if( this._control.isCreated() ) {
      this._addCanvasToDOM();
    }
    this._linearGradient = null;
  },

  destruct : function() {
    this._control.removeEventListener( "create", this._onControlCreate, this );
    if( this._control.isCreated() && !this._control.isDisposed() ) {
      this._removeCanvasFromDOM();
    }
    this._control = null;
    this._canvas.rwtObject = null;
    this._canvas = null;
    if( this._context.dispose ) {
      this._context.dispose();
    }
    this._context = null;
  },

  members : {

    init : function( width, height, font, background, foreground  ) {
      this._canvas.width = width;
      this._canvas.style.width = width + "px";
      this._canvas.height = height;
      this._canvas.style.height = height + "px";
      this._context.clearRect( 0, 0, width, height );
      this._initFields( font, background, foreground );
      this._control.dispatchSimpleEvent( "paint" ); // client-side painting on server-side redraw
    },

    /**
     * Executes drawing operations using the HTML5-Canvas 2D-Context syntax.
     * Only a subset is supported on all browser, especially IE is limited.
     * Each operation is an array starting with the name of the function to call, followed
     * by its parameters. Properties are treated the same way, i.e. [ "propertyName", "value" ].
     * Other differences from official HTML5-Canvas API:
     *  - Colors are to be given as array ( [ red, green blue ] )
     *  - "addColorStop" will automatically applied to the last created gradient.
     *  - To assign the last created linear gradient as a style, use "linearGradient" as the value.
     *  - strokeText behaves like fillText and fillText draws a rectangular background
     *  - ellipse is not a W3C standard, only WHATWG, but we need it for SWT arc to work.
     */
    draw : function( operations ) {
      for( var i = 0; i < operations.length; i++ ) {
        try {
          var op = operations[ i ][ 0 ];
          switch( op ) {
            case "fillStyle":
            case "strokeStyle":
            case "globalAlpha":
            case "lineWidth":
            case "lineCap":
            case "lineJoin":
            case "font":
              this._setProperty( operations[ i ] );
            break;
            case "createLinearGradient":
            case "addColorStop":
            case "fillText":
            case "strokeText":
            case "ellipse":
            case "drawImage":
              this[ "_" + op ]( operations[ i ] );
            break;
            default:
              this._context[ op ].apply( this._context, operations[ i ].slice( 1 ) );
            break;
          }
        } catch( ex ) {
          var opArrStr = "[ " + operations[ i ].join( ", " ) + " ]";
          throw new Error( "Drawing operation failed: " + opArrStr + " :" + ex.message );
        }
      }
    },

    getNativeContext : function() {
      return this._context;
    },

    ////////////
    // Internals

    _createCanvas : function() {
      this._canvas = document.createElement( "canvas" );
      this._context = this._canvas.getContext( "2d" );
    },

    _onControlCreate : function() {
      this._addCanvasToDOM();
    },

    _addCanvasToDOM  : function() {
      var controlElement = this._control._getTargetNode();
      var firstChild = controlElement.firstChild;
      if( firstChild ) {
        controlElement.insertBefore( this._canvas, firstChild );
      } else {
        controlElement.appendChild( this._canvas );
      }
    },

    _removeCanvasFromDOM : function() {
      this._canvas.parentNode.removeChild( this._canvas );
    },

    _initFields : function( font, background, foreground ) {
      this._context.strokeStyle = rwt.util.Colors.rgbToRgbString( foreground );
      this._context.fillStyle = rwt.util.Colors.rgbToRgbString( background );
      this._context.globalAlpha = 1.0;
      this._context.lineWidth = 1;
      this._context.lineCap = "butt";
      this._context.lineJoin = "miter";
      this._context.font = this._toCssFont( font );
      this._context.textBaseline = "top";
      this._context.textAlign = "left";
    },

    // See http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#building-paths
    _ellipse : function( operation ) {
      var cx = operation[ 1 ];
      var cy = operation[ 2 ];
      var rx = operation[ 3 ];
      var ry = operation[ 4 ];
      //var rotation = operation[ 5 ]; // not supported
      var startAngle = operation[ 6 ];
      var endAngle = operation[ 7 ];
      var dir = operation[ 8 ];
      if( rx > 0 && ry > 0 ) {
        this._context.save();
        this._context.translate( cx, cy );
        // TODO [tb] : using scale here changes the stroke-width also, looks wrong
        this._context.scale( 1, ry / rx );
        this._context.arc( 0, 0, rx, startAngle, endAngle, dir );
        this._context.restore();
      }
    },

    _setProperty : function( operation ) {
      var property = operation[ 0 ];
      var value = operation[ 1 ];
      if( value === "linearGradient" ) {
        value = this._linearGradient;
      } else if( property === "fillStyle" || property === "strokeStyle" ) {
        value = rwt.util.Colors.rgbToRgbString( value );
      } else if( property === "font" ) {
        value = this._toCssFont( value );
      }
      this._context[ property ] = value;
    },

    _strokeText : function( operation ) {
      var x = operation[ 5 ];
      var y = operation[ 6 ];
      var text = this._prepareText.apply( this, operation.slice( 1, 5 ) );
      var lines = text.split( "\n" );
      if( lines.length > 1 ) {
        var textBounds = this._getTextBounds.apply( this, operation.slice( 1, 7 ) );
        this._drawText( lines, textBounds, false );
      } else {
        this._context.save();
        this._context.fillStyle = this._context.strokeStyle;
        this._context.fillText( text, x, y );
        this._context.restore();
      }
    },

    _fillText : function( operation ) {
      var text = this._prepareText.apply( this, operation.slice( 1, 5 ) );
      var lines = text.split( "\n" );
      var textBounds = this._getTextBounds.apply( this, operation.slice( 1, 7 ) );
      this._drawText( lines, textBounds, true );
    },

    _drawText : function( textLines, bounds, fill ) {
      this._context.save();
      if( fill ) {
        this._context.fillRect.apply( this._context, bounds );
      }
      this._context.fillStyle = this._context.strokeStyle;
      var lineHeight = bounds[ 3 ] / textLines.length;
      for( var i = 0; i < textLines.length; i++ ) {
        this._context.fillText( textLines[ i ], bounds[ 0 ], i * lineHeight + bounds[ 1 ] );
      }
      this._context.restore();
    },

    _drawImage : function( operation ) {
      var args = operation.slice( 1 );
      var image = new Image();
      image.src = args[ 0 ];
      args[ 0 ] = image;
      // On (native) canvas, only loaded images can be drawn:
      if( image.complete ) {
        this._context.drawImage.apply( this._context, args );
      } else {
        var alpha = this._context.globalAlpha;
        var context = this._context;
        image.onload = function() {
          // TODO [tb] : The z-order will be wrong in this case.
          context.save();
          context.globalAlpha = alpha;
          context.drawImage.apply( context, args );
          context.restore();
        };
      }
    },

    _createLinearGradient : function( operation ) {
      var func = this._context.createLinearGradient;
      this._linearGradient = func.apply( this._context, operation.slice( 1 ) );
    },

    _addColorStop : function( operation ) {
      this._linearGradient.addColorStop(
        operation[ 1 ],
        rwt.util.Colors.rgbToRgbString( operation[ 2 ] )
      );
    },

    _prepareText : function( value, drawMnemonic, drawDelemiter, drawTab ) {
      var EncodingUtil = rwt.util.Encoding;
      var text = drawMnemonic ? EncodingUtil.removeAmpersandControlCharacters( value ) : value;
      var replacement = drawDelemiter ? "\n" : "";
      text = EncodingUtil.replaceNewLines( text, replacement );
      replacement = drawTab ? "    " : "";
      text = text.replace( /\t/g, replacement );
      return text;
    },

    _getTextBounds : function( text, drawMnemonic, drawDelemiter, drawTab, x, y ) {
      var escapedText = this._escapeText( text, drawMnemonic, drawDelemiter, drawTab );
      var fontProps = {};
      rwt.html.Font.fromString( this._context.font ).renderStyle( fontProps );
      var calc = rwt.widgets.util.FontSizeCalculation;
      var dimension = calc.computeTextDimensions( escapedText, fontProps );
      return [ x, y, dimension[ 0 ], dimension[ 1 ] ];
    },

    _escapeText : function( value, drawMnemonic, drawDelemiter, drawTab ) {
      var EncodingUtil = rwt.util.Encoding;
      var text = EncodingUtil.escapeText( value, drawMnemonic );
      var replacement = drawDelemiter ? "<br/>" : "";
      text = EncodingUtil.replaceNewLines( text, replacement );
      replacement = drawTab ? "&nbsp;&nbsp;&nbsp;&nbsp;" : "";
      text = text.replace( /\t/g, replacement );
      return text;
    },

    _toCssFont : function( fontArray ) {
      var result = "";
      if( fontArray[ 3 ] ) {
        result += "italic ";
      }
      if( fontArray[ 2 ] ) {
        result += "bold ";
      }
      result += fontArray[ 1 ] + "px ";
      result += fontArray[ 0 ].join( "," );
      return result;
    }

  }
} );

/*******************************************************************************
 * Copyright (c) 2011, 2013 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.remote.HandlerRegistry.add( "rwt.widgets.Composite", {

  factory : function( properties ) {
    var result = new rwt.widgets.Composite();
    rwt.remote.HandlerUtil.addStatesForStyles( result, properties.style );
    result.setUserData( "isControl", true );
    rwt.remote.HandlerUtil.setParent( result, properties.parent );
    return result;
  },

  destructor : rwt.remote.HandlerUtil.getControlDestructor(),

  getDestroyableChildren : rwt.remote.HandlerUtil.getDestroyableChildrenFinder(),

  properties : rwt.remote.HandlerUtil.extendControlProperties( [
    "backgroundGradient",
    "roundedBorder",
    "clientArea"
  ] ),

  propertyHandler : rwt.remote.HandlerUtil.extendControlPropertyHandler( {
    "backgroundGradient" : rwt.remote.HandlerUtil.getBackgroundGradientHandler(),
    "roundedBorder" : rwt.remote.HandlerUtil.getRoundedBorderHandler()
  } ),

  listeners : rwt.remote.HandlerUtil.extendControlListeners( [] ),

  listenerHandler : rwt.remote.HandlerUtil.extendControlListenerHandler( {} ),

  methods: [ "addListener", "removeListener" ],

  methodHandler : rwt.remote.HandlerUtil.extendListenerMethodHandler( {} ),

  scriptingMethods : rwt.remote.HandlerUtil.extendControlScriptingMethods( {} )

} );

/*******************************************************************************
 * Copyright (c) 2009, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.qx.Class.define( "rwt.widgets.Composite", {

  extend : rwt.widgets.base.Parent,

  include : [ rwt.animation.VisibilityAnimationMixin, rwt.widgets.util.OverStateMixin ],

  construct : function() {
    this.base( arguments );
    this.setAppearance( "composite" );
    this.setOverflow( "hidden" );
    this.setHideFocus( true );
    // Disable scrolling (see bug 345903)
    rwt.widgets.base.Widget.disableScrolling( this );
    this._clientArea = [ 0, 0, 0, 0 ];
  },

  destruct : function() {
    this._clientArea = null;
  },

  members : {

    setClientArea : function( clientArea ) {
      this._clientArea = clientArea;
      this.dispatchSimpleEvent( "clientAreaChanged" );
    },

    getClientArea : function() {
      return this._clientArea.concat();
    }

  }
} );

/*******************************************************************************
 * Copyright (c) 2007, 2014 Innoopract Informationssysteme GmbH and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Innoopract Informationssysteme GmbH - initial API and implementation
 *    EclipseSource - ongoing development
 ******************************************************************************/

rwt.qx.Class.define( "rwt.widgets.Sash", {

  extend : rwt.widgets.base.Parent,

  include : rwt.widgets.util.OverStateMixin,

  construct : function() {
    this.base( arguments );
    this.setOverflow( null );
    this.setHtmlProperty( "unselectable", "on" );
    this.addEventListener( "changeWidth", this._onChangeSize, this );
    this.addEventListener( "changeHeight", this._onChangeSize, this );
    this._slider = new rwt.widgets.base.Parent();
    this._slider.setAppearance( "sash-slider" );
    this._slider.setVisibility( false );
    this.add( this._slider );
    this._sliderHandle = new rwt.widgets.base.Parent();
    rwt.html.Style.setBackgroundPosition( this._sliderHandle, "center center" );
    this._sliderHandle.setAppearance( "sash-handle" );
    this._sliderHandle.setVisibility( false );
    this.add( this._sliderHandle );
    this._handle = new rwt.widgets.base.Parent();
    rwt.html.Style.setBackgroundPosition( this._handle, "center center" );
    this._handle.setAppearance( "sash-handle" );
    this.add( this._handle );
    this.initOrientation();
    this._bufferZIndex = null;
  },

  destruct : function() {
    this.removeEventListener( "changeWidth", this._onChangeSize, this );
    this.removeEventListener( "changeHeight", this._onChangeSize, this );
    this._removeStyle( this.getOrientation() );
    this._disposeObjects( "_slider", "_handle", "_sliderHandle" );
  },

  properties : {

    appearance : {
      refine : true,
      init : "sash"
    },

    orientation : {
      check : [ "horizontal", "vertical" ],
      apply : "_applyOrientation",
      init : "horizontal",
      nullable : true
    }

  },

  members : {

    _onChangeSize : function() {
      this._handle.setWidth( this.getWidth() );
      this._handle.setHeight( this.getHeight() );
    },

    _onMouseDownX : function( evt ) {
      if( evt.isLeftButtonPressed() ) {
        if( this.getEnabled() ) {
          this._commonMouseDown();
          this._dragOffset = evt.getPageX();
          this._minMove = - this.getLeft() - this._frameOffset;
          this._maxMove = this.getParent().getWidth() - this.getLeft()
                              - this.getWidth() - this._frameOffset;
        }
      }
    },

    _onMouseDownY : function( evt ) {
      if( evt.isLeftButtonPressed() ) {
        if( this.getEnabled() ) {
          this._commonMouseDown();
          this._dragOffset = evt.getPageY();
          this._minMove = - this.getTop() - this._frameOffset;
          this._maxMove = this.getParent().getHeight() - this.getTop()
                              - this.getHeight() - this._frameOffset;
        }
      }
    },

    _commonMouseDown : function() {
      this.setCapture( true );
      this.getTopLevelWidget().setGlobalCursor( this.getCursor() );
      // Used to subtract border width
      // Note: Assumes that the Sash border has equal width on all four edges
      this._frameOffset = this.getFrameWidth() / 2;
      this._slider.setLeft( 0 - this._frameOffset );
      this._slider.setTop( 0 - this._frameOffset );
      this._slider.setWidth( this.getWidth() );
      this._slider.setHeight( this.getHeight() );
      this._sliderHandle.setLeft( 0 );
      this._sliderHandle.setTop( 0 );
      this._sliderHandle.setWidth( this.getWidth() );
      this._sliderHandle.setHeight( this.getHeight() );
      this._bufferZIndex = this.getZIndex();
      this.setZIndex( 1e7 );
      this._slider.show();
      this._sliderHandle.show();
      // notify server
      this._sendWidgetSelected();
    },

    _onMouseUpX : function() {
      if( this.getCapture() ) {
        this._commonMouseUp();
      }
    },

    _onMouseUpY : function() {
      if( this.getCapture() ) {
        this._commonMouseUp();
      }
    },

    _commonMouseUp : function() {
      this._slider.hide();
      this._sliderHandle.hide();
      this.setCapture( false );
      this.getTopLevelWidget().setGlobalCursor( null );
      if( this._bufferZIndex != null ) {
        this.setZIndex( this._bufferZIndex );
      }
      var widgetUtil = rwt.widgets.util.WidgetUtil;
      widgetUtil._fakeMouseEvent( this, "mouseout" );
      // notify server
      this._sendWidgetSelected();
    },

    _onMouseMoveX : function( evt ) {
      if( this.getCapture() ) {
        // [if] Global cursor is reset by Request#_hideWaitHint. Set it again.
        if( this.getTopLevelWidget().getGlobalCursor() != this.getCursor() ) {
          this.getTopLevelWidget().setGlobalCursor( this.getCursor() );
        }
        var toMove = evt.getPageX() - this._dragOffset;
        this._slider.setLeft( this._normalizeMove( toMove ) );
        this._sliderHandle.setLeft( this._normalizeMove( toMove ) );
      }
    },

    _onMouseMoveY : function( evt ) {
      if( this.getCapture() ) {
        // [if] Global cursor is reset by Request#_hideWaitHint. Set it again.
        if( this.getTopLevelWidget().getGlobalCursor() != this.getCursor() ) {
          this.getTopLevelWidget().setGlobalCursor( this.getCursor() );
        }
        var toMove = evt.getPageY() - this._dragOffset;
        this._slider.setTop( this._normalizeMove( toMove ) );
        this._sliderHandle.setTop( this._normalizeMove( toMove ) );
      }
    },

    _normalizeMove : function( toMove ) {
      var result = toMove;
      if( result < this._minMove ) {
        result = this._minMove;
      }
      if( result > this._maxMove ) {
        result = this._maxMove;
      }
      return result;
    },

    _applyOrientation : function( value, old ) {
      this._removeStyle( old );
      this._setStyle( value );
    },

    _setStyle : function( style ) {
      if( style == "horizontal" ) {
        this.addEventListener( "mousedown", this._onMouseDownY, this );
        this.addEventListener( "mousemove", this._onMouseMoveY, this );
        this.addEventListener( "mouseup", this._onMouseUpY, this );
        this.addState( "horizontal" );
        this._handle.addState( "horizontal" );
        this._sliderHandle.addState( "horizontal" );
      } else if( style == "vertical" ) {
        this.addEventListener( "mousemove", this._onMouseMoveX, this );
        this.addEventListener( "mousedown", this._onMouseDownX, this );
        this.addEventListener( "mouseup", this._onMouseUpX, this );
        this.addState( "vertical" );
        this._handle.addState( "vertical" );
        this._sliderHandle.addState( "vertical" );
      }
    },

    _removeStyle : function( style ) {
      if( style == "horizontal" ) {
        this.removeEventListener( "mousedown", this._onMouseDownY, this );
        this.removeEventListener( "mousemove", this._onMouseMoveY, this );
        this.removeEventListener( "mouseup", this._onMouseUpY, this );
        this.removeState( "horizontal" );
        this._handle.removeState( "horizontal" );
        this._sliderHandle.removeState( "horizontal" );
      } else if( style == "vertical" ) {
        this.removeEventListener( "mousedown", this._onMouseDownX, this );
        this.removeEventListener( "mousemove", this._onMouseMoveX, this );
        this.removeEventListener( "mouseup", this._onMouseUpX, this );
        this.removeState( "vertical" );
        this._handle.removeState( "vertical" );
        this._sliderHandle.removeState( "vertical" );
      }
    },

    _sendWidgetSelected : function() {
      var leftOffset = this._slider.getLeft() + this._frameOffset;
      var topOffset = this._slider.getTop() + this._frameOffset;
      rwt.remote.EventUtil.notifySelected(
        this,
        this.getLeft() + leftOffset,
        this.getTop() + topOffset,
        this.getWidth(),
        this.getHeight(),
        this.getCapture() ? "drag" : null
       );
    }

  }

} );

/*******************************************************************************
 * Copyright (c) 2011, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.remote.HandlerRegistry.add( "rwt.widgets.Sash", {

  factory : function( properties ) {
    var result = new rwt.widgets.Sash();
    rwt.remote.HandlerUtil.addStatesForStyles( result, properties.style );
    result.setUserData( "isControl", true );
    rwt.remote.HandlerUtil.setParent( result, properties.parent );
    var orientation = rwt.widgets.util.Layout.ORIENTATION_VERTICAL;
    if( properties.style.indexOf( "HORIZONTAL" ) != -1 ) {
      orientation = rwt.widgets.util.Layout.ORIENTATION_HORIZONTAL;
    }
    result.setOrientation( orientation );
    return result;
  },

  destructor : rwt.remote.HandlerUtil.getControlDestructor(),

  getDestroyableChildren : rwt.remote.HandlerUtil.getDestroyableChildrenFinder(),

  properties : rwt.remote.HandlerUtil.extendControlProperties( [] ),

  propertyHandler : rwt.remote.HandlerUtil.extendControlPropertyHandler( {} ),

  events : [ "Selection" ],

  listeners : rwt.remote.HandlerUtil.extendControlListeners( [] ),

  listenerHandler : rwt.remote.HandlerUtil.extendControlListenerHandler( {} )

} );

/*******************************************************************************
 * Copyright (c) 2011, 2013 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.remote.HandlerRegistry.add( "rwt.widgets.Canvas", {

  factory : function( properties ) {
    var result = new rwt.widgets.Composite();
    rwt.remote.HandlerUtil.addStatesForStyles( result, properties.style );
    result.setUserData( "isControl", true );
    rwt.remote.HandlerUtil.setParent( result, properties.parent );
    return result;
  },

  destructor : rwt.remote.HandlerUtil.getControlDestructor(),

  getDestroyableChildren : rwt.remote.HandlerUtil.getDestroyableChildrenFinder(),

  properties : rwt.remote.HandlerUtil.extendControlProperties( [
    "backgroundGradient",
    "roundedBorder",
    "clientArea"
  ] ),

  propertyHandler : rwt.remote.HandlerUtil.extendControlPropertyHandler( {
    "backgroundGradient" : rwt.remote.HandlerUtil.getBackgroundGradientHandler(),
    "roundedBorder" : rwt.remote.HandlerUtil.getRoundedBorderHandler()
  } ),

  listeners : rwt.remote.HandlerUtil.extendControlListeners( [] ),

  listenerHandler : rwt.remote.HandlerUtil.extendControlListenerHandler( {} ),

  methods: [ "addListener", "removeListener" ],

  methodHandler : rwt.remote.HandlerUtil.extendListenerMethodHandler( {} ),

  /**
   * @class RWT Scripting analoge to org.eclipse.swt.widgets.Canvas
   * @name Canvas
   * @extends Composite
   * @description The constructor is not public.
   * @since 2.2
   */
  scriptingMethods : rwt.remote.HandlerUtil.extendControlScriptingMethods(
    /** @lends Canvas.prototype */
  {

    /**
     * @description Fires a Paint event.
     * <p>
     *   Only <code>ClientListener</code> are notified, not server side listener.
     * </p>
     * @see SWT.Paint
     * @see Event#gc
     */
    redraw : function() {
      var gc = rwt.widgets.util.WidgetUtil.getGC( this );
      var width = this.getInnerWidth();
      var height = this.getInnerHeight();
      var fillStyle = this.getBackgroundColor();
      var strokeStyle = this.getTextColor();
      var font = [[]];
      if( this.getFont() ) {
        font[ 0 ] = this.getFont().getFamily();
        font[ 1 ] = this.getFont().getSize();
        font[ 2 ] = this.getFont().getBold();
        font[ 3 ] = this.getFont().getItalic();
      }
      gc.init(
        width,
        height,
        font,
        rwt.util.Colors.stringToRgb( fillStyle ? fillStyle : "#000000" ),
        rwt.util.Colors.stringToRgb( strokeStyle ? strokeStyle : "#000000" )
      );
    }
  } )


} );

/*******************************************************************************
 * Copyright: 2004, 2014 1&1 Internet AG, Germany, http://www.1und1.de,
 *                       and EclipseSource
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v1.0 which accompanies this
 * distribution, and is available at http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

rwt.qx.Class.define( "rwt.widgets.List", {
  extend : rwt.widgets.base.Scrollable,

  construct : function( multiSelection ) {
    this.base( arguments, new rwt.widgets.base.VerticalBoxLayout() );
    this.setAppearance( "list" );
    this.setScrollBarsVisible( false, false );
    this._manager = new rwt.widgets.util.SelectionManager( this._clientArea );
    this._manager.setMultiSelection( multiSelection );
    this._manager.setDragSelection( false );
    this._manager.addEventListener( "changeLeadItem", this._onChangeLeadItem, this );
    this._manager.addEventListener( "changeSelection", this._onSelectionChange, this );
    this.addEventListener( "focus", this._onFocusChange, this );
    this.addEventListener( "blur", this._onFocusChange, this );
    this.addEventListener( "mouseover", this._onMouseOver, this );
    this.addEventListener( "mousedown", this._onMouseDown, this );
    this.addEventListener( "mouseup", this._onMouseUp, this );
    this.addEventListener( "click", this._onClick, this );
    this.addEventListener( "dblclick", this._onDblClick, this );
    this.addEventListener( "keypress", this._onKeyPress, this );
    this.addEventListener( "appear", this._onAppear, this );
    this.addEventListener( "userScroll", this._onUserScroll );
    this.initOverflow();
    this.initTabIndex();
    this._pressedString = "";
    this._lastKeyPress = 0;
    this._itemWidth = 0;
    this._itemHeight = 0;
    this._topIndex = 0;
    this._markupEnabled = false;
  },

  destruct : function() {
    this._disposeObjects( "_manager" );
  },

  members : {

    setMarkupEnabled : function( value ) {
      this._markupEnabled = value;
    },

    getSelectedItem : function() {
      return this._manager.getSelectedItems()[0] || null;
    },

    getSelectedItems : function() {
      return this._manager.getSelectedItems();
    },

    _onAppear : function() {
      // [ad] Fix for Bug 277678
      // when #showSelection() is called for invisible widget
      this._applyTopIndex( this._topIndex );
    },

    setTopIndex : function( value ) {
      this._topIndex = value;
      this._applyTopIndex( value );
    },

    _applyTopIndex : function( newIndex ) {
      var items = this._manager.getItems();
      if( items.length > 0 && items[ 0 ].isCreated() ) {
        if( this._itemHeight > 0 ) {
          this.setVBarSelection( newIndex * this._itemHeight );
        }
      }
    },

    _getTopIndex : function() {
      var topIndex = 0;
      var scrollTop = this._clientArea.getScrollTop();
      var items = this._manager.getItems();
      if( items.length > 0 ) {
        var itemHeight = this._manager.getItemHeight( items[ 0 ] );
        if( itemHeight > 0 ) {
          topIndex = Math.round( scrollTop / itemHeight );
        }
      }
      return topIndex;
    },

    _onChangeLeadItem : function() {
      if( !rwt.remote.EventUtil.getSuspended() ) {
        var focusIndex = this._clientArea.indexOf( this._manager.getLeadItem() );
        rwt.remote.Connection.getInstance().getRemoteObject( this ).set( "focusIndex", focusIndex );
      }
    },

    _onSelectionChange : function() {
      if( !rwt.remote.EventUtil.getSuspended() ) {
        this._sendSelectionChange();
        rwt.remote.EventUtil.notifySelected( this );
      }
      this._updateSelectedItemState();
    },

    _sendSelectionChange : function() {
      var selection = [];
      var selectedItems = this._manager.getSelectedItems();
      for( var i = 0; i < selectedItems.length; i++ ) {
        var index = this._clientArea.indexOf( selectedItems[ i ] );
        selection.push( index );
      }
      rwt.remote.Connection.getInstance().getRemoteObject( this ).set( "selection", selection );
    },

    _onFocusChange : function() {
      this._updateSelectedItemState();
    },

    _updateSelectedItemState : function() {
      var selectedItems = this._manager.getSelectedItems();
      for( var i = 0; i < selectedItems.length; i++ ) {
        selectedItems[ i ].toggleState( "parent_unfocused", !this.getFocused() );
      }
    },

    _onUserScroll : function() {
      this._topIndex = this._isCreated ? this._getTopIndex() : 0;
      rwt.remote.Connection.getInstance().getRemoteObject( this ).set( "topIndex", this._topIndex );
    },

    _onDblClick : function() {
      rwt.remote.EventUtil.notifyDefaultSelected( this );
    },

    _onMouseOver : function( event ) {
      var item = this.getListItemTarget( event.getTarget() );
      if( item ) {
        this._manager.handleMouseOver( item, event );
      }
    },

    _onMouseDown : function( event ) {
      if( !this._checkAndProcessHyperlink( event ) ) {
        var item = this.getListItemTarget( event.getTarget() );
        if( item ) {
          this._manager.handleMouseDown( item, event );
        }
      }
    },

    _onMouseUp : function( event ) {
      if( !this._checkAndProcessHyperlink( event ) ) {
        var item = this.getListItemTarget( event.getTarget() );
        if( item ) {
          this._manager.handleMouseUp( item, event );
        }
      }
    },

    _onClick : function( event ) {
      if( !this._checkAndProcessHyperlink( event ) ) {
        var item = this.getListItemTarget( event.getTarget() );
        if( item ) {
          this._manager.handleClick( item, event );
        }
      }
    },

    getListItemTarget : function( item ) {
      while( item != null && item.getParent() != this._clientArea ) {
        item = item.getParent();
      }
      return item;
    },

    _onKeyPress : function( event ) {
      this._manager.handleKeyPress( event );
      // Fix for bug# 288344
      if( !event.isAltPressed() && !event.isCtrlPressed() ) {
        if( event.getCharCode() !== 0 ) {
          // Reset string after a second of non pressed key
          if( ( ( new Date() ).valueOf() - this._lastKeyPress ) > 1000 ) {
            this._pressedString = "";
          }
          // Combine keys the user pressed to a string
          this._pressedString += String.fromCharCode( event.getCharCode() );
          // Find matching item
          var matchedItem = this.findString( this._pressedString, null );
          if( matchedItem ) {
            var oldVal = this._manager._getChangeValue();
            // Temporary disable change event
            var oldFireChange = this._manager.getFireChange();
            this._manager.setFireChange( false );
            // Reset current selection
            this._manager._deselectAll();
            // Update manager
            this._manager.setItemSelected( matchedItem, true );
            this._manager.setAnchorItem( matchedItem );
            this._manager.setLeadItem( matchedItem );
            // Scroll to matched item
            matchedItem.scrollIntoView();
            // Recover event status
            this._manager.setFireChange( oldFireChange );
            // Dispatch event if there were any changes
            if( oldFireChange && this._manager._hasChanged( oldVal ) ) {
              this._manager._dispatchChange();
            }
          }
          // Store timestamp
          this._lastKeyPress = ( new Date() ).valueOf();
          event.preventDefault();
        }
      }
    },

    findString : function( text, startIndex ) {
      return this._findItem( text, startIndex || 0 );
    },

    _findItem : function( userValue, startIndex ) {
      var allItems = this.getItems();
      // If no startIndex given try to get it by current selection
      if( startIndex == null ) {
        startIndex = allItems.indexOf( this.getSelectedItem() );
        if (startIndex == -1) {
          startIndex = 0;
        }
      }
      // Mode #1: Find all items after the startIndex
      for( var i = startIndex; i < allItems.length; i++ ) {
        if( allItems[ i ].matchesString( userValue ) ) {
          return allItems[i];
        }
      }
      // Mode #2: Find all items before the startIndex
      for( var i = 0; i < startIndex; i++ ) {
        if( allItems[ i ].matchesString( userValue ) ) {
          return allItems[i];
        }
      }
      return null;
    },

    setItems : function( value ) {
      var items = this._escapeItems( value );
      // preserve selection and focused item
      var oldLeadItem = this._manager.getLeadItem();
      var oldAnchorItem = this._manager.getAnchorItem();
      var oldSelection = this._manager.getSelectedItems();
      // exchange/add/remove items
      var oldItems = this.getItems();
      for( var i = 0; i < items.length; i++ ) {
        if( i < oldItems.length ) {
          oldItems[ i ].setLabel( items[ i ] );
        } else {
          var item = new rwt.widgets.ListItem();
          item.addEventListener( "mouseover", this._onListItemMouseOver, this );
          item.addEventListener( "mouseout", this._onListItemMouseOut, this );
          // prevent items from being drawn outside the list
          this._renderItemDimension( item );
          item.setTabIndex( null );
          item.setLabel( items[ i ] );
          if( i % 2 === 0 ) {
            item.addState( "even" );
          }
          if( this._customVariant !== null ) {
            item.addState( this._customVariant );
          }
          this._clientArea.add( item );
        }
      }
      var child = null;
      while( this._clientArea.getChildrenLength() > items.length ) {
        child = this._clientArea.getLastChild();
        child.removeEventListener( "mouseover", this._onListItemMouseOver, this );
        child.removeEventListener( "mouseout", this._onListItemMouseOut, this );
        // [if] Workaround for bug:
        // 278361: [Combo] Overlays text after changing items
        // https://bugs.eclipse.org/bugs/show_bug.cgi?id=278361
        // Items are not removed from DOM if the _isDisplayable property is false.
        child._isDisplayable = true;
        child.destroy();
      }
      // restore previous selection and focusItem
      this._manager.setSelectedItems( oldSelection );
      this._manager.setLeadItem( oldLeadItem );
      if( this._manager.getMultiSelection() ) {
        this._manager.setAnchorItem( oldAnchorItem );
      }
      this._updateScrollDimension();
      this._applyTopIndex( this._topIndex );
    },

    _escapeItems : function( items ) {
      var result = items;
      if( !this._markupEnabled ) {
        var EncodingUtil = rwt.util.Encoding;
        for( var i = 0; i < result.length; i++ ) {
          result[ i ] = EncodingUtil.replaceNewLines( result[ i ], " " );
          result[ i ] = EncodingUtil.escapeText( result[ i ], false );
          result[ i ] = EncodingUtil.replaceWhiteSpaces( result[ i ] );
        }
      }
      return result;
    },

    getItems : function() {
      return this._manager.getItems();
    },

    getItemsCount : function() {
      return this.getItems().length;
    },

    getItemIndex : function( item ) {
      return this._clientArea.indexOf( item );
    },

    /**
     * Sets the single selection for the List to the item specified by the given
     * itemIndex (-1 to clear selection).
     */
    selectItem : function( itemIndex ) {
      if( itemIndex == -1 ) {
        this._manager.deselectAll();
      } else {
        var item = this.getItems()[ itemIndex ];
        this._manager.setSelectedItem( item );
        // avoid warning message. scrollIntoView works only for visible widgets
        // the assumtion is that if 'this' is visible, the item to scroll into
        // view is also visible
        if ( this._clientArea.isCreated() && this._clientArea.isDisplayable() ) {
          this._manager.scrollItemIntoView( item );
        }
      }
    },

    /**
     * Sets the multi selection for the List to the items specified by the given
     * itemIndices array (empty array to clear selection).
     */
    selectItems : function( itemIndices ) {
      this._manager.deselectAll();
      for( var i = 0; i < itemIndices.length; i++ ) {
        var item = this.getItems()[ itemIndices[ i ] ];
        this._manager.setItemSelected( item, true );
      }
    },

    /**
     * Sets the focused item the List to the item specified by the given
     * itemIndex (-1 for no focused item).
     */
    focusItem : function( itemIndex ) {
      if( itemIndex == -1 ) {
        this._manager.setLeadItem( null );
      } else {
        var items = this.getItems();
        this._manager.setLeadItem( items[ itemIndex ] );
      }
    },

    selectAll : function() {
      if( this._manager.getMultiSelection() === true ) {
        this._manager.selectAll();
      }
    },

    setItemDimensions : function( width, height ) {
      this._itemWidth = width;
      this._itemHeight = height;
      var items = this.getItems();
      for( var i = 0; i < items.length; i++ ) {
        this._renderItemDimension( items[ i ] );
      }
      this._vertScrollBar.setIncrement( height );
      this._updateScrollDimension();
      this._applyTopIndex( this._topIndex );
    },

    _updateScrollDimension : function() {
      var itemCount = this.getItems().length;
      this._horzScrollBar.setMaximum( this._itemWidth );
      this._vertScrollBar.setMaximum( this._itemHeight * itemCount );
    },

    setCustomVariant : function( value ) {
      if( this._customVariant !== null ) {
        var oldState = this._customVariant;
        this._clientArea.forEachChild( function() {
          this.removeState( oldState );
        } );
      }
      this._clientArea.forEachChild( function() {
        this.addState( value );
      } );
      this.base( arguments, value );
    },

    _renderItemDimension : function( item ) {
      item.setWidth( this._itemWidth );
      item.setHeight( this._itemHeight );
    },

    _onListItemMouseOver : function( evt ) {
      evt.getTarget().addState( "over" );
    },

    _onListItemMouseOut : function( evt ) {
      evt.getTarget().removeState( "over" );
    },

    _checkAndProcessHyperlink : function( event ) {
      var hyperlink = null;
      var target = event.getOriginalTarget();
      if( this._markupEnabled && target instanceof rwt.widgets.ListItem ) {
        hyperlink = this._findHyperlink( event );
        if( hyperlink !== null && this._isRWTHyperlink( hyperlink ) ) {
          event.setDefaultPrevented( true );
          if( event.getType() === "click" ) {
            this._activateHyperlink( hyperlink );
          }
        }
      }
      return hyperlink !== null;
    },

    _activateHyperlink : function( hyperlink ) {
      var text = hyperlink.getAttribute( "href" );
      if( !text ) {
        text = hyperlink.innerHTML;
      }
      var properties = {
        "detail" : "hyperlink",
        "text" : text
      };
      rwt.remote.EventUtil.notifySelected( this, properties );
    },

    _findHyperlink : function( event ) {
      var targetNode = event.getDomTarget();
      var tagName = targetNode.tagName.toLowerCase();
      while( tagName !== 'a' && tagName !== 'div' ) {
        targetNode = targetNode.parentNode;
        tagName = targetNode.tagName.toLowerCase();
      }
      return tagName === 'a' ? targetNode : null;
    },

    _isRWTHyperlink : function( hyperlink ) {
      return hyperlink.getAttribute( "target" ) === "_rwt";
    }

  }

} );

/*******************************************************************************
 * Copyright (c) 2011, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.remote.HandlerRegistry.add( "rwt.widgets.List", {

  factory : function( properties ) {
    var multiSelection = properties.style.indexOf( "MULTI" ) != -1;
    var result = new rwt.widgets.List( multiSelection );
    result.setMarkupEnabled( properties.markupEnabled === true );
    rwt.remote.HandlerUtil.addStatesForStyles( result, properties.style );
    result.setUserData( "isControl", true );
    rwt.remote.HandlerUtil.setParent( result, properties.parent );
    return result;
  },

  destructor : rwt.remote.HandlerUtil.getControlDestructor(),

  getDestroyableChildren : rwt.remote.HandlerUtil.getDestroyableChildrenFinder(),

  properties : rwt.remote.HandlerUtil.extendControlProperties( [
    // order of items, selection, focus is crucial
    "items",
    "selectionIndices",
    "topIndex",
    "focusIndex",
    "itemDimensions"
  ] ),

  propertyHandler : rwt.remote.HandlerUtil.extendControlPropertyHandler( {
    "selectionIndices" : function( widget, value ) {
      if( widget.hasState( "rwt_MULTI" ) ) {
        if( widget.getItemsCount() === value.length ) {
          widget.selectAll();
        } else {
          widget.selectItems( value );
        }
      } else {
        widget.selectItem( value[ 0 ] !== undefined ? value[ 0 ] : -1 );
      }
    },
    "focusIndex" : function( widget, value ) {
      widget.focusItem( value );
    },
    "scrollBarsVisible" : function( widget, value ) {
      widget.setScrollBarsVisible( value[ 0 ], value[ 1 ] );
    },
    "itemDimensions" : function( widget, value ) {
      widget.setItemDimensions( value[ 0 ], value[ 1 ] );
    }
  } ),

  events : [ "Selection", "DefaultSelection" ],

  listeners : rwt.remote.HandlerUtil.extendControlListeners( [] ),

  listenerHandler : rwt.remote.HandlerUtil.extendControlListenerHandler( {} ),

  scriptingMethods : rwt.remote.HandlerUtil.extendControlScriptingMethods( {
    "getSelection" : function() {
      var items = this.getSelectedItems();
      var result = [];
      for( var i = 0; i < items.length; i++ ) {
        result[ i ] = rwt.util.Encoding.unescape( items[ i ].getLabel() );
      }
      return result;
    }
  } )

} );

/*******************************************************************************
 * Copyright (c) 2002, 2014 Innoopract Informationssysteme GmbH and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Innoopract Informationssysteme GmbH - initial API and implementation
 *    EclipseSource - ongoing development
 ******************************************************************************/

rwt.qx.Class.define( "rwt.widgets.util.TabUtil", {

  statics : {
    createTabItem : function( id, parentId, index ) {
      var widgetManager = rwt.remote.WidgetManager.getInstance();
      var tabFolder = widgetManager.findWidgetById( parentId );
      var tabItem = new rwt.widgets.TabItem();
      tabItem.setTabIndex( null );
      tabItem.setEnableElementFocus( false );
      tabItem.addEventListener( "changeFocused", rwt.widgets.util.TabUtil._onTabItemChangeFocus );
      tabItem.addEventListener( "changeChecked", rwt.widgets.util.TabUtil._onTabItemSelected );
      tabItem.addEventListener( "click", rwt.widgets.util.TabUtil._onTabItemClick );
      tabFolder.getBar().addAt( tabItem, index );
      var tabViewPage = new rwt.widgets.base.TabFolderPage( tabItem );
      tabFolder.getPane().add( tabViewPage );
      widgetManager.add( tabViewPage, id + "pg" );
      return tabItem;
    },

    releaseTabItem : function( tabItem ) {
      tabItem.removeEventListener( "changeFocused", rwt.widgets.util.TabUtil._onTabItemChangeFocus );
      tabItem.removeEventListener( "changeChecked", rwt.widgets.util.TabUtil._onTabItemSelected );
      tabItem.removeEventListener( "click", rwt.widgets.util.TabUtil._onTabItemClick );
      var widgetManager = rwt.remote.WidgetManager.getInstance();
      var itemId = widgetManager.findIdByWidget( tabItem );
      widgetManager.dispose( itemId + "pg" );
      widgetManager.dispose( itemId );
    },

    _onTabItemChangeFocus : function( evt ) {
      // Focus the tabFolder the item belongs to when the item is focused
      if( evt.getTarget().getFocused() ) {
        evt.getTarget().getParent().getParent().focus();
      }
    },

    _onTabItemClick : function( evt ) {
      // Focus the tabFolder the item belongs to when the item is clicked
      var folder = evt.getTarget().getParent().getParent();
      if( !folder.getFocused() ) {
        folder.focus();
      }
    },

    _onTabItemSelected : function( evt ) {
      var tab = evt.getTarget();
      if( !rwt.remote.EventUtil.getSuspended() && tab.getChecked() ) {
        var itemId = rwt.remote.WidgetManager.getInstance().findIdByWidget( tab );
        var folder = tab.getParent().getParent();
        var remoteObject = rwt.remote.Connection.getInstance().getRemoteObject( folder );
        remoteObject.set( "selection", itemId );
        rwt.remote.EventUtil.notifySelected( folder, { "item" : itemId } );
      }
    },

    onTabFolderKeyPress : function( evt ) {
      var folder = evt.getTarget();
      if( folder.classname == "rwt.widgets.TabFolder" ) {
        var manager = folder.getBar().getManager();
        var item = manager.getSelected();
        if( item != null ) {
          switch( evt.getKeyIdentifier() ) {
            case "Left":
              manager.selectPrevious( item );
              rwt.widgets.util.TabUtil.markTabItemFocused( folder, evt.getTarget() );
              evt.stopPropagation();
              break;
            case "Right":
              manager.selectNext( item );
              rwt.widgets.util.TabUtil.markTabItemFocused( folder, evt.getTarget() );
              evt.stopPropagation();
              break;
          }
        }
      }
    },

    onTabFolderChangeFocused : function( evt ) {
      var folder = evt.getTarget();
      var item = folder.getBar().getManager().getSelected();
      rwt.widgets.util.TabUtil.markTabItemFocused( folder, item );
    },

    markTabItemFocused : function( folder, item ) {
      var items = folder.getBar().getManager().getItems();
      for( var i = 0; i < items.length; i++ ) {
        items[i].removeState( "focused" );
      }
      // add state to the selected item if the tabFolder is focused
      if( item != null && folder.getFocused() ) {
        item.addState( "focused" );
      }
    }
  }
});

/*******************************************************************************
 * Copyright (c) 2011, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.remote.HandlerRegistry.add( "rwt.widgets.TabFolder", {

  factory : function( properties ) {
    var result = new rwt.widgets.TabFolder();
    rwt.remote.HandlerUtil.addStatesForStyles( result, properties.style );
    result.setUserData( "isControl", true );
    rwt.remote.HandlerUtil.setParent( result, properties.parent );
    result.setHideFocus( true );
    result.setPlaceBarOnTop( properties.style.indexOf( "BOTTOM" ) === -1 );
    return result;
  },

  destructor : rwt.remote.HandlerUtil.getControlDestructor(),

  getDestroyableChildren : rwt.remote.HandlerUtil.getDestroyableChildrenFinder(),

  properties : rwt.remote.HandlerUtil.extendControlProperties( [
    "selection"
  ] ),

  propertyHandler : rwt.remote.HandlerUtil.extendControlPropertyHandler( {
    "selection" : function( widget, value ) {
      rwt.remote.HandlerUtil.callWithTarget( value, function( item ) {
        var items = widget.getBar().getChildren();
        for( var index = 0; index < items.length; index++ ) {
          if( items[ index ] === item ) {
            items[ index ].setChecked( true );
          } else if( items[ index ].getChecked() ) {
            items[ index ].setChecked( false );
          }
        }
      } );
    }
  } ),

  events : [ "Selection" ],

  listeners : rwt.remote.HandlerUtil.extendControlListeners( [] ),

  listenerHandler : rwt.remote.HandlerUtil.extendControlListenerHandler( {} )

} );

/*******************************************************************************
 * Copyright (c) 2011, 2015 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.remote.HandlerRegistry.add( "rwt.widgets.TabItem", {

  factory : function( properties ) {
    var result = rwt.widgets.util.TabUtil.createTabItem( properties.id,
                                                         properties.parent,
                                                         properties.index );

    rwt.remote.HandlerUtil.callWithTarget( properties.parent, function( parent ) {
      rwt.remote.HandlerUtil.addDestroyableChild( parent, result );
      result.setUserData( "protocolParent", parent );
    } );
    return result;
  },

  destructor : function( widget ) {
    var control = widget.getUserData( "control" );
    if( control ) {
      if( !control._isInGlobalDisposeQueue ) {
        control.setParent( null );
      }
      widget.setUserData( "control", null );
    }
    rwt.widgets.util.TabUtil.releaseTabItem( widget );
    var parent = widget.getUserData( "protocolParent" );
    if( parent ) {
      rwt.remote.HandlerUtil.removeDestroyableChild( parent, widget );
    }
  },

  properties : [
    "text",
    "mnemonicIndex",
    "image",
    "control",
    "toolTipMarkupEnabled",
    "toolTip",
    "customVariant",
    "badge",
    "data"
  ],

  propertyHandler : {
    "data" : rwt.remote.HandlerUtil.getControlPropertyHandler( "data" ),
    "control" : function( widget, value ) {
      if( value !== null ) {
        rwt.remote.HandlerUtil.callWithTarget( value, function( control ) {
          var widgetManager = rwt.remote.WidgetManager.getInstance();
          var id = widgetManager.findIdByWidget( widget ) + "pg";
          rwt.remote.HandlerUtil.callWithTarget( id, function( parent ) {
            control.setParent( parent );
            widget.setUserData( "control", control );
          } );
        } );
      }
    },
    "toolTipMarkupEnabled" : rwt.remote.HandlerUtil.getControlPropertyHandler( "toolTipMarkupEnabled" ),
    "toolTip" : rwt.remote.HandlerUtil.getControlPropertyHandler( "toolTip" ),
    "badge" : function( widget, value ) {
      rwt.widgets.util.Badges.setBadge( widget, value );
    }
  }

} );

/*******************************************************************************
 * Copyright (c) 2008, 2014 Innoopract Informationssysteme GmbH.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Innoopract Informationssysteme GmbH - initial API and implementation
 *    EclipseSource - ongoing development
 ******************************************************************************/

 /**
  * This is a modified version of qooxdoo qx.ui.component.DateChooser component.
  */

/**
 * Shows a calendar and allows choosing a date.
 *
 * @appearance calendar-toolbar-button {qx.ui.toolbar.Button}
 * @appearance calendar-navBar {rwt.widgets.base.BoxLayout}
 * @appearance calendar-monthyear {rwt.widgets.base.Label}
 * @appearance calendar-weekday {rwt.widgets.base.Label}
 * @appearance calendar-datepane {rwt.widgets.base.Parent}
 * @appearance calendar-weekday {rwt.widgets.base.Label}
 *
 * @appearance calendar-day {rwt.widgets.base.Label}
 * @state weekend {calendar-day}
 * @state otherMonth {calendar-day}
 * @state today {calendar-day}
 * @state selected {calendar-day}
 */
rwt.qx.Class.define("rwt.widgets.base.Calendar", {
  extend : rwt.widgets.base.BoxLayout,

  /*
  *****************************************************************************
     CONSTRUCTOR
  *****************************************************************************
  */

  /**
   * @param date {Date ? null} The initial date to show. If <code>null</code>
   *        the current day (today) is shown.
   */
  construct : function( date ) {
    this.base( arguments );
    this.setOrientation( "vertical" );

    // Create the navigation bar
    var navBar = new rwt.widgets.base.BoxLayout();
    navBar.setAppearance("calendar-navBar");

    navBar.set( {
      height  : "auto",
      spacing : 1
    } );

    var lastYearBt = new rwt.widgets.base.BasicButton( "push", true );
    var lastMonthBt = new rwt.widgets.base.BasicButton( "push", true );
    var monthYearLabel = new rwt.widgets.base.Label();
    var nextMonthBt = new rwt.widgets.base.BasicButton( "push", true );
    var nextYearBt = new rwt.widgets.base.BasicButton( "push", true );

    var wm = rwt.remote.WidgetManager.getInstance();
    wm.setToolTip( lastYearBt, "Previous year" );
    wm.setToolTip( lastMonthBt, "Previous month" );
    wm.setToolTip( nextMonthBt, "Next month" );
    wm.setToolTip( nextYearBt, "Next year" );

    lastYearBt.setTabIndex( null );
    lastYearBt.setUserData( "calendar-button", true );

    lastMonthBt.setTabIndex( null );
    lastMonthBt.setUserData( "calendar-button", true );

    nextMonthBt.setTabIndex( null );
    nextMonthBt.setUserData( "calendar-button", true );

    nextYearBt.setTabIndex( null );
    nextYearBt.setUserData( "calendar-button", true );

    lastYearBt.setAppearance("calendar-toolbar-previous-year-button");
    lastMonthBt.setAppearance("calendar-toolbar-previous-month-button");
    nextMonthBt.setAppearance("calendar-toolbar-next-month-button");
    nextYearBt.setAppearance("calendar-toolbar-next-year-button");

    lastYearBt.addEventListener("click", this._onNavButtonClicked, this);
    lastMonthBt.addEventListener("click", this._onNavButtonClicked, this);
    nextMonthBt.addEventListener("click", this._onNavButtonClicked, this);
    nextYearBt.addEventListener("click", this._onNavButtonClicked, this);

    this._lastYearBt = lastYearBt;
    this._lastMonthBt = lastMonthBt;
    this._nextMonthBt = nextMonthBt;
    this._nextYearBt = nextYearBt;

    monthYearLabel.setAppearance("calendar-monthyear");
    monthYearLabel.set( { width : "1*" } );

    navBar.add(lastYearBt, lastMonthBt, monthYearLabel, nextMonthBt, nextYearBt);
    this._monthYearLabel = monthYearLabel;

    // Create the date pane
    var datePane = new rwt.widgets.base.Parent();
    datePane.setAppearance("calendar-datepane");

    datePane.set( {
      width  : rwt.widgets.base.Calendar.CELL_WIDTH * 8,
      height : rwt.widgets.base.Calendar.CELL_HEIGHT * 7
    } );

    // Create the weekdays
    // Add an empty label as spacer for the week numbers
    var label = new rwt.widgets.base.Label();
    label.setAppearance( "calendar-week" );

    label.set( {
      width  : rwt.widgets.base.Calendar.CELL_WIDTH,
      height : rwt.widgets.base.Calendar.CELL_HEIGHT,
      left   : 0
    } );

    label.addState( "header" );
    datePane.add( label );

    this._weekdayLabelArr = [];

    for( var i=1; i<8; i++ ) {
      var label = new rwt.widgets.base.Label();
      label.setAppearance( "calendar-weekday" );
      label.setSelectable( false );
      label.setCursor( "default" );

      label.set( {
        width  : rwt.widgets.base.Calendar.CELL_WIDTH,
        height : rwt.widgets.base.Calendar.CELL_HEIGHT,
        left   : i * rwt.widgets.base.Calendar.CELL_WIDTH
      } );

      datePane.add( label );
      this._weekdayLabelArr.push( label );
    }

    // Add the days
    this._dayLabelArr = [];
    this._weekLabelArr = [];

    for( var y = 0; y < 6; y++ ) {
      // Add the week label
      var label = new rwt.widgets.base.Label();
      label.setAppearance( "calendar-week" );
      label.setSelectable( false );
      label.setCursor( "default" );

      label.set( {
        width  : rwt.widgets.base.Calendar.CELL_WIDTH,
        height : rwt.widgets.base.Calendar.CELL_HEIGHT,
        left   : 0,
        top    : (y + 1) * rwt.widgets.base.Calendar.CELL_HEIGHT
      } );

      datePane.add( label );
      this._weekLabelArr.push( label );

      // Add the day labels
      for (var x=1; x<8; x++) {
        var label = new rwt.widgets.base.Label();
        label.setAppearance( "calendar-day" );
        label.setSelectable( false );
        label.setCursor( "default" );

        label.set( {
          width  : rwt.widgets.base.Calendar.CELL_WIDTH,
          height : rwt.widgets.base.Calendar.CELL_HEIGHT,
          left   : x * rwt.widgets.base.Calendar.CELL_WIDTH,
          top    : (y + 1) * rwt.widgets.base.Calendar.CELL_HEIGHT
        } );

        label.addEventListener( "mousedown", this._onDayClicked, this );
        label.addEventListener( "dblclick", this._onDayDblClicked, this );
        label.addEventListener( "mouseover", this._onDayMouseOver, this );
        label.addEventListener( "mouseout", this._onDayMouseOut, this );
        label.setUserData( "calendar-day", true );
        datePane.add( label );
        this._dayLabelArr.push( label );
      }
    }

    // [if] The focus and key keypress event are handled by DateTimeCalendar
    // Make focusable
    // this.setTabIndex(1);
    // this.addEventListener("keypress", this._onkeypress);

    // Show the right date
    var shownDate = ( date != null ) ? date : new Date();
    this.showMonth( shownDate.getMonth(), shownDate.getFullYear() );

    // Add the main widgets
    this.add( navBar );
    this.add( datePane );

    // Initialize dimensions
    this.initWidth();
    this.initHeight();
  },

  /*
  *****************************************************************************
     EVENTS
  *****************************************************************************
  */

  events: {
    /** Fired when a date was selected. The event holds the new selected date in its data property.*/
    "select"     : "rwt.event.DataEvent"
  },

  /*
  *****************************************************************************
     STATICS
  *****************************************************************************
  */

  statics : {
    CELL_WIDTH : 24,
    CELL_HEIGHT : 16,
    MONTH_NAMES : [],
    WEEKDAY_NAMES : []
  },

  /*
  *****************************************************************************
     PROPERTIES
  *****************************************************************************
  */

  properties : {
    width : {
      refine : true,
      init : "auto"
    },

    height : {
      refine : true,
      init : "auto"
    },

    /** The currently shown month. 0 = january, 1 = february, and so on. */
    shownMonth : {
      check : "Integer",
      init : null,
      nullable : true,
      event : "changeShownMonth"
    },

    /** The currently shown year. */
    shownYear : {
      check : "Integer",
      init : null,
      nullable : true,
      event : "changeShownYear"
    },

    /** {Date} The currently selected date. */
    date : {
      check : "Date",
      init : null,
      nullable : true,
      apply : "_applyDate",
      event : "changeDate",
      transform : "_checkDate"
    }
  },

  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members : {

    _getSubWidgets : function() {
      var result = [ this._monthYearLabel ];
      result.concat( this._weekdayLabelArr, this._dayLabelArr, this._weekLabelArr );
      return result;
    },

    // property checker
    /**
     * TODOC
     *
     * @type member
     * @param value {var} Current value
     * @return {var} TODOC
     */
    _checkDate : function(value) {
      // Use a clone of the date internally since date instances may be changed
      return (value == null) ? null : new Date(value.getTime());
    },

    // property modifier
    /**
     * TODOC
     *
     * @type member
     * @param value {var} Current value
     * @param old {var} Previous value
     */
    _applyDate : function(value) {
      if ((value != null) && (this.getShownMonth() != value.getMonth() || this.getShownYear() != value.getFullYear())) {
        // The new date is in another month -> Show that month
        this.showMonth(value.getMonth(), value.getFullYear());
      } else {
        // The new date is in the current month -> Just change the states
        var newDay = (value == null) ? -1 : value.getDate();

        for (var i=0; i<6*7; i++) {
          var dayLabel = this._dayLabelArr[i];

          if (dayLabel.hasState("otherMonth")) {
            if (dayLabel.hasState("selected")) {
              dayLabel.removeState("selected");
            }
          } else {
            var day = parseInt( dayLabel.getText(), 10 );
            if( day == newDay ) {
              dayLabel.addState("selected");
            } else if (dayLabel.hasState("selected")) {
              dayLabel.removeState("selected");
            }
          }
        }
      }
    },

    /**
     * Event handler. Called when a navigation button has been clicked.
     *
     * @type member
     * @param evt {Map} the event.
     * @return {void}
     */
    _onNavButtonClicked : function(evt) {
      var year = this.getShownYear();
      var month = this.getShownMonth();

      switch(evt.getTarget()) {
        case this._lastYearBt:
          year--;
          break;

        case this._lastMonthBt:
          month--;

          if (month < 0) {
            month = 11;
            year--;
          }
          break;

        case this._nextMonthBt:
          month++;

          if (month >= 12) {
            month = 0;
            year++;
          }
          break;

        case this._nextYearBt:
          year++;
          break;
      }

      this.showMonth(month, year);
      this.setDate( new Date( year, month, 1 ) );
    },

    /**
     * Event handler. Called when a day has been clicked.
     *
     * @type member
     * @param evt {Map} the event.
     * @return {void}
     */
    _onDayClicked : function(evt) {
      if( evt.isLeftButtonPressed() ) {
        var time = evt.getTarget().dateTime;
        this.setDate(new Date(time));
      }
    },

    /**
     * TODOC
     *
     * @type member
     * @return {void}
     */
    _onDayDblClicked : function() {
      this.createDispatchDataEvent("select", this.getDate());
    },

    _onDayMouseOver : function( evt ) {
      evt.getTarget().addState( "over" );
    },

    _onDayMouseOut : function( evt ) {
      evt.getTarget().removeState( "over" );
    },

    /**
     * Event handler. Called when a key was pressed.
     *
     * @type member
     * @param evt {Map} the event.
     * @return {boolean | void} TODOC
     */
    _onkeypress : function( evt ) {
      var dayIncrement = null;
      var monthIncrement = null;
      var yearIncrement = null;
      if( evt.getModifiers() === 0 ) {
        switch( evt.getKeyIdentifier() ) {
          case "Left":
            dayIncrement = -1;
            evt.preventDefault();
            evt.stopPropagation();
            break;

          case "Right":
            dayIncrement = 1;
            evt.preventDefault();
            evt.stopPropagation();
            break;

          case "Up":
            dayIncrement = -7;
            evt.preventDefault();
            evt.stopPropagation();
            break;

          case "Down":
            dayIncrement = 7;
            evt.preventDefault();
            evt.stopPropagation();
            break;

          case "PageUp":
            monthIncrement = -1;
            evt.preventDefault();
            evt.stopPropagation();
            break;

          case "PageDown":
            monthIncrement = 1;
            evt.preventDefault();
            evt.stopPropagation();
            break;

          case "Home":
          case "End":
            evt.preventDefault();
            evt.stopPropagation();
            break;

          case "Enter":
            if (this.getDate() != null) {
              this.createDispatchDataEvent("select", this.getDate());
            }

            evt.preventDefault();
            evt.stopPropagation();
            return;
        }
      }
      else if (evt.isShiftPressed()) {
        switch(evt.getKeyIdentifier()) {
          case "PageUp":
            yearIncrement = -1;
            evt.preventDefault();
            evt.stopPropagation();
            break;

          case "PageDown":
            yearIncrement = 1;
            evt.preventDefault();
            evt.stopPropagation();
            break;
        }
      }

      if (dayIncrement != null || monthIncrement != null || yearIncrement != null) {
        var date = this.getDate();

        if (date != null) {
          date = new Date(date.getTime()); // TODO: Do cloning in getter
        }

        if (date == null) {
          date = new Date();
        } else {
          if( dayIncrement != null ) {
            date.setDate( date.getDate() + dayIncrement );
          }
          if( monthIncrement != null ) {
            date.setMonth( date.getMonth() + monthIncrement );
          }
          if( yearIncrement != null ) {
            date.setFullYear( date.getFullYear() + yearIncrement );
          }
        }

        this.setDate(date);
      }
    },

    // ***** Methods *****
    /**
     * Shows a certain month.
     *
     * @type member
     * @param month {Integer ? null} the month to show (0 = january). If not set the month
     *      will remain the same.
     * @param year {Integer ? null} the year to show. If not set the year will remain the
     *      same.
     * @return {void}
     */
    showMonth : function(month, year) {
      if ((month != null && month != this.getShownMonth()) || (year != null && year != this.getShownYear())) {
        if (month != null) {
          this.setShownMonth(month);
        }

        if (year != null) {
          this.setShownYear(year);
        }

        this._updateDatePane();
      }
    },

    /**
     * Updates the date pane.
     *
     * @type member
     * @return {void}
     */
    _updateDatePane : function() {
      var today = new Date();
      var todayYear = today.getFullYear();
      var todayMonth = today.getMonth();
      var todayDayOfMonth = today.getDate();

      var selDate = this.getDate();
      var selYear = (selDate == null) ? -1 : selDate.getFullYear();
      var selMonth = (selDate == null) ? -1 : selDate.getMonth();
      var selDayOfMonth = (selDate == null) ? -1 : selDate.getDate();

      var shownMonth = this.getShownMonth();
      var shownYear = this.getShownYear();

      var startOfWeek = this.__getWeekStart();

      // Create a help date that points to the first of the current month
      var helpDate = new Date(this.getShownYear(), this.getShownMonth(), 1);

      var year = this.getShownYear();
      var month = rwt.widgets.base.Calendar.MONTH_NAMES[ this.getShownMonth() ];
      this._monthYearLabel.setText( month + " " + year );

      // Show the day names
      var firstDayOfWeek = helpDate.getDay();
      var firstSundayInMonth = (1 + 7 - firstDayOfWeek) % 7;

      for (var i=0; i<7; i++) {
        var day = (i + startOfWeek) % 7;

        var dayLabel = this._weekdayLabelArr[i];

        helpDate.setDate(firstSundayInMonth + day);

        var weekdayName = rwt.widgets.base.Calendar.WEEKDAY_NAMES[ helpDate.getDay() + 1 ];

        dayLabel.setText( weekdayName );

        dayLabel.toggleState( "weekend", this.__isWeekend( day ) );
      }

      // Show the days
      helpDate = new Date(shownYear, shownMonth, 1);
      var nrDaysOfLastMonth = (7 + firstDayOfWeek - startOfWeek) % 7;
      helpDate.setDate(helpDate.getDate() - nrDaysOfLastMonth);

      for (var week=0; week<6; week++) {
        this._weekLabelArr[week].setText("" + this.__getWeekInYear(helpDate));

        for (var i=0; i<7; i++) {
          var dayLabel = this._dayLabelArr[week * 7 + i];

          var year = helpDate.getFullYear();
          var month = helpDate.getMonth();
          var dayOfMonth = helpDate.getDate();

          var isSelectedDate = (selYear == year && selMonth == month && selDayOfMonth == dayOfMonth);
          var isToday = (year == todayYear && month == todayMonth && dayOfMonth == todayDayOfMonth);

          dayLabel.toggleState( "selected", isSelectedDate );
          dayLabel.toggleState( "otherMonth", month != shownMonth );
          dayLabel.toggleState( "today", isToday );

          dayLabel.setText("" + dayOfMonth);
          dayLabel.dateTime = helpDate.getTime();

          // Go to the next day
          helpDate.setDate(helpDate.getDate() + 1);
        }
      }
    },

    /**
     * Returns the thursday in the same week as the date.
     *
     * @type member
     * @param date {Date} the date to get the thursday of.
     * @return {Date} the thursday in the same week as the date.
     */
    __thursdayOfSameWeek : function(date) {
      return new Date(date.getTime() + (3 - ((date.getDay() + 6) % 7)) * 86400000);
    },

    /**
     * Returns the week in year of a date.
     *
     * @type member
     * @param date {Date} the date to get the week in year of.
     * @return {Integer} the week in year.
     */
    __getWeekInYear : function(date) {
      // This algorithm gets the correct calendar week after ISO 8601.
      // This standard is used in almost all european countries.
      // TODO: In the US week in year is calculated different!
      // See http://www.merlyn.demon.co.uk/weekinfo.htm
      // The following algorithm comes from http://www.salesianer.de/util/kalwoch.html
      // Get the thursday of the week the date belongs to
      var thursdayDate = this.__thursdayOfSameWeek(date);

      // Get the year the thursday (and therefor the week) belongs to
      var weekYear = thursdayDate.getFullYear();

      // Get the thursday of the week january 4th belongs to
      // (which defines week 1 of a year)
      var thursdayWeek1 = this.__thursdayOfSameWeek(new Date(weekYear, 0, 4));

      // Calculate the calendar week
      return Math.floor(1.5 + (thursdayDate.getTime() - thursdayWeek1.getTime()) / 86400000 / 7);
    },

    /**
     * Return the day the week starts with
     *
     * Reference: Common Locale Data Repository (cldr) supplementalData.xml
     *
     * @type member
     * @return {Integer} index of the first day of the week. 0=sunday, 1=monday, ...
     */
    __getWeekStart : function() {
      var weekStart = {
        // default is monday
        "MV" : 5, // friday
        "AE" : 6, // saturday
        "AF" : 6,
        "BH" : 6,
        "DJ" : 6,
        "DZ" : 6,
        "EG" : 6,
        "ER" : 6,
        "ET" : 6,
        "IQ" : 6,
        "IR" : 6,
        "JO" : 6,
        "KE" : 6,
        "KW" : 6,
        "LB" : 6,
        "LY" : 6,
        "MA" : 6,
        "OM" : 6,
        "QA" : 6,
        "SA" : 6,
        "SD" : 6,
        "SO" : 6,
        "TN" : 6,
        "YE" : 6,
        "AS" : 0, // sunday
        "AU" : 0,
        "AZ" : 0,
        "BW" : 0,
        "CA" : 0,
        "CN" : 0,
        "FO" : 0,
        "GE" : 0,
        "GL" : 0,
        "GU" : 0,
        "HK" : 0,
        "IE" : 0,
        "IL" : 0,
        "IS" : 0,
        "JM" : 0,
        "JP" : 0,
        "KG" : 0,
        "KR" : 0,
        "LA" : 0,
        "MH" : 0,
        "MN" : 0,
        "MO" : 0,
        "MP" : 0,
        "MT" : 0,
        "NZ" : 0,
        "PH" : 0,
        "PK" : 0,
        "SG" : 0,
        "TH" : 0,
        "TT" : 0,
        "TW" : 0,
        "UM" : 0,
        "US" : 0,
        "UZ" : 0,
        "VI" : 0,
        "ZA" : 0,
        "ZW" : 0,
        "MW" : 0,
        "NG" : 0,
        "TJ" : 0
      };

      var territory = this.__getTerritory();

      // default is monday
      return weekStart[territory] != null ? weekStart[territory] : 1;
    },

    /**
     * Return the day the weekend starts with
     *
     * Reference: Common Locale Data Repository (cldr) supplementalData.xml
     *
     * @type member
     * @return {Integer} index of the first day of the weekend. 0=sunday, 1=monday, ...
     */
    __getWeekendStart : function() {
      var weekendStart = {
        // default is saturday
        "EG" : 5, // friday
        "IL" : 5,
        "SY" : 5,
        "IN" : 0, // sunday
        "AE" : 4, // thursday
        "BH" : 4,
        "DZ" : 4,
        "IQ" : 4,
        "JO" : 4,
        "KW" : 4,
        "LB" : 4,
        "LY" : 4,
        "MA" : 4,
        "OM" : 4,
        "QA" : 4,
        "SA" : 4,
        "SD" : 4,
        "TN" : 4,
        "YE" : 4
      };

      var territory = this.__getTerritory();

      // default is saturday
      return weekendStart[territory] != null ? weekendStart[territory] : 6;
    },

    /**
     * Return the day the weekend ends with
     *
     * Reference: Common Locale Data Repository (cldr) supplementalData.xml
     *
     * @type member
     * @return {Integer} index of the last day of the weekend. 0=sunday, 1=monday, ...
     */
    __getWeekendEnd : function() {
      var weekendEnd = {
        // default is sunday
        "AE" : 5, // friday
        "BH" : 5,
        "DZ" : 5,
        "IQ" : 5,
        "JO" : 5,
        "KW" : 5,
        "LB" : 5,
        "LY" : 5,
        "MA" : 5,
        "OM" : 5,
        "QA" : 5,
        "SA" : 5,
        "SD" : 5,
        "TN" : 5,
        "YE" : 5,
        "AF" : 5,
        "IR" : 5,
        "EG" : 6, // saturday
        "IL" : 6,
        "SY" : 6
      };

      var territory = this.__getTerritory();

      // default is sunday
      return weekendEnd[territory] != null ? weekendEnd[territory] : 0;
    },

    /**
     * Returns whether a certain day of week belongs to the week end.
     *
     * @type member
     * @param day {Integer} index of the day. 0=sunday, 1=monday, ...
     * @return {Boolean} whether the given day is a weekend day
     */
    __isWeekend : function(day) {
      var weekendStart = this.__getWeekendStart();
      var weekendEnd = this.__getWeekendEnd();

      if (weekendEnd > weekendStart) {
        return ((day >= weekendStart) && (day <= weekendEnd));
      } else {
        return ((day >= weekendStart) || (day <= weekendEnd));
      }
    },

    /**
     * Extract the territory part from a locale
     *
     * @type member
     * @return {String} territory
     */
    __getTerritory : function() {
        var territory = rwt.client.Client.getTerritory() || rwt.client.Client.getLanguage();
      return territory.toUpperCase();
    }
  },

  /*
  *****************************************************************************
     DESTRUCTOR
  *****************************************************************************
  */

  destruct : function() {
    this._disposeObjects("_lastYearBt", "_lastMonthBt", "_nextMonthBt", "_nextYearBt", "_monthYearLabel");

    this._disposeObjectDeep("_weekdayLabelArr", 1);
    this._disposeObjectDeep("_dayLabelArr", 1);
    this._disposeObjectDeep("_weekLabelArr", 1);
  }
} );

/*******************************************************************************
 * Copyright (c) 2002, 2014 Innoopract Informationssysteme GmbH and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Innoopract Informationssysteme GmbH - initial API and implementation
 *    EclipseSource - ongoing development
 ******************************************************************************/

/**
 * The parameter orientation must be one of "vertical" or "horizontal".
 * Note that updateHandleBounds must be called after each size manipulation.
 */
rwt.qx.Class.define( "rwt.widgets.CoolItem", {
  extend : rwt.widgets.base.Parent,

  construct : function( orientation ) {
    this.base( arguments );
    this.setOverflow( "hidden" );
    this.setAppearance( "coolitem" );
    this._orientation = orientation;
    // Create handle to drag this CoolItem around
    this._handle = new rwt.widgets.base.Terminator();
    this._handle.addState( orientation );
    this._handle.setAppearance( "coolitem-handle" );
    //this._handle.setHeight( "100%" );
    this._handle.addEventListener( "mousedown", this._onHandleMouseDown, this );
    this._handle.addEventListener( "mousemove", this._onHandleMouseMove, this );
    this._handle.addEventListener( "mouseup", this._onHandleMouseUp, this );
    this.add( this._handle );
    // buffers zIndex and background during drag to be restored when dropped
    this._bufferedZIndex = null;
    this._bufferedControlZIndex = null;
    this._control = null;
  },

  destruct : function() {
    if( this._handle != null ) {
      this._handle.removeEventListener( "mousedown", this._onHandleMouseDown, this );
      this._handle.removeEventListener( "mousemove", this._onHandleMouseMove, this );
      this._handle.removeEventListener( "mouseup", this._onHandleMouseUp, this );
      this._handle.dispose();
    }
  },

  statics : {
    DRAG_CURSOR : "col-resize",
    CONTROL_OFFSET : 6
  },

  members : {

    setLocked : function( value )  {
      this._handle.setDisplay( !value );
    },

    // reparenting to enable coolitem dragging
    setControl : function( control ) {
      if( control != null ) {
        // TODO [tb] : Control positioning is already handled by server
        control.setLeft( this.getLeft() + rwt.widgets.CoolItem.CONTROL_OFFSET );
        control.setDisplay( true );
      }
      if( this._control != null ) {
        this._control.setDisplay( false );
      }
      this._control = control;
    },

    updateHandleBounds : function() {
      if( this._orientation == "vertical" ) {
        this._handle.setWidth( this.getWidth() );
      } else {
        this._handle.setHeight( this.getHeight() );
      }
    },

    _applyParent : function( value, oldValue ) {
      this.base( arguments, value, oldValue );
      if( value != null ) {
        this.setLocked( value.getLocked() );
      }
    },

    _onHandleMouseDown : function( evt ) {
      this._handle.setCapture( true );
      this.getTopLevelWidget().setGlobalCursor( rwt.widgets.CoolItem.DRAG_CURSOR );
      this._offsetX = evt.getPageX() - this.getLeft();
      this._offsetY = evt.getPageY() - this.getTop();
      this._bufferedZIndex = this.getZIndex();
      this.setZIndex( 1e7 - 1 );
      if( this._control != null ) {
        this._bufferedControlZIndex = this._control.getZIndex();
        this._control.setZIndex( 1e7 );
      }
      // In some cases the coolItem appeare transparent when dragged around
      // To fix this, walk along the parent hierarchy and use the first explicitly
      // set background color.
      this.setBackgroundColor( this._findBackground() );
    },

    _applyLeft : function( newValue, oldValue ) {
      this.base( arguments, newValue, oldValue );
      if( this._control != null ) {
        var left = newValue + rwt.widgets.CoolItem.CONTROL_OFFSET;
        this._control.setLeft( left );
      }
    },

    _applyWidth : function( newValue, oldValue ) {
      this.base( arguments, newValue, oldValue );
      if( this._control != null ) {
        var width = newValue - rwt.widgets.CoolItem.CONTROL_OFFSET;
        this._control.setWidth( width );
      }
    },

    _onHandleMouseMove : function( evt ) {
      if( this._handle.getCapture() ) {
        this.setLeft( evt.getPageX() - this._offsetX );
      }
    },

    _onHandleMouseUp : function() {
      this._handle.setCapture( false );
      this.setZIndex( this._bufferedZIndex );
      if( this._control != null ) {
        this._control.setZIndex( this._bufferedControlZIndex );
      }
      this.resetBackgroundColor();
      this.getTopLevelWidget().setGlobalCursor( null );
      // Send request that informs about dragged CoolItem
      if( !rwt.remote.EventUtil.getSuspended() ) {
        rwt.remote.Connection.getInstance().getRemoteObject( this ).call( "move", {
          "left" : this.getLeft()
        } );
      }
    },

    _findBackground : function() {
      var hasParent = true;
      var result = null;
      var parent = this.getParent();
      while( hasParent && parent != null && result == null ) {
        if( parent.getBackgroundColor ) {
          result = parent.getBackgroundColor();
        }
        if( parent.getParent ) {
          parent = parent.getParent();
        } else {
          hasParent = false;
        }
      }
      return result;
    }
  }
});

/*******************************************************************************
 * Copyright (c) 2011, 2015 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.remote.HandlerRegistry.add( "rwt.widgets.CoolItem", {

  factory : function( properties ) {
    var styles = rwt.remote.HandlerUtil.createStyleMap( properties.style );
    var orientation = styles.VERTICAL ? "vertical" : "horizontal";
    var result = new rwt.widgets.CoolItem( orientation );
    rwt.remote.HandlerUtil.setParent( result, properties.parent );
    result.setMinWidth( 0 );
    result.setMinHeight( 0 );
    return result;
  },

  destructor : rwt.remote.HandlerUtil.getWidgetDestructor(),

  properties : [ "bounds", "control", "customVariant", "data" ],

  propertyHandler : {
    "data" : rwt.remote.HandlerUtil.getControlPropertyHandler( "data" ),
    "bounds" : function( widget, bounds ) {
      widget.setLeft( bounds[ 0 ] );
      widget.setTop( bounds[ 1 ] );
      widget.setWidth( bounds[ 2 ] );
      widget.setHeight( bounds[ 3 ] );
      widget.updateHandleBounds();
    },
    "control" : function( widget, controlId ) {
      rwt.remote.HandlerUtil.callWithTarget( controlId, function( control ) {
        widget.setControl( control );
      } );
    }
  }

} );

/*******************************************************************************
 * Copyright (c) 2009, 2015 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.qx.Class.define( "rwt.widgets.Button", {

  extend : rwt.widgets.base.BasicButton,

  construct : function( buttonType ) {
    this.base( arguments, buttonType );
    this._alignment = buttonType === "arrow" ? "up" : "center";
    switch( buttonType ) {
     case "arrow":
       this.addState( "rwt_UP" );
       this.setAppearance( "push-button" );
     break;
     case "push":
     case "toggle":
       this.setAppearance( "push-button" );
     break;
     case "check":
       this.setAppearance( "check-box" );
     break;
     case "radio":
       this.setAppearance( "radio-button" );
    }
    this.initTabIndex();
    this._rawText = null;
    this._mnemonicIndex = null;
    this._markupEnabled = false;
  },

  destruct : function() {
    this.setMnemonicIndex( null );
  },

  properties : {

    tabIndex : {
      refine : true,
      init : 1
    }

  },

  members : {

    setMarkupEnabled : function( value ) {
      this._markupEnabled = value;
    },

    setText : function( value ) {
      this._rawText = value;
      this._mnemonicIndex = null;
      this._applyText( false );
      this.dispatchSimpleEvent( "changeText", this ); // used by Synchronizer.js
    },

    setMnemonicIndex : function( value ) {
      this._mnemonicIndex = value;
      var mnemonicHandler = rwt.widgets.util.MnemonicHandler.getInstance();
      if( ( typeof value === "number" ) && ( value >= 0 ) ) {
        mnemonicHandler.add( this, this._onMnemonic );
      } else {
        mnemonicHandler.remove( this );
      }
    },

    getMnemonicIndex : function() {
      return this._mnemonicIndex;
    },

    setAlignment : function( value ) {
      if( this.hasState( "rwt_ARROW" ) ) {
        this.removeState( "rwt_" + this._alignment.toUpperCase() );
        this.addState( "rwt_" + value.toUpperCase() );
      } else {
        this.setHorizontalChildrenAlign( value );
      }
      this._alignment = value;
    },

    setWrap : function( value ) {
      if( value ) {
        this.setFlexibleCell( 2 );
        this.setWordWrap( true );
      }
    },

    getToolTipTargetBounds : function() {
      if( this.getSelectionIndicator() ) {
        var styleTop = parseInt( this.getCellNode( 0 ).style.top, 10 );
        return  {
          "left" : this._cachedBorderLeft + this.getPaddingLeft(),
          "top" : this._cachedBorderTop + styleTop,
          "width" : this.getSelectionIndicator()[ 1 ],
          "height" : this.getSelectionIndicator()[ 2 ]
        };
      } else {
        return  {
          "left" : 0,
          "top" : 0,
          "width" : this.getBoxWidth(),
          "height" : this.getBoxHeight()
        };
      }
    },

    computeBadgePosition : function() {
      return [ -3, -5, "auto", "auto" ];
    },

    _onMnemonic : function( event ) {
      switch( event.type ) {
        case "show":
          this._applyText( true );
        break;
        case "hide":
          this._applyText( false );
        break;
        case "trigger":
          var charCode = this._rawText.toUpperCase().charCodeAt( this._mnemonicIndex );
          if( event.charCode === charCode ) {
            this.setFocused( true );
            this.execute();
            event.success = true;
          }
        break;
      }
    },

    _applyText : function( mnemonic ) {
      var EncodingUtil = rwt.util.Encoding;
      if( this._rawText ) {
        var text = this._rawText;
        if( !this._markupEnabled ) {
          var mnemonicIndex = mnemonic ? this._mnemonicIndex : undefined;
          text = EncodingUtil.escapeText( this._rawText, mnemonicIndex );
          text = EncodingUtil.replaceNewLines( text, "<br/>" );
        }
        this.setCellContent( 2, text );
      } else {
        this.setCellContent( 2, null );
      }
    },

    //overwritten:
    _afterRenderLayout : function() {
      if( this.getFocused() ) {
         this._showFocusIndicator();
      }
    },

    _ontabfocus : function() {
      this._showFocusIndicator();
    },

    _showFocusIndicator : function() {
      if( !rwt.widgets.util.FocusHandler.mouseFocus ) {
        var focusIndicator = rwt.widgets.util.FocusIndicator.getInstance();
        var node = this.getCellNode( 2 ) != null ? this.getCellNode( 2 ) : this.getCellNode( 1 );
        focusIndicator.show( this, "Button-FocusIndicator", node );
      }
    },

    _visualizeBlur : function() {
      this.base( arguments );
      rwt.widgets.util.FocusIndicator.getInstance().hide( this );
    },

    // overwritten:
    _notifySelected : function() {
      rwt.remote.EventUtil.notifySelected( this );
    }

  }
} );

/*******************************************************************************
 * Copyright (c) 2011, 2015 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.remote.HandlerRegistry.add( "rwt.widgets.Button", {

  factory : function( properties ) {
    var styleMap = rwt.remote.HandlerUtil.createStyleMap( properties.style );
    var buttonType = "push";
    if( styleMap.CHECK ) {
      buttonType = "check";
    } else if( styleMap.TOGGLE ) {
      buttonType = "toggle";
    } else if( styleMap.RADIO ) {
      buttonType = "radio";
    } else if( styleMap.ARROW ) {
      buttonType = "arrow";
    }
    var result = new rwt.widgets.Button( buttonType );
    result.setMarkupEnabled( properties.markupEnabled === true );
    result.setWrap( styleMap.WRAP );
    rwt.remote.HandlerUtil.addStatesForStyles( result, properties.style );
    result.setUserData( "isControl", true );
    rwt.remote.HandlerUtil.setParent( result, properties.parent );
    rwt.remote.HandlerUtil.callWithTarget( properties.parent, function( parent ) {
      result.setNoRadioGroup( parent.hasState( "rwt_NO_RADIO_GROUP" ) );
    } );
    return result;
  },

  destructor : rwt.remote.HandlerUtil.getControlDestructor(),

  getDestroyableChildren : rwt.remote.HandlerUtil.getDestroyableChildrenFinder(),

  properties : rwt.remote.HandlerUtil.extendControlProperties( [
    /**
     * @name setText
     * @methodOf Button#
     * @description Sets the receivers text to the given string.
     * @param {string} text the new text
     */
    "text",
    "mnemonicIndex",
    "alignment",
    "image",
    /**
     * @name setSelection
     * @methodOf Button#
     * @description Sets the selection state of the receiver, if it is of type <code>CHECK</code>,
     * <code>RADIO</code>, or <code>TOGGLE</code>.
     *
     * <p>
     * When the receiver is of type <code>CHECK</code> or <code>RADIO</code>,
     * it is selected when it is checked. When it is of type <code>TOGGLE</code>,
     * it is selected when it is pushed in.
     * </p>
     * @param {boolean} selected the new selection state
     */
    "selection",
    "grayed",
    "badge"
  ] ),

  propertyHandler : rwt.remote.HandlerUtil.extendControlPropertyHandler( {
    "image" : function( widget, value ) {
      if( value === null ) {
        widget.setImage( value );
      } else {
        widget.setImage.apply( widget, value );
      }
    },
    "badge" : function( widget, value ) {
      rwt.widgets.util.Badges.setBadge( widget, value );
    }
  } ),

  events : [ "Selection" ],

  listeners : rwt.remote.HandlerUtil.extendControlListeners( [] ),

  listenerHandler : rwt.remote.HandlerUtil.extendControlListenerHandler( {} ),

  methods: [ "addListener", "removeListener" ],

  methodHandler : rwt.remote.HandlerUtil.extendListenerMethodHandler( {} ),

  /**
   * @class RWT Scripting analoge to org.eclipse.swt.widgets.Button
   * @name Button
   * @extends Control
   * @description The constructor is not public.
   * @since 2.2
   */
  scriptingMethods : rwt.remote.HandlerUtil.extendControlScriptingMethods(
    /** @lends Button.prototype */
  {
    /**
     * @description  Returns the widget text.
     * @return {string} the widget text
     */
    getText : function() {
      return this.getCellContent( 2 );
    },
    /**
     * @description Returns <code>true</code> if the receiver is selected,
     * and false otherwise.
     * <p>
     * When the receiver is of type <code>CHECK</code> or <code>RADIO</code>,
     * it is selected when it is checked. When it is of type <code>TOGGLE</code>,
     * it is selected when it is pushed in. If the receiver is of any other type,
     * this method returns false.
     *</p>
     * @return {boolean} the selection state
     */
    getSelection : function() {
      return this.hasState( "selected" );
    }
  } )

} );

/*******************************************************************************
 * Copyright (c) 2011, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.qx.Class.define( "rwt.widgets.FileUpload", {

  extend : rwt.widgets.Button,

  construct : function( multi ) {
    this.base( arguments, "push" );
    this.setAppearance( "file-upload" );
    this.addEventListener( "insertDom", this._layoutInputElement, this );
    this.addEventListener( "elementOver", this._onMouseOverElement, this );
    this._formElement = null;
    this._inputElement = null;
    this._iframe = null;
    this._multi = multi;
    this._cursor = "";
    this.__onValueChange = rwt.util.Functions.bind( this._onValueChange, this );
    this.setEnableElementFocus( false );
    this._createIframeWidget();
  },

  destruct : function() {
    this._formElement = null;
    this._inputElement = null;
  },

  members : {

    submit : function( url ) {
      if( typeof url !== "string" ) {
        throw new Error( "No url given!" );
      }
      if( this._getFileNames().length === 0 ) {
        throw new Error( "No file selected!" );
      }
      if( this._formElement === null ) {
        throw new Error( "Form element not created!" );
      }
      this._formElement.setAttribute( "action", url );
      this._formElement.submit();
    },

    destroy : function() {
      this.base( arguments );
      this._iframe.destroy();
    },

    execute : function() {
      // suppress button default action
    },

    ////////////
    // Internals

    _createSubElements : function() {
      // NOTE: MultiCellWidget uses innerHTML, therefore this must be done here:
      if( this._formElement === null ) {
        this.base( arguments );
        this._createFormElement();
        this._createInputElement();
      } else {
        this._formElement.removeChild( this._inputElement );
        this._getTargetNode().removeChild( this._formElement );
        this.base( arguments );
        this._getTargetNode().appendChild( this._formElement );
        this._formElement.appendChild( this._inputElement );
      }
    },

    _createFormElement : function() {
      this._formElement = document.createElement( "form" );
      this._formElement.setAttribute( "target", this._getFrameName() );
      this._formElement.setAttribute( "method", "POST" );
      this._formElement.setAttribute( "enctype", "multipart/form-data" );
      this._getTargetNode().appendChild( this._formElement );
    },

    _createInputElement : function() {
      this._inputElement = document.createElement( "input" );
      this._inputElement.style.position = "absolute";
      this._inputElement.setAttribute( "type", "file" );
      this._inputElement.setAttribute( "name", "file" );
      this._inputElement.setAttribute( "size", "1" );
      if( this._multi ) {
        this._inputElement.setAttribute( "multiple", "multiple" );
      }
      this._inputElement.style.cursor = this._cursor;
      this._inputElement.onchange = this.__onValueChange;
      this._inputElement.style.opacity = 0;
      this._formElement.appendChild( this._inputElement );
    },

    _createIframeWidget : function() {
      this._iframe = new rwt.widgets.base.Iframe();
      // NOTE: The frame-content should only be changed by the form:
      this._iframe.setSource( "about:blank" );
      this._iframe.setVisibility( false );
      this._iframe.setWidth( 0 );
      this._iframe.setHeight( 0 );
      this._iframe.setFrameName( this._getFrameName() );
      this._iframe.addToDocument();
    },

    _onValueChange : function() {
      try {
        var fileNames = this._formatFileNames( this._getFileNames() );
        rwt.remote.Connection.getInstance().getRemoteObject( this ).set( "fileNames", fileNames );
        this._notifySelected();
      } catch( ex ) {
        rwt.runtime.ErrorHandler.processJavaScriptError( ex );
      }
    },

    _getFileNames : function() {
      var element = this._inputElement;
      var result = element.value ? [ element.value ] : [];
      if( element.files ) {
        for( var i = 0; i < element.files.length; i++ ) {
          result[ i ] = element.files[ i ].name;
        }
      }
      return result;
    },

    ////////////
    // Layouting

    _layoutPost : function( changes ) {
      this.base( arguments, changes );
      if( changes.width || changes.height ) {
        this._layoutInputElement();
      }
    },

    _layoutInputElement : function() {
      if( this.getEnabled() && this.isSeeable() && !rwt.client.Client.isMobileSafari() ) {
        //Assumed maximal padding between input button and input outer dimensions:
        var padding = 10;
        this._layoutInputElementHorizontal( padding );
        this._layoutInputElementVertical( padding );
      }
    },

    _layoutInputElementHorizontal : function( padding ) {
      // Respect assumed maximal relative width of the input textfield:
      var inputButtonPercentage = 0.6;
      // NOTE : This is how inputWidth is calculated:
      // widgetWidth + padding * 2 = 0.6 * inputWidth
      // inputWidth = ( widthWidth + padding * 2 ) / 0.6
      var widgetWidth = this.getBoxWidth();
      var inputTargetWidth =   ( widgetWidth + padding * 2 )
                             / ( inputButtonPercentage );
      var fontSize = inputTargetWidth / 10;
      this._inputElement.style.fontSize = fontSize;
      var iterations = 0;
      while( this._inputElement.offsetWidth <= inputTargetWidth ) {
        fontSize += 10;
        this._inputElement.style.font = fontSize + "px monospace";
        iterations++;
        if( iterations > 100 ) {
          // crash the rap-application instead of freezing the browser.
          var msg = "Failed to force input-element width.";
          throw new Error( msg );
        }
      }
      var actualInputWidth = this._inputElement.offsetWidth;
      var inputLeft = widgetWidth - actualInputWidth + padding;
      this._inputElement.style.left = inputLeft + "px";
    },

    _layoutInputElementVertical : function( padding ) {
      var widgetHeight = this.getBoxHeight();
      this._inputElement.style.height = ( widgetHeight + padding * 2 ) + "px";
      this._inputElement.style.top = ( padding * -1 ) + "px";
    },

    setStyleProperty : function( propName, value ) {
      if( propName === "cursor" ) {
        this._cursor = value;
        if( this._inputElement != null ) {
          // NOTE : This will have no effect in firefox.
          this._inputElement.style.cursor = value;
        }
      } else {
        this.base( arguments, propName, value );
      }
    },

    _applyEnabled : function( value, oldValue ) {
      this.base( arguments, value, oldValue );
      if( this._inputElement ) {
        this._inputElement.style.display = value ? "" : "none";
        this._layoutInputElement();
      }
    },

    _afterAppear : function() {
      this.base( arguments );
      this._layoutInputElement();
    },

    ////////////////
    // Mouse-control

    // NOTE : In contrast to other widgets, the border does not trigger the
    //        expected function, adapt state-behavior accordingly:

    _onMouseOver : function( event ) {
      if( event.getDomTarget() === this._inputElement ) {
        this.base( arguments, event );
      }
    },

    _onMouseOverElement : function( event ) {
      if( event.getDomTarget() === this._inputElement ) {
        this._onMouseOver( event );
      }
    },

    _onMouseDown : function( event ) {
      if( event.getDomTarget() === this._inputElement ) {
        this.base( arguments, event );
      }
      if( rwt.client.Client.getBrowser() === "chrome") {
        // Chrome looses keyboard control on mouse-focus, see _ontabfocus.
        this._visualizeBlur();
      }
    },

    _onMouseUp : function( event ) {
      if( event.getDomTarget() === this._inputElement || this.hasState( "abandoned" ) ) {
        this.base( arguments, event );
      }
    },

    /////////////////////////
    // Focus/keyboard-control

    // NOTE : Since the browse-button can't be triggered programatically,
    //        supporting native keyboard-control is necessary, which is a bit
    //        problematic.
    _onFocus : function( event ) {
      this.base( arguments, event );
      this._inputElement.focus();
    },

    // NOTE : key-handling interferes with native keyboard control. This
    //        disables the "pressed" state, but is still the lesser evil.
    _onKeyDown : rwt.util.Functions.returnTrue,
    _onKeyUp : rwt.util.Functions.returnTrue,

    _showFocusIndicator : function() {
      var focusIndicator = rwt.widgets.util.FocusIndicator.getInstance();
      var node = this.getCellNode( 2 ) != null ? this.getCellNode( 2 ) : this.getCellNode( 1 );
      focusIndicator.show( this, "FileUpload-FocusIndicator", node );
    },

    /////////
    // Helper

    _formatFileNames : function( fileNames ) {
      var result = [];
      for( var i = 0; i < fileNames.length; i++ ) {
        var fileName = fileNames[ i ];
        if( fileName.indexOf( "\\" ) != -1 ) {
          fileName = fileName.substr( fileName.lastIndexOf( "\\" ) + 1 );
        } else if( fileName.indexOf( "/" ) != -1 ) {
          fileName = fileName.substr( fileName.lastIndexOf( "/" ) + 1 );
        }
        result[ i ] = fileName;
      }
      return result;
    },

    _getFrameName : function() {
      return "FileUpload_" + this.toHashCode();
    }

  }

} );

/*******************************************************************************
 * Copyright (c) 2011, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.remote.HandlerRegistry.add( "rwt.widgets.FileUpload", {

  factory : function( properties ) {
    var multi = properties.style.indexOf( "MULTI" ) !== -1 ;
    var result = new rwt.widgets.FileUpload( multi );
    rwt.remote.HandlerUtil.addStatesForStyles( result, properties.style );
    result.setUserData( "isControl", true );
    rwt.remote.HandlerUtil.setParent( result, properties.parent );
    return result;
  },

  destructor : rwt.remote.HandlerUtil.getControlDestructor(),

  getDestroyableChildren : rwt.remote.HandlerUtil.getDestroyableChildrenFinder(),

  properties : rwt.remote.HandlerUtil.extendControlProperties( [
    "text",
    "image"
  ] ),

  propertyHandler : rwt.remote.HandlerUtil.extendControlPropertyHandler( {
    "image" : function( widget, value ) {
      if( value === null ) {
        widget.setImage( value );
      } else {
        widget.setImage.apply( widget, value );
      }
    }
  } ),

  events : [ "Selection" ],

  listeners : rwt.remote.HandlerUtil.extendControlListeners( [] ),

  listenerHandler : rwt.remote.HandlerUtil.extendControlListenerHandler( {} ),

  methods : [
    "submit"
  ],

  methodHandler : {
    "submit" : function( widget, args ) {
      widget.submit( args.url );
    }
  }

} );

/*******************************************************************************
 * Copyright (c) 2008, 2014 Innoopract Informationssysteme GmbH and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Innoopract Informationssysteme GmbH - initial API and implementation
 *    EclipseSource - ongoing development
 ******************************************************************************/

/**
 * This class provides the client-side counterpart for
 * rwt.widgets.Slider.
 */
rwt.qx.Class.define( "rwt.widgets.Slider", {
  extend : rwt.widgets.base.AbstractSlider,

  construct : function( isHorizontal ) {
    this.base( arguments, isHorizontal );
    this._requestScheduled = false;
    this.addEventListener( "contextmenu", this._onContextMenu, this );
    this.addEventListener( "keypress", this._onKeyPress, this );
  },

  statics : {

    SEND_DELAY : 50,

    _isNoModifierPressed : function( evt ) {
      return    !evt.isCtrlPressed()
             && !evt.isShiftPressed()
             && !evt.isAltPressed()
             && !evt.isMetaPressed();
    }

  },

  members : {

    _configureAppearance : function() {
      this.setAppearance( "slider" );
      this._thumb.setAppearance( "slider-thumb" );
      this._minButton.setAppearance( "slider-min-button" );
      this._maxButton.setAppearance( "slider-max-button" );
    },

    setSelection : function( value ) {
      this._setSelection( value );
    },

    setIncrement : function( value ) {
      this._setIncrement( value );
    },

    setPageIncrement : function( value ) {
      this._setPageIncrement( value );
    },

    getToolTipTargetBounds : function() {
      return {
        "left" : this._cachedBorderLeft + ( this._thumb.getLeft() || 0 ),
        "top" : this._cachedBorderLeft + ( this._thumb.getTop() || 0 ),
        "width" : this._thumb.getBoxWidth(),
        "height" : this._thumb.getBoxHeight()
      };
    },

    //////////////
    // Overwritten

    _setSelection : function( value ) {
      this.base( arguments, value );
      this._scheduleSendChanges();
    },

    ////////////
    // Internals

    _onContextMenu : function( evt ) {
      var menu = this.getContextMenu();
      if( menu != null ) {
        menu.setLocation( evt.getPageX(), evt.getPageY() );
        menu.setOpener( this );
        menu.show();
        evt.stopPropagation();
      }
    },

    _onKeyPress : function( evt ) {
      var keyIdentifier = evt.getKeyIdentifier();
      var sel = null;
      if( rwt.widgets.Slider._isNoModifierPressed( evt ) ) {
        switch( keyIdentifier ) {
          case "Left":
            sel = this._selection - this._increment;
            evt.preventDefault();
            evt.stopPropagation();
            break;
          case "Down":
            if( this._horizontal ) {
              sel = this._selection - this._increment;
            } else {
              sel = this._selection + this._increment;
            }
            evt.preventDefault();
            evt.stopPropagation();
            break;
          case "Right":
            sel = this._selection + this._increment;
            evt.preventDefault();
            evt.stopPropagation();
            break;
          case "Up":
            if( this._horizontal ) {
              sel = this._selection + this._increment;
            } else {
              sel = this._selection - this._increment;
            }
            evt.preventDefault();
            evt.stopPropagation();
            break;
          case "Home":
            sel = this._minimum;
            evt.preventDefault();
            evt.stopPropagation();
            break;
          case "End":
            sel = this._maximum;
            evt.preventDefault();
            evt.stopPropagation();
            break;
          case "PageDown":
            if( this._horizontal ) {
              sel = this._selection - this._pageIncrement;
            } else {
              sel = this._selection + this._pageIncrement;
            }
            evt.preventDefault();
            evt.stopPropagation();
            break;
          case "PageUp":
            if( this._horizontal ) {
              sel = this._selection + this._pageIncrement;
            } else {
              sel = this._selection - this._pageIncrement;
            }
            evt.preventDefault();
            evt.stopPropagation();
            break;
        }
        if( sel != null ) {
          if( sel < this._minimum ) {
            sel = this._minimum;
          }
          if( sel > this._maximum ) {
            sel = this._maximum;
          }
          this.setSelection( sel );
          if( this._readyToSendChanges ) {
            this._readyToSendChanges = false;
            // Send changes
            rwt.client.Timer.once( this._sendChanges,
                                  this,
                                  rwt.widgets.Slider.SEND_DELAY );
          }
        }
      }
    },

    _onMouseWheel : function( evt ) {
      if( this.getFocused() ) {
        this.base( arguments, evt );
        if( this._readyToSendChanges ) {
          this._readyToSendChanges = false;
          // Send changes
          rwt.client.Timer.once( this._sendChanges, this, 500 );
        }
      }
    },

    // TODO [tb] : refactor to use only this for scheduling
    _scheduleSendChanges : function() {
      if( !rwt.remote.EventUtil.getSuspended() ) {
        if( !this._requestScheduled ) {
          this._requestScheduled = true;
          // Send changes
          rwt.client.Timer.once( this._sendChanges,
                                this,
                                rwt.widgets.Slider.SEND_DELAY );

        }
      }
    },

    _sendChanges : function() {
      rwt.remote.Connection.getInstance().getRemoteObject( this ).set( "selection", this._selection );
      rwt.remote.EventUtil.notifySelected( this );
      this._requestScheduled = false;
    }

  }

} );

/*******************************************************************************
 * Copyright (c) 2011, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.remote.HandlerRegistry.add( "rwt.widgets.Slider", {

  factory : function( properties ) {
    var isHorizontal = properties.style.indexOf( "HORIZONTAL" ) != -1;
    var result = new rwt.widgets.Slider( isHorizontal );
    rwt.remote.HandlerUtil.addStatesForStyles( result, properties.style );
    result.setUserData( "isControl", true );
    rwt.remote.HandlerUtil.setParent( result, properties.parent );
    return result;
  },

  destructor : rwt.remote.HandlerUtil.getControlDestructor(),

  properties : rwt.remote.HandlerUtil.extendControlProperties( [
    "minimum",
    "maximum",
    "selection",
    "increment",
    "pageIncrement",
    "thumb"
  ] ),

  propertyHandler : rwt.remote.HandlerUtil.extendControlPropertyHandler( {} ),

  getDestroyableChildren : rwt.remote.HandlerUtil.getDestroyableChildrenFinder(),

  events : [ "Selection" ],

  listeners : rwt.remote.HandlerUtil.extendControlListeners( [] ),

  listenerHandler : rwt.remote.HandlerUtil.extendControlListenerHandler( {} )

} );

/*******************************************************************************
 * Copyright (c) 2007, 2014 Innoopract Informationssysteme GmbH and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Innoopract Informationssysteme GmbH - initial API and implementation
 *    EclipseSource - ongoing development
 ******************************************************************************/

rwt.qx.Class.define( "rwt.widgets.Spinner", {
  extend : rwt.widgets.base.Spinner,

  construct : function() {
    this.base( arguments );
    this.setWrap( false );
    // Hack to prevent the spinner text field to request the focus
    this._textfield.setFocused = function() {};
    this._textfield.addEventListener( "changeValue", this._onChangeValue, this );
    this._textfield.addEventListener( "keypress", this._onChangeValue, this );
    this._textfield.addEventListener( "blur", this._onChangeValue, this );
    this._textfield.addEventListener( "keydown", this._onKeyDown, this );
    this._textfield.setTabIndex( null );
    this.addEventListener( "changeEnabled", this._onChangeEnabled, this );
    this.addEventListener( "focusout", this._onFocusOut, this );
    this._checkValue = this.__checkValueWithDigits;
  },

  destruct : function() {
    this._textfield.removeEventListener( "changeValue", this._onChangeValue, this );
    this._textfield.removeEventListener( "keypress", this._onChangeValue, this );
    this._textfield.removeEventListener( "blur", this._onChangeValue, this );
    this._textfield.removeEventListener( "keydown", this._onKeyDown, this );
    this.removeEventListener( "changeEnabled", this._onChangeEnabled, this );
    this.removeEventListener( "focusout", this._onFocusOut, this );
  },

  properties : {

    digits : {
      check : "Integer",
      init : 0,
      apply : "_applyDigits"
    },

    decimalSeparator : {
      check : "String",
      init : ".",
      apply : "_applyDecimalSeparator"
    }

  },

  members : {

    _applyTextColor : function( value, old ) {
      this.base( arguments, value, old );
      this._textfield.setTextColor( value );
    },

    setFont : function( value ) {
      this._textfield.setFont( value );
    },

    setMaxLength : function( value ) {
      this._textfield.setMaxLength( value );
    },

    // [if] Spinner#setValues allows minimum, maximum and selection to be set in
    // one hop. In case of not crossed ranges ( for example new min > old max ),
    // a javascript error appears if we set them one by one.
    setMinMaxSelection : function( min, max, value ) {
      this.setMin( Math.min( min, this.getMin() ) );
      this.setMax( Math.max( max, this.getMax() ) );
      this.setValue( value );
      this.setMin( min );
      this.setMax( max );
    },

    _applyCursor : function( value, old ) {
      this.base( arguments, value, old );
      if( value ) {
        this._upbutton.setCursor( value );
        this._downbutton.setCursor( value );
        this._textfield.setCursor( value );
      } else {
        this._upbutton.resetCursor();
        this._downbutton.resetCursor();
        this._textfield.resetCursor();
      }
    },

    _visualizeFocus : function() {
      this._textfield._visualizeFocus();
      if( this._textfield.isCreated() ) {
        this._textfield.selectAll();
      }
      this.addState( "focused" );
    },

    _visualizeBlur : function() {
      // setSelectionLength( 0 ) for TextField - needed for IE
      this._textfield._setSelectionLength( 0 );
      this._textfield._visualizeBlur();
      this.removeState( "focused" );
    },

    // [if] Override original qooxdoo Spinner method. Fix for bug 209476
    _oninput : function() {
      this._suspendTextFieldUpdate = true;
      this._checkValue( true, false );
      this._suspendTextFieldUpdate = false;
    },

    _onChangeValue : function() {
      if( !rwt.remote.EventUtil.getSuspended() ) {
        var connection = rwt.remote.Connection.getInstance();
        var remoteObject = connection.getRemoteObject( this );
        remoteObject.set( "selection", this.getManager().getValue() );
        if( remoteObject.isListening( "Selection" ) ) {
          connection.onNextSend( this._sendWidgetSelected, this );
          connection.sendDelayed( 500 );
        }
      }
    },

    // TODO [rst] workaround: setting enabled to false still leaves the buttons enabled
    _onChangeEnabled : function( evt ) {
      var enabled = evt.getValue();
      this._upbutton.setEnabled( enabled && this.getValue() < this.getMax() );
      this._downbutton.setEnabled( enabled && this.getValue() > this.getMin() );
    },

    _onKeyDown : function( event ) {
      if(    event.getKeyIdentifier() == "Enter"
          && !event.isShiftPressed()
          && !event.isAltPressed()
          && !event.isCtrlPressed()
          && !event.isMetaPressed() )
      {
        event.stopPropagation();
        rwt.remote.EventUtil.notifyDefaultSelected( this );
      }
    },

    _onmousewheel : function( evt ) {
      if( this.getFocused() ) {
        this.base( arguments, evt );
      }
    },

    _sendWidgetSelected : function() {
      rwt.remote.EventUtil.notifySelected( this );
    },

    /////////////////
    // Digits support

    _applyDigits : function() {
      var spinnerValue = this.getManager().getValue();
      if( this.getDigits() > 0 ) {
        this._textfield.setValue( this._format( spinnerValue ) );
      } else {
        this._textfield.setValue( String( spinnerValue ) );
      }
    },

    _applyDecimalSeparator : function() {
      var spinnerValue = this.getManager().getValue();
      if( this.getDigits() > 0 ) {
        this._textfield.setValue( this._format( spinnerValue ) );
      }
    },

    _format : function( value ) {
      var digits = this.getDigits();
      var floatValue = value / Math.pow( 10, digits );
      var result = floatValue.toFixed( digits );
      var separator = this.getDecimalSeparator();
      if( separator != "." ) {
        var dot = rwt.util.Encoding.escapeRegexpChars( "." );
        result = result.replace( new RegExp( dot ), separator );
      }
      return result;
    },

    _limit : function( value ) {
      var result = value;
      var digits = this.getDigits();
      if( digits > 0 ) {
        result = result * Math.pow( 10, digits );
      }
      result = Math.round( result );
      if( result > this.getMax() ) {
        result = this.getMax();
      }
      if( result < this.getMin() ) {
        result = this.getMin();
      }
      return result;
    },

    _onFocusOut : function() {
      this._checkValue( true, false );
    },

    _onkeypress : function( evt ) {
      var identifier = evt.getKeyIdentifier();
      var separator = this.getDecimalSeparator();
      if( !( this.getDigits() > 0 && identifier == separator ) ) {
        this.base( arguments, evt );
      }
    },

    _onchange : function() {
      var value = this.getManager().getValue();
      if( !this._suspendTextFieldUpdate ) {
        if( this.getDigits() > 0 ) {
          this._textfield.setValue( this._format( value ) );
        } else {
          this._textfield.setValue( String( value ) );
        }
      }
      if( value == this.getMin() && !this.getWrap() ) {
        this._downbutton.removeState( "pressed" );
        this._downbutton.setEnabled( false );
        this._timer.stop();
      } else {
        this._downbutton.resetEnabled();
      }
      if( value == this.getMax() && !this.getWrap() ) {
        this._upbutton.removeState( "pressed" );
        this._upbutton.setEnabled( false );
        this._timer.stop();
      } else {
        this._upbutton.resetEnabled();
      }
      this.createDispatchDataEvent( "change", value );
    },

    __checkValueWithDigits : function( acceptEmpty, acceptEdit ) {
      var inputElement = this._textfield.getInputElement();
      if( inputElement ) {
        if( inputElement.value === "" && !acceptEmpty ) {
          this.resetValue();
        } else {
          var strValue = inputElement.value;
          var parseValue = strValue;
          var separator = this.getDecimalSeparator();
          if( this.getDigits() > 0 && separator != "." ) {
            separator = rwt.util.Encoding.escapeRegexpChars( separator );
            parseValue = strValue.replace( new RegExp( separator ), "." );
          }
          var value = parseFloat( parseValue );
          var limitedValue = this._limit( value );
          var oldValue = this.getManager().getValue();
          var fixedValue = limitedValue;
          if( isNaN( value ) || value != limitedValue || value != parseValue ) {
            if( acceptEdit ) {
              this._textfield.setValue( this._last_value );
            } else if( isNaN( limitedValue ) ) {
              fixedValue = oldValue;
            }
          }
          if( !acceptEdit ) {
            var formattedValue = String( fixedValue );
            if( this.getDigits() > 0 ) {
              formattedValue = this._format( fixedValue );
            }
            if(    fixedValue === oldValue
                && strValue !== formattedValue
                && !this._suspendTextFieldUpdate )
            {
              this._textfield.setValue( formattedValue );
            }
            this.getManager().setValue( fixedValue );
          }
        }
      }
    }

  }

} );

/*******************************************************************************
 * Copyright (c) 2011, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.remote.HandlerRegistry.add( "rwt.widgets.Spinner", {

  factory : function( properties ) {
    var result = new rwt.widgets.Spinner();
    rwt.remote.HandlerUtil.addStatesForStyles( result, properties.style );
    result.setUserData( "isControl", true );
    rwt.remote.HandlerUtil.setParent( result, properties.parent );
    var styleMap = rwt.remote.HandlerUtil.createStyleMap( properties.style );
    if( styleMap.READ_ONLY ) {
      result.setEditable( false );
    }
    if( styleMap.WRAP ) {
      result.setWrap( true );
    }
    return result;
  },

  destructor : rwt.remote.HandlerUtil.getControlDestructor(),

  getDestroyableChildren : rwt.remote.HandlerUtil.getDestroyableChildrenFinder(),

  properties : rwt.remote.HandlerUtil.extendControlProperties( [
    // [if] Important: Order matters - minimum, maximum, selection
    "minimum",
    "maximum",
    /**
     * @name setSelection
     * @methodOf Spinner#
     * @description Sets the 'selection', which is the receiver's value, to the argument which
     * must be greater than or equal to zero.
     * @param {int} selection the new selection (must be zero or greater)
     */
    "selection",
    "digits",
    "increment",
    "pageIncrement",
    "textLimit",
    "decimalSeparator"
  ] ),

  propertyHandler : rwt.remote.HandlerUtil.extendControlPropertyHandler( {
    "minimum" : function( widget, value ) {
      // [if] Ensures that we don't set min bigger than current max, otherwize and error will be
      // thrown. The correct max is always set by the server in this case.
      var max = widget.getMax();
      if( value > max ) {
        widget.setMax( value + 1 );
      }
      widget.setMin( value );
    },
    "maximum" : function( widget, value ) {
      widget.setMax( value );
    },
    "selection" : function( widget, value ) {
      widget.setValue( value );
    },
    "increment" : function( widget, value ) {
      widget.setIncrementAmount( value );
      widget.setWheelIncrementAmount( value );
    },
    "pageIncrement" : function( widget, value ) {
      widget.setPageIncrementAmount( value );
    },
    "textLimit" : function( widget, value ) {
      widget.setMaxLength( value );
    }
  } ),

  events : [ "Selection", "DefaultSelection" ],

  listeners : rwt.remote.HandlerUtil.extendControlListeners( [] ),

  listenerHandler : rwt.remote.HandlerUtil.extendControlListenerHandler( {} ),

  methods: [ "addListener", "removeListener" ],

  methodHandler : rwt.remote.HandlerUtil.extendListenerMethodHandler( {} ),

  /**
   * @class RWT Scripting analoge to org.eclipse.swt.widgets.Spinner
   * @name Spinner
   * @extends Control
   * @description The constructor is not public.
   * @since 2.2
   */
  scriptingMethods : rwt.remote.HandlerUtil.extendControlScriptingMethods(
    /** @lends Spinner.prototype */
  {
     /**
      * @description Returns the 'selection', which is the receiver's position.
      * @return {int} the selection
      */
    getSelection : function() {
      return this.getValue();
    },
    /**
     * @description  Returns a string containing a copy of the contents of the
     * receiver's text field, or an empty string if there are no
     * contents.
     * @return {string} the receiver's text
     */
    getText : function() {
      return this._textfield.getValue();
    },
     /**
      * @description Returns the maximum value which the receiver will allow.
      * @return {int} the maximum
      */
    getMaximum : function() {
      return this.getMax();
    },
     /**
      * @description Returns the minimum value which the receiver will allow.
      * @return {int} the minimum
      */
     getMinimum : function() {
      return this.getMin();
    }
  } )

} );

/*******************************************************************************
 * Copyright (c) 2008, 2014 Innoopract Informationssysteme GmbH and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Innoopract Informationssysteme GmbH - initial API and implementation
 *    EclipseSource - ongoing development
 ******************************************************************************/

rwt.qx.Class.define( "rwt.widgets.DateTimeTime", {
  extend : rwt.widgets.base.Parent,

  construct : function( style ) {
    this.base( arguments );
    this.setOverflow( "hidden" );
    this._short = rwt.util.Strings.contains( style, "short" );
    this._medium = rwt.util.Strings.contains( style, "medium" );
    this._long = rwt.util.Strings.contains( style, "long" );
    this.addEventListener( "keypress", this._onKeyPress, this );
    this.addEventListener( "keyup", this._onKeyUp, this );
    this.addEventListener( "mousewheel", this._onMouseWheel, this );
    this.addEventListener( "focus", this._onFocusIn, this );
    this.addEventListener( "blur", this._onFocusOut, this );
    // Hours
    this._hoursTextField = new rwt.widgets.base.Label( "00" );
    this._hoursTextField.setAppearance( "datetime-field" );
    this._hoursTextField.setUserData( "maxLength", 2 );
    this._hoursTextField.addEventListener( "mousedown",  this._onTextFieldMouseDown, this );
    this.add(this._hoursTextField);
    // Separator
    this._separator3 = new rwt.widgets.base.Label( ":" );
    this._separator3.setAppearance( "datetime-separator" );
    this.add(this._separator3);
    // Minutes
    this._minutesTextField = new rwt.widgets.base.Label( "00" );
    this._minutesTextField.setAppearance( "datetime-field" );
    this._minutesTextField.setUserData( "maxLength", 2 );
    this._minutesTextField.addEventListener( "mousedown",  this._onTextFieldMouseDown, this );
    this.add(this._minutesTextField);
    // Separator
    this._separator4 = new rwt.widgets.base.Label( ":" );
    this._separator4.setAppearance( "datetime-separator" );
    if( this._medium || this._long ) {
      this.add(this._separator4);
    }
    // Seconds
    this._secondsTextField = new rwt.widgets.base.Label( "00" );
    this._secondsTextField.setAppearance( "datetime-field" );
    this._secondsTextField.setUserData( "maxLength", 2 );
    this._secondsTextField.addEventListener( "mousedown",  this._onTextFieldMouseDown, this );
    if( this._medium || this._long ) {
      this.add(this._secondsTextField);
    }
    // Spinner
    this._spinner = this._createSpinner();
    this.add( this._spinner );
    // Set the default focused text field
    this._focusedTextField = this._hoursTextField;
    // Set the appearance after subwidgets are created
    this.setAppearance( "datetime-time" );
  },

  destruct : function() {
    this._disposeObjects( "_hoursTextField",
                          "_minutesTextField",
                          "_secondsTextField",
                          "_focusedTextField",
                          "_spinner",
                          "_separator3",
                          "_separator4" );
  },

  members : {

    _getSubWidgets : function() {
      return [ this._hoursTextField,
               this._minutesTextField,
               this._secondsTextField,
               this._spinner,
               this._separator3,
               this._separator4 ];
    },

    _createSpinner : function() {
      var spinner = new rwt.widgets.base.Spinner();
      spinner.set( {
        wrap: true,
        border: null,
        backgroundColor: null,
        selectTextOnInteract : false
      } );
      spinner.setMin( 0 );
      spinner.setMax( 23 );
      spinner.setValue( 0 );
      spinner.addEventListener( "change",  this._onSpinnerChange, this );
      spinner._textfield.setTabIndex( null );
      // Hack to prevent the spinner text field to request the focus
      spinner._textfield.setFocused = rwt.util.Functions.returnTrue;
      // Solution for Bug 284021
      spinner._textfield.setDisplay( false );
      spinner._upbutton.setAppearance( "datetime-button-up" );
      spinner._downbutton.setAppearance( "datetime-button-down" );
      spinner.removeEventListener( "keypress", spinner._onkeypress, spinner );
      spinner.removeEventListener( "keydown", spinner._onkeydown, spinner );
      spinner.removeEventListener( "keyup", spinner._onkeyup, spinner );
      spinner.removeEventListener( "mousewheel", spinner._onmousewheel, spinner );
      return spinner;
    },

    _applyFont : function( value, old ) {
      this.base( arguments, value, old );
      this._hoursTextField.setFont( value );
      this._minutesTextField.setFont( value );
      this._secondsTextField.setFont( value );
      this._separator3.setFont( value );
      this._separator4.setFont( value );
    },

    _onFocusIn : function() {
      this._focusedTextField.addState( "selected" );
      this._initialEditing = true;
    },

    _onFocusOut : function() {
      this._focusedTextField.removeState( "selected" );
    },

    _onTextFieldMouseDown : function( event ) {
      this._setFocusedTextField( event.getTarget() );
    },

    _setFocusedTextField :  function( textField ) {
      if( this._focusedTextField !== textField ) {
        var tmpValue;
        this._focusedTextField.removeState( "selected" );
        this._focusedTextField = null;
        if( textField === this._hoursTextField ) {
          this._spinner.setMin( 0 );
          this._spinner.setMax( 23 );
          tmpValue = this._removeLeadingZero( this._hoursTextField.getText() );
          this._spinner.setValue( parseInt( tmpValue, 10 ) );
        } else if( textField === this._minutesTextField ) {
          this._spinner.setMin( 0 );
          this._spinner.setMax( 59 );
          tmpValue = this._removeLeadingZero( this._minutesTextField.getText() );
          this._spinner.setValue( parseInt( tmpValue, 10 ) );
        } else if( textField === this._secondsTextField ) {
          this._spinner.setMin( 0 );
          this._spinner.setMax( 59 );
          tmpValue = this._removeLeadingZero( this._secondsTextField.getText() );
          this._spinner.setValue( parseInt( tmpValue, 10 ) );
        }
        this._focusedTextField = textField;
        this._focusedTextField.addState( "selected" );
        this._initialEditing = true;
      }
    },

    _onSpinnerChange : function() {
      if( this._focusedTextField != null ) {
        var oldValue = this._focusedTextField.getText();
        var newValue = this._addLeadingZero( this._spinner.getValue() );
        this._focusedTextField.setText( newValue );
        if( oldValue != newValue ) {
          this._sendChanges();
        }
      }
    },

    _onKeyPress : function( event ) {
      if( event.getModifiers() === 0 ) {
        switch( event.getKeyIdentifier() ) {
          case "Enter":
            this._handleKeyEnter( event );
            break;
          case "Left":
            this._handleKeyLeft( event );
            break;
          case "Right":
            this._handleKeyRight( event );
            break;
          case "Up":
            this._handleKeyUp( event );
            break;
          case "Down":
            this._handleKeyDown( event );
            break;
          case "PageUp":
          case "PageDown":
          case "Home":
          case "End":
            this._stopEvent( event );
            break;
        }
      }
    },

    _onKeyUp : function( event ) {
      if( event.getModifiers() === 0 ) {
        switch( event.getKeyIdentifier() ) {
          case "0": case "1": case "2": case "3": case "4":
          case "5": case "6": case "7": case "8": case "9":
            this._handleKeyNumber( event );
            break;
          case "Home":
            this._handleKeyHome( event );
            break;
          case "End":
            this._handleKeyEnd( event );
            break;
        }
      }
    },

    _handleKeyEnter : function() {
      rwt.remote.EventUtil.notifyDefaultSelected( this );
    },

    _handleKeyLeft : function( event ) {
      if( this._focusedTextField === this._hoursTextField ) {
        if( this._short ) {
          this._setFocusedTextField( this._minutesTextField );
        } else {
          this._setFocusedTextField( this._secondsTextField );
        }
      } else if( this._focusedTextField === this._minutesTextField ) {
        this._setFocusedTextField( this._hoursTextField );
      } else if( this._focusedTextField === this._secondsTextField ) {
        this._setFocusedTextField( this._minutesTextField );
      }
      this._stopEvent( event );
    },

    _handleKeyRight : function( event ) {
      if( this._focusedTextField === this._hoursTextField ) {
        this._setFocusedTextField( this._minutesTextField );
      } else if( this._focusedTextField === this._minutesTextField ) {
        if( this._short ) {
          this._setFocusedTextField( this._hoursTextField );
        } else {
          this._setFocusedTextField( this._secondsTextField );
        }
      } else if( this._focusedTextField === this._secondsTextField ) {
        this._setFocusedTextField( this._hoursTextField );
      }
      this._stopEvent( event );
    },

    _handleKeyDown : function( event ) {
      var value = this._spinner.getValue();
      if( value == this._spinner.getMin() ) {
        this._spinner.setValue( this._spinner.getMax() );
      } else {
        this._spinner.setValue( value - 1 );
      }
      this._stopEvent( event );
    },

    _handleKeyUp : function( event ) {
      var value = this._spinner.getValue();
      if( value == this._spinner.getMax() ) {
        this._spinner.setValue( this._spinner.getMin() );
      } else {
        this._spinner.setValue( value + 1 );
      }
      this._stopEvent( event );
    },

    _handleKeyNumber : function( event ) {
      var key = event.getKeyIdentifier();
      var value = this._removeLeadingZero( this._focusedTextField.getText() );
      var maxChars = this._focusedTextField.getUserData( "maxLength" );
      var newValue = value.length < maxChars && !this._initialEditing ? value + key : key;
      var intValue = parseInt( newValue, 10 );
      if( intValue >= this._spinner.getMin() && intValue <= this._spinner.getMax() ) {
        this._spinner.setValue( intValue );
      } else {
        intValue = parseInt( key, 10 );
        if( intValue >= this._spinner.getMin() && intValue <= this._spinner.getMax() ) {
          this._spinner.setValue( intValue );
        }
      }
      this._initialEditing = false;
      this._stopEvent( event );
    },

    _handleKeyHome : function( event ) {
      this._spinner.setValue( this._spinner.getMin() );
      this._initialEditing = true;
      this._stopEvent( event );
    },

    _handleKeyEnd : function( event ) {
      this._spinner.setValue( this._spinner.getMax() );
      this._initialEditing = true;
      this._stopEvent( event );
    },

    _onMouseWheel : function( event ) {
      if( this.getFocused() ) {
        this._stopEvent( event );
        this._spinner._onmousewheel( event );
      }
    },

    _stopEvent : function( event ) {
      event.preventDefault();
      event.stopPropagation();
    },

    _addLeadingZero : function( value ) {
      return value < 10 ? "0" + value : "" + value;
    },

    _removeLeadingZero : function( value ) {
      var result = value;
      if( value.length == 2 ) {
        var firstChar = value.substring( 0, 1 );
        if( firstChar == "0" ) {
          result = value.substring( 1 );
        }
      }
      return result;
    },

    _sendChanges : function() {
      if( !rwt.remote.EventUtil.getSuspended() ) {
        var connection = rwt.remote.Connection.getInstance();
        var remoteObject = connection.getRemoteObject( this );
        var hours = parseInt( this._removeLeadingZero( this._hoursTextField.getText() ), 10 );
        remoteObject.set( "hours", hours );
        var minutes = parseInt( this._removeLeadingZero( this._minutesTextField.getText() ), 10 );
        remoteObject.set( "minutes", minutes );
        var seconds = parseInt( this._removeLeadingZero( this._secondsTextField.getText() ), 10 );
        remoteObject.set( "seconds", seconds );
        if( remoteObject.isListening( "Selection" ) ) {
          connection.onNextSend( this._onSend, this );
          connection.sendDelayed( 200 );
        }
      }
    },

    _onSend : function() {
      rwt.remote.EventUtil.notifySelected( this );
    },

    setHours : function( value ) {
      this._hoursTextField.setText( this._addLeadingZero( value ) );
      if( this._focusedTextField === this._hoursTextField ) {
        this._spinner.setValue( value );
      }
    },

    setMinutes : function( value ) {
      this._minutesTextField.setText( this._addLeadingZero( value ) );
      if( this._focusedTextField === this._minutesTextField ) {
        this._spinner.setValue( value );
      }
    },

    setSeconds : function( value ) {
      this._secondsTextField.setText( this._addLeadingZero( value ) );
      if( this._focusedTextField === this._secondsTextField ) {
        this._spinner.setValue( value );
      }
    },

    setBounds : function( index, x, y, width, height ) {
      var widget;
      switch( index ) {
        case 7:
          widget = this._spinner;
        break;
        case 8:
          widget = this._hoursTextField;
        break;
        case 9:
          widget = this._minutesTextField;
        break;
        case 10:
          widget = this._secondsTextField;
        break;
        case 11:
          widget = this._separator3;
        break;
        case 12:
          widget = this._separator4;
        break;
      }
      widget.set( {
        left: x,
        top: y,
        width: width,
        height: height
      } );
    }

  }

} );

/*******************************************************************************
 * Copyright (c) 2008, 2015 Innoopract Informationssysteme GmbH and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Innoopract Informationssysteme GmbH - initial API and implementation
 *    EclipseSource - ongoing development
 ******************************************************************************/

rwt.qx.Class.define( "rwt.widgets.DateTimeDate", {
  extend : rwt.widgets.base.Parent,

  construct : function( style,
                        monthNames,
                        weekdayNames,
                        weekdayShortNames,
                        dateSeparator,
                        datePattern )
  {
    this.base( arguments );
    this.setOverflow( "hidden" );
    this._short = rwt.util.Strings.contains( style, "short" );
    this._medium = rwt.util.Strings.contains( style, "medium" );
    this._long = rwt.util.Strings.contains( style, "long" );
    this._drop_down = rwt.util.Strings.contains( style, "drop_down" );
    this._internalDateChanged = false;
    this._weekday = weekdayNames;
    this._monthname = monthNames;
    this._datePattern = datePattern;
    this.addEventListener( "keypress", this._onKeyPress, this );
    this.addEventListener( "keyup", this._onKeyUp, this );
    this.addEventListener( "mousewheel", this._onMouseWheel, this );
    this.addEventListener( "focus", this._onFocusIn, this );
    this.addEventListener( "blur", this._onFocusOut, this );
    // Weekday
    this._weekdayTextField = new rwt.widgets.base.Label();
    this._weekdayTextField.setAppearance( "datetime-field" );
    if( this._long ) {
      this.add( this._weekdayTextField );
    }
    // Separator
    this._separator0 = new rwt.widgets.base.Label(",");
    this._separator0.setAppearance( "datetime-separator" );
    if( this._long ) {
      this.add(this._separator0);
    }
    // Month
    this._monthTextField = new rwt.widgets.base.Label();
    this._monthTextField.setAppearance( "datetime-field" );
    this._monthTextField.setTextAlign( this._medium ? "right" : "center" );
    // Integer value of the month
    this._monthInt = 1;
    if( this._medium ) {
      this._monthTextField.setText( "1" );
    } else {
      this._monthTextField.setText( this._monthname[ this._monthInt - 1 ] );
    }
    this._monthTextField.addEventListener( "mousedown",  this._onTextFieldMouseDown, this );
    this.add( this._monthTextField );
    // Separator
    this._separator1 = new rwt.widgets.base.Label( dateSeparator );
    this._separator1.setAppearance( "datetime-separator" );
    if( this._medium ) {
      this.add(this._separator1);
    }
    // Date
    this._dayTextField = new rwt.widgets.base.Label( "1" );
    this._dayTextField.setAppearance( "datetime-field" );
    this._dayTextField.setUserData( "maxLength", 2 );
    this._dayTextField.setTextAlign( "right" );
    this._dayTextField.addEventListener( "mousedown",  this._onTextFieldMouseDown, this );
    if( !this._short ) {
      this.add( this._dayTextField );
    }
    // Separator
    this._separator2 = new rwt.widgets.base.Label( "," );
    this._separator2.setAppearance( "datetime-separator" );
    if( this._medium ) {
      this._separator2.setText( dateSeparator );
    }
    this.add(this._separator2);
    // Year
    this._yearTextField = new rwt.widgets.base.Label( "1970" );
    this._yearTextField.setAppearance( "datetime-field" );
    this._yearTextField.setUserData( "maxLength", 4 );
    this._yearTextField.setTextAlign( "right" );
    // Last valid year
    this._lastValidYear = 1970;
    this._yearTextField.addEventListener( "mousedown",  this._onTextFieldMouseDown, this );
    this.add( this._yearTextField );
    // Spinner
    this._spinner = this._createSpinner();
    this._spinner.setDisplay( !this._drop_down );
    this.add( this._spinner );
    // Drop-down button and calendar
    this._dropped = false;
    this._dropDownButton = null;
    this._calendar = null;
    if( this._drop_down ) {
      // Add events listeners
      var document = rwt.widgets.base.ClientDocument.getInstance();
      document.addEventListener( "windowblur", this._onWindowBlur, this );
      this.addEventListener( "appear", this._onAppear, this );
      this.addEventListener( "changeVisibility", this._onChangeVisibility, this );
      this.addEventListener( "mousedown", this._onMouseDown, this );
      this.addEventListener( "click", this._onMouseClick, this );
      this.addEventListener( "mouseover", this._onMouseOver, this );
      this.addEventListener( "mouseout", this._onMouseOut, this );
      this._dropDownButton = new rwt.widgets.base.BasicButton( "push", true );
      this._dropDownButton.setAppearance( "datetime-drop-down-button" );
      this._dropDownButton.setTabIndex( null );
      this._dropDownButton.setAllowStretchY( true );
      this.add( this._dropDownButton );
      // Get names of weekdays and months
      rwt.widgets.base.Calendar.MONTH_NAMES = monthNames;
      rwt.widgets.base.Calendar.WEEKDAY_NAMES = weekdayShortNames;
      this._calendar = new rwt.widgets.base.Calendar();
      this._calendar.setAppearance( "datetime-drop-down-calendar" );
      this._calendar.setDate( new Date( 70, 0, 1 ) );
      this._calendar.setTabIndex( null );
      this._calendar.setVisibility( false );
      this._calendar.addEventListener( "changeDate", this._onCalendarDateChange, this );
      // TODO: [if] Calendar buttons tooltips have wrong z-index
      // Remove tooltips for now.
      this._calendar._lastYearBt.setToolTipText( null );
      this._calendar._lastMonthBt.setToolTipText( null );
      this._calendar._nextMonthBt.setToolTipText( null );
      this._calendar._nextYearBt.setToolTipText( null );
    }
    // Set the default focused text field
    this._focusedTextField = this._monthTextField;
    // Set the weekday
    this._setWeekday();
    // Set the appearance after subwidgets are created
    this.setAppearance( "datetime-date" );
  },

  destruct : function() {
    this._disposeObjects( "_weekdayTextField",
                          "_monthTextField",
                          "_dayTextField",
                          "_yearTextField",
                          "_focusedTextField",
                          "_spinner",
                          "_separator0",
                          "_separator1",
                          "_separator2" );
    if( this._drop_down ) {
      var document = rwt.widgets.base.ClientDocument.getInstance();
      document.removeEventListener( "windowblur", this._onWindowBlur, this );
      this._dropDownButton.dispose();
      this._dropDownButton = null;
      if( !rwt.qx.Object.inGlobalDispose() ) {
        this._calendar.setParent( null );
      }
      this._calendar.dispose();
      this._calendar = null;
    }
  },

  members : {

    _getSubWidgets : function() {
      var result = [ this._weekdayTextField,
                     this._monthTextField,
                     this._dayTextField,
                     this._yearTextField,
                     this._spinner,
                     this._separator0,
                     this._separator1,
                     this._separator2 ];
      if( this._drop_down ) {
        result.push( this._dropDownButton, this._calendar );
      }
      return result;
    },

    _createSpinner : function() {
      var spinner = new rwt.widgets.base.Spinner();
      spinner.set( {
        wrap: true,
        border: null,
        backgroundColor: null,
        selectTextOnInteract : false
      } );
      spinner.setMin( 1 );
      spinner.setMax( 12 );
      spinner.setValue( this._monthInt );
      spinner.addEventListener( "change",  this._onSpinnerChange, this );
      spinner._textfield.setTabIndex( null );
      // Hack to prevent the spinner text field to request the focus
      spinner._textfield.setFocused = rwt.util.Functions.returnTrue;
      // Solution for Bug 284021
      spinner._textfield.setDisplay( false );
      spinner._upbutton.setAppearance( "datetime-button-up" );
      spinner._downbutton.setAppearance( "datetime-button-down" );
      spinner.removeEventListener( "keypress", spinner._onkeypress, spinner );
      spinner.removeEventListener( "keydown", spinner._onkeydown, spinner );
      spinner.removeEventListener( "keyup", spinner._onkeyup, spinner );
      spinner.removeEventListener( "mousewheel", spinner._onmousewheel, spinner );
      return spinner;
    },

    _applyFont : function( value, old ) {
      this.base( arguments, value, old );
      this._weekdayTextField.setFont( value );
      this._dayTextField.setFont( value );
      this._monthTextField.setFont( value );
      this._yearTextField.setFont( value );
      this._separator0.setFont( value );
      this._separator1.setFont( value );
      this._separator2.setFont( value );
    },

    _onFocusIn : function() {
      this._focusedTextField.addState( "selected" );
      this._initialEditing = true;
    },

    _onFocusOut : function() {
      if( this._focusedTextField === this._yearTextField ) {
        this._checkAndApplyYearValue();
      }
      this._focusedTextField.removeState( "selected" );
      this._hideCalendar();
    },

    _onTextFieldMouseDown : function( event ) {
      if( this._focusedTextField === this._yearTextField ) {
        this._checkAndApplyYearValue();
      }
      this._setFocusedTextField( event.getTarget() );
    },

    _setFocusedTextField :  function( textField ) {
      if( this._focusedTextField !== textField ) {
        this._focusedTextField.removeState( "selected" );
        this._focusedTextField = null;
        if( textField === this._dayTextField ) {
          this._spinner.setMin( 1 );
          this._spinner.setMax( this._getDaysInMonth() );
          var tmpValue = this._removeLeadingZero( this._dayTextField.getText() );
          this._spinner.setValue( parseInt( tmpValue, 10 ) );
        } else if( textField === this._monthTextField ) {
          this._spinner.setMin( 1 );
          this._spinner.setMax( 12 );
          this._spinner.setValue( this._monthInt );
        } else if( textField === this._yearTextField ) {
          this._spinner.setMax( 9999 );
          this._spinner.setMin( 1752 );
          this._spinner.setValue( this._lastValidYear );
        }
        this._focusedTextField = textField;
        this._focusedTextField.addState( "selected" );
        this._initialEditing = true;
      }
    },

    _onSpinnerChange : function() {
      if( this._focusedTextField != null ) {
        var oldValue = this._focusedTextField.getText();
        // Set the value
        if( this._focusedTextField === this._monthTextField ) {
          this._monthInt = this._spinner.getValue();
          if( this._medium ) {
            this._focusedTextField.setText( this._addLeadingZero( this._monthInt ) );
          } else {
            this._focusedTextField.setText( this._monthname[ this._monthInt - 1 ] );
          }
        } else if( this._focusedTextField === this._yearTextField ) {
          this._lastValidYear = this._spinner.getValue();
          this._focusedTextField.setText( "" + this._spinner.getValue() );
        } else {
          this._focusedTextField.setText( this._addLeadingZero( this._spinner.getValue() ) );
        }
        // Adjust date field
        if(    this._focusedTextField == this._monthTextField // month
            || this._focusedTextField == this._yearTextField ) // year
        {
          var dateValue = this._dayTextField.getText();
          if( dateValue > this._getDaysInMonth() ) {
            this._dayTextField.setText( "" + this._getDaysInMonth() );
          }
        }
        // Set the weekday field
        this._setWeekday();
        var newValue = this._focusedTextField.getText();
        if( oldValue != newValue ) {
          this._sendChanges();
        }
      }
    },

    _onKeyPress : function( event ) {
      var key = event.getKeyIdentifier();
      if( this._drop_down && ( key === "Up" || key === "Down" ) && event.isAltPressed() ) {
        this._toggleCalendarVisibility();
      } else if( this._dropped ) {
        this._calendar._onkeypress( event );
        if( event.getModifiers() === 0 ) {
          if( key === "Enter" ) {
            this._hideCalendar();
            this._handleKeyEnter( event );
          } else if( key === "Escape" || key === "Space" ) {
            this._hideCalendar();
          }
        }
      } else if( event.getModifiers() === 0 ) {
        switch( key ) {
          case "Enter":
            this._handleKeyEnter( event );
            break;
          case "Left":
            this._handleKeyLeft( event );
            break;
          case "Right":
            this._handleKeyRight( event );
            break;
          case "Up":
            this._handleKeyUp( event );
            break;
          case "Down":
            this._handleKeyDown( event );
            break;
          case "PageUp":
          case "PageDown":
          case "Home":
          case "End":
            this._stopEvent( event );
            break;
        }
      }
    },

    _onKeyUp : function( event ) {
      if( !this._dropped && event.getModifiers() === 0 ) {
        switch( event.getKeyIdentifier() ) {
          case "0": case "1": case "2": case "3": case "4":
          case "5": case "6": case "7": case "8": case "9":
            this._handleKeyNumber( event );
            break;
          case "Home":
            this._handleKeyHome( event );
            break;
          case "End":
            this._handleKeyEnd( event );
            break;
        }
      }
    },

    _handleKeyEnter : function() {
      rwt.remote.EventUtil.notifyDefaultSelected( this );
    },

    _handleKeyLeft : function( event ) {
      if( this._focusedTextField === this._yearTextField ) {
        this._checkAndApplyYearValue();
      }
      if( this._datePattern == "MDY") {
        this._rollLeft( this._monthTextField, this._dayTextField, this._yearTextField );
      } else if( this._datePattern == "DMY") {
        this._rollLeft( this._dayTextField, this._monthTextField, this._yearTextField );
      } else {
        if( this._medium ) {
          this._rollLeft( this._yearTextField, this._monthTextField, this._dayTextField );
        } else {
          this._rollLeft( this._monthTextField, this._dayTextField, this._yearTextField );
        }
      }
      this._stopEvent( event );
    },

    _handleKeyRight : function( event ) {
      if( this._focusedTextField === this._yearTextField ) {
        this._checkAndApplyYearValue();
      }
      if( this._datePattern == "MDY") {
        this._rollRight( this._monthTextField, this._dayTextField, this._yearTextField );
      } else if( this._datePattern == "DMY") {
        this._rollRight( this._dayTextField, this._monthTextField, this._yearTextField );
      } else {
        if( this._medium ) {
          this._rollRight( this._yearTextField, this._monthTextField, this._dayTextField );
        } else {
          this._rollRight( this._monthTextField, this._dayTextField, this._yearTextField );
        }
      }
      this._stopEvent( event );
    },

    _rollRight : function( first, second, third ) {
      if( this._focusedTextField === first ){
        if( second.isSeeable() ) {
          this._setFocusedTextField( second );
        } else {
          this._setFocusedTextField( third );
        }
      } else if( this._focusedTextField === second ) {
        if( third.isSeeable() ) {
          this._setFocusedTextField( third );
        } else {
          this._setFocusedTextField( first );
        }
      } else if( this._focusedTextField === third ) {
        if( first.isSeeable() ) {
          this._setFocusedTextField( first );
        } else {
          this._setFocusedTextField( second );
        }
      }
    },

    _rollLeft : function( first, second, third ) {
      if( this._focusedTextField === first ) {
        if( third.isSeeable() ) {
          this._setFocusedTextField( third );
        } else {
          this._setFocusedTextField( second );
        }
      } else if( this._focusedTextField === second ) {
        if( first.isSeeable() ) {
          this._setFocusedTextField( first );
        } else {
          this._setFocusedTextField( third );
        }
      } else if( this._focusedTextField === third ) {
        if( second.isSeeable() ) {
          this._setFocusedTextField( second );
        } else {
          this._setFocusedTextField( first );
        }
      }
    },

    _handleKeyDown : function( event ) {
      if( this._focusedTextField === this._yearTextField ) {
        this._checkAndApplyYearValue();
      }
      var value = this._spinner.getValue();
      if( value == this._spinner.getMin() ) {
        this._spinner.setValue( this._spinner.getMax() );
      } else {
        this._spinner.setValue( value - 1 );
      }
      this._stopEvent( event );
    },

    _handleKeyUp : function( event ) {
      if( this._focusedTextField === this._yearTextField ) {
        this._checkAndApplyYearValue();
      }
      var value = this._spinner.getValue();
      if( value == this._spinner.getMax() ) {
        this._spinner.setValue( this._spinner.getMin() );
      } else {
        this._spinner.setValue( value + 1 );
      }
      this._stopEvent( event );
    },

    _handleKeyNumber : function( event ) {
      var key = event.getKeyIdentifier();
      var value = this._removeLeadingZero( this._focusedTextField.getText() );
      var maxChars = this._focusedTextField.getUserData( "maxLength" );
      if( this._focusedTextField === this._monthTextField ) {
        value = "" + this._monthInt;
        maxChars = 2;
      }
      var newValue = value.length < maxChars && !this._initialEditing ? value + key : key;
      var intValue = parseInt( newValue, 10 );
      if(    this._focusedTextField === this._dayTextField
          || this._focusedTextField === this._monthTextField )
      {
        if( intValue >= this._spinner.getMin() && intValue <= this._spinner.getMax() ) {
          this._spinner.setValue( intValue );
        } else {
          // Do it again without adding the old value
          intValue = parseInt( key, 10 );
          if( intValue >= this._spinner.getMin() && intValue <= this._spinner.getMax() ) {
            this._spinner.setValue( intValue );
          }
        }
      } else if( this._focusedTextField == this._yearTextField ) {
        this._focusedTextField.setText( newValue );
        if( newValue.length == 4 ) {
          this._checkAndApplyYearValue();
        }
      }
      this._initialEditing = false;
      this._stopEvent( event );
    },

    _handleKeyHome : function( event ) {
      this._spinner.setValue( this._spinner.getMin() );
      this._initialEditing = true;
      this._stopEvent( event );
    },

    _handleKeyEnd : function( event ) {
      this._spinner.setValue( this._spinner.getMax() );
      this._initialEditing = true;
      this._stopEvent( event );
    },

    _onMouseWheel : function( event ) {
      if( this.getFocused() ) {
        this._stopEvent( event );
        if( !this._dropped ) {
          this._spinner._onmousewheel( event );
        }
      }
    },

    _stopEvent : function( event ) {
      event.preventDefault();
      event.stopPropagation();
    },

    _getDaysInMonth : function() {
      var result = 31;
      var tmpMonth = this._monthInt - 1;
      var tmpYear = parseInt( this._yearTextField.getText(), 10 );
      var tmpDate = new Date( tmpYear, tmpMonth, 1 );
      tmpDate.setDate( result );
      while( tmpDate.getMonth() !== tmpMonth ) {
        result--;
        tmpDate = new Date( tmpYear, tmpMonth, 1 );
        tmpDate.setDate( result );
      }
      return result;
    },

    _setWeekday : function() {
      var tmpDate = new Date();
      tmpDate.setDate( parseInt( this._dayTextField.getText(), 10 ) );
      tmpDate.setMonth( this._monthInt - 1 );
      tmpDate.setFullYear( parseInt( this._yearTextField.getText(), 10 ) );
      this._weekdayTextField.setText( this._weekday[ tmpDate.getDay() + 1 ] );
    },

    _checkAndApplyYearValue : function() {
      var oldValue = this._lastValidYear;
      var value = parseInt( this._yearTextField.getText(), 10 );
      if( value >= 0 && value <= 29 ) {
        this._lastValidYear = 2000 + value;
      } else if( value >= 30 && value <= 99 ) {
        this._lastValidYear = 1900 + value;
      } else if( value >= 1752 ) {
        this._lastValidYear = value;
      }
      this._yearTextField.setText( "" + oldValue );
      if( oldValue != this._lastValidYear ) {
        this._spinner.setValue( this._lastValidYear );
      }
    },

    _addLeadingZero : function( value ) {
      return value < 10 ? "0" + value : "" + value;
    },

    _removeLeadingZero : function( value ) {
      var result = value;
      if( value.length == 2 ) {
        var firstChar = value.substring( 0, 1 );
        if( firstChar == "0" ) {
          result = value.substring( 1 );
        }
      }
      return result;
    },

    _sendChanges : function() {
      if( !rwt.remote.EventUtil.getSuspended() ) {
        var connection = rwt.remote.Connection.getInstance();
        var remoteObject = connection.getRemoteObject( this );
        var day = parseInt( this._removeLeadingZero( this._dayTextField.getText() ), 10 );
        remoteObject.set( "day", day );
        remoteObject.set( "month", this._monthInt - 1 );
        remoteObject.set( "year", this._lastValidYear );
        if( remoteObject.isListening( "Selection" ) ) {
          connection.onNextSend( this._onSend, this );
          connection.sendDelayed( 200 );
        }
      }
    },

    _onSend : function() {
      rwt.remote.EventUtil.notifySelected( this );
    },

    setMonth : function( value ) {
      this._monthInt = value + 1;
      if( this._medium ) {
        this._monthTextField.setText( this._addLeadingZero( this._monthInt ) );
      } else {
        this._monthTextField.setText( this._monthname[ this._monthInt - 1 ] );
      }
      if( this._focusedTextField === this._monthTextField ) {
        this._spinner.setValue( this._monthInt );
      }
      // Set the weekday
      this._setWeekday();
    },

    setDay : function( value ) {
      this._dayTextField.setText( this._addLeadingZero( value ) );
      if( this._focusedTextField === this._dayTextField ) {
        this._spinner.setValue( value );
      }
      // Set the weekday
      this._setWeekday();
    },

    setYear : function( value ) {
      this._lastValidYear = value;
      this._yearTextField.setText( "" + value );
      if( this._focusedTextField === this._yearTextField ) {
        this._spinner.setValue( value );
      }
      // Set the weekday
      this._setWeekday();
    },

    _setDate : function( date ) {
      this.setYear( date.getFullYear() );
      this.setMonth( date.getMonth() );
      this.setDay( date.getDate() );
    },

    setBounds : function( index, x, y, width, height ) {
      var widget;
      switch( index ) {
        case 0:
          widget = this._weekdayTextField;
        break;
        case 1:
          widget = this._dayTextField;
        break;
        case 2:
          widget = this._monthTextField;
        break;
        case 3:
          widget = this._yearTextField;
        break;
        case 4:
          widget = this._separator0;
        break;
        case 5:
          widget = this._separator1;
        break;
        case 6:
          widget = this._separator2;
        break;
        case 7:
          widget = this._spinner;
        break;
        case 13:
          widget = this._dropDownButton;
        break;
      }
      if( widget ) {
        widget.set( {
          left: x,
          top: y,
          width: width,
          height: height
        } );
      }
    },

    //////////////////////////////////////
    // Drop-down calendar handling methods

    _onAppear : function() {
      if( this._drop_down ) {
        this.getTopLevelWidget().add( this._calendar );
        this._setCalendarLocation();
      }
    },

    _onWindowBlur : function() {
      this._hideCalendar();
    },

    _onChangeVisibility : function( event ) {
      var value = event.getValue();
      if( !value ) {
        this._hideCalendar();
      }
    },

    _onCalendarDateChange : function() {
      if( !this._internalDateChanged ) {
        this._setDate( this._calendar.getDate() );
        this._sendChanges();
      }
    },

    _onMouseDown : function( event ) {
      var target = event.getTarget();
      if( target.getUserData( "calendar-day" ) ) {
        event.stopPropagation();
      } else if( target.getUserData( "calendar-button" ) ) {
        event.stopPropagation();
      } else if( this._dropped && target !== this._dropDownButton ) {
        this._hideCalendar();
      }
    },

    _onMouseClick : function( event ) {
      if( event.isLeftButtonPressed() ) {
        var target = event.getTarget();
        if( target.getUserData( "calendar-day" ) ) {
          this._calendar._onDayClicked( event );
          this._hideCalendar();
          this.setFocused( true );
        } else if( target.getUserData( "calendar-button" ) ) {
          this._calendar._onNavButtonClicked( event );
        } else if( target === this._dropDownButton ) {
          this._toggleCalendarVisibility();
        }
      }
    },

    _onMouseOver : function( event ) {
      var target = event.getTarget();
      if( target == this._dropDownButton ) {
        this._dropDownButton.addState( "over" );
      } else if( target.getUserData( "calendar-day" ) ) {
        this._calendar._onDayMouseOver( event );
      }
    },

    _onMouseOut : function( event ) {
      var target = event.getTarget();
      if( target == this._dropDownButton ) {
        this._dropDownButton.removeState( "over" );
      } else if( target.getUserData( "calendar-day" ) ) {
        this._calendar._onDayMouseOut( event );
      }
    },

    _toggleCalendarVisibility : function() {
      if( this._dropped ) {
        this._hideCalendar();
      } else {
        this._showCalendar();
      }
    },

    _showCalendar : function() {
      if( this._drop_down && !this._dropped ) {
        this._dropped = true;
        this._calendar.setVisibility( true );
        this.setCapture( true );
        this._bringToFront();
        this._setCalendarLocation();
        var year = parseInt( this._yearTextField.getText(), 10 );
        var day = parseInt( this._dayTextField.getText(), 10 );
        var date = new Date( year, this._monthInt - 1, day );
        this._internalDateChanged = true;
        this._calendar.setDate( date );
        this._internalDateChanged = false;
        this._focusedTextField.removeState( "selected" );
      }
    },

    _hideCalendar : function() {
      if( this._drop_down && this._dropped ) {
        this._dropped = false;
        this._calendar.setVisibility( false );
        this.setCapture( false );
        if( this.getFocused() ){
          this._focusedTextField.addState( "selected" );
        }
      }
    },

    _setCalendarLocation : function() {
      if( this.getElement() && this._calendar != null ) {
        var browserWidth = window.innerWidth;
        var browserHeight = window.innerHeight;
        var elementPos = rwt.html.Location.get( this.getElement() );
        var left = elementPos.left;
        var top = elementPos.top + this.getHeight();
        var width = this._calendar.getWidthValue();
        var height = this._calendar.getHeightValue();
        if( top + height > browserHeight && elementPos.top - height > 0 ) {
          top = elementPos.top - height;
        }
        if( left + width > browserWidth ) {
          left =  Math.max( 0, browserWidth - width );
        }
        this._calendar.setLocation( left, top );
      }
    },

    _bringToFront : function() {
      var allWidgets = this.getTopLevelWidget().getChildren();
      var topZIndex = this._calendar.getZIndex();
      for( var vHashCode in allWidgets ) {
        var widget = allWidgets[ vHashCode ];
        if( widget.getZIndex ) {
          if( topZIndex < widget.getZIndex() ) {
            topZIndex = widget.getZIndex();
          }
        }
      }
      if( topZIndex > this._calendar.getZIndex() ) {
        this._calendar.setZIndex( topZIndex + 1 );
      }
    }

  }

} );

/*******************************************************************************
 * Copyright (c) 2008, 2014 Innoopract Informationssysteme GmbH.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Innoopract Informationssysteme GmbH - initial API and implementation
 *    EclipseSource - ongoing development
 ******************************************************************************/

rwt.qx.Class.define( "rwt.widgets.DateTimeCalendar", {
  extend : rwt.widgets.base.Parent,

  construct : function( style, monthNames, weekdayNames ) {
    this.base( arguments );
    this.setOverflow( "hidden" );
    this.setAppearance( "datetime-calendar" );
    // Get names of weekdays and months
    rwt.widgets.base.Calendar.MONTH_NAMES = monthNames;
    rwt.widgets.base.Calendar.WEEKDAY_NAMES = weekdayNames;
    // The Calendar
    this._calendar = new rwt.widgets.base.Calendar();
    this._calendar.setDate( new Date( 74, 5, 6 ) );
    this._calendar.setTabIndex( null );
    this._calendar.addEventListener( "changeDate", this._onChangeDate, this );
    this._calendar.addEventListener( "select", this._onSelect, this );
    this.add( this._calendar );
    this.addEventListener( "keypress", this._onKeyPress, this );
    this.addEventListener( "mousewheel", this._onMouseWheel, this );
    this.addEventListener( "focus", this._onFocusChange, this );
    this.addEventListener( "blur", this._onFocusChange, this );
    this._updateSelectedDayState();
  },

  destruct : function() {
    this._disposeObjects( "_calendar" );
  },

  members : {

    _getSubWidgets : function() {
      return [ this._calendar ];
    },

    _onKeyPress : function( event ) {
      this._calendar._onkeypress( event );
    },

    _onMouseWheel : function( event ) {
      event.preventDefault();
      event.stopPropagation();
    },

    _onFocusChange : function() {
      this._updateSelectedDayState();
    },

    _updateSelectedDayState : function() {
      for( var i = 0; i < 6 * 7; i++ ) {
        this._calendar._dayLabelArr[ i ].toggleState( "parent_unfocused", !this.getFocused() );
      }
    },

    _onChangeDate : function() {
      if( !rwt.remote.EventUtil.getSuspended() ) {
        var connection = rwt.remote.Connection.getInstance();
        var remoteObject = connection.getRemoteObject( this );
        var date = this._calendar.getDate();
        remoteObject.set( "day", date.getDate() );
        remoteObject.set( "month", date.getMonth() );
        remoteObject.set( "year", date.getFullYear() );
        if( remoteObject.isListening( "Selection" ) ) {
          connection.onNextSend( this._onSend, this );
          connection.sendDelayed( 200 );
        }
      }
    },

    _onSend : function() {
      rwt.remote.EventUtil.notifySelected( this );
    },

    _onSelect : function() {
      rwt.remote.EventUtil.notifyDefaultSelected( this );
    },

    setMonth : function( value ) {
      var date = this._calendar.getDate();
      date.setMonth( value );
      this._calendar.setDate( date );
    },

    setDay : function( value ) {
      var date = this._calendar.getDate();
      date.setDate( value );
      this._calendar.setDate( date );
    },

    setYear : function( value ) {
      var date = this._calendar.getDate();
      date.setYear( value );
      this._calendar.setDate( date );
    },

    setFont : function() {
      // TODO: [if] Calendar font is not implemented
    }

  }

} );

/*******************************************************************************
 * Copyright (c) 2011, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.remote.HandlerRegistry.add( "rwt.widgets.DateTime", {

  factory : function( properties ) {
    var result;
    var styleMap = rwt.remote.HandlerUtil.createStyleMap( properties.style );
    var styles;
    if( styleMap.SHORT ) {
      styles = "short";
    } else if( styleMap.LONG ) {
      styles = "long";
    } else {
      styles = "medium";
    }
    if( styleMap.DROP_DOWN ) {
      styles += "|drop_down";
    }
    if( styleMap.TIME ) {
      result = new rwt.widgets.DateTimeTime( styles );
    } else if( styleMap.CALENDAR ) {
      rwt.widgets.base.Calendar.CELL_WIDTH = properties.cellSize[ 0 ];
      rwt.widgets.base.Calendar.CELL_HEIGHT = properties.cellSize[ 1 ];
      result = new rwt.widgets.DateTimeCalendar( styles,
                                                 properties.monthNames,
                                                 properties.weekdayShortNames );
    } else {
      rwt.widgets.base.Calendar.CELL_WIDTH = properties.cellSize[ 0 ];
      rwt.widgets.base.Calendar.CELL_HEIGHT = properties.cellSize[ 1 ];
      result = new rwt.widgets.DateTimeDate( styles,
                                             properties.monthNames,
                                             properties.weekdayNames,
                                             properties.weekdayShortNames,
                                             properties.dateSeparator,
                                             properties.datePattern );
    }
    rwt.remote.HandlerUtil.addStatesForStyles( result, properties.style );
    result.setUserData( "isControl", true );
    rwt.remote.HandlerUtil.setParent( result, properties.parent );
    return result;
  },

  destructor : rwt.remote.HandlerUtil.getControlDestructor(),

  getDestroyableChildren : rwt.remote.HandlerUtil.getDestroyableChildrenFinder(),

  properties : rwt.remote.HandlerUtil.extendControlProperties( [
    "year",
    "month",
    "day",
    "hours",
    "minutes",
    "seconds",
    "subWidgetsBounds"
  ] ),

  propertyHandler : rwt.remote.HandlerUtil.extendControlPropertyHandler( {
    "subWidgetsBounds" : function( widget, value ) {
      for( var i = 0; i < value.length; i++ ) {
        widget.setBounds.apply( widget, value[ i ] );
      }
    }
  } ),

  events : [ "Selection", "DefaultSelection" ],

  listeners : rwt.remote.HandlerUtil.extendControlListeners( [] ),

  listenerHandler : rwt.remote.HandlerUtil.extendControlListenerHandler( {} )

} );

/*******************************************************************************
 * Copyright (c) 2008, 2014 Innoopract Informationssysteme GmbH and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Innoopract Informationssysteme GmbH - initial API and implementation
 *    EclipseSource - ongoing development
 ******************************************************************************/

rwt.qx.Class.define( "rwt.widgets.ExpandItem", {
  extend : rwt.widgets.base.Parent,

  construct : function( parent ) {
    this.base( arguments );
    this._expandBar = parent;
    this._expanded = false;
    this._header = new rwt.widgets.base.MultiCellWidget( [ "image", "label", "image" ] );
    this._header.setAppearance( "expand-item-header" );
    this._header.setFlexibleCell( 1 );
    this._header.expandFlexCell( true );
    this._header.setTextOverflow( "ellipsis" );
    this._header.setHeight( 24 );
    this._header.addEventListener( "click", this._onClick, this );
    this._header.addEventListener( "mouseover", this._onMouseOver, this );
    this._header.addEventListener( "mouseout", this._onMouseOut, this );
    this.add( this._header );
    // Set the appearance after _header is created
    this.setAppearance( "expand-item" );
  },

  destruct : function() {
    this._disposeObjects( "_header" );
  },

  properties : {

    chevronIcon : {
      themeable : true,
      apply : "_applyChevronIcon"
    }

  },

  members : {

    _getSubWidgets : function() {
      return [ this._header ];
    },

    _applyChevronIcon : function( value ) {
      if( value ) {
        this._header.setCellContent( 2, value[ 0 ] );
        this._header.setCellDimension( 2, value[ 1 ], value[ 2 ] );
      } else {
        this._header.setCellContent( 2, null );
      }
    },

    setExpanded : function( expanded ) {
      this._expanded = expanded;
      this.toggleState( "expanded", expanded );
      this._header.toggleState( "expanded", expanded );
    },

    getExpanded : function() {
      return this._expanded;
    },

    setImage : function( image ) {
      if( image ) {
        this._header.setCellContent( 0, image[ 0 ] );
        this._header.setCellDimension( 0, image[ 1 ], image[ 2 ] );
      } else {
        this._header.setCellContent( 0, null );
      }
    },

    setText : function( text ) {
      this._header.setCellContent( 1, text );
    },

    setHeaderHeight : function( headerHeight ) {
      this._header.setHeight( headerHeight );
    },

    _onClick : function() {
      if( !rwt.remote.EventUtil.getSuspended() ) {
        this.setExpanded( !this._expanded );
        var connection = rwt.remote.Connection.getInstance();
        connection.getRemoteObject( this ).set( "expanded", this._expanded );
        var eventName = this._expanded ? "Expand" : "Collapse";
        var itemId = rwt.remote.ObjectRegistry.getId( this );
        connection.getRemoteObject( this._expandBar ).notify( eventName, { "item" : itemId } );
      }
    },

    _onMouseOver : function() {
      this.addState( "over" );
    },

    _onMouseOut : function() {
      this.removeState( "over" );
    }

  }

} );

/*******************************************************************************
 * Copyright (c) 2011, 2015 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.remote.HandlerRegistry.add( "rwt.widgets.ExpandItem", {

  factory : function( properties ) {
    var result;
    rwt.remote.HandlerUtil.callWithTarget( properties.parent, function( parent ) {
      result = new rwt.widgets.ExpandItem( parent );
      parent.addWidget( result );
      rwt.remote.HandlerUtil.addDestroyableChild( parent, result );
      result.setUserData( "protocolParent", parent );
    } );
    return result;
  },

  destructor : rwt.remote.HandlerUtil.getWidgetDestructor(),

  properties : [
    "customVariant",
    "bounds",
    "text",
    "image",
    "expanded",
    "headerHeight",
    "data"
  ],

  propertyHandler : {
    "data" : rwt.remote.HandlerUtil.getControlPropertyHandler( "data" ),
    "bounds" : function( widget, value ) {
      widget.setLeft( value[ 0 ] );
      widget.setTop( value[ 1 ] );
      widget.setWidth( value[ 2 ] );
      widget.setHeight( value[ 3 ] );
    },
    "text" : function( widget, value ) {
      var EncodingUtil = rwt.util.Encoding;
      var text = EncodingUtil.escapeText( value, false );
      widget.setText( text );
    }
  }

} );

/*******************************************************************************
 * Copyright (c) 2008, 2014 Innoopract Informationssysteme GmbH and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Innoopract Informationssysteme GmbH - initial API and implementation
 *    EclipseSource - ongoing development
 ******************************************************************************/

rwt.qx.Class.define( "rwt.widgets.ExpandBar", {
  extend : rwt.widgets.base.Scrollable,

  construct : function() {
    this.base( arguments, new rwt.widgets.base.Parent() );
    this.setAppearance( "expand-bar" );
    this.setHideFocus( true );
    this.setScrollBarsVisible( false, false );
    // This object is needed for proper scrolling behaviour
    this._bottomSpacing = new rwt.widgets.base.Parent();
    this._clientArea.add( this._bottomSpacing );
  },

  destruct : function() {
    this._disposeObjects( "_bottomSpacing" );
  },

  members : {

    addWidget : function( widget ) {
      this._clientArea.add( widget );
    },

    setBottomSpacingBounds : function( x, y, width, height ) {
      this._bottomSpacing.setLeft( x );
      this._bottomSpacing.setTop( y );
      this._bottomSpacing.setWidth( width );
      this._bottomSpacing.setHeight( height );
    },

    setVScrollBarVisible : function( show ) {
      this.setScrollBarsVisible( false, show );
      if( !show ) {
        this.setVBarSelection( 0 );
      }
    },

    setVScrollBarMax : function( value ) {
      this._vertScrollBar.setMaximum( value );
    }

  }

} );

/*******************************************************************************
 * Copyright (c) 2011, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.remote.HandlerRegistry.add( "rwt.widgets.ExpandBar", {

  factory : function( properties ) {
    var result = new rwt.widgets.ExpandBar();
    rwt.remote.HandlerUtil.addStatesForStyles( result, properties.style );
    result.setUserData( "isControl", true );
    rwt.remote.HandlerUtil.setParent( result, properties.parent );
    return result;
  },

  destructor : rwt.remote.HandlerUtil.getControlDestructor(),

  getDestroyableChildren : rwt.remote.HandlerUtil.getDestroyableChildrenFinder(),

  properties : rwt.remote.HandlerUtil.extendControlProperties( [
    "bottomSpacingBounds",
    "vScrollBarMax"
  ] ),

  propertyHandler : rwt.remote.HandlerUtil.extendControlPropertyHandler( {
    "bottomSpacingBounds" : function( widget, value ) {
      widget.setBottomSpacingBounds.apply( widget, value );
    }
  } ),

  events : [ "Expand", "Collapse" ],

  listeners : rwt.remote.HandlerUtil.extendControlListeners( [] ),

  listenerHandler : rwt.remote.HandlerUtil.extendControlListenerHandler( {} )

} );

/*******************************************************************************
 * Copyright (c) 2010, 2015 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

(function() {

rwt.qx.Class.define( "rwt.widgets.Text", {

  extend : rwt.widgets.base.BasicText,

  construct : function( isTextarea ) {
    this.base( arguments );
    if( isTextarea ) {
      this._inputTag = "textarea";
      this._inputType = null;
      this._inputOverflow = "auto";
      this.setAppearance( "text-area" );
      this.setAllowStretchY( true );
      this.__oninput = rwt.util.Functions.bind( this._oninputDomTextarea, this );
    }
    this._message = null;
    this._messageElement = null;
    this._searchIconElement = null;
    this._cancelIconElement = null;
  },

  destruct : function() {
    this._messageElement = null;
    this._searchIconElement = null;
    this._cancelIconElement = null;
    this.__oninput = null;
  },

  properties : {

    wrap : {
      check : "Boolean",
      init : true,
      apply : "_applyWrap"
    }

  },

  members : {

    //////
    // API

    setMessage : function( value ) {
      this._message = value ? rwt.util.Encoding.escapeText( value, false ) : null;
      this._updateMessage();
    },

    getMessage : function() {
      return this._message;
    },

    setPasswordMode : function( value ) {
      var type = value ? "password" : "text";
      if( !this._isTextArea() && this._inputType != type ) {
        this._inputType = type;
        if( this._isCreated ) {
          this._inputElement.type = this._inputType;
        }
      }
    },

    ////////////////
    // event handler

    _ontabfocus : function() {
      if( this._isTextArea() ) {
        this._renderSelection();
      } else {
        this.selectAll();
      }
    },

    _onkeydown : function( event ) {
      this.base( arguments, event );
      if(    event.getKeyIdentifier() == "Enter"
          && !event.isShiftPressed()
          && !event.isAltPressed()
          && !event.isCtrlPressed()
          && !event.isMetaPressed() )
      {
        if( this._isTextArea() ) {
          event.stopPropagation();
        }
        if( this._shouldNotifyDefaultSelection() ) {
          rwt.remote.EventUtil.notifyDefaultSelected( this );
        }
      }
    },

    _shouldNotifyDefaultSelection : function() {
      // Emulate SWT (on Windows) where a default button takes precedence over
      // a SelectionListener on a text field when both are on the same shell.
      var shell = rwt.widgets.util.WidgetUtil.getShell( this );
      var defButton = shell ? shell.getDefaultButton() : null;
      var hasDefaultButton = defButton != null && defButton.isSeeable() && defButton.getEnabled();
      return !hasDefaultButton && !this._isTextArea();
    },

    _onMouseDownUp : function( event ) {
      this.base( arguments, event );
      if( event.getType() === "mousedown" ) {
        var target = event.getDomTarget();
        var detail = null;
        if( target === this._searchIconElement ) {
          detail = "search";
        } else if( target === this._cancelIconElement ) {
          this.setValue( "" );
          detail = "cancel";
        }
        if( detail != null ) {
          rwt.remote.EventUtil.notifyDefaultSelected( this, 0, 0, 0, 0, detail );
        }
      }
    },

    ///////////////
    // send changes

    _handleSelectionChange : function( start, length ) {
      this.base( arguments, start, length );
      if( !rwt.remote.EventUtil.getSuspended() ) {
        var remoteObject = rwt.remote.Connection.getInstance().getRemoteObject( this );
        remoteObject.set( "selection", [ start, start + length ] );
      }
    },

    _handleModification : function() {
      var remoteObject = rwt.remote.Connection.getInstance().getRemoteObject( this );
      remoteObject.set( "text", this.getComputedValue() );
      this._notifyModify();
      this._detectSelectionChange();
    },

    _notifyModify : function() {
      var connection = rwt.remote.Connection.getInstance();
      if( connection.getRemoteObject( this ).isListening( "Modify" ) ) {
        connection.onNextSend( this._onSend, this );
        connection.sendDelayed( 500 );
      }
    },

    _onSend : function() {
      if( !this.isDisposed() ) {
        rwt.remote.Connection.getInstance().getRemoteObject( this ).notify( "Modify", null, true );
      }
    },

    ///////////////////
    // textarea support

    _applyElement : function( value, oldValue ) {
      this.base( arguments, value, oldValue );
      if( this._isTextArea() ) {
        this._styleWrap();
      }
      var client = rwt.client.Client;
      if( client.isTrident() && client.getVersion() === 9 && this._isTextArea() ) {
        // Bug 427828 - [Text] Loses focus on click in IE8
        // Bug 422974 - [Text] Multi-Line Text with border-radius not focusable by mouse in IE9
        var blank = rwt.remote.Connection.RESOURCE_PATH + "static/image/blank.gif";
        rwt.html.Style.setBackgroundImage( this._inputElement, blank );
      }
      // Fix for bug 306354
      this._inputElement.style.paddingRight = "1px";
      this._updateAllIcons();
      this._updateMessage();
    },

    _webkitMultilineFix : function() {
      if( !this._isTextArea() ) {
        this.base( arguments );
      }
    },

    _applyWrap : function() {
      if( this._isTextArea() ) {
        this._styleWrap();
      }
    },

    _styleWrap : rwt.util.Variant.select( "qx.client", {
      "gecko" : function() {
        if( this._inputElement ) {
          var wrapValue = this.getWrap() ? "soft" : "off";
          var styleValue = this.getWrap() ? "" : "auto";
          this._inputElement.setAttribute( 'wrap', wrapValue );
          this._inputElement.style.overflow = styleValue;
        }
      },
      "default" : function() {
        if( this._inputElement ) {
          var wrapValue = this.getWrap() ? "soft" : "off";
          this._inputElement.setAttribute( 'wrap', wrapValue );
        }
      }
    } ),

    _applyMaxLength : function( value, oldValue ) {
      if( !this._isTextArea() ) {
        this.base( arguments, value, oldValue );
      }
    },

    _oninputDomTextarea : function( event ) {
      try {
        var maxLength = this.getMaxLength();
        var fireEvents = true;
        if( maxLength != null ) {
          var value = this._inputElement.value;
          if( value.length > this.getMaxLength() ) {
            var oldValue = this.getValue();
            // NOTE [tb] : When pasting strings, this might not always
            //             behave like SWT. There is no reliable fix for that.
            var position = this._getSelectionStart();
            if( oldValue.length == ( value.length - 1 ) ) {
              // The user added one character, undo.
              this._inputElement.value = oldValue;
              this._setSelectionStart( position - 1 );
              this._setSelectionLength( 0 );
            } else if( value.length >= oldValue.length && value != oldValue) {
              // The user pasted a string, shorten:
              this._inputElement.value = value.slice( 0, this.getMaxLength() );
              this._setSelectionStart( Math.min( position, this.getMaxLength() ) );
              this._setSelectionLength( 0 );
            }
            if( this._inputElement.value == oldValue ) {
              fireEvents = false;
            }
          }
        }
        if( fireEvents ) {
          this._oninput( event );
        }
      } catch( ex ) {
        rwt.runtime.ErrorHandler.processJavaScriptError( ex );
      }
    },

    _isTextArea : function() {
      return this._inputTag === "textarea";
    },

    ////////////////
    // icons support

    // overrided
    _syncFieldWidth : function() {
      var width =   this.getInnerWidth()
                  - this._getIconOuterWidth( "search" )
                  - this._getIconOuterWidth( "cancel" );
      this._inputElement.style.width = Math.max( 2, width ) + "px";
    },

    _syncFieldLeft : function() {
      this._inputElement.style.marginLeft = this._getIconOuterWidth( "search" ) + "px";
    },

    _updateAllIcons : function() {
      if( this._isCreated ) {
        this._updateIcon( "search" );
        this._updateIcon( "cancel" );
      }
    },

    _updateIcon : function( iconId ) {
      var element = this._getIconElement( iconId );
      if( this._hasIcon( iconId ) && element == null ) {
        element = document.createElement( "div" );
        element.style.position = "absolute";
        element.style.cursor = "pointer";
        this._getTargetNode().insertBefore( element, this._inputElement );
        this._setIconElement( iconId, element );
      }
      if( element ) {
        var image = this._getIconImage( iconId );
        rwt.html.Style.setBackgroundImage( element, image ? image[ 0 ] : null );
      }
      this._layoutIcon( iconId );
    },

    _layoutAllIcons : function() {
      this._layoutIcon( "search" );
      this._layoutIcon( "cancel" );
    },

    _layoutIcon : function( iconId ) {
      var element = this._getIconElement( iconId );
      if( element ) {
        var style = element.style;
        var image = this._getIconImage( iconId );
        style.width = image ? image[ 1 ] + "px" : 0;
        style.height = image ? image[ 2 ] + "px" : 0;
        var iconHeight = parseInt( style.height, 10 );
        style.top = Math.round( this.getInnerHeight() / 2 - iconHeight / 2 ) + "px";
        if( this._getIconPosition( iconId ) === "right" ) {
          var styleMap = this._getMessageStyle();
          var iconWidth = parseInt( style.width, 10 );
          style.left = (   this.getBoxWidth()
                         - this._cachedBorderRight
                         - styleMap.paddingRight
                         - iconWidth ) + "px";
        }
      }
    },

    _getIconElement : function( iconId ) {
      return iconId === "search" ? this._searchIconElement : this._cancelIconElement;
    },

    _setIconElement : function( iconId, element ) {
      if( iconId === "search" ) {
        this._searchIconElement = element;
      } else {
        this._cancelIconElement = element;
      }
    },

    _getIconOuterWidth : function( iconId ) {
      var result = 0;
      var image = this._getIconImage( iconId );
      if( this._hasIcon( iconId ) && image != null ) {
        result = image[ 1 ] + this._getIconSpacing( iconId );
      }
      return result;
    },

    _hasIcon : function( iconId ) {
      return this.hasState( iconId === "search" ? "rwt_ICON_SEARCH" : "rwt_ICON_CANCEL" );
    },

    _getIconImage : function( iconId ) {
      return this._hasIcon( iconId ) ? this._getIconStyle( iconId ).icon : null;
    },

    _getIconPosition : function( iconId ) {
      return iconId === "search" ? "left" : "right";
    },

    _getIconSpacing : function( iconId ) {
      return this._hasIcon( iconId ) ? this._getIconStyle( iconId ).spacing : 0;
    },

    _getIconStyle : function( iconId ) {
      var manager = rwt.theme.AppearanceManager.getInstance();
      var states = {};
      if( iconId === "search" ) {
        states[ "search" ] = true;
      }
      if( this._customVariant !== null ) {
        states[ this._customVariant ] = true;
      }
      return manager.styleFrom( "text-field-icon", states );
    },

    ///////////////////
    // password support

    _reCreateInputField : function() {
      var selectionStart = this._getSelectionStart();
      var selectionLength = this._getSelectionLength();
      this._inputElement.parentNode.removeChild( this._inputElement );
      this._inputElement.onpropertychange = null;
      this._inputElement = null;
      this._firstInputFixApplied = false;
      this._textColor = null;
      this._applyElement( this.getElement(), null );
      this._afterAppear();
      this._postApply();
      this._applyFocused( this.getFocused() );
      this._setSelectionStart( selectionStart );
      this._setSelectionLength( selectionLength );
    },

    //////////////////
    // message support

    _postApply : function() {
      this.base( arguments );
      this._syncFieldLeft();
      this._layoutAllIcons();
      this._layoutMessageX();
    },

    _applyValue : function( newValue, oldValue ) {
      this.base( arguments, newValue, oldValue );
      this._updateMessageVisibility();
      if( !rwt.remote.EventUtil.getSuspended() ) {
        this._handleModification();
      }
    },

    _applyFocused : function( newValue, oldValue ) {
      this.base( arguments, newValue, oldValue );
      this._updateMessageVisibility();
      if( newValue && ( this.getValue() === "" || this.getValue() == null ) ) {
        this._forceFocus();
      }
    },

    _forceFocus : rwt.util.Variant.select( "qx.client", {
      "webkit|blink" : function() {
        rwt.client.Timer.once( function() {
          if( this._inputElement ) {
            this._inputElement.focus();
          }
        }, this, 1 );
      },
      "default" : function() {
        // nothing to do
      }
    } ),

    _applyCursor : function( newValue, oldValue ) {
      this.base( arguments, newValue, oldValue );
      this._updateMessageCursor();
    },

    _applyFont : function( newValue, oldValue ) {
      this.base( arguments, newValue, oldValue );
      this._updateMessageFont();
    },

    // Overwritten
    _preventEnter : function( event ) {
      if( !this._isTextArea() ) {
        this.base( arguments, event );
      }
    },

    _updateMessage : function() {
      if( this._isCreated ) {
        if( this._message != null && this._message !== "" && this._messageElement == null ) {
          this._messageElement = document.createElement( "div" );
          var style = this._messageElement.style;
          style.position = "absolute";
          style.outline = "none";
          style.overflow = "hidden";
          var styleMap = this._getMessageStyle();
          style.color = styleMap.textColor || "";
          style.left = styleMap.paddingLeft + "px";
          rwt.html.Style.setTextShadow( this._messageElement, styleMap.textShadow );
          this._getTargetNode().insertBefore( this._messageElement, this._inputElement );
        }
        if( this._messageElement ) {
          this._messageElement.innerHTML = this._message ? this._message : "";
        }
        this._updateMessageCursor();
        this._updateMessageVisibility();
        this._updateMessageFont();
        this._layoutMessageX();
      }
    },

    _centerFieldVertically : function() {
      this.base( arguments );
      this._layoutMessageY();
    },

    _layoutMessageX : function() {
      if( this._messageElement ) {
        var styleMap = this._getMessageStyle();
        var style = this._messageElement.style;
        var width = this.getBoxWidth()
                    - this._cachedBorderLeft
                    - this._cachedBorderRight
                    - styleMap.paddingLeft
                    - styleMap.paddingRight
                    - this._getIconOuterWidth( "search" )
                    - this._getIconOuterWidth( "cancel" );
        style.width = Math.max( 0, width ) + "px";
        if( this._isTextArea() ) {
          // The text-area padding is hard codded in the appearances
          style.left = "3px";
        } else {
          style.left = ( this._getIconOuterWidth( "search" ) + styleMap.paddingLeft ) + "px";
        }
      }
    },

    _layoutMessageY : function() {
      if( this._messageElement ) {
        if( this._isTextArea() ) {
          this._messageElement.style.top = "0px";
        } else {
          this._messageElement.style.top = this.getInputElement().style.top;
        }
      }
    },

    _getMessageStyle : function() {
      var manager = rwt.theme.AppearanceManager.getInstance();
      return manager.styleFrom( "text-field-message", {} );
    },

    _updateMessageVisibility : function() {
      if( this._messageElement ) {
        var visible = ( this.getValue() == null || this.getValue() === "" ) && !this.getFocused();
        this._messageElement.style.display = visible ? "" : "none";
      }
    },

    _updateMessageFont : function() {
      if( this._messageElement ) {
        var font = this.getFont();
        font.renderElement( this._messageElement );
      }
    },

    _updateMessageCursor : function() {
      if( this._messageElement ) {
        var cursor = this._inputElement.style.cursor;
        if( cursor == null || cursor === "" ) {
          cursor = "text";
        }
        this._messageElement.style.cursor = cursor;
      }
    }

  }

} );

}() );


/*******************************************************************************
 * Copyright (c) 2011, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.remote.HandlerRegistry.add( "rwt.widgets.Text", {

  factory : function( properties ) {
    var styleMap = rwt.remote.HandlerUtil.createStyleMap( properties.style );
    var result = new rwt.widgets.Text( styleMap.MULTI );
    rwt.remote.HandlerUtil.addStatesForStyles( result, properties.style );
    result.setUserData( "isControl", true );
    rwt.remote.HandlerUtil.setParent( result, properties.parent );
    if( styleMap.RIGHT ) {
      result.setTextAlign( "right" );
    } else if( styleMap.CENTER ) {
      result.setTextAlign( "center" );
    }
    result.setWrap( styleMap.WRAP !== undefined );
    return result;
  },

  destructor : rwt.remote.HandlerUtil.getControlDestructor(),

  getDestroyableChildren : rwt.remote.HandlerUtil.getDestroyableChildrenFinder(),

  properties : rwt.remote.HandlerUtil.extendControlProperties( [
    /**
     * @name setText
     * @methodOf Text#
     * @description Sets the contents of the receiver to the given string. If the receiver has style
     * SINGLE and the argument contains multiple lines of text, the result of this
     * operation is undefined and may vary from platform to platform.
     * @param {string} text the new text
     */
    "text",
    "message",
    "echoChar",
    "editable",
    /**
     * @name setSelection
     * @methodOf Text#
     * @description Sets the selection to the range specified
     * by an array whose first value is the
     * character position representing the start of the selected
     * text, and whose second value is the character position
     * representing the end of the selection. An "empty" selection
     * is indicated by the values being identical.
     * <p>
     * Indexing is zero based.  The range of
     * a selection is from 0..N where N is
     * the number of characters in the widget.
     * </p><p>
     * Text selections are specified in terms of
     * caret positions.  In a text widget that
     * contains N characters, there are N+1 caret
     * positions, ranging from 0..N.  This differs
     * from other functions that address character
     * position such as getText () that use the
     * usual array indexing rules.
     * </p>
     *
     * @param {int[]} selection array representing the selection start and end
     */
    "selection",
    "textLimit"
  ] ),



  propertyHandler : rwt.remote.HandlerUtil.extendControlPropertyHandler( {
    "text" : function( widget, value ) {
      var EncodingUtil = rwt.util.Encoding;
      var text = EncodingUtil.truncateAtZero( value );
      if( !widget.hasState( "rwt_MULTI" ) ) {
        text = EncodingUtil.replaceNewLines( text, " " );
      }
      widget.setValue( text );
    },
    "echoChar" : function( widget, value ) {
      if( !widget.hasState( "rwt_MULTI" ) ) {
        widget.setPasswordMode( value !== null );
      }
    },
    "editable" : function( widget, value ) {
      widget.setReadOnly( !value );
    },
    "textLimit" : function( widget, value ) {
      widget.setMaxLength( value );
    }
  } ),

  events : [ "DefaultSelection", "Modify" ],

  listeners : rwt.remote.HandlerUtil.extendControlListeners( [] ),

  listenerHandler : rwt.remote.HandlerUtil.extendControlListenerHandler( {} ),

  methods: [ "addListener", "removeListener" ],

  methodHandler : rwt.remote.HandlerUtil.extendListenerMethodHandler( {} ),

  /**
   * @class RWT Scripting analoge to org.eclipse.swt.widgets.Text
   * @name Text
   * @extends Control
   * @description The constructor is not public.
   * @since 2.2
   */
  scriptingMethods : rwt.remote.HandlerUtil.extendControlScriptingMethods(
    /** @lends Text.prototype */
  {

    /**
     * @description  Returns the widget text.
     * @return {string} the widget text
     */
    getText : function() {
      return this.getValue();
    },

    /**
     * @description Returns an array whose first value is the
     * character position representing the start of the selected
     * text, and whose second value is the character position
     * representing the end of the selection. An "empty" selection
     * is indicated by the values being identical.
     * <p>
     * Indexing is zero based.  The range of a selection is from
     * 0..N where N is the number of characters in the widget.
     * </p>
     *
     * @return {int[]} array representing the selection start and end
     */
    getSelection : function() {
      return this.getSelection();
    },

    /**
     * @description  Returns the editable state.
     * @return {boolean} whether or not the receiver is editable
     */
    getEditable : function() {
      return !this.getReadOnly();
    }

  } )

} );

/*******************************************************************************
 * Copyright (c) 2002, 2014 Innoopract Informationssysteme GmbH and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Innoopract Informationssysteme GmbH - initial API and implementation
 *    EclipseSource - ongoing development
 ******************************************************************************/

/**
 * This class represents SWT Labels with style SWT.SEPARATOR
 */
rwt.qx.Class.define( "rwt.widgets.Separator", {
  extend : rwt.widgets.base.BoxLayout,

  construct : function() {
    this.base( arguments );
    // the actual separator line
    this._line = new rwt.widgets.base.Parent();
    this._line.setAnonymous( true );
    this._line.setAppearance( "separator-line" );
    this.add( this._line );
  },

  properties : {

    appearance : {
      refine : true,
      init : "separator"
    }

  },

  destruct : function() {
    this._line.dispose();
    this._line = null;
  },

  members : {

    _getSubWidgets : function() {
      return [ this._line ];
    },

    setLineStyle : function( style ) {
      this._line.addState( style );
    },

    setLineOrientation : function( value ) {
      if( value == "vertical" ) {
        this.setHorizontalChildrenAlign( "center" );
        this._line.setHeight( "100%" );
      } else {
        this.setVerticalChildrenAlign( "middle" );
        this._line.setWidth( "100%" );
      }
      this._line.toggleState( "rwt_VERTICAL", value == "vertical" );
    }

  }

} );

/*******************************************************************************
 * Copyright (c) 2011, 2012 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.remote.HandlerRegistry.add( "rwt.widgets.Separator", {

  factory : function( properties ) {
    var result = new rwt.widgets.Separator();
    rwt.remote.HandlerUtil.addStatesForStyles( result, properties.style );
    result.setUserData( "isControl", true );
    rwt.remote.HandlerUtil.setParent( result, properties.parent );
    var styleMap = rwt.remote.HandlerUtil.createStyleMap( properties.style );
    result.setLineOrientation( styleMap.VERTICAL ? "vertical" : "horizontal" );
    var lineStyle = "rwt_SHADOW_NONE";
    if( styleMap.SHADOW_IN ) {
      lineStyle = "rwt_SHADOW_IN";
    } else if( styleMap.SHADOW_OUT ) {
      lineStyle = "rwt_SHADOW_OUT";
    }
    result.setLineStyle( lineStyle );
    return result;
  },

  destructor : rwt.remote.HandlerUtil.getControlDestructor(),

  getDestroyableChildren : rwt.remote.HandlerUtil.getDestroyableChildrenFinder(),

  properties : rwt.remote.HandlerUtil.extendControlProperties( [] ),

  propertyHandler : rwt.remote.HandlerUtil.extendControlPropertyHandler( {} ),

  listeners : rwt.remote.HandlerUtil.extendControlListeners( [] ),

  listenerHandler : rwt.remote.HandlerUtil.extendControlListenerHandler( {} )

} );

/*******************************************************************************
 * Copyright (c) 2009, 2012 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.qx.Class.define( "rwt.widgets.ControlDecorator", {
  extend : rwt.widgets.base.Image,

  construct : function() {
    this.base( arguments );
    this.setZIndex( 1000 );
    this.setVisibility( false );
    this._showHover = true;
    this._text = null;
  },

  members : {

    setText : function( value ) {
      this._text = value;
      this._updateToolTip();
    },

    setShowHover : function( value ) {
      this._showHover = value;
      this._updateToolTip();
    },

    _updateToolTip : function() {
      var wm = rwt.remote.WidgetManager.getInstance();
      if( this._text === null || this._text === "" || !this._showHover ) {
        wm.setToolTip( this, null );
      } else {
        wm.setToolTip( this, this._text );
      }
    },

    setHasSelectionListener : function( value ) {
      var eventUtil = rwt.remote.EventUtil;
      if( value ) {
        this.addEventListener( "mousedown", eventUtil.widgetSelected, this );
      } else {
        this.removeEventListener( "mousedown", eventUtil.widgetSelected, this );
      }
    },

    setHasDefaultSelectionListener : function( value ) {
      var eventUtil = rwt.remote.EventUtil;
      if( value ) {
        this.addEventListener( "dblclick", eventUtil.widgetDefaultSelected, this );
      } else {
        this.removeEventListener( "dblclick", eventUtil.widgetDefaultSelected, this );
      }
    }

  }
} );

/*******************************************************************************
 * Copyright (c) 2011, 2013 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.remote.HandlerRegistry.add( "rwt.widgets.ControlDecorator", {

  factory : function( properties ) {
    var result = new rwt.widgets.ControlDecorator();
    rwt.remote.HandlerUtil.addStatesForStyles( result, properties.style );
    rwt.remote.HandlerUtil.setParent( result, properties.parent );
    // [if] ControlDecorator is destroyded by the protocol and must not be set as destroyable child.
    // See bug 407397
    rwt.remote.HandlerUtil.callWithTarget( properties.parent, function( parent ) {
      rwt.remote.HandlerUtil.removeDestroyableChild( parent, result );
      result.setUserData( "protocolParent", null );
    } );
    return result;
  },

  destructor : rwt.remote.HandlerUtil.getWidgetDestructor(),

  properties : [
    "bounds",
    "text",
    "image",
    "visible",
    "showHover"
  ],

  propertyHandler : {
    "bounds" : function( widget, value ) {
      widget.setLeft( value[ 0 ] );
      widget.setTop( value[ 1 ] );
      widget.setWidth( value[ 2 ] );
      widget.setHeight( value[ 3 ] );
    },
    "image" : function( widget, value ) {
      if( value === null ) {
        widget.setSource( null );
      } else {
        widget.setSource( value[ 0 ] );
      }
    },
    "visible" : function( widget, value ) {
      widget.setVisibility( value );
    }
  },

  listeners : [ "Selection", "DefaultSelection" ]

} );

/*******************************************************************************
 * Copyright (c) 2010, 2014 Innoopract Informationssysteme GmbH and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - ongoing development
 *    Austin Riddle (Texas Center for Applied Technology) - draggable types
 ******************************************************************************/

/*global alert:false, console:false */

namespace( "rwt.runtime" );


rwt.runtime.MobileWebkitSupport = {

  // These represent widget types and (optionally) defined appearances that are used to determine
  // if the widget is draggable.  If appearances are defined for a type, then one of the
  // appearances must match to allow the widget to be draggable.
  _draggableTypes : {
    "rwt.widgets.Shell" : null,
    "rwt.widgets.Sash"  : null,
    "rwt.widgets.Scale" : [ "scale-thumb" ],
    "rwt.widgets.Slider" : [ "slider-thumb" ],
    "rwt.widgets.base.ScrollBar" : null,
    "rwt.widgets.ScrolledComposite" : [ "scrollbar-thumb" ],
    "rwt.widgets.base.BasicButton" : [ "scrollbar-thumb" ],
    "rwt.widgets.base.Parent" : [ "coolitem-handle" ],
    "rwt.widgets.List" : [ "scrollbar-thumb" ],
    "rwt.widgets.Grid" : [ "tree-column", "label", "image", "scrollbar-thumb" ]
  },

  _lastMouseOverTarget : null,
  _lastMouseClickTarget : null,
  _lastMouseClickTime : null,
  _mouseEnabled : true,
  _fullscreen : window.navigator.standalone,
  _touchListener : null,
  _gestureListener : null,
  _touchSession : null,
  _allowNativeScroll : false,

  _allowedMouseEvents : {
    "INPUT" : {
      "mousedown" : true,
      "mouseup" : true
    },
    "TEXTAREA" : {
      "mousedown" : true,
      "mouseup" : true
    },
    "*" : {
      "mousewheel" : true
    }
  },

  init : function() {
    if( rwt.client.Client.supportsTouch() ) {
      this._configureToolTip();
      this._hideTabHighlight();
      this._bindListeners();
      this._registerListeners();
      this._registerFilter();
      // scrolling is currently very buggy in android, deactivated:
      this.setTouchScrolling( !rwt.client.Client.isAndroidBrowser() );
    }
  },

  // API for registration of custom-widgets for touch handling
  addDraggableType : function( type ) {
    // protect already registered types
    var exists = type in this._draggableTypes;
    if( !exists ) {
      this._draggableTypes[ type ] = null;
    }
  },

  // Experimental API for custom-widget
  setTouchListener : function( func, context ) {
    this._touchListener = [ func, context ];
  },

  // Experimental API for custom-widget
  setGestureListener : function( func, context ) {
    this._gestureListener = [ func, context ];
  },

  setTouchScrolling : function( value ) {
    this._allowNativeScroll = value;
  },

  _isZoomed : function() {
    var vertical = window.orientation % 180 === 0;
    var width = vertical ? screen.width : screen.height;
    return window.innerWidth !== width;
  },

  _configureToolTip : function() {
    var toolTip = rwt.widgets.base.WidgetToolTip.getInstance();
    toolTip.setMousePointerOffsetX( -35 );
    toolTip.setMousePointerOffsetY( -100 );
    var manager = rwt.widgets.util.ToolTipManager.getInstance();
    manager.handleMouseEvent = function( event ) {
      var type = event.getType();
      if( type === "mousedown" ) {
        this._handleMouseOver( event );
      } else if( type === "mouseup" ) {
        this.setCurrentToolTipTarget( null );
      }
    };
  },

  _hideTabHighlight : function() {
    rwt.html.StyleSheet.createElement( " * { -webkit-tap-highlight-color: rgba(0,0,0,0); }" );
  },

  _bindListeners : function() {
     this.__onTouchEvent = rwt.util.Functions.bind( this._onTouchEvent, this );
     this.__onGestureEvent = rwt.util.Functions.bind( this._onGestureEvent, this );
     this.__onOrientationEvent = rwt.util.Functions.bind( this._onOrientationEvent, this );
  },

  _registerListeners : function() {
    var target = document.body;
    if( rwt.client.Client.isGecko() ) {
      target.addEventListener( "touchstart", this.__onTouchEvent, false );
      target.addEventListener( "touchmove", this.__onTouchEvent, false );
      target.addEventListener( "touchend", this.__onTouchEvent, false );
      target.addEventListener( "touchcancel", this.__onTouchEvent, false );
      target.addEventListener( "deviceorientation", this.__onOrientationEvent, false );
    } else {
      // older iOs versions didn't recognize touch listener registered by AddEventListener:
      target.ontouchstart = this.__onTouchEvent;
      target.ontouchmove = this.__onTouchEvent;
      target.ontouchend = this.__onTouchEvent;
      target.ontouchcancel = this.__onTouchEvent;
      // on new iOS versions on the "ongestureXYZ" setter no longer works
      target.addEventListener( "gesturestart", this.__onGestureEvent );
      target.addEventListener( "gesturechange", this.__onGestureEvent );
      target.addEventListener( "gestureend", this.__onGestureEvent );
      target.onorientationchange = this.__onOrientationEvent;
    }
  },

  _removeListeners : function() {
    var target = document.body;
    if( rwt.client.Client.isGecko() ) {
      target.removeEventListener( "touchstart", this.__onTouchEvent, false );
      target.removeEventListener( "touchmove", this.__onTouchEvent, false );
      target.removeEventListener( "touchend", this.__onTouchEvent, false );
      target.removeEventListener( "touchcancel", this.__onTouchEvent, false );
      target.removeEventListener( "deviceorientation", this.__onOrientationEvent, false );
    } else {
      target.ontouchstart = null;
      target.ontouchmove = null;
      target.ontouchend = null;
      target.ontouchcancel = null;
      target.removeEventListener( "gesturestart", this.__onGestureEvent );
      target.removeEventListener( "gesturechange", this.__onGestureEvent );
      target.removeEventListener( "gestureend", this.__onGestureEvent );
      target.onorientationchange = null;
    }
  },

  _registerFilter : function() {
    rwt.event.EventHandler.setMouseDomEventFilter( this._filterMouseEvents, this );
  },

  _filterMouseEvents : function( event ) {
    var allowedMap = this._allowedMouseEvents;
    var result = typeof event.originalEvent === "object"; // faked event?
    if( !result ) {
      result = allowedMap[ "*" ][ event.type ] === true;
    }
    if( !result && typeof allowedMap[ event.target.tagName ] === "object" ) {
      result = allowedMap[ event.target.tagName ][ event.type ] === true;
    }
    if( !result ) {
      event.preventDefault();
      event.returnValue = false;
    }
    return result;
  },

  _onTouchEvent : function( domEvent ) {
    try {
      if( !rwt.remote.EventUtil.getSuspended() ) {
        var type = domEvent.type;
        if( this._mouseEnabled ) {
          switch( type ) {
          case "touchstart":
            this._handleTouchStart( domEvent );
            break;
          case "touchend":
            this._handleTouchEnd( domEvent );
            break;
          case "touchmove":
            this._handleTouchMove( domEvent );
            break;
          }
        } else {
          if( this._touchListener !== null ) {
            this._touchListener[ 0 ].call( this._touchListener[ 1 ], domEvent );
          }
        }
      } else {
        domEvent.preventDefault();
      }
    } catch( ex ) {
      // problem: touch events emulate mouse events. When an error occurs in the emulation
      // layer, it would be ignored. However, if the ErrorHandler is called here, it will be
      // called twice if the error occurs within the mouse event handling. Therefore only
      // alert is used for now:
      alert( "Error in touch event handling:" + ex );
      if( typeof console === "object" ) {
        console.log( ex );
        if( ex.stack ) {
          console.log( ex.stack );
        }
      }
    }
  },

  _getTouch : function( domEvent ) {
    var touch = domEvent.touches.item( 0 );
    if( touch === null ) {
      // Should happen at touchend (behavior seems unpredictable)
      touch = domEvent.changedTouches.item( 0 );
    }
    return touch;
  },

  _handleTouchStart : function( domEvent ) {
    var touch = this._getTouch( domEvent );
    var target = domEvent.target;
    var widgetTarget = rwt.event.EventHandlerUtil.getOriginalTargetObject( target );
    var pos = [ touch.clientX, touch.clientY ];
    this._touchSession = {
     "type" : this._getSessionType( widgetTarget ),
     "initialTarget" : target,
     "widgetTarget" : widgetTarget,
     "initialPosition" : pos
    };
    if(    !this._touchSession.type.scroll
        && !this._touchSession.type.outerScroll
        && !this._touchSession.type.focus )
    {
      domEvent.preventDefault();
    }
    this._moveMouseTo( target, domEvent );
    if( this._touchSession.type.click ) {
      this._fireMouseEvent( "mousedown", target, domEvent, pos );
    }
    if( this._touchSession.type.virtualScroll ) {
      this._initVirtualScroll( widgetTarget );
    }
  },

  _handleTouchMove : function( domEvent ) {
    if( this._touchSession !== null ) {
      var touch = this._getTouch( domEvent );
      var pos = [ touch.clientX, touch.clientY ];
      if( this._touchSession.type.virtualScroll ) {
        this._handleVirtualScroll( pos );
      }
      if( !this._touchSession.type.scroll ) {
        domEvent.preventDefault();
      }
      if( this._touchSession.type.drag ) {
        domEvent.preventDefault();
        var target = domEvent.target;
        this._fireMouseEvent( "mousemove", target, domEvent, pos );
      } else {
        var oldPos = this._touchSession.initialPosition;
        // TODO [tb] : offset too big for good use with touch-scrolling
        if(    Math.abs( oldPos[ 0 ] - pos[ 0 ] ) >= 15
            || Math.abs( oldPos[ 1 ] - pos[ 1 ] ) >= 15 )
        {
          this._cancelMouseSession( domEvent );
        }
      }
    }
  },

  _handleTouchEnd : function( domEvent ) {
    domEvent.preventDefault();
    var touch = this._getTouch( domEvent );
    var pos = [ touch.clientX, touch.clientY ];
    var target = domEvent.target;
    if( this._touchSession !== null ) {
      var type = this._touchSession.type;
      if( type.delayedClick ) {
        this._fireMouseEvent( "mousedown", target, domEvent, pos );
      }
      if( type.click || type.delayedClick ) {
        this._fireMouseEvent( "mouseup", target, domEvent, pos );
      }
      if( this._touchSession.type.virtualScroll ) {
        this._finishVirtualScroll();
      }
      if( ( type.click || type.delayedClick ) && this._touchSession.initialTarget === target ) {
        this._fireMouseEvent( "click", target, domEvent, pos );
        this._touchSession = null;
        if( this._isDoubleClick( domEvent ) ) {
          this._lastMouseClickTarget = null;
          this._lastMouseClickTime = null;
          this._fireMouseEvent( "dblclick", target, domEvent, pos );
        } else {
          this._lastMouseClickTarget = target;
          this._lastMouseClickTime = ( new Date() ).getTime();
        }
      }
    }
  },

  _getSessionType : function( widgetTarget ) {
    var result = {};
    if( this._isSelectableWidget( widgetTarget ) || this._isFocusable( widgetTarget ) ) {
      result.delayedClick = true;
    } else {
      result.click = true;
    }
    if( this._isDraggableWidget( widgetTarget ) ) {
      result.drag = true;
    } else if( this._isGridRow( widgetTarget ) ) {
      result.virtualScroll = true;
      result.outerScroll = this._allowNativeScroll && this._isScrollableWidget( widgetTarget );
    } else if( this._allowNativeScroll && this._isScrollableWidget( widgetTarget ) ) {
      result.scroll = true;
    } else if( this._isFocusable( widgetTarget ) ) {
      result.focus = true;
    }
    return result;
  },

  ////////////////////
  // virtual scrolling

  _initVirtualScroll : function( widget ) {
    var scrollable;
    if( widget instanceof rwt.widgets.base.GridRow ) {
      scrollable = widget.getParent().getParent();
    } else {
      scrollable = this._findScrollable( widget );
    }
    var scrollBarV = scrollable._vertScrollBar;
    var scrollBarH = scrollable._horzScrollBar;
    this._touchSession.scrollBarV = scrollBarV;
    this._touchSession.initScrollY = scrollBarV.getValue();
    this._touchSession.maxScrollY = scrollBarV.getMaximum();
    this._touchSession.scrollBarH = scrollBarH;
    this._touchSession.initScrollX = scrollBarH.getValue();
    this._touchSession.maxScrollX = scrollBarH.getMaximum();
  },

  _handleVirtualScroll : function( pos ) {
    var oldPos = this._touchSession.initialPosition;
    var offsetX = oldPos[ 0 ] - pos[ 0 ];
    var offsetY = oldPos[ 1 ] - pos[ 1 ];
    var newX = this._touchSession.initScrollX + offsetX;
    var newY = this._touchSession.initScrollY + offsetY;
    var max =   this._touchSession.scrollBarV.getMaximum()
              - this._touchSession.scrollBarV._thumbLength;
    var nudged = newY < 0 || newY > max;
    if( this._touchSession.type.outerScroll && nudged ) {
      var outer = this._findScrollable( this._touchSession.widgetTarget );
      var outerValue = outer._vertScrollBar.getValue();
      var outerMax =   outer._vertScrollBar.getMaximum()
                     - outer._vertScrollBar._thumbLength;
      if(    ( newY < 0 && outerValue > 0 )
          || ( newY > max && outerValue < outerMax ) )
      {
        delete this._touchSession.type.virtualScroll;
        this._touchSession.type.scroll = true;
      }
    }
    this._touchSession.scrollBarH.setValue( newX );
    this._touchSession.scrollBarV.setValue( newY );
  },

  _finishVirtualScroll : function() {
    // set ideal value to actual value (prevents scroll on resize when on max position)
    var barV = this._touchSession.scrollBarV;
    barV.setValue( barV.getValue() );
  },

  /////////
  // Helper

  _isFocusable : function( widgetTarget ) {
    return widgetTarget instanceof rwt.widgets.base.BasicText;
  },

  _isScrollableWidget : function( widget ) {
    return this._findScrollable( widget ) !== null;
  },

  _isGridRow : function( widgetTarget ) {
    return widgetTarget instanceof rwt.widgets.base.GridRow;
  },

  _isSelectableWidget : function( widgetTarget ) {
    var result = false;
    if(    widgetTarget instanceof rwt.widgets.ListItem
        || widgetTarget instanceof rwt.widgets.base.GridRow )
    {
      result = true;
    }
    return result;
  },

  _findScrollable : function( widget ) {
    var result = null;
    var currentWidget = widget;
    do {
      if( currentWidget instanceof rwt.widgets.base.Scrollable ) {
        result = currentWidget;
      } else if( currentWidget instanceof rwt.widgets.base.ClientDocument ) {
        currentWidget = null;
      } else {
        currentWidget = currentWidget.getParent();
      }
    } while( currentWidget && !result );
    return result;
  },

  _isDraggableWidget : function ( widgetTarget ) {
    var widgetManager = rwt.remote.WidgetManager.getInstance();
    // We find the nearest control because matching based on widgetTarget can produce too
    // generalized cases.
    var widget = widgetManager.findControl( widgetTarget );
    var draggable = false;
    if( widget == null ) {
      widget = widgetTarget;
    }
    if( widget != null && widget.classname in this._draggableTypes ) {
      var appearances = this._draggableTypes[ widget.classname ];
      if( appearances == null ) {
        draggable = true;
      } else {
        for( var i = 0; i < appearances.length && !draggable; i++ ) {
          if( widgetTarget.getAppearance() === appearances[ i ] ) {
            draggable = true;
          }
        }
      }
    }
    return draggable;
  },

  _isDoubleClick : function( domEvent ) {
    var target = domEvent.target;
    var result = false;
    if( this._lastMouseClickTarget === target ) {
      var diff = ( ( new Date() ).getTime() ) - this._lastMouseClickTime;
      result = diff < rwt.remote.EventUtil.DOUBLE_CLICK_TIME;
    }
    return result;
  },

  _onGestureEvent : function( domEvent ) {
    domEvent.preventDefault();
    var type = domEvent.type;
    if( this._gestureListener !== null ) {
      this._gestureListener[ 0 ].call( this._gestureListener[ 1 ], domEvent );
    }
    switch( type ) {
      case "gesturestart":
        this._disableMouse( domEvent );
      break;
      case "gestureend":
        this._enableMouse( domEvent );
      break;
    }
  },

  _onOrientationEvent : function() {
    // Nothing to do yet
  },

  ////////////////
  // emulate mouse

  _disableMouse : function( domEvent ) {
    // Note: Safari already does somthing similar to this (a touchevent
    // that executes JavaScript will prevent further touch/gesture events),
    // but no in all cases, e.g. on a touchstart with two touches.
    this._cancelMouseSession( domEvent );
    this._mouseEnabled = false;
  },

  _cancelMouseSession : function( domEvent ) {
    var dummy = this._getDummyTarget();
    this._moveMouseTo( dummy, domEvent );
    if( this._touchSession !== null ) {
      this._fireMouseEvent( "mouseup", dummy, domEvent, [ 0, 0 ] );
      delete this._touchSession.type.click;
      delete this._touchSession.type.delayedClick;
    }
  },

  // The target used to release the virtual mouse without consequences
  _getDummyTarget : function() {
    return rwt.widgets.base.ClientDocument.getInstance()._getTargetNode();
  },

  _enableMouse : function() {
    this._mouseEnabled = true;
  },

  _moveMouseTo : function( target, domEvent ) {
    var oldTarget = this._lastMouseOverTarget;
    if( oldTarget !== target ) {
      var pos = [ 0, 0 ];
      if( oldTarget !== null ) {
        this._fireMouseEvent( "mouseout", oldTarget, domEvent, pos );
      }
      this._lastMouseOverTarget = target;
      this._fireMouseEvent( "mouseover", target, domEvent, pos );
    }
  },

  _fireMouseEvent : function( type, target, originalEvent, coordiantes ) {
    var event = document.createEvent( "MouseEvent" );
    event.initMouseEvent( type,
                          true, // bubbles
                          true, //cancelable
                          window, //view
                          0, // detail
                          coordiantes[ 0 ], //screenX
                          coordiantes[ 1 ], //screenY
                          coordiantes[ 0 ], //clientX
                          coordiantes[ 1 ], //clientY
                          false, //ctrlKey
                          false, //altKey
                          false, //shiftKey
                          false, //metaKey
                          rwt.event.MouseEvent.buttons.left,
                          null );
    event.originalEvent = originalEvent;
    target.dispatchEvent( event );
  },

  _postMouseEvent : function( type ) {
    if( type === "mouseup" ) {
      rwt.widgets.util.ToolTipManager.getInstance().setCurrentToolTipTarget( null );
    }
  }

};

/*******************************************************************************
 * Copyright (c) 2011, 2014 Rüdiger Herrmann and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Rüdiger Herrmann - initial API and implementation
 *    EclipseSource - ongoing development
 ******************************************************************************/

rwt.qx.Class.define( "rwt.widgets.ToolTip", {
  extend : rwt.widgets.base.Popup,
  include : rwt.animation.VisibilityAnimationMixin,

  construct : function( style ) {
    this.base( arguments );
    this._style = style;
    this.setAutoHide( false );
    this.setDisplay( true );
    this.setVisibility( false );
    this.setAppearance( "tool-tip" );
    var doc = rwt.widgets.base.ClientDocument.getInstance();
    this.setMaxWidth( doc.getClientWidth() / 2 );
    this.setMaxHeight( doc.getClientHeight() / 2 );
    this.addToDocument();
    this.addEventListener( "click", this._onClick, this );
    this._hideAfterTimeout = false;
    this._messageFont = this._getMessageFont();
    this._contentArea = null;
    this._textArea = null;
    this._image = null;
    this._text = null;
    this._message = null;
    this._markupEnabled = false;
    this._createControls();
  },

  destruct : function() {
    this.removeEventListener( "click", this._onClick, this );
    this._contentArea.dispose();
    this._textArea.dispose();
    this._image.dispose();
    this._text.dispose();
    this._message.dispose();
    this._messageFont = null;
  },

  members : {

    setText : function( value ) {
      var text = value;
      if( !this._markupEnabled ) {
        text = rwt.util.Encoding.escapeText( text, false );
      }
      this._text.setText( text );
      if( this.getVisibility() ) {
        this._update();
      }
    },

    setMessage : function( value ) {
      var message = value;
      if( !this._markupEnabled ) {
        var EncodingUtil = rwt.util.Encoding;
        message = EncodingUtil.escapeText( message, false );
        message = EncodingUtil.replaceNewLines( message, "<br/>" );
      }
      this._message.setText( message );
      if( this.getVisibility() ) {
        this._update();
      }
    },

    setMarkupEnabled : function( value ) {
      this._markupEnabled = value;
    },

    setLocation : function( x, y ) {
      this.setLeft( x );
      this.setTop( y );
    },

    setHideAfterTimeout : function( value ) {
      this._hideAfterTimeout = value;
    },

    setVisible : function( visible ) {
      this.setVisibility( visible );
      if( visible ) {
        this._update();
        this.bringToFront();
        if( this._hideAfterTimeout ) {
          rwt.client.Timer.once( this._hide, this, 5 * 1000 );
        }
      }
    },

    addState : function( state ) {
      this.base( arguments, state );
      this._image.addState( state );
    },

    removeState : function( state ) {
      this.base( arguments, state );
      this._image.removeState( state );
    },

    _createControls : function() {
      this._contentArea = new rwt.widgets.base.BoxLayout( "horizontal" );
      this._contentArea.setWidth( "100%" );
      this._contentArea.setHeight( "100%" );
      this._contentArea.setSpacing( 5 );
      this._contentArea.setOverflow( "hidden" );
      this._contentArea.setParent( this );
      this._image = new rwt.widgets.base.Image();
      this._image.setAppearance( "tool-tip-image" );
      this._image.setParent( this._contentArea );
      this._textArea = new rwt.widgets.base.BoxLayout( "vertical" );
      this._textArea.setParent( this._contentArea );
      this._textArea.setHeight( "100%" );
      this._textArea.setSpacing( 5 );
      this._text = new rwt.widgets.base.Label();
      this._text.setAppearance( "tool-tip-text" );
      this._text.setParent( this._textArea );
      this._message = new rwt.widgets.base.Label();
      this._message.setAppearance( "tool-tip-message" );
      this._message.setHeight( "auto" );
      this._message.setWrap( true );
      this._message.setParent( this._textArea );
    },

    _update : function() {
      var message = this._message.getText();
      var textSize = this._getTextSize( this._text.getText(), -1 );
      var messageSize = this._getTextSize( message, -1 );
      if( !this._markupEnabled ) {
        var width = messageSize.x;
        while( width > 0 && !this._matchesWidthToHeightRatio( messageSize ) ) {
          width -= 10;
          messageSize = this._getTextSize( message, width );
        }
      }
      messageSize.x = this._max( messageSize.x, textSize.x );
      this._message.setWidth( messageSize.x );
      this._message.setHeight( messageSize.y );
    },

    _matchesWidthToHeightRatio : function( size ) {
      return size.x / size.y <= 6;
    },

    _max : function( a, b ) {
      return a > b ? a : b;
    },

    _getTextSize : function( text, width ) {
      var data = [];
      data[ 0 ] = "";
      data[ 1 ] = text;
      data[ 2 ] = this._messageFont.getFamily();
      data[ 3 ] = this._messageFont.getSize();
      data[ 4 ] = this._messageFont.getBold();
      data[ 5 ] = this._messageFont.getItalic();
      data[ 6 ] = width;
      var textSize = rwt.widgets.util.FontSizeCalculation._measureItem( data );
      return {
        x : textSize[ 0 ],
        y : textSize[ 1 ]
      };
    },

    _onClick : function() {
      this._hide();
      rwt.remote.EventUtil.notifySelected( this );
    },

    _hide : function() {
      if( this.getVisibility() ) {
        this.setVisible( false );
        rwt.widgets.base.Widget.flushGlobalQueues();
        rwt.remote.Connection.getInstance().getRemoteObject( this ).set( "visible", false );
      }
    },

    _getMessageFont : function() {
      var tv = new rwt.theme.ThemeValues( {} );
      return tv.getCssFont( "ToolTip-Message", "font" );
    }

  }

} );

/*******************************************************************************
 * Copyright (c) 2011, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.remote.HandlerRegistry.add( "rwt.widgets.ToolTip", {

  factory : function( properties ) {
    var styleMap = rwt.remote.HandlerUtil.createStyleMap( properties.style );
    var style = null;
    if( styleMap.ICON_ERROR ) {
      style = "error";
    } else if( styleMap.ICON_WARNING ) {
      style = "warning";
    } else if( styleMap.ICON_INFORMATION ) {
      style = "information";
    }
    var result = new rwt.widgets.ToolTip( style );
    result.setMarkupEnabled( properties.markupEnabled === true );
    rwt.remote.HandlerUtil.addStatesForStyles( result, properties.style );
    rwt.remote.HandlerUtil.callWithTarget( properties.parent, function( parent ) {
      rwt.remote.HandlerUtil.addDestroyableChild( parent, result );
    } );
    return result;
  },

  destructor : rwt.remote.HandlerUtil.getWidgetDestructor(),

  properties : [
    "customVariant",
    "roundedBorder",
    "backgroundGradient",
    "autoHide",
    "text",
    "message",
    "location",
    // Visible must be set after all other properties
    "visible"
  ],

  propertyHandler : {
    "roundedBorder" : rwt.remote.HandlerUtil.getRoundedBorderHandler(),
    "backgroundGradient" : rwt.remote.HandlerUtil.getBackgroundGradientHandler(),
    "autoHide" : function( widget, value ) {
      widget.setHideAfterTimeout( value );
    },
    "location" : function( widget, value ) {
      widget.setLocation( value[ 0 ], value[ 1 ] );
    }
  },

  events : [ "Selection" ]

} );

/*******************************************************************************
 * Copyright (c) 2002, 2014 Innoopract Informationssysteme GmbH.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Innoopract Informationssysteme GmbH - initial API and implementation
 *    EclipseSource - ongoing development
 ******************************************************************************/

/**
 * Maps widget id's to their respective object references. Allows for
 * adding, removing and disposing of widgets and their id. In addition
 * the mapping of widgets and their respective id's can be queried.
 *
 * TODO [tb] : use ObjectRegistry/WidgetUtil instead, remove class
 *
 */
rwt.qx.Class.define( "rwt.remote.WidgetManager", {

  extend : rwt.qx.Object,

  statics : {

    getInstance : function() {
      return rwt.runtime.Singletons.get( rwt.remote.WidgetManager );
    }

  },

  construct : function() {
    this.base( arguments );
  },

  members : {
    /**
     * Disposes of the widget that is registered with the given id. The widget
     * is disconnected from its parent, its 'dispose' method is called and it is
     * removed from this WidgetManager (see remove).
     * No action is taken if there is no widget registered for the given id or
     * the widget was already disposed of.
     */
    dispose : function( id ) {
      var widget = this.findWidgetById( id );
      if( widget != null ) {
        this.remove( widget );
        if( !widget.getDisposed() ) {
          this._removeToolTipPopup( widget );
          widget.destroy();
        }
      }
    },

    /**
     * Registers the given widget under the given id at the WidgetManager.
     */
    add : function( widget, id, isControl, adapter ) {
      if( isControl === true ) {
        widget.setUserData( "isControl", true );
      }
      rwt.remote.ObjectRegistry.add( id, widget, adapter );
    },

    /**
     * Unregisters the given widget at the WidgetManager. Note that the widget is
     * not disposed of.
     */
    remove : function( widget ) {
      var id = this.findIdByWidget( widget );
      rwt.remote.ObjectRegistry.remove( id );
    },

    /**
     * Returns the widget for the given id or null if there is no widget
     * registered for the given id exists.
     */
    findWidgetById : function( id ) {
      return rwt.remote.ObjectRegistry.getObject( id );
    },

    /**
     * Returns the id (string) for the given widget or null if the widget is not
     * registered.
     */
    findIdByWidget : function( widget ) {
      return rwt.remote.ObjectRegistry.getId( widget );
    },

    /**
     * Determines whether the given widget represents a server-side instance of
     * Control (or one of its subclasses)
     */
    isControl : function( widget ) {
      var data = null;
      if( widget != null ) {
        data = widget.getUserData( "isControl" );
      }
      return data === true;
    },

    /**
     * Returns the nearest SWT-control in the hierarchy for the given qxWidget
     * or null if no parent control could be found. If the given qxWidget
     * represents a control, it is returned.
     */
    findControl : function( qxWidget ) {
      var parent = qxWidget;
      while( parent != null && !this.isControl( parent ) ) {
        parent = parent.getParent ? parent.getParent() : null;
      }
      return parent;
    },

    findEnabledControl : function( qxWidget ) {
      var parent = qxWidget;
      while( parent != null && !( this.isControl( parent ) && parent.getEnabled() ) ) {
        parent = parent.getParent ? parent.getParent() : null;
      }
      return parent;
    },

    ////////////////////
    // ToolTip handling

    /**
     * Sets the toolTipText for the given widget. An empty or null toolTipText
     * removes the tool tip of the widget.
     */
    setToolTip : function( widget, toolTipText ) {
      rwt.widgets.base.WidgetToolTip.setToolTipText( widget, toolTipText );
    },

    _removeToolTipPopup : function( widget ) {
      widget.setToolTipText( null );
    }

  }
} );

/*******************************************************************************
 * Copyright (c) 2011, 2015 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

(function() {

namespace( "rwt.remote" );

var paused = false;
var pendingMessage = null;

rwt.remote.MessageProcessor = {

  processMessage : function( messageObject, callback, startOffset ) {
    var offset = 0;
    if( typeof startOffset !== "undefined" ) {
      offset = startOffset;
    }
    if( offset === 0 ) {
      rap._.notify("receive", messageObject );
      this.processHead( messageObject.head );
    }
    var operations = messageObject.operations;
    while( offset < operations.length ) {
      this.processOperationArray( operations[ offset ] );
      offset++;
      if( paused ) {
        this._suspendMessageProcessing( messageObject, callback, offset );
        return;
      }
    }
    rap._.notify("process", messageObject );
    if( callback ) {
      callback();
    }
  },

  processHead : function( head ) {
    var connection = rwt.remote.Connection.getInstance();
    if( head.url ) {
      connection.setUrl( head.url );
    }
    if( head.cid ) {
      connection.setConnectionId( head.cid );
    }
    if( head.redirect ) {
      rwt.widgets.Display.getCurrent().setExitConfirmation( null );
      document.location = head.redirect;
    }
  },

  processOperationArray : function( operation ) {
    var action = operation[ 0 ];
    try {
      switch( action ) {
        case "create":
          this._processCreate( operation[ 1 ], operation[ 2 ], operation[ 3 ] );
        break;
        case "set":
          this._processSet( operation[ 1 ], operation[ 2 ] );
        break;
        case "listen":
          this._processListen( operation[ 1 ], operation[ 2 ] );
        break;
        case "call":
          this._processCall( operation[ 1 ], operation[ 2 ], operation[ 3 ] );
        break;
        case "destroy":
          this._processDestroy( operation[ 1 ] );
        break;
      }
    } catch( ex ) {
      this._processError( ex, operation );
    }
  },

  processOperation : function( operation ) {
    switch( operation.action ) {
      case "create":
        this._processCreate( operation.target, operation.type, operation.properties );
      break;
      case "set":
        this._processSet( operation.target, operation.properties );
      break;
      case "destroy":
        this._processDestroy( operation.target );
      break;
      case "call":
        this._processCall( operation.target, operation.method, operation.properties );
      break;
      case "listen":
        this._processListen( operation.target, operation.properties );
      break;
    }
  },

  pauseExecution : function() {
    paused = true;
  },

  isPaused : function() {
    return paused;
  },

  continueExecution : function() {
    paused = false;
    var resumingMessage = pendingMessage;
    pendingMessage = null;
    this.processMessage.apply( this, resumingMessage );
  },

  ////////////
  // Internals

  _processCreate : function( targetId, type, properties ) {
    var handler = rwt.remote.HandlerRegistry.getHandler( type );
    if( handler.service === true ) {
      throw new Error( "Objects of type " + type + " can not be created" );
    }
    var targetObject = handler.factory( properties );
    this._addTarget( targetObject, targetId, handler );
    this._processSetImpl( targetObject, handler, properties );
  },

  _processDestroy : function( targetId ) {
    var objectEntry = rwt.remote.ObjectRegistry.getEntry( targetId );
    var handler = objectEntry.handler;
    var targetObject = objectEntry.object;
    var children =   handler.getDestroyableChildren
                   ? handler.getDestroyableChildren( targetObject )
                   : null;
    if( handler.destructor instanceof Function ) {
      handler.destructor( targetObject );
    } else if( typeof handler.destructor === "string" ) {
      var destructorName = handler.destructor;
      targetObject[ destructorName ]();
    }
    rwt.remote.ObjectRegistry.remove( targetId );
    rwt.remote.RemoteObjectFactory.remove( targetId );
    for( var i = 0; children != null && i < children.length; i++ ) {
      if( children[ i ] ) {
        this._processDestroy( rwt.remote.ObjectRegistry.getId( children[ i ] ) );
      }
    }
  },

  _processSet : function( targetId, properties ) {
    var objectEntry = rwt.remote.ObjectRegistry.getEntry( targetId );
    this._processSetImpl( objectEntry.object, objectEntry.handler, properties );
  },

  _processSetImpl : function( targetObject, handler, properties ) {
    if( handler.isGeneric && !rwt.util.Objects.isEmpty( properties ) ) {
      targetObject.set( properties, { "nosync" : true } );
    } else if( properties && handler.properties instanceof Array ) {
      for( var i = 0; i < handler.properties.length; i++ ) {
        var property = handler.properties [ i ];
        var value = properties[ property ];
        if( value !== undefined ) {
          if( handler.propertyHandler && handler.propertyHandler[ property ] ) {
            handler.propertyHandler[ property ].call( window, targetObject, value );
          } else {
            var setterName = this._getSetterName( property );
            targetObject[ setterName ]( value );
          }
        }
      }
    }
  },

  _processCall : function( targetId, method, properties ) {
    var objectEntry = rwt.remote.ObjectRegistry.getEntry( targetId );
    var handler = objectEntry.handler;
    var targetObject = objectEntry.object;
    if( handler.isGeneric ) {
      targetObject[ method ]( properties );
    } else if( handler.methods instanceof Array && handler.methods.indexOf( method ) !== -1 ) {
      if( handler.methodHandler && handler.methodHandler[ method ] ) {
        handler.methodHandler[ method ]( targetObject, properties );
      } else {
        targetObject[ method ]( properties );
      }
    }
  },

  _processListen : function( targetId, properties ) {
    var objectEntry = rwt.remote.ObjectRegistry.getEntry( targetId );
    var handler = objectEntry.handler;
    var targetObject = objectEntry.object;
    if( handler.events instanceof Array || handler.isGeneric ) {
      var remoteObject = rwt.remote.RemoteObjectFactory.getRemoteObject( targetObject );
      var events = handler.isGeneric ? rwt.util.Objects.getKeys( properties ) : handler.events;
      for( var i = 0; i < events.length; i++ ) {
        var type = events[ i ];
        if( properties[ type ] === true ) {
          remoteObject._.listen[ type ] = true;
        } if( properties[ type ] === false ) {
          remoteObject._.listen[ type ] = false;
        }
      }
    }
    if( handler.listeners instanceof Array ) {
      for( var i = 0; i < handler.listeners.length; i++ ) {
        var type = handler.listeners[ i ];
        if( properties[ type ] === true ) {
          this._addListener( handler, targetObject, type );
        } if( properties[ type ] === false ) {
          this._removeListener( handler, targetObject, type );
        }
      }
    }
  },

  ////////////
  // Internals

  _processError : function( error, operation ) {
    var errorstr;
    if( error ) {
      errorstr = error.message ? error.message : error.toString();
    } else {
      errorstr = "No Error given!";
    }
    var msg = "Operation \"" + operation[ 0 ] + "\"";
    msg += " on target \"" +  operation[ 1 ] + "\"";
    var objectEntry = rwt.remote.ObjectRegistry.getEntry( operation[ 1 ] );
    var target = objectEntry ? objectEntry.object : null;
    msg += " of type \"" +  ( target && target.classname ? target.classname : target ) + "\"";
    msg += " failed:";
    msg += "\n" + errorstr +"\n";
    msg += "Properties: \n" + this._getPropertiesString( operation );
    throw new Error( msg );
  },

  _getPropertiesString : function( operation ) {
    var result = "";
    var properties;
    switch( operation[ 0 ] ) {
      case "set":
      case "listen":
        properties = operation[ 2 ];
      break;
      case "create":
      case "call":
        properties = operation[ 3 ];
      break;
      default:
        properties = {};
      break;
    }
    for( var key in properties ) {
      result += key + " = " + properties[ key ] + "\n";
    }
    return result;
  },

  _addTarget : function( target, targetId, handler ) {
    if( target instanceof rwt.widgets.base.Widget ) {
      // TODO [tb] : remove WidgetManager and then this if
      var widgetManager = rwt.remote.WidgetManager.getInstance();
      widgetManager.add( target, targetId, false, handler ); // uses ObjectManager internally
    } else {
      rwt.remote.ObjectRegistry.add( targetId, target, handler );
    }
  },

  _addListener : function( handler, targetObject, eventType ) {
    if( handler.listenerHandler &&  handler.listenerHandler[ eventType ] ) {
      handler.listenerHandler[ eventType ]( targetObject, true );
    } else {
      var setterName = this._getListenerSetterName( eventType );
      targetObject[ setterName ]( true );
    }
  },

  _removeListener : function( handler, targetObject, eventType ) {
    if( handler.listenerHandler &&  handler.listenerHandler[ eventType ] ) {
      handler.listenerHandler[ eventType ]( targetObject, false );
    } else {
      var setterName = this._getListenerSetterName( eventType );
      targetObject[ setterName ]( false );
    }
  },

  _getSetterName : function( property ) {
    return "set" + rwt.util.Strings.toFirstUp( property );
  },

  _getListenerSetterName : function( eventType ) {
    return "setHas" + rwt.util.Strings.toFirstUp( eventType ) + "Listener";
  },

  _suspendMessageProcessing : function( message, callback, offset ) {
    if( pendingMessage != null ) {
      throw new Error( "A message is already suspended" );
    }
    pendingMessage = [ message, callback, offset ];
  }


};

}() );

/*******************************************************************************
 * Copyright (c) 2012, 2013 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

namespace( "rwt.remote" );

rwt.remote.MessageWriter = function() {
  this._head = {};
  this._operations = [];
  this._currentSetOperation = null;
  this._disposed = false;
};

rwt.remote.MessageWriter.prototype = {

    dispose : function() {
      this._operations = null;
      this._head = null;
      this._disposed = true;
    },

    hasOperations : function() {
      return this._operations.length > 0;
    },

    createMessage : function() {
      if( this._disposed ) {
        throw new Error( "Protocol message writer already disposed!" );
      }
      var message = {
        "head" : this._head,
        "operations" : this._operations
      };
      return JSON.stringify( message );
    },

    appendHead : function( property, value ) {
      this._head[ property ] = value;
    },

    getHead : function( property ) {
      return this._head[ property ] || null;
    },

    appendSet : function( targetId, property, value ) {
      var properties = this._getPropertiesObjectFor( targetId );
      properties[ property ] = value;
    },

    appendNotify : function( targetId, eventName, properties ) {
      this._currentSetOperation = null;
      this._operations.push( [ "notify", targetId, eventName, properties ] );
    },

    appendCall : function( targetId, methodName, properties ) {
      this._currentSetOperation = null;
      this._operations.push( [ "call", targetId, methodName, properties ] );
    },

    _getPropertiesObjectFor : function( targetId ) {
      if( this._currentSetOperation === null || this._currentSetOperation[ 1 ] !== targetId ) {
        this._currentSetOperation = [ "set", targetId, {} ];
        this._operations.push( this._currentSetOperation );
      }
      return this._currentSetOperation[ 2 ];
    }

};

/*******************************************************************************
 * Copyright (c) 2011, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

namespace( "rwt.client" );

rwt.client.ServerPush = function() {
  this._retryCount = 0;
  this._active = false;
  this._running = false;
  this._requestTimer = new rwt.client.Timer( 0 );
  this._requestTimer.addEventListener( "interval", this._doSendServerPushRequest, this );
};

rwt.client.ServerPush.getInstance = function() {
  return rwt.runtime.Singletons.get( rwt.client.ServerPush );
};

rwt.client.ServerPush.prototype = {

  setActive : function( active ) {
    this._active = active;
  },

  sendServerPushRequest : function() {
    if( this._active && !this._running ) {
      this._running = true;
      this._requestTimer.start();
    }
  },

  // workaround for bug 353819 - send ServerPushRequest with a timer
  _doSendServerPushRequest : function() {
    this._requestTimer.stop();
    this._createRequest().send();
  },

  _createRequest : function() {
    var connection = rwt.remote.Connection.getInstance();
    var request = new rwt.remote.Request( connection.getUrl(), "GET", "application/javascript" );
    request.setSuccessHandler( this._handleSuccess, this );
    request.setErrorHandler( this._handleError, this );
    request.setData( "servicehandler=org.eclipse.rap.serverpush&cid=" + connection.getConnectionId() );
    return request;
  },

  _handleSuccess : function() {
    this._running = false;
    this._retryCount = 0;
    this._sendUIRequest();
  },

  _sendUIRequest : function() {
    rwt.remote.Connection.getInstance().sendImmediate( true );
  },

  _handleError : function( event ) {
    this._running = false;
    if( rwt.remote.Connection.getInstance()._isConnectionError( event.status ) ) {
      if( this._retryCount < 3 ) {
        var delay = 1000 * this._retryCount++;
        rwt.client.Timer.once( this.sendServerPushRequest, this, delay );
      } else {
        this._handleConnectionError();
      }
    } else {
      this._handleServerError( event );
    }
  },

  _handleConnectionError : function() {
    rwt.remote.Connection.getInstance().sendImmediate( true );
  },

  _handleServerError : function( event ) {
    var text = event.responseText;
    if( text && text.length > 0 ) {
      rwt.runtime.ErrorHandler.showErrorPage( text );
    } else {
      rwt.runtime.ErrorHandler.showErrorBox( "request failed" );
    }
  }

};

/*******************************************************************************
 * Copyright (c) 2011, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.remote.HandlerRegistry.add( "rwt.client.ServerPush", {

  factory : function() {
    return rwt.client.ServerPush.getInstance();
  },

  service : true,

  properties : [
    "active"
  ]

} );

/*******************************************************************************
 * Copyright (c) 2002, 2015 Innoopract Informationssysteme GmbH and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Innoopract Informationssysteme GmbH - initial API and implementation
 *    EclipseSource - ongoing development
 ******************************************************************************/

(function() {

var Client = rwt.client.Client;
var Timer = rwt.client.Timer;
var Processor = rwt.remote.MessageProcessor;
var ErrorHandler = rwt.runtime.ErrorHandler;
var EventUtil = rwt.remote.EventUtil;
var ServerPush = rwt.client.ServerPush;
var ClientDocument = rwt.widgets.base.ClientDocument;
var Widget = rwt.widgets.base.Widget;

rwt.qx.Class.define( "rwt.remote.Connection", {

  extend : rwt.qx.Target,

  statics : {

    getInstance : function() {
      return rwt.runtime.Singletons.get( rwt.remote.Connection );
    }

  },

  construct : function() {
    this.base( arguments );
    this._url = "";
    this._writer = null;
    this._event = null;
    this._requestCounter = 0;
    this._requestPending = false;
    this._connectionId = null;
    this._sendTimer = new Timer( 60 );
    this._sendTimer.addEventListener( "interval", function() {
      this.sendImmediate( true );
     }, this );
    this._delayTimer = new Timer();
    this._delayTimer.addEventListener( "interval", function() {
      this._delayTimer.stop();
      this.send();
    }, this );
    this._waitHintTimer = new Timer( 1000 );
    this._waitHintTimer.addEventListener( "interval", this._showWaitHint, this );
    this._retryHandler = null;
    this._sendListeners = [];
  },

  destruct : function() {
    this._retryHandler = null;
    this._sendTimer.dispose();
    this._sendTimer = null;
    this._waitHintTimer.dispose();
    this._waitHintTimer = null;
  },

  members : {

    //////
    // API

    setUrl : function( url ) {
      this._url = url;
    },

    getUrl : function() {
      return this._url;
    },

    setConnectionId : function( connectionId ) {
      this._connectionId = connectionId;
    },

    getConnectionId : function() {
      return this._connectionId;
    },

    _flushEvent : function() {
      if( this._event ) {
        var writer = this.getMessageWriter();
        this._event[ 1 ] = this._event[ 1 ].split( "." ).pop();
        writer.appendNotify.apply( writer, this._event );
        this._event = null;
      }
    },

    sendDelayed : function( time ) {
      this._delayTimer.setInterval( time );
      this._delayTimer.start();
    },

    /**
     * Sends an asynchronous request within 60 milliseconds
     */
    send : function() {
      this._sendTimer.start();
    },

    /**
     * Sends an synchronous or asynchronous request immediately. All parameters that were added
     * since the last request will be sent.
     */
    sendImmediate : function( async ) {
      this._delayTimer.stop();
      if( this._requestPending && async ) {
        this._sendTimer.stop();
        this.send();
      } else {
        this._flushEvent();
        this.dispatchSimpleEvent( "send" );
        rap._.notify( "send" );
        this._flushEvent();
        this._sendTimer.stop();
        this.getMessageWriter().appendHead( "requestCounter", this._requestCounter++ );
        this._requestPending = true;
        this._startWaitHintTimer();
        var request = this._createRequest();
        request.setAsynchronous( async );
        request.setData( this.getMessageWriter().createMessage() );
        this._writer.dispose();
        this._writer = null;
        request.send();
        this._removeSendListeners();
      }
    },

    getMessageWriter : function() {
      if( this._writer === null ) {
        this._writer = new rwt.remote.MessageWriter();
      }
      return this._writer;
    },

    getRemoteObject : function( target ) {
      return rwt.remote.RemoteObjectFactory.getRemoteObject( target );
    },

    onNextSend : function( func, context ) {
      this._sendListeners.push( [ func, context ] );
      this.addEventListener( "send", func, context );
    },

    getWaitHintTimer : function() {
      return this._waitHintTimer;
    },

    _startWaitHintTimer : function() {
      if( this._requestCounter !== 0 ) {
        this._waitHintTimer.start();
      }
    },

    _removeSendListeners : function() {
      for( var i = 0; i < this._sendListeners.length; i++ ) {
        var item = this._sendListeners[ i ];
        this.removeEventListener( "send", item[ 0 ], item[ 1 ] );
      }
      this._sendListeners = [];
    },

    ////////////
    // Internals

    _createRequest : function() {
      var cid = "";
      if( this._connectionId ) {
        cid = ( this._url.indexOf( "?" ) === -1 ? "?cid=" : "&cid=" ) + this._connectionId;
      }
      var result = new rwt.remote.Request( this._url + cid, "POST", "application/json" );
      result.setSuccessHandler( this._handleSuccess, this );
      result.setErrorHandler( this._handleError, this );
      return result;
    },

    ////////////////////////
    // Handle request events

    _handleError : function( event ) {
      this._hideWaitHint();
      if( this._isConnectionError( event.status ) ) {
        this._handleConnectionError( event );
      } else {
        var text = event.responseText;
        if( text && text.length > 0 ) {
          if( this._isJsonResponse( event ) ) {
            var messageObject = JSON.parse( text );
            ErrorHandler.showErrorBox( messageObject.head.error, true );
          } else {
            ErrorHandler.showErrorPage( text );
          }
        } else {
          ErrorHandler.showErrorBox( "request failed" );
        }
      }
    },

    _handleSuccess : function( event ) {
      try {
        var messageObject = JSON.parse( event.responseText );
        rwt.remote.EventUtil.setSuspended( true );
        var that = this;
        Processor.processMessage( messageObject, function() {
          that._requestPending = false;
          Widget.flushGlobalQueues();
          rap._.notify( "render" );
          EventUtil.setSuspended( false );
          ServerPush.getInstance().sendServerPushRequest();
          that.dispatchSimpleEvent( "received" );
          that._hideWaitHint();
        } );
      } catch( ex ) {
        ErrorHandler.processJavaScriptErrorInResponse( event.responseText, ex, event.target );
        this._hideWaitHint();
      }
    },

    ///////////////////////////////
    // Handling connection problems

    _handleConnectionError : function( event ) {
      ClientDocument.getInstance().setGlobalCursor( null );
      rwt.runtime.ErrorHandler.showErrorBox( "connection error", false );
      this._retryHandler = function() {
        var request = this._createRequest();
        var failedRequest = event.target;
        request.setAsynchronous( failedRequest.getAsynchronous() );
        request.setData( failedRequest.getData() );
        request.send();
      };
    },

    _retry : function() {
      try {
        ErrorHandler.hideErrorBox();
        this._showWaitHint();
        this._retryHandler();
      } catch( ex ) {
        rwt.runtime.ErrorHandler.processJavaScriptError( ex );
      }
    },

    _isConnectionError : rwt.util.Variant.select( "qx.client", {
      "trident" : function( statusCode ) {
        // for a description of the IE status codes, see
        // http://support.microsoft.com/kb/193625
        // Some modern IEs use standard, but not all
        return (    statusCode === 12007    // ERROR_INTERNET_NAME_NOT_RESOLVED
                 || statusCode === 12029    // ERROR_INTERNET_CANNOT_CONNECT
                 || statusCode === 12030    // ERROR_INTERNET_CONNECTION_ABORTED
                 || statusCode === 12031    // ERROR_INTERNET_CONNECTION_RESET
                 || statusCode === 12152    // ERROR_HTTP_INVALID_SERVER_RESPONSE
                 || statusCode === 0 );
      },
      "gecko" : function( statusCode ) {
        // Firefox 3 reports other statusCode than oder versions (bug #249814)
        var result;
        // Check if Gecko > 1.9 is running (used in FF 3)
        // Gecko/app integration overview: http://developer.mozilla.org/en/Gecko
        if( Client.getMajor() * 10 + Client.getMinor() >= 19 ) {
          result = ( statusCode === 0 );
        } else {
          result = ( statusCode === -1 );
        }
        return result;
      },
      "default" : function( statusCode ) {
        return statusCode === 0;
      }
    } ),

    _isJsonResponse : function( event ) {
      var contentType = event.responseHeaders[ "Content-Type" ];
      return contentType.indexOf( "application/json" ) !== -1;
    },

    ///////////////////////////////////////////////////
    // Wait hint - UI feedback while request is running

    _showWaitHint : function() {
      this._waitHintTimer.stop();
      ClientDocument.getInstance().setGlobalCursor( "progress" );
      ErrorHandler.showWaitHint();
    },

    _hideWaitHint : function() {
      this._waitHintTimer.stop();
      ErrorHandler.hideErrorBox();
      ClientDocument.getInstance().setGlobalCursor( null );
    }

  }
} );

}());

/**
 * Path that points to the "resources/resource" path in the bundle. Files
 * must be registered in ClientResources.java.
 */
rwt.remote.Connection.RESOURCE_PATH = "./rwt-resources/resource/";

/*******************************************************************************
 * Copyright (c) 2002, 2014 Innoopract Informationssysteme GmbH and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Innoopract Informationssysteme GmbH - initial API and implementation
 *    EclipseSource - ongoing development
 ******************************************************************************/

rwt.qx.Class.define( "rwt.widgets.CTabItem", {

  extend : rwt.widgets.base.MultiCellWidget,

  construct : function( parent, canClose ) {
    this.base( arguments, [ "image", "label", "image" ] );
    this._parent = parent;
    // TODO [rst] change when a proper state inheritance concept exists
    if( parent.hasState( "rwt_BORDER" ) ) {
      this.addState( "rwt_BORDER" );
    }
    this.setAppearance( "ctab-item" );
    this.setVerticalChildrenAlign( rwt.widgets.util.Layout.ALIGN_MIDDLE );
    this.setHorizontalChildrenAlign( rwt.widgets.util.Layout.ALIGN_LEFT );
    this.setOverflow( "hidden" );
    this.setTabIndex( null );
    this._selected = false;
    this._showClose = false;
    this._rawText = null;
    this._mnemonicIndex = null;
    this._canClose = canClose;
    this.updateForeground();
    this.updateBackground();
    this.updateBackgroundImage();
    this.updateBackgroundGradient();
    this.setTabPosition( parent.getTabPosition() );
    this.updateCloseButton( false );
    this.addEventListener( "elementOver", this._onElementOver, this );
    this.addEventListener( "elementOut", this._onElementOut, this );
    this.addEventListener( "click", this._onClick, this );
    this.addEventListener( "dblclick", this._onDblClick, this );
    this.addEventListener( "changeParent", this._onChangeParent, this );
    this.addEventListener( "changeLeft", this._onChangeLeft, this );
  },

  destruct : function() {
    this.setMnemonicIndex( null );
  },

  statics : {

    IMG_CLOSE : rwt.remote.Connection.RESOURCE_PATH + "widget/rap/ctabfolder/close.gif",
    IMG_CLOSE_HOVER : rwt.remote.Connection.RESOURCE_PATH + "widget/rap/ctabfolder/close_hover.gif"

  },

  members : {

    setText : function( value ) {
      this._rawText = value;
      this._mnemonicIndex = null;
      this._applyText( false );
    },

    setImage : function( value ) {
      if( value === null ) {
        this.setCellContent( 0, null );
        this.setCellDimension( 0, 0, 0 );
      } else {
        this.setCellContent( 0, value[ 0 ] );
        this.setCellDimension( 0, value[ 1 ], value[ 2 ] );
      }
    },

    setMnemonicIndex : function( value ) {
      this._mnemonicIndex = value;
      var mnemonicHandler = rwt.widgets.util.MnemonicHandler.getInstance();
      if( ( typeof value === "number" ) && ( value >= 0 ) ) {
        mnemonicHandler.add( this, this._onMnemonic );
      } else {
        mnemonicHandler.remove( this );
      }
    },

    getMnemonicIndex : function() {
      return this._mnemonicIndex;
    },

    _applyText : function( mnemonic ) {
      if( this._rawText ) {
        var mnemonicIndex = mnemonic ? this._mnemonicIndex : undefined;
        var text = rwt.util.Encoding.escapeText( this._rawText, mnemonicIndex );
        this.setCellContent( 1, text );
      } else {
        this.setCellContent( 1, null );
      }
    },

    setTabPosition : function( tabPosition ) {
      this.toggleState( "barTop", tabPosition === "top" );
    },

    setSelected : function( selected ) {
      if( this._selected !== selected ) {
        this._selected = selected;
        this.toggleState( "selected", selected );
        this._updateNextSelected();
        this.updateForeground();
        this.updateBackground();
        this.updateBackgroundImage();
        this.updateBackgroundGradient();
        this.updateCloseButton( false );
      }
    },

    _onMnemonic : function( event ) {
      switch( event.type ) {
        case "show":
          this._applyText( true );
        break;
        case "hide":
          this._applyText( false );
        break;
        case "trigger":
          var charCode = this._rawText.toUpperCase().charCodeAt( this._mnemonicIndex );
          if( event.charCode === charCode ) {
            this._parent._notifySelection( this );
            event.success = true;
          }
        break;
      }
    },

    _updateNextSelected : function() {
      var prevItem = null;
      var children = this._parent.getChildren();
      for( var i = 0; i < children.length; i++ ) {
        if( children[ i ].classname === "rwt.widgets.CTabItem" ) {
          children[ i ].removeState( "nextSelected" );
          if( prevItem != null && children[ i ].isSelected() ) {
            prevItem.addState( "nextSelected" );
          }
          prevItem = children[ i ];
        }
      }
    },

    isSelected : function() {
      return this._selected;
    },

    setShowClose : function( value ) {
      this._showClose = value;
      this.updateCloseButton( false );
    },

    updateForeground : function() {
      var color = this.isSelected()
                ? this._parent.getSelectionForeground()
                : this._parent.getTextColor();
      if( color != null ) {
        this.setTextColor( color );
      } else {
        this.resetTextColor();
      }
    },

    updateBackground : function() {
      var color = this.isSelected() ? this._parent.getSelectionBackground() : null;
      if( color != null ) {
        this.setBackgroundColor( color );
      } else {
        this.resetBackgroundColor();
      }
    },

    updateBackgroundImage : function() {
      var image = this.isSelected() ? this._parent.getSelectionBackgroundImage() : null;
      if( image != null ) {
        this.setUserData( "backgroundImageSize", image.slice( 1 ) );
        this.setBackgroundImage( image[ 0 ] );
      } else {
        this.resetBackgroundImage();
      }
    },

    updateBackgroundGradient : function() {
      var gradient = this.isSelected() ? this._parent.getSelectionBackgroundGradient() : null;
      if( gradient != null ) {
        this.setBackgroundGradient( gradient );
      } else {
        this.resetBackgroundGradient();
      }
    },

    _onElementOver : function( event ) {
      this.addState( "over" );
      this.updateCloseButton( this._isCloseButtonTarget( event ) );
    },

    _onElementOut : function( event ) {
      if( event.getDomTarget() === this.getElement() ) {
        this.removeState( "over" );
      }
      this.updateCloseButton( false );
    },

    updateCloseButton : function( over ) {
      var visible = false;
      if( this._canClose || this._showClose ) {
        var unselectedVisible = this._parent.getUnselectedCloseVisible() && this.hasState( "over" );
        visible = this.isSelected() || unselectedVisible;
      }
      if( visible ) {
        var image = over ? rwt.widgets.CTabItem.IMG_CLOSE_HOVER : rwt.widgets.CTabItem.IMG_CLOSE;
        this.setCellContent( 2, image );
        this.setCellDimension( 2, 16, 16 );
      } else {
        this.setCellContent( 2, null );
        this.setCellDimension( 2, 0, 0 );
      }
    },

    _onClick : function( event ) {
      if( this._isCloseButtonTarget( event ) ) {
        rwt.remote.Connection.getInstance().getRemoteObject( this._parent ).notify( "Folder", {
          "detail" : "close",
          "item" : rwt.remote.ObjectRegistry.getId( this )
        } );
      } else {
        this._parent._notifySelection( this );
      }
    },

    _onDblClick : function( event ) {
      if( !this._isCloseButtonTarget( event ) ) {
        this._parent._notifyDefaultSelection( this );
      }
    },

    _isCloseButtonTarget : function( event ) {
      return event.getDomTarget() === this.getCellNode( 2 );
    },

    _onChangeParent : function() {
      if( !this._parent._isInGlobalDisposeQueue ) {
        this._updateNextSelected();
      }
    },

    _onChangeLeft : function() {
      this.toggleState( "firstItem", this.getLeft() === 0 );
    }
  }
} );

/*******************************************************************************
 * Copyright (c) 2011, 2015 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.remote.HandlerRegistry.add( "rwt.widgets.CTabItem", {

  factory : function( properties ) {
    var result;
    rwt.remote.HandlerUtil.callWithTarget( properties.parent, function( parent ) {
      result = new rwt.widgets.CTabItem( parent, parent.hasState( "rwt_CLOSE" ) );
      parent.addAt( result, properties.index );
      rwt.remote.HandlerUtil.addStatesForStyles( result, properties.style );
      rwt.remote.HandlerUtil.addDestroyableChild( parent, result );
      result.setUserData( "protocolParent", parent );
    } );
    return result;
  },

  destructor : rwt.remote.HandlerUtil.getWidgetDestructor(),

  properties : [
    "bounds",
    "font",
    "text",
    "mnemonicIndex",
    "image",
    "toolTipMarkupEnabled",
    "toolTip",
    "customVariant",
    "showing",
    "showClose",
    "data"
  ],

  propertyHandler : {
    "data" : rwt.remote.HandlerUtil.getControlPropertyHandler( "data" ),
    "bounds" : function( widget, value ) {
      var bounds = value;
      if( widget.getParent().getTabPosition() === "bottom" ) {
        bounds[ 1 ] -= 1;
      }
      bounds[ 3 ] += 1;
      widget.setLeft( bounds[ 0 ] );
      widget.setTop( bounds[ 1 ] );
      widget.setWidth( bounds[ 2 ] );
      widget.setHeight( bounds[ 3 ] );
    },
    "font" : rwt.remote.HandlerUtil.getControlPropertyHandler( "font" ),
    "toolTipMarkupEnabled" : rwt.remote.HandlerUtil.getControlPropertyHandler( "toolTipMarkupEnabled" ),
    "toolTip" : rwt.remote.HandlerUtil.getControlPropertyHandler( "toolTip" ),
    "showing" : function( widget, value ) {
      widget.setVisibility( value );
    }
  }

} );

/*******************************************************************************
 * Copyright (c) 2002, 2014 Innoopract Informationssysteme GmbH.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Innoopract Informationssysteme GmbH - initial API and implementation
 *    EclipseSource - ongoing development
 ******************************************************************************/

rwt.qx.Class.define( "rwt.widgets.CTabFolder", {
  extend : rwt.widgets.base.Parent,

  construct : function() {
    this.base( arguments );
    this.setTabIndex( 1 );
    this.setHideFocus( true );
    this.setAppearance( "ctabfolder" );
    this.setOverflow( "hidden" );
    this._tabPosition = "top";
    this._tabHeight = 0;
    this._selectionForeground = null;
    this._selectionBackground = null;
    this._selectionBackgroundImage = null;
    this._selectionBackgroundGradient = null;
    this._chevron = null;
    this._chevronBounds = [ 0, 0, 0, 0 ];
    this._chevronMenu = null;
    this._unselectedCloseVisible = true;
    // Minimize/maximize buttons, initially non-existing
    this._minMaxState = "normal";  // valid states: min, max, normal
    this._maxButton = null;
    this._maxButtonBounds = [ 0, 0, 0, 0 ];
    this._minButton = null;
    this._minButtonBounds = [ 0, 0, 0, 0 ];
    this._body = new rwt.widgets.base.Parent();
    this._body.addState( "barTop" );
    this._body.setAppearance( "ctabfolder-body" );
    this.add( this._body );
    this._separator = new rwt.widgets.base.Parent();
    this._separator.setAppearance( "ctabfolder-separator" );
    this.add( this._separator );
    this._frame = new rwt.widgets.base.Parent();
    this._frame.setAppearance( "ctabfolder-frame" );
    this.add( this._frame );
    this._frameBorder = new rwt.html.Border( 2, "solid", "black" );

    // Create horizontal line that separates the button bar from the rest of
    // the client area
    // Add resize listeners to update selection border (this._highlightXXX)
    this.addEventListener( "changeWidth", this._updateLayout, this );
    this.addEventListener( "changeHeight", this._updateLayout, this );
    // Add keypress listener to select items with left/right keys
    this.addEventListener( "keypress", this._onKeyPress, this );
    this.addEventListener( "contextmenu", this._onContextMenu, this );
  },

  destruct : function() {
    // use hideMin/MaxButton to dispose of toolTips
    this.hideMinButton();
    this.hideMaxButton();
    this.removeEventListener( "changeWidth", this._updateLayout, this );
    this.removeEventListener( "changeHeight", this._updateLayout, this );
    this.removeEventListener( "keypress", this._onKeyPress, this );
    this.removeEventListener( "contextmenu", this._onContextMenu, this );
    this._disposeObjects( "_frame", "_separator" );
    this._frameBorder.dispose();
  },

  statics : {
    BUTTON_SIZE : 18,

    MIN_TOOLTIP : "Minimize",
    MAX_TOOLTIP : "Maximize",
    RESTORE_TOOLTIP : "Restore",
    CHEVRON_TOOLTIP : "Show List",
    CLOSE_TOOLTIP : "Close",

    setToolTipTexts : function( min, max, restore, chevron, close ) {
      rwt.widgets.CTabFolder.MIN_TOOLTIP = min;
      rwt.widgets.CTabFolder.MAX_TOOLTIP = max;
      rwt.widgets.CTabFolder.RESTORE_TOOLTIP = restore;
      rwt.widgets.CTabFolder.CHEVRON_TOOLTIP = chevron;
      rwt.widgets.CTabFolder.CLOSE_TOOLTIP = close;
    }
  },

  members : {

    addState : function( state ) {
      this.base( arguments, state );
      if( state.substr( 0, 8 ) == "variant_" || state.substr( 0, 4 ) == "rwt_" ) {
        this._body.addState( state );
        this._frame.addState( state );
        this._mapItems( function( item ) {
          item.addState( state );
        } );
      }
    },

    removeState : function( state ) {
      this.base( arguments, state );
      if( state.substr( 0, 8 ) == "variant_" || state.substr( 0, 4 ) == "rwt_" ) {
        this._body.removeState( state );
        this._frame.removeState( state );
        this._mapItems( function( item ) {
          item.removeState( state );
        } );
      }
    },

    /* valid values: "top", "bottom" */
    setTabPosition : function( tabPosition ) {
      this._tabPosition = tabPosition;
      this._mapItems( function( item ) {
        item.setTabPosition( tabPosition );
      } );
      this._body.toggleState( "barTop", tabPosition == "top" );
      this._updateLayout();
    },

    /* returns one of: "top", "bottom" */
    getTabPosition : function() {
      return this._tabPosition;
    },

    setTabHeight : function( tabHeight ) {
      this._tabHeight = tabHeight;
      var buttonTop = this._getButtonTop();
      if( this._minButton != null ) {
        this._minButton.setTop( buttonTop );
      }
      if( this._maxButton != null ) {
        this._maxButton.setTop( buttonTop );
      }
      if( this._chevron != null ) {
        this._chevron.setTop( buttonTop );
      }
      this._updateLayout();
    },

    _applyTextColor : function( value, old ) {
      this.base( arguments, value, old );
      this._mapItems( function( item ) {
        item.updateForeground();
      } );
    },

    _applyBackgroundColor : function( value ) {
      this._body.setBackgroundColor( value );
    },

    _applyBackgroundImage : function( value ) {
      this._body.setUserData( "backgroundImageSize", this.getUserData( "backgroundImageSize" ) );
      this._body.setBackgroundImage( value );
    },

    // transparent not supported, null resets color
    setSelectionForeground : function( color ) {
      this._selectionForeground = color;
      this._mapItems( function( item ) {
        item.updateForeground();
      } );
    },

    // transparent not supported, null resets color
    setSelectionBackground : function( color ) {
      this._selectionBackground = color;
      this._mapItems( function( item ) {
        item.updateBackground();
      } );
      if( color != null && !this.hasState( "rwt_FLAT" ) ) {
        this._frame.setBorder( null );
        this._frameBorder.dispose();
        this._frameBorder = new rwt.html.Border( 2, "solid", color );
        this._frame.setBorder( this._frameBorder );
      } else {
        this._frame.resetBorder();
      }
    },

    setSelectionBackgroundImage : function( image ) {
      this._selectionBackgroundImage = image;
      this._mapItems( function( item ) {
        item.updateBackgroundImage();
      } );
    },

    setSelectionBackgroundGradient : function( gradient ) {
      this._selectionBackgroundGradient = gradient;
      this._mapItems( function( item ) {
        item.updateBackgroundGradient();
      } );
    },

    setUnselectedCloseVisible : function( value ) {
      this._unselectedCloseVisible = value;
      this._mapItems( function( item ) {
        item.updateCloseButton();
      } );
    },

    setBorderVisible : function( visible ) {
      this.toggleState( "rwt_BORDER", visible );
      this._updateLayout();
    },

    getSelectionForeground : function() {
      return this._selectionForeground;
    },

    getSelectionBackground : function() {
      return this._selectionBackground;
    },

    getSelectionBackgroundImage : function() {
      return this._selectionBackgroundImage;
    },

    getSelectionBackgroundGradient : function() {
      return this._selectionBackgroundGradient;
    },

    getUnselectedCloseVisible : function() {
      return this._unselectedCloseVisible;
    },

    _mapItems : function( func ) {
      var children = this.getChildren();
      for( var i = 0; i < children.length; i++ ) {
        if( children[ i ].classname === "rwt.widgets.CTabItem" ) {
          func( children[ i ] );
        }
      }
    },

    _getButtonTop : function() {
      return ( this._tabHeight / 2 ) - ( rwt.widgets.CTabFolder.BUTTON_SIZE / 2 );
    },

    setChevronBounds : function( left, top, width, height ) {
      this._chevronBounds = [ left, top, width, height ];
      if( this._chevron != null ) {
        this._chevron.setSpace( left, width, top, height );
      }
    },

    showChevron : function() {
      if( this._chevron == null ) {
        // Create chevron button
        this._chevron = new rwt.widgets.base.BasicButton( "push", true );
        this._chevron.setAppearance( "ctabfolder-drop-down-button" );
        this._chevron.addEventListener( "execute", this._onChevronExecute, this );
        var wm = rwt.remote.WidgetManager.getInstance();
        wm.setToolTip( this._chevron, rwt.widgets.CTabFolder.CHEVRON_TOOLTIP );
        this.add( this._chevron );
      }
      this._chevron.setLeft( this._chevronBounds[ 0 ] );
      this._chevron.setTop( this._chevronBounds[ 1 ] );
      this._chevron.setWidth( this._chevronBounds[ 2 ] );
      this._chevron.setHeight( this._chevronBounds[ 3 ] );
    },

    hideChevron : function() {
      if( this._chevron != null ) {
        var wm = rwt.remote.WidgetManager.getInstance();
        wm.setToolTip( this._chevron, null );
        this._chevron.removeEventListener( "execute", this._onChevronExecute, this );
        this.remove( this._chevron );
        this._chevron.dispose();
        this._chevron = null;
      }
    },

    setMinMaxState : function( state ) {
      this._minMaxState = state;
      var minIcon = [ null, 10, 10 ];
      var maxIcon = [ null, 10, 10 ];
      var minToolTip = "";
      var maxToolTip = "";
      var path = rwt.remote.Connection.RESOURCE_PATH + "widget/rap/ctabfolder/";
      switch( state ) {
        case "min":
          minIcon[ 0 ] = path + "restore.gif";
          maxIcon[ 0 ] = path + "maximize.gif";
          minToolTip = rwt.widgets.CTabFolder.RESTORE_TOOLTIP;
          maxToolTip = rwt.widgets.CTabFolder.MAX_TOOLTIP;
          break;
        case "max":
          minIcon[ 0 ] = path + "minimize.gif";
          maxIcon[ 0 ] = path + "restore.gif";
          minToolTip = rwt.widgets.CTabFolder.MIN_TOOLTIP;
          maxToolTip = rwt.widgets.CTabFolder.RESTORE_TOOLTIP;
          break;
        case "normal":
          minIcon[ 0 ] = path + "minimize.gif";
          maxIcon[ 0 ] = path + "maximize.gif";
          minToolTip = rwt.widgets.CTabFolder.MIN_TOOLTIP;
          maxToolTip = rwt.widgets.CTabFolder.MAX_TOOLTIP;
          break;
      }
      var wm = rwt.remote.WidgetManager.getInstance();
      if( this._minButton != null ) {
        this._minButton.setIcon( minIcon );
        wm.setToolTip( this._minButton, minToolTip );
      }
      if( this._maxButton != null ) {
        this._maxButton.setIcon( maxIcon );
        wm.setToolTip( this._maxButton, maxToolTip );
      }
    },

    setMaxButtonBounds : function( left, top, width, height ) {
      this._maxButtonBounds = [ left, top, width, height ];
      if( this._maxButton != null ) {
        this._maxButton.setSpace( left, width, top, height );
      }
    },

    showMaxButton : function() {
      if( this._maxButton == null ) {
        this._maxButton = new rwt.widgets.base.BasicButton( "push", true );
        this._maxButton.setAppearance( "ctabfolder-button" );
        this.setMinMaxState( this._minMaxState );  // initializes the icon according to current state
        // [if] "mousedown" is used instead of "execute" because of the bug 247672
        this._maxButton.addEventListener( "mousedown", this._onMinMaxExecute, this );
        this.add( this._maxButton );
      }
      this._maxButton.setLeft( this._maxButtonBounds[ 0 ] );
      this._maxButton.setTop( this._maxButtonBounds[ 1 ] );
      this._maxButton.setWidth( this._maxButtonBounds[ 2 ] );
      this._maxButton.setHeight( this._maxButtonBounds[ 3 ] );
    },

    hideMaxButton : function() {
      if( this._maxButton != null ) {
        this._maxButton.removeEventListener( "mousedown", this._onMinMaxExecute, this );
        var wm = rwt.remote.WidgetManager.getInstance();
        wm.setToolTip( this._maxButton, null );
        this.remove( this._maxButton );
        this._maxButton.dispose();
        this._maxButton = null;
      }
    },

    setMinButtonBounds : function( left, top, width, height ) {
      this._minButtonBounds = [ left, top, width, height ];
      if( this._minButton != null ) {
        this._minButton.setSpace( left, width, top, height );
      }
    },

    showMinButton : function() {
      if( this._minButton == null ) {
        this._minButton = new rwt.widgets.base.BasicButton( "push", true );
        this._minButton.setAppearance( "ctabfolder-button" );
        this.setMinMaxState( this._minMaxState );  // initializes the icon according to current state
        // [if] "mousedown" is used instead of "execute" because of the bug 247672
        this._minButton.addEventListener( "mousedown", this._onMinMaxExecute, this );
        this.add( this._minButton );
      }
      this._minButton.setLeft( this._minButtonBounds[ 0 ] );
      this._minButton.setTop( this._minButtonBounds[ 1 ] );
      this._minButton.setWidth( this._minButtonBounds[ 2 ] );
      this._minButton.setHeight( this._minButtonBounds[ 3 ] );
    },

    hideMinButton : function() {
      if( this._minButton != null ) {
        this._minButton.removeEventListener( "mousedown", this._onMinMaxExecute, this );
        var wm = rwt.remote.WidgetManager.getInstance();
        wm.setToolTip( this._minButton, null );
        this.remove( this._minButton );
        this._minButton.dispose();
        this._minButton = null;
      }
    },

    deselectAll : function() {
      this._mapItems( function( item ) {
        item.setSelected( false );
      } );
    },

    _updateLayout : function() {
      // TODO [rst] take actual border width into account
      var borderWidth = this.hasState( "rwt_BORDER" ) ? 1 : 0;
      var sepBorderWidth = 1;
      var width = this.getWidth() - borderWidth * 2;
      var tabHeight = this._tabHeight + 1;

      this._body.setLeft( 0 );
      this._body.setTop( 0 );
      this._body.setWidth( this.getWidth() );
      this._body.setHeight( this.getHeight() );

      this._separator.setLeft( borderWidth );
      this._separator.setWidth( width );
      this._separator.setHeight( 10 );

      this._frame.setLeft( borderWidth );
      this._frame.setWidth( width );
      this._frame.setHeight( this.getHeight() - borderWidth - sepBorderWidth - tabHeight );

      if( this._tabPosition == "top" ) {
        this._separator.setTop( tabHeight );
        this._frame.setTop( tabHeight + 1 );
      } else { // tabPosition == "bottom"
        this._separator.setTop( this.getHeight() - tabHeight - 1 );
        this._frame.setTop( borderWidth );
      }
    },

    _onChevronExecute : function() {
      if( this._chevronMenu == null || !this._chevronMenu.isSeeable() ) {
        if( !rwt.remote.EventUtil.getSuspended() ) {
          var server = rwt.remote.Connection.getInstance();
          server.getRemoteObject( this ).notify( "Folder", { "detail" : "showList" } );
        }
      }
    },

    _onMinMaxExecute : function( evt ) {
      if( !rwt.remote.EventUtil.getSuspended() ) {
        var detail;
        if ( evt.getTarget() == this._minButton ) {
          // Minimize button was pressed
          if( this._minMaxState == "min" ) {
            this.setMinMaxState( "normal" );
            detail = "restore";
          } else {
            this.setMinMaxState( "min" );
            detail = "minimize";
          }
        } else {
          // Maximize button was pressed
          if( this._minMaxState == "normal" || this._minMaxState == "min" ) {
            this.setMinMaxState( "max" );
            detail = "maximize";
          } else {
            this.setMinMaxState( "normal" );
            detail = "restore";
          }
        }
        var remoteObject = rwt.remote.Connection.getInstance().getRemoteObject( this );
        remoteObject.set( "minimized", this._minMaxState == "min" );
        remoteObject.set( "maximized", this._minMaxState == "max" );
        remoteObject.notify( "Folder", { "detail" : detail } );
      }
    },

    _onKeyPress : function( evt ) {
      switch( evt.getKeyIdentifier() ) {
        case "Left":
          // TODO [rh] implementation missing: select tab item to the left
          evt.stopPropagation();
          break;
        case "Right":
          // TODO [rh] implementation missing: select tab item to the right
          evt.stopPropagation();
          break;
      }
    },

    _onContextMenu : function( evt ) {
      var menu = this.getContextMenu();
      if( menu != null ) {
        menu.setLocation( evt.getPageX(), evt.getPageY() );
        menu.setOpener( this );
        menu.show();
        evt.stopPropagation();
      }
    },

    _notifySelection : function( item ) {
      if( !rwt.remote.EventUtil.getSuspended() ) {
        if( !item.isSelected() ) {
          this.deselectAll();
          item.setSelected( true );
          var itemId = rwt.remote.ObjectRegistry.getId( item );
          rwt.remote.Connection.getInstance().getRemoteObject( this ).set( "selection", itemId );
          rwt.remote.EventUtil.notifySelected( this, { "item" : itemId } );
        }
      }
    },

    _notifyDefaultSelection : function( item ) {
      if( !rwt.remote.EventUtil.getSuspended() ) {
        var itemId = rwt.remote.ObjectRegistry.getId( item );
        rwt.remote.EventUtil.notifyDefaultSelected( this, { "item" : itemId } );
      }
    }
  }
} );

/*******************************************************************************
 * Copyright (c) 2011, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.remote.HandlerRegistry.add( "rwt.widgets.CTabFolder", {

  factory : function( properties ) {
    var result = new rwt.widgets.CTabFolder();
    rwt.remote.HandlerUtil.addStatesForStyles( result, properties.style );
    result.setUserData( "isControl", true );
    rwt.widgets.CTabFolder.setToolTipTexts.apply( result, properties.toolTipTexts );
    rwt.remote.HandlerUtil.setParent( result, properties.parent );
    return result;
  },

  destructor : rwt.remote.HandlerUtil.getControlDestructor(),

  getDestroyableChildren : rwt.remote.HandlerUtil.getDestroyableChildrenFinder(),

  properties : rwt.remote.HandlerUtil.extendControlProperties( [
    "tabPosition",
    "tabHeight",
    "minMaxState",
    "minimizeBounds",
    "minimizeVisible",
    "maximizeBounds",
    "maximizeVisible",
    "chevronBounds",
    "chevronVisible",
    "unselectedCloseVisible",
    "selection",
    "selectionBackground",
    "selectionForeground",
    "selectionBackgroundImage",
    "selectionBackgroundGradient",
    "borderVisible"
  ] ),

  propertyHandler : rwt.remote.HandlerUtil.extendControlPropertyHandler( {
    "minimizeBounds" : function( widget, value ) {
      widget.setMinButtonBounds.apply( widget, value );
    },
    "minimizeVisible" : function( widget, value ) {
      if( value ) {
        widget.showMinButton();
      } else {
        widget.hideMinButton();
      }
    },
    "maximizeBounds" : function( widget, value ) {
      widget.setMaxButtonBounds.apply( widget, value );
    },
    "maximizeVisible" : function( widget, value ) {
      if( value ) {
        widget.showMaxButton();
      } else {
        widget.hideMaxButton();
      }
    },
    "chevronBounds" : function( widget, value ) {
      widget.setChevronBounds.apply( widget, value );
    },
    "chevronVisible" : function( widget, value ) {
      if( value ) {
        widget.showChevron();
      } else {
        widget.hideChevron();
      }
    },
    "selection" : function( widget, value ) {
      widget.deselectAll();
      rwt.remote.HandlerUtil.callWithTarget( value, function( item ) {
        if( item != null ) {
          item.setSelected( true );
        }
      } );
    },
    "selectionBackground" : function( widget, value ) {
      if( value === null ) {
        widget.setSelectionBackground( null );
      } else {
        widget.setSelectionBackground( rwt.util.Colors.rgbToRgbString( value ) );
      }
    },
    "selectionForeground" : function( widget, value ) {
      if( value === null ) {
        widget.setSelectionForeground( null );
      } else {
        widget.setSelectionForeground( rwt.util.Colors.rgbToRgbString( value ) );
      }
    },
    "selectionBackgroundGradient" : function( widget, value ) {
      var gradient = null;
      if( value ) {
        var colors = value[ 0 ];
        var percents = value[ 1 ];
        var vertical = value[ 2 ];
        gradient = [];
        for( var i = 0; i < colors.length; i++ ) {
          gradient[ i ] = [ percents[ i ] / 100, rwt.util.Colors.rgbToRgbString( colors[ i ] ) ];
        }
        gradient.horizontal = !vertical;
      }
      widget.setSelectionBackgroundGradient( gradient );
    }
  } ),

  events : [ "Folder", "Selection", "DefaultSelection" ],

  listeners : rwt.remote.HandlerUtil.extendControlListeners( [] ),

  listenerHandler : rwt.remote.HandlerUtil.extendControlListenerHandler( {} )

} );

/*******************************************************************************
 * Copyright (c) 2012, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

(function(){

var Connection = rwt.remote.Connection;

/**
 * @private
 * @class Instances of RemoteObject represent the server-side counterpart of a client object
 * and are used to write operations into the next protocol message.
 * @description The constructor is not public. Instances can
 * be obtained from {@link rap.getRemoteObject}.
 * @exports rwt.remote.RemoteObject as RemoteObject
 * @since 2.0
 * @param {}
 *
 */
rwt.remote.RemoteObject = function( id ) {
  this._ = {
    "id" : id,
    "listen" : {}
  };
};

rwt.remote.RemoteObject.prototype = {

  /**
   * @description Sets the specified property of the remote object to the given value.
   * Calling this method multiple times for the same property will overwrite the previous value,
   * the message will not become longer. This method does not cause the message to be sent
   * immediately. Instead it will be sent the next time a "notify" or "call" operation is
   * written to the message.
   * @param {string} property The name of the property.
   * @param {var} value The value of the property.
   */
  set : function( key, value ) {
    Connection.getInstance().getMessageWriter().appendSet( this._.id, key, value );
  },

  /**
   * @description Notifies the remote object that an event of the given type occurred.
   * Notifications can only be sent for types that the server is currently listening for
   * (see {@link rap.registerTypeHandler}, <b>handler.events</b>). If this is not the
   * case, no "notify" operation is written into the message and no request will be sent.
   * Otherwise the message will be sent to the server within a few milliseconds. One message
   * may contain several "notify" operations, if they are added consecutively.
   * @param {string} event The type of the event that occured.
   * @param {Object|null} [properties] This object may contain any number of additional
   * properties/fields associated with the event. It may also be null or omitted.
   */
  notify : function( event, properties ) {
    var suppressSend = arguments[ 2 ];
   // TODO [tb]: suppressSend (or something similar) should be public API
    var actualProps = properties ? properties : {};
    if( this.isListening( event ) ) {
      var connection = Connection.getInstance();
      connection.getMessageWriter().appendNotify( this._.id, event, actualProps );
      if( suppressSend !== true ) {
        if( typeof suppressSend === "number" ) {
          connection.sendDelayed( suppressSend );
        } else {
          connection.send();
        }
      }
    }
  },

  /**
   * @description Instructs the remote object to call the given method.
   * Calling this method will write a "call" operation into the message, which will to be sent to
   * the server within a few milliseconds. One message
   * may contain several "call" operations, if they are added consecutively.
   * @param {string} method The name of the method.
   * @param {Object|null} [properties] This object may contain any number of additional
   * properties/fields associated with the call. It may also be null or omitted.
   */
  call : function( method, properties ) {
    var actualProps = properties ? properties : {};
    Connection.getInstance().getMessageWriter().appendCall( this._.id, method, actualProps );
    Connection.getInstance().send();
  },

  isListening : function( type ) {
    return this._.listen[ type ] === true;
  }

};

}());

/*******************************************************************************
 * Copyright (c) 2012, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

(function(){

var ObjectRegistry = rwt.remote.ObjectRegistry;

rwt.remote.RemoteObjectFactory = { // TODO [tb] : merge with Connection.js? (not a factory)

  _db : {},

  getRemoteObject : function( target ) {
    var id = ObjectRegistry.getId( target );
    if( id == null ){
      throw new Error( "Invalid target for ServerObject, or target not in ObjectManager" );
    }
    return this._getRemoteObject( id );
  },

  remove : function( id ) {
    delete this._db[ id ];
  },

  _getRemoteObject : function( id ) {
    if( this._db[ id ] == null ) {
      this._db[ id ] = new rwt.remote.RemoteObject( id );
      this._initRemoteObject( id );
    }
    return this._db[ id ];
  },

  _initRemoteObject : function( id ) {
    var remoteObject = this._db[ id ];
    var handler = ObjectRegistry.getEntry( id ).handler;
    if( handler && handler.listeners ) {
      for( var i = 0; i < handler.listeners.length; i++ ) {
        var type = handler.listeners[ i ];
        remoteObject._.listen[ type ] = true;
      }
    }
  }

};


}());

/*******************************************************************************
 * Copyright (c) 2009, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.qx.Class.define( "rwt.remote.KeyEventSupport", {

  extend : rwt.qx.Object,

  statics : {

    getInstance : function() {
      return rwt.runtime.Singletons.get( rwt.remote.KeyEventSupport );
    }

  },

  construct : function() {
    this.base( arguments );
    rwt.event.EventHandler.setKeyDomEventFilter( this._onKeyDomEvent, this );
    rwt.event.EventHandler.setKeyEventFilter( this._onKeyEvent, this );
    this._keyBindings = {};
    this._cancelKeys = {};
    this._currentKeyCode = -1;
    this._bufferedEvents = [];
    this._keyEventRequestRunning = false;
    this._ignoreNextKeypress = false;
    var req = rwt.remote.Connection.getInstance();
    req.addEventListener( "received", this._onRequestReceived, this );
  },

  destruct : function() {
    var req = rwt.remote.Connection.getInstance();
    req.removeEventListener( "received", this._onRequestReceived, this );
    rwt.event.EventHandler.setKeyDomEventFilter( function(){}, null );
    rwt.event.EventHandler.setKeyEventFilter( function(){}, null );
  },

  members : {

    //////
    // API

    setKeyBindings : function( value ) {
      this._keyBindings = value;
    },

    setCancelKeys : function( value ) {
      this._cancelKeys = value;
    },

    ////////////
    // Internals

    _onKeyDomEvent : function( eventType, keyCode, charCode, domEvent ) {
      if( eventType === "keydown" ) {
        this._currentKeyCode = keyCode;
      }
      var control = this._getTargetControl();
      var mHandler = rwt.widgets.util.MnemonicHandler.getInstance();
      var mnemonic = mHandler.handleKeyEvent( eventType, keyCode, charCode, domEvent );
      if( mnemonic || this._shouldCancel( this._currentKeyCode, charCode, domEvent, control ) ) {
        rwt.event.EventHandlerUtil.stopDomEvent( domEvent );
        domEvent._noProcess = true;
        domEvent._mnemonic = mnemonic;
      }
      if( mnemonic ) {
        this._ignoreNextKeypress = true;
      }
    },

    _onKeyEvent : function( eventType, keyCode, charCode, domEvent ) {
      var control = this._getTargetControl();
      if(    !domEvent._mnemonic
          && this._shouldSend( eventType, this._currentKeyCode, charCode, domEvent, control ) )
      {
        this._sendKeyEvent( control, this._currentKeyCode, charCode, domEvent );
      }
      if( !domEvent._mnemonic && ( eventType === "keypress" || eventType === "keyup" ) ) {
        this._ignoreNextKeypress = false;
      }
      return !domEvent._noProcess;
    },

    /////////////
    // send event

    _shouldSend : function( eventType, keyCode, charCode, domEvent, control ) {
      var result = false;
      if( this._isRelevant( keyCode, eventType, domEvent ) ) {
        result =    this._shouldSendTraverse( keyCode, charCode, domEvent, control )
                 || this._shouldSendKeyDown( keyCode, charCode, domEvent, control );
      }
      return result;
    },

    _shouldSendTraverse : function( keyCode, charCode, domEvent, control ) {
      return this._hasTraverseListener( control ) && this._isTraverseKey( keyCode );
    },

    _shouldSendKeyDown : function( keyCode, charCode, domEvent, control ) {
      var result = false;
      if( this._hasKeyListener( control ) ) {
        var activeKeys = control.getUserData( "activeKeys" );
        if( activeKeys ) {
          result = this._isActive( activeKeys, domEvent, keyCode, charCode );
        } else {
          result = true;
        }
      }
      if( !result ) {
        result = this._isActive( this._keyBindings, domEvent, keyCode, charCode );
      }
      return result;
    },

    _isRelevant : function( keyCode, eventType, domEvent ) {
      var result;
      if( eventType === "keypress" ) {
        // NOTE : modifier don't repeat
        result = !this._isModifier( keyCode ) && !this._ignoreNextKeypress;
      } else if( eventType === "keydown" ) {
        // NOTE : Prefered when keypress might not be fired, e.g. browser shortcuts that
        //        are not or can not be prevented/canceled. Key might not repeat in that case.
        //        Not to be used when charcode might be unkown (e.g. shift + char, special char)-
        var EventHandlerUtil = rwt.event.EventHandlerUtil;
        result =    EventHandlerUtil.isNonPrintableKeyCode( keyCode )
                 || EventHandlerUtil.isSpecialKeyCode( keyCode );
        if( !result && ( domEvent.altKey || domEvent.ctrlKey ) ) {
          result = this._isAlphaNumeric( keyCode );
        }
        if( result ) {
          this._ignoreNextKeypress = true;
        }
      }
      if( domEvent.ctrlKey && keyCode === 9 ) {
        // Used by the browser to switch tabs, not useable
        result = false;
      }
      return result;
    },

    _onRequestReceived : function() {
      if( this._keyEventRequestRunning ) {
        this._keyEventRequestRunning = false;
        this._checkBufferedEvents();
      }
    },

    _checkBufferedEvents : function() {
      while( this._bufferedEvents.length > 0 && !this._keyEventRequestRunning ) {
        var oldEvent = this._bufferedEvents.shift();
        this._sendKeyEvent.apply( this, oldEvent );
      }
    },

    _sendKeyEvent : function( widget, keyCode, charCode, domEvent ) {
      if( this._keyEventRequestRunning ) {
        this._bufferedEvents.push( [ widget, keyCode, charCode, domEvent ] );
      } else if( widget == null || !widget.isDisposed() ) {
        this._attachKeyEvent( widget, keyCode, charCode, domEvent );
        this._keyEventRequestRunning = true;
        this._sendRequestAsync();
      }
    },

    _sendRequestAsync : function() {
      window.setTimeout( function() {
        rwt.remote.Connection.getInstance().sendImmediate( true );
      }, 0 );
    },

    _attachKeyEvent : function( widget, keyCode, charCode, domEvent ) {
      var server = rwt.remote.Connection.getInstance();
      var remoteObject;
      if( widget === null ) {
        remoteObject = server.getRemoteObject( rwt.widgets.Display.getCurrent() );
      } else {
        remoteObject = server.getRemoteObject( widget );
      }
      var finalCharCode = this._getCharCode( keyCode, charCode, domEvent );
      var properties = {
        "keyCode" : keyCode,
        "charCode" : finalCharCode
      };
      rwt.remote.EventUtil.addModifierToProperties( properties, domEvent );
      if( this._shouldSendTraverse( keyCode, charCode, domEvent, widget ) ) {
        remoteObject.notify( "Traverse", properties, true );
      }
      if( this._shouldSendKeyDown( keyCode, charCode, domEvent, widget ) ) {
        remoteObject.notify( "KeyDown", properties, true );
      }
    },

    ///////////////
    // cancel event

    _shouldCancel : function( keyCode, charCode, domEvent, control ) {
      var result = this._isActive( this._cancelKeys, domEvent, keyCode, charCode );
      if( !result ) {
        var cancelKeys = control ? control.getUserData( "cancelKeys" ) : null;
        if( cancelKeys ) {
          result = this._isActive( cancelKeys, domEvent, keyCode, charCode );
        }
      }
      return result;
    },

    /////////
    // helper

    _getTargetControl : function() {
      var result = rwt.event.EventHandler.getCaptureWidget();
      if( !result ) {
        var focusRoot = rwt.event.EventHandler.getFocusRoot();
        result = focusRoot === null ? null : focusRoot.getActiveChild();
      }
      var widgetManager = rwt.remote.WidgetManager.getInstance();
      while( result !== null && !widgetManager.isControl( result ) ) {
        result = result.getParent ? result.getParent() : null;
      }
      return result;
    },

    _isActive : function( activeKeys, domEvent, keyCode, charCode ) {
      var result = false;
      var identifier = this._getKeyBindingIdentifier( domEvent, "keydown", keyCode, charCode );
      result = activeKeys[ identifier ] === true;
      if( !result ) {
        identifier = this._getKeyBindingIdentifier( domEvent, "keypress", keyCode, charCode );
        result = activeKeys[ identifier ] === true;
      }
      return result;
    },

    _getKeyBindingIdentifier : function( domEvent, eventType, keyCode, charCode ) {
      var result = [];
      if( eventType === "keydown" && !isNaN( keyCode ) && keyCode > 0 ) {
        if( domEvent.altKey ) {
          result.push( "ALT" );
        }
        if( domEvent.ctrlKey ) {
          result.push( "CTRL" ); //TODO Command @ apple?
        }
        if( domEvent.shiftKey ) {
          result.push( "SHIFT" );
        }
        result.push( "#" + keyCode.toString() );
      } else if( eventType === "keypress" && !isNaN( charCode ) && charCode > 0 ) {
        result.push( String.fromCharCode( charCode ) );
      }
      return result.join( "+" );
    },

    _getCharCode : function( keyCode, charCode, domEvent ) {
      var result = charCode;
      if( result === 0 && this._isAlphaNumeric( keyCode ) ) {
        if( domEvent.shiftKey && !this._isNumeric( keyCode ) ) {
          result = keyCode;
        } else {
          result = String.fromCharCode( keyCode ).toLowerCase().charCodeAt( 0 );
        }
      }
      return result;
    },

    _isModifier : function( keyCode ) {
      return keyCode >= 16 && keyCode <= 20 && keyCode !== 19;
    },

    _isAlphaNumeric : function( keyCode ) {
      return ( keyCode >= 65 && keyCode <= 90 ) || this._isNumeric( keyCode );
    },

    _isNumeric : function( keyCode ) {
      return keyCode >= 48 && keyCode <= 57;
    },

    _hasKeyListener : function( widget ) {
      return widget !== null && widget.getUserData( "keyListener" ) === true;
    },

    _hasTraverseListener : function( widget ) {
      return widget !== null && widget.getUserData( "traverseListener" ) === true;
    },

    _isTraverseKey : function( keyCode ) {
      var result = false;
      if( keyCode === 27 || keyCode === 13 || keyCode === 9 ) {
        result = true;
      }
      return result;
    }

  }
} );

// force instance:
rwt.remote.KeyEventSupport.getInstance();

/*******************************************************************************
 * Copyright (c) 2012, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

namespace( "rwt.client" );

rwt.client.JavaScriptExecutor = function() {

  this.execute = function( code ) {
    eval( code );
  };

};

rwt.client.JavaScriptExecutor.getInstance = function() {
  return rwt.runtime.Singletons.get( rwt.client.JavaScriptExecutor );
};

/*******************************************************************************
 * Copyright (c) 2012, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.remote.HandlerRegistry.add( "rwt.client.ConnectionMessages", {

  factory : function() {
    return rwt.remote.Connection.getInstance();
  },

  service : true,

  properties : [ "waitHintTimeout" ],

  propertyHandler : {

    waitHintTimeout : function( server, value ) {
      server.getWaitHintTimer().setInterval( value );
    }

  }


} );

/*******************************************************************************
 * Copyright (c) 2013, 2015 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

namespace( "rwt.client" );

rwt.client.ClientMessages = function() {
  this._messages = {
    "ServerError" : "Server Error",
    "ServerErrorDescription" : "The application terminated unexpectedly.",
    "ConnectionError" : "Network Error",
    "ConnectionErrorDescription" : "The server seems to be temporarily unavailable.",
    "SessionTimeout" : "Session Timeout",
    "SessionTimeoutDescription" : "The server session timed out.",
    "ClientError" : "Client Error",
    "Retry" : "Retry",
    "Restart" : "Restart",
    "Details" : "Details:"
  };
};

rwt.client.ClientMessages.getInstance = function() {
  return rwt.runtime.Singletons.get( rwt.client.ClientMessages );
};

rwt.client.ClientMessages.prototype = {

  setMessages : function( messages ) {
    for( var id in messages ) {
      this._messages[ id ] = messages[ id ];
    }
  },

  getMessage : function( id ) {
    return this._messages[ id ] ? this._messages[ id ] : "";
  }

};

/*******************************************************************************
 * Copyright (c) 2013, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.remote.HandlerRegistry.add( "rwt.client.ClientMessages", {

  factory : function() {
    return rwt.client.ClientMessages.getInstance();
  },

  service : true,

  properties : [ "messages" ]

} );

/*******************************************************************************
 * Copyright (c) 2012, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.remote.HandlerRegistry.add( "rwt.client.JavaScriptExecutor", {

  factory : function() {
    return rwt.client.JavaScriptExecutor.getInstance();
  },

  service : true,

  destructor : rwt.util.Functions.returnTrue,

  methods : [
    "execute"
  ],

  methodHandler : {
    "execute" : function( object, args ) {
      object.execute( args.content );
    }
  }

} );

/*******************************************************************************
 * Copyright (c) 2012, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

namespace( "rwt.client" );

rwt.client.UrlLauncher = function() {
  this._window = window;
  var iframe = document.createElement( "iframe" );
  iframe.style.visibility = "hidden";
  iframe.style.position = "absolute";
  iframe.style.left = "-1000px";
  iframe.style.top = "-1000px";
  iframe.src = rwt.remote.Connection.RESOURCE_PATH + "static/html/blank.html";
  document.body.appendChild( iframe );
  this._iframe = iframe;
};

rwt.client.UrlLauncher.getInstance = function() {
  return rwt.runtime.Singletons.get( rwt.client.UrlLauncher );
};

rwt.client.UrlLauncher.prototype = {

  openURL : function( url ) {
    var protocol = this.getProtocol( url );
    try {
      if( [ "http:", "https:", "ftp:", "ftps:" ].indexOf( protocol ) !== -1 ) {
        this._window.open( url, "_blank" );
      } else {
        this._iframe.src = url;
      }
    } catch( ex ) {
      // IE may throw security exception even if the user allows the popup
    }
  },

  getProtocol : function( url ) {
    var protocol = url.indexOf( ":" ) !== -1 ? url.split( ":" )[ 0 ] + ":" : location.protocol;
    return protocol.toLowerCase();
  }

};

/*******************************************************************************
 * Copyright (c) 2012, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.remote.HandlerRegistry.add( "rwt.client.UrlLauncher", {

  factory : function() {
    return rwt.client.UrlLauncher.getInstance();
  },

  service : true,

  methods : [
    "openURL"
  ],

  methodHandler : {
    "openURL" : function( object, args ) {
      object.openURL( args.url );
    }
  }

} );

/*******************************************************************************
 * Copyright (c) 2012, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

namespace( "rwt.client" );

rwt.client.JavaScriptLoader = {

  load : function( params ) {
    if( params.files.length !== 1 ) {
      throw new Error( "JavaScriptLoader does not support parallel script loading" );
    }
    rwt.remote.MessageProcessor.pauseExecution();
    this._loadFile( params.files[ 0 ] );
  },

  _loadFile : function( file ) {
    var scriptElement = document.createElement( "script" );
    scriptElement.type = "text/javascript";
    scriptElement.src = file;
    this._attachLoadedCallback( scriptElement );
    document.getElementsByTagName( "head" )[ 0 ].appendChild( scriptElement );
  },

  _attachLoadedCallback : function( scriptElement ) {
    scriptElement.onload = function() {
      rwt.remote.MessageProcessor.continueExecution();
      scriptElement.onload = null;
    };
  }

};

/*******************************************************************************
 * Copyright (c) 2012, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.remote.HandlerRegistry.add( "rwt.client.JavaScriptLoader", {

  factory : function() {
    return rwt.client.JavaScriptLoader;
  },

  service : true,

  methods : [
    "load"
  ]

} );

/*******************************************************************************
 * Copyright (c) 2004, 2015 1&1 Internet AG, Germany, http://www.1und1.de,
 *                          EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    1&1 Internet AG and others - original API and implementation
 *    EclipseSource - adaptation for the Eclipse Remote Application Platform
 ******************************************************************************/

rwt.qx.Class.define( "rwt.runtime.System", {

  extend : rwt.qx.Target,

  statics : {

    getInstance : function() {
      return rwt.runtime.Singletons.get( rwt.runtime.System );
    }

  },

  construct : function() {
    if( this.isSupported() ) {
      this.base( arguments );
      this._startupTime = new Date().getTime();
      // Attach load/unload events
      this._onloadWrapped = rwt.util.Functions.bind( this._onload, this );
      this._onbeforeunloadWrapped = rwt.util.Functions.bind( this._onbeforeunload, this );
      this._onunloadWrapped = rwt.util.Functions.bind( this._onunload, this );
      window.addEventListener( "load", this._onloadWrapped, false );
      window.addEventListener( "beforeunload", this._onbeforeunloadWrapped, false );
      window.addEventListener( "unload", this._onunloadWrapped, false );
      rwt.event.EventHandler.setAllowContextMenu( rwt.widgets.Menu.getAllowContextMenu );
    }
  },

  members : {

    _autoDispose : false,
    _onloadDone : false,
    _uiReady : false,

    setUiReady : function( value ) {
      this._uiReady = value;
      if( value ) {
        this.createDispatchEvent( "uiready" );
      }
    },

    getUiReady : function() {
      return this._uiReady;
    },

    isSupported : function() {
      return this._isBrowserSupported() && this._isModeSupported() && this._isXHRSupported();
    },

    getStartupTime : function() {
      return this._startupTime;
    },

    getStartupParameters : function() {
      var queryString = window.location.search;
      if( queryString !== "" ) {
        return this._parseQueryString( queryString.substr( 1 ) );
      }
      return null;
    },

    _parseQueryString : function( queryString ) {
      var parameters = {};
      queryString.split( "&" ).forEach( function( pair ) {
        var parts = pair.split( "=" );
        var name = decodeURIComponent( parts[ 0 ] );
        var value = parts.length === 1 ? "" : decodeURIComponent( parts[ 1 ] );
        if( parameters[ name ] ) {
          parameters[ name ].push( value );
        } else {
          parameters[ name ] = [ value ];
        }
      } );
      return parameters;
    },

    _onload : function() {
      try {
        if( !this._onloadDone ) {
          this._onloadDone = true;
          rwt.widgets.base.ClientDocument.getInstance();
          rwt.runtime.MobileWebkitSupport.init();
          rwt.client.Timer.once( this._preload, this, 0 );
        }
      } catch( ex ) {
        rwt.runtime.ErrorHandler.processJavaScriptError( ex );
      }
    },

    _preload : function() {
      var visibleImages = rwt.html.ImageManager.getInstance().getVisibleImages();
      this.__preloader = new rwt.html.ImagePreloaderSystem( visibleImages, this._preloaderDone, this );
      this.__preloader.start();
    },

    _preloaderDone : function() {
      this.__preloader.dispose();
      this.__preloader = null;
      rwt.event.EventHandler.init();
      rwt.event.EventHandler.attachEvents();
      this.setUiReady( true );
      rwt.widgets.base.Widget.flushGlobalQueues();
      rwt.client.Timer.once( this._postload, this, 100 );
    },

    _postload : function() {
      var hiddenImages = rwt.html.ImageManager.getInstance().getHiddenImages();
      this.__postloader = new rwt.html.ImagePreloaderSystem( hiddenImages, this._postloaderDone, this );
      this.__postloader.start();
    },

    _postloaderDone : function() {
      this.__postloader.dispose();
      this.__postloader = null;
    },

    _onbeforeunload : function( event ) {
      try {
        var domEvent = new rwt.event.DomEvent( "beforeunload", event, window, this );
        this.dispatchEvent( domEvent, false );
        var msg = domEvent.getUserData( "returnValue" );
        domEvent.dispose();
        return msg !== null ? msg : undefined;
      } catch( ex ) {
        rwt.runtime.ErrorHandler.processJavaScriptError( ex );
      }
    },

    _onunload : function() {
      try {
        this.createDispatchEvent( "unload" );
        rwt.event.EventHandler.detachEvents();
        rwt.event.EventHandler.cleanUp();
        rwt.qx.Object.dispose( true );
      } catch( ex ) {
        rwt.runtime.ErrorHandler.processJavaScriptError( ex );
      }
    },

    _isBrowserSupported : function() {
      var result = true;
      var engine = rwt.client.Client.getEngine();
      var version = rwt.client.Client.getMajor();
      if( engine === "trident" && version < 9 ) {
        result = false;
      }
      return result;
    },

    _isModeSupported : function() {
      var result = true;
      var engine = rwt.client.Client.getEngine();
      if( engine === "trident" && document.documentMode < 9 ) {
        result = false;
      }
      return result;
    },

    _isXHRSupported : function() {
      return typeof window.XMLHttpRequest !== "undefined";
    }

  },

  destruct : function() {
    window.removeEventListener( "load", this._onloadWrapped, false );
    window.removeEventListener( "beforeunload", this._onbeforeunloadWrapped, false );
    window.removeEventListener( "unload", this._onunloadWrapped, false );
  },

  defer : function( statics )  {
    // Force direct creation
    statics.getInstance();
  }

} );

/*******************************************************************************
 * Copyright (c) 2013, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

(function() {

var EventHandlerUtil = rwt.event.EventHandlerUtil;
var WidgetUtil = rwt.widgets.util.WidgetUtil;

rwt.qx.Class.define( "rwt.widgets.util.MnemonicHandler", {

  extend : rwt.qx.Object,

  statics : {

    getInstance : function() {
      return rwt.runtime.Singletons.get( rwt.widgets.util.MnemonicHandler );
    }

  },

  construct : function() {
    this.base( arguments );
    this._map = {};
    this._activator = null;
    this._active = null;
    this._activeMenu = null;
    this._allowMenuActivate = false;
  },

  members : {

    add : function( widget, listener ) {
      var shell = WidgetUtil.getShell( widget );
      if( shell != null ) {  // TODO [tb] : this is for MenuBar items, handle them like Menu items
        this._registerFocusRoot( shell );
        var handlers = this._map[ shell.toHashCode() ];
        if( widget instanceof rwt.widgets.MenuItem ) {
          handlers.menu[ widget.toHashCode() ] = [ widget, listener ];
        } else {
          handlers.controls[ widget.toHashCode() ] = [ widget, listener ];
        }
      }
    },

    remove : function( widget ) {
      // NOTE: The shell may be gone if the widget is in dispose, therefore we have to search:
      var hash = widget.toHashCode();
      if( widget instanceof rwt.widgets.MenuItem ) {
        for( var key in this._map ) {
          if( this._map[ key ].menu[ widget.toHashCode() ] ) {
            delete this._map[ key ].menu[ hash ];
            return;
          }
        }
      } else {
        for( var key in this._map ) {
          if( this._map[ key ].controls[ widget.toHashCode() ] ) {
            delete this._map[ key ].controls[ hash ];
            return;
          }
        }
      }
    },

    setActivator : function( str ) {
      if( str ) {
        this._activator = {};
        this._activator.ctrlKey = str.indexOf( "CTRL" ) !== -1;
        this._activator.altKey = str.indexOf( "ALT" ) !== -1;
        this._activator.shiftKey = str.indexOf( "SHIFT" ) !== -1;
      } else {
        this._activator = null;
      }
    },

    isActive : function() {
      return this._active != null;
    },

    handleKeyEvent : function( eventType, keyCode, charCode, domEvent ) {
      var result = false;
      this._checkActiveMenu();
      // Some browser fire multiple keydown for modifier keys:
      if( eventType !== "keydown" || rwt.event.EventHandlerUtil.isFirstKeyDown( keyCode ) ) {
        if( this._isActivation( eventType, keyCode, charCode, domEvent ) ) {
          this.activate();
        } else if( this._isDeactivation( eventType, keyCode, charCode, domEvent ) ) {
          this.deactivate( this._allowMenuActivate || this._activeMenu );
        } else if( this._isTrigger( eventType, keyCode, charCode, domEvent ) ) {
          result = this.trigger( keyCode );
          this._allowMenuActivate = false;
        } else if( this.isActive() && !this._isActivatorCombo( domEvent ) ) {
          this._allowMenuActivate = false;
        }
      }
      return result;
    },

    activate : function() {
      if( this._noMenuOpen() ) {
        var root = rwt.widgets.base.Window.getDefaultWindowManager().getActiveWindow();
        if( root == null ) {
          root = rwt.widgets.base.ClientDocument.getInstance();
        }
        this._active = root.toHashCode();
        this._allowMenuActivate = true;
        this._fire( { "type" : "show" } );
      }
    },

    deactivate : function( allowMenuToggle ) {
      if( this._activeMenu && allowMenuToggle ) {
        this._activeMenu.setActive( false );
        this._activeMenu = null;
      }
      if( this._active ) {
        this._fire( { "type" : "hide" } );
        if( allowMenuToggle ) {
          this._activateMenuBar();
        }
        this._active = null;
      }
    },

    trigger : function( charCode ) {
      var event = {
        "type" : "trigger",
        "charCode" : charCode,
        "success" : false
      };
      this._fire( event, true );
      return event.success;
    },

    _registerFocusRoot : function( root ) {
      if( !this._map[ root.toHashCode() ] ) {
        this._map[ root.toHashCode() ] = { "menu" : {}, "controls" : {} };
        root.addEventListener( "dispose", function() {
          this.deactivate();
          delete this._map[ root.toHashCode() ];
        }, this );
        root.addEventListener( "changeActive", this._onRootChangeActive, this );
      }
    },

    _onRootChangeActive : function( event ) {
      if( event.getValue() === false ) {
        this.deactivate();
      }
    },

    _fire : function( event, onlyVisible ) {
      if( this._map[ this._active ] ) {
        this._doFire( event, onlyVisible, this._map[ this._active ].controls );
        if( !event.success ) {
          this._doFire( event, onlyVisible, this._map[ this._active ].menu );
        }
      }
    },

    _doFire : function( event, onlyVisible, handlers ) {
      for( var key in handlers ) {
        var entry = handlers[ key ];
        if( ( !onlyVisible || entry[ 0 ].isSeeable() ) && entry[ 0 ].getEnabled() ) {
          try{
            entry[ 1 ].call( entry[ 0 ], event );
            if( event.success ) {
              break;
            }
          } catch( ex ) {
            var msg = "Could not handle mnemonic " + event.type + ". ";
            if( entry[ 0 ].isDisposed() ) {
              msg +=  entry[ 0 ].classname + " is disposed. ";
            }
            msg += ex.message;
            throw new Error( msg );
          }
        }
      }
    },

    _activateMenuBar : function() {
      // Accepted limitation: MenuBars without mnemonics can not be activated by mnemonic keys
      if( this._map[ this._active ] ) {
        var items = this._map[ this._active ].menu;
        for( var key in items ) {
          var bar = items[ key ][ 0 ].getParentMenu();
          bar.setMnemonics( true );
          bar.setActive( true );
          this._activeMenu = bar;
          break;
        }
      }
    },

    _checkActiveMenu : function() {
      if( this._activeMenu && !this._activeMenu.getActive() ) {
        this._activeMenu = null;
      }
    },

    /////////
    // Helper

    _isActivation : function( eventType, keyCode, charCode, domEvent ) {
      return    this._activator
             && this._active == null && this._activeMenu == null
             && eventType === "keydown"
             && EventHandlerUtil.isModifier( keyCode )
             && this._isActivatorCombo( domEvent );
    },

    _isDeactivation : function( eventType, keyCode, charCode, domEvent ) {
      return    this._isGlobalDeactivation( eventType, keyCode, charCode, domEvent )
             || this._isMenuDeactivation( eventType, keyCode, charCode, domEvent );
    },

    _isMenuDeactivation : function( eventType, keyCode, charCode, domEvent ) {
      return    this._activator != null
             && this._activeMenu != null
             && EventHandlerUtil.isModifier( keyCode )
             && this._isActivatorCombo( domEvent );
    },

    _isGlobalDeactivation : function( eventType, keyCode, charCode, domEvent ) {
      return    this._activator != null
             && this._active != null
             && eventType != "keypress"
             && !this._isActivatorCombo( domEvent );
    },

    _isActivatorCombo : function( domEvent ) {
      return    this._activator.ctrlKey === domEvent.ctrlKey
             && this._activator.altKey === domEvent.altKey
             && this._activator.shiftKey === domEvent.shiftKey;
    },

    _isTrigger : function( eventType, keyCode ) {
      var isChar = !isNaN( keyCode ) && rwt.event.EventHandlerUtil.isAlphaNumericKeyCode( keyCode );
      return this._active != null && eventType === "keydown" && isChar;
     },

     _noMenuOpen : function() {
       return rwt.util.Objects.isEmpty( rwt.widgets.util.MenuManager.getInstance().getAll() );
     }

  }

} );

}() );

/*******************************************************************************
 * Copyright (c) 2012, 2015 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

(function(){

/**
 * Contains methods required for custom widget development and RWT Scripting.
 *
 * @public
 * @since 2.0
 * @namespace Holds all global public methods of the RAP WebClient.
 */
rap = {

  /**
   * @description Registers a RAP protocol type handler for a specific type of client objects.
   * The handler is used by the protocol message processor to process operations that target
   * any client object of this type. Example:
   *
   * @example
   * rap.registerTypeHandler( "project.MyWidget", {
   *   factory : function( properties ) {
   *     return new MyWidget();
   *   },
   *   properties : [ "propA", "propB" ]
   * } );
   *
   * @param {string} type
   *
   * @param {Object} handler The handler object.
   *
   * @param {Function} handler.factory Called for create operations.
   * Is given a properties object as the first argument, which may contain any number for
   * properties/fields set by the server. Has to return a "client object" representing an instance
   * of the type of this handler. <em>Required for all type handler</em>.
   *
   * @param {string} handler.destructor Name of the method that is called for destroy operations.
   * If the string is given, the client object <em>has</em> to implement a method with the given
   * name. <em>Optional</em>
   *
   * @param {string[]} handler.properties List of properties supported by this type.
   * The order in the list controls the order in which the properties are applied by the message
   * processor. The client object <em>has</em> to implement a setter for each supported property.
   * For example, if the property is "bounds", <code>setBounds</code> will be called on the client
   * object. Properties given by the server that are not in this list will be ignored. (One
   * exception is the factory, which gets an object with <i>all</i> properties set by the server
   * at that time.)  If the property changes on the client, {@link RemoteObject#set} can be
   * used to synchronize the value with the server.
   * <em>Optional.</em>
   *
   * @param {string[]} handler.methods List of methods supported by this type.
   * The order in the list is meaningless, "call" operations are processed in the order in which
   * they are given by the server. The client object has to implement a method of the same name.
   * One argument will be given, which is a properties object with any number of properties/fields.
   * A "call" operation given by the server for a method that is not in this list will be ignored.
   * <em>Optional.</em>
   *
   * @param {string[]} handler.events List of event types supported by this type.
   * The server may instruct the client object with "listen" operations to start or stop sending
   * notifications when events of he given event type occur. Notifications may and can only be
   * sent for types that are given in this list and are listened to by the server. See also
   * {@link RemoteObject#notify}.
   * <em>Optional.</em>
   */
  registerTypeHandler : function( type, handler ) {
    handler.isPublic = true;
    rwt.remote.HandlerRegistry.add( type, handler );
  },

  /**
   * Returns the client object associated with the given id as returned
   * by <code>org.eclipse.rap.rwt.widget.WidgetUtil.getId</code> and
   * <code>org.eclipse.rap.rwt.remote.RemoteObject.getId</code>.
   * If there is no object registered for the given id, <code>null</code> is returned.
   * For custom widgets, that is the result of the type handler factory.
   * For SWT/RWT widgets (any Control or Item) a wrapper (instance of {@link Widget}) is returned that approximates
   * a subset of the API of its Java analog. Getting objects of other types is unsupported.
   * @see Widget
   * @see rap.registerTypeHandler   
   * @param {string} id The protocol id for a client object.
   * @returns {Object} The client object associated with the id.
   */
  getObject : function( id ) {
    var entry = rwt.remote.ObjectRegistry.getEntry( id );
    var result;
    if( entry && entry.handler.isPublic ) {
      result = entry.object;
    } else if( entry ) {
      result = rwt.scripting.WidgetProxyFactory.getWidgetProxy( entry.object );
    }
    return result;
  },

  /**
   * @description Returns an instance of {@link RemoteObject} for the given client object.
   * A client object is any object that was created by an type handler factory method.
   * Multiple calls for the same object will return the same RemoteObject
   * instance.
   * @see rap.registerTypeHandler
   * @param {Object} object The client object.
   * @returns {RemoteObject}
   */
  getRemoteObject : function( object ) {
    return rwt.remote.Connection.getInstance().getRemoteObject( object );
  },

  /**
   * @description Register the function as a listener of the given type. Registering unknown
   * types throws an Error.
   * @param {string} type The type of the event (e.g. "send").
   * @param {Function} listener The callback function. It is executed in global context.
   */
   on : function( type, handler ) {
     if( this._.events[ type ] ) {
       if( this._.events[ type ].indexOf( handler ) === -1 ) {
         this._.events[ type ].push( handler );
       }
     } else {
       throw new Error( "Unknown type " + type );
     }
   },

  /**
   * @description De-register the function as a listener of the given type.
   * @param {string} type The type of the event
   * @param {Function} listener The callback function
   */
   off : function( type, handler ) {
     if( this._.events[ type ] ) {
       var index = this._.events[ type ].indexOf( handler );
       if( index !== -1 ) {
         rwt.util.Arrays.removeAt( this._.events[ type ], index );
       }
     }
   },

   _ : {
    events : {
      /**
       * @event
       * @description Sent right before a message is send to the server.
       * @name rap#send
       */
      "send" : [],
      /**
       * @event
       * @description Sent after a message has been processed.
       * @name rap#render
       */
      "render" : [],
      "receive" : [],
      "process" : []
    },
    notify : function( type ) {
      var listener = this.events[ type ].concat();
      for( var i = 0; i < listener.length; i++ ) {
        listener[ i ].apply( window, Array.prototype.slice.call( arguments, 1 ) );
      }
    }
  }

};

}());

/*******************************************************************************
 * Copyright (c) 2012, 2013 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

/**
 * This object defines the public constants used by RWT Scripting, specifically
 * event types and keycodes.
 *
 * @namespace RWT Scripting analoge to org.eclipse.swt.widgets.SWT
 * @static
 * @since 2.2
 * @see Event
 */
SWT = {

  /**
   * The key down event type
   */
  KeyDown : "KeyDown",

  /**
   * The key up event type
   */
  KeyUp : "KeyUp",

  /**
   * The mouse down event type
   */
  MouseDown : "MouseDown",

  /**
   * The mouse up event type
   */
  MouseUp : "MouseUp",

  /**
   * The mouse move event type
   */
  MouseMove : "MouseMove",

  /**
   * The mouse enter event type
   */
  MouseEnter : "MouseEnter",

  /**
   * The mouse exit event type
   */
  MouseExit : "MouseExit",

  /**
   * The mouse double click event type
   */
  MouseDoubleClick : "MouseDoubleClick",

  /**
   * The paint event type
   */
  Paint : "Paint",

  /**
   * The resize event type
   *
   * Fired by Composite and Canvas
   */
  Resize : "Resize",

  /**
   * The selection event type
   *
   * Fired by Button and Scale
   */
  Selection : "Selection",

  /**
   * The default selection event type
   */
  DefaultSelection : "DefaultSelection",

  /**
   * The focus in event type
   */
  FocusIn : "FocusIn",

  /**
   * The focus out event type
   */
  FocusOut : "FocusOut",

  /**
   * The show event type
   */
  Show : "Show",

  /**
   * The hide event type
   */
  Hide : "Hide",

  /**
   * The modify event type
   *
   * Fired by Text and combo
   */
  Modify : "Modify",

  /**
   * The verify event type
   *
   * Fired by Text and Combo
   *
   * Notes:
   *  - is not fired on programatic changes
   *  - calling setText in verify onsupported
   */
  Verify : "Verify",

  /**
   * The mouse wheel event type
   */
  MouseWheel : "MouseWheel",

  /**
   * Keyboard event constant representing the UP ARROW key
   */
  ARROW_UP : 38,

  /**
   * Keyboard event constant representing the DOWN ARROW key
   */
  ARROW_DOWN : 40,

  /**
   * Keyboard event constant representing the LEFT ARROW key
   */
  ARROW_LEFT : 37,

  /**
   * Keyboard event constant representing the RIGHT ARROW key
   */
  ARROW_RIGHT : 39,

  /**
   * Keyboard event constant representing the PAGE UP key
   */
  PAGE_UP : 33,

  /**
   * Keyboard event constant representing the PAGE DOWN key
   */
  PAGE_DOWN : 34,

  /**
   * Keyboard event constant representing the HOME key
   */
  HOME : 36,

  /**
   * Keyboard event constant representing the END key
   */
  END : 35,

  /**
   * Keyboard event constant representing the INSERT key
   */
  INSERT : 45,

  /**
   * Keyboard event constant representing the F1 key
   */
  F1 : 112,

  /**
   * Keyboard event constant representing the F2 key
   */
  F2 : 113,

  /**
   * Keyboard event constant representing the F3 key
   */
  F3 : 114,

  /**
   * Keyboard event constant representing the F4 key
   */
  F4 : 115,

  /**
   * Keyboard event constant representing the F5 key
   */
  F5 : 116,

  /**
   * Keyboard event constant representing the F6 key
   */
  F6 : 117,

  /**
   * Keyboard event constant representing the F7 key
   */
  F7 : 118,

  /**
   * Keyboard event constant representing the F8 key
   */
  F8 : 119,

  /**
   * Keyboard event constant representing the F9 key
   */
  F9 : 120,

  /**
   * Keyboard event constant representing the F10 key
   */
  F10 : 121,

  /**
   * Keyboard event constant representing the F11 key
   */
  F11 : 122,

  /**
   * Keyboard event constant representing the F12 key
   */
  F12 : 123,

  /**
   * Keyboard event constant representing the numeric key
   */
  KEYPAD_MULTIPLY : 106,

  /**
   * Keyboard event constant representing the numeric key
   */
  KEYPAD_ADD : 107,

  /**
   * Keyboard event constant representing the numeric key
   */
  KEYPAD_SUBTRACT : 109,

  /**
   * Keyboard event constant representing the numeric key
   */
  KEYPAD_DECIMAL : 110,

  /**
   * Keyboard event constant representing the numeric key
   */
  KEYPAD_DIVIDE : 111,

  /**
   * Keyboard event constant representing the numeric key
   * pad zero key
   */
  KEYPAD_0 : 96,

  /**
   * Keyboard event constant representing the numeric key
   * pad one key
   */
  KEYPAD_1 : 97,

  /**
   * Keyboard event constant representing the numeric key
   * pad two key
   */
  KEYPAD_2 : 98,

  /**
   * Keyboard event constant representing the numeric key
   * pad three key
   */
  KEYPAD_3 : 99,

  /**
   * Keyboard event constant representing the numeric key
   * pad four key
   */
  KEYPAD_4 : 100,

  /**
   * Keyboard event constant representing the numeric key
   * pad five key
   */
  KEYPAD_5 : 101,

  /**
   * Keyboard event constant representing the numeric key
   * pad six key
   */
  KEYPAD_6 : 102,

  /**
   * Keyboard event constant representing the numeric key
   * pad seven key
   */
  KEYPAD_7 : 103,

  /**
   * Keyboard event constant representing the numeric key
   * pad eight key
   */
  KEYPAD_8 : 104,

  /**
   * Keyboard event constant representing the numeric key
   * pad nine key
   */
  KEYPAD_9 : 105,

  /**
   * Keyboard event constant representing the numeric key
   * pad equal key
   */
  KEYPAD_EQUAL : 61,

  /**
   * Keyboard event constant representing the numeric key
   * pad enter key
   */
  KEYPAD_CR : 80,

  /**
   * Keyboard event constant representing the caps
   * lock key
   */
  CAPS_LOCK : 20,

  /**
   * Keyboard event constant representing the num
   * lock key
   */
  NUM_LOCK : 144,

  /**
   * Keyboard event constant representing the scroll
   * lock key
   */
  SCROLL_LOCK : 145,

  /**
   * Keyboard event constant representing the pause
   * key
   */
  PAUSE : 19,

  /**
   * Keyboard event constant representing the break
   * key
   */
  BREAK : 19,

  /**
   * Keyboard event constant representing the print screen
   * key
   */
  PRINT_SCREEN : 44,

  /**
   * keyboard and/or mouse event mask indicating that the ALT key
   * was pushed on the keyboard when the event was generated
   */
  ALT : 1 << 16,

  /**
   * Keyboard and/or mouse event mask indicating that the SHIFT key
   * was pushed on the keyboard when the event was generated
   */
  SHIFT : 1 << 17,

  /**
   * Keyboard and/or mouse event mask indicating that the CTRL key
   * was pushed on the keyboard when the event was generated
   */
  CTRL : 1 << 18,

  /**
   * Keyboard and/or mouse event mask indicating that the CTRL key
   * was pushed on the keyboard when the event was generated. This
   * is a synonym for CTRL
   */
  CONTROL : 1 << 18,

  /**
   * Keyboard and/or mouse event mask indicating that the COMMAND key
   * was pushed on the keyboard when the event was generated
   */
  COMMAND : 1 << 22,

  // NOTE : The following constants are characters in SWT and can be compared with both the
  // keyCode and the character field of an event. Here these keys are currently only representend
  // by the events keyCode, therefore these are numbers instead and can only be compared with
  // the keyCode field.

  /**
   * Keyboard event constant representing the delete key
   */
  DEL : 46,

  /**
   * Keyboard event constant representing the escape key
   */
  ESC : 27,

  /**
   * Keyboard event constant representing the backspace key
   */
  BS : 8,

  /**
   * Keyboard event constant representing the carriage return key
   */
  CR : 13,

  /**
   * Keyboard event constant representing the tab key
   */
  TAB : 9,

  /**
   * System arrow cursor
   * @see Control#setCursor
   */
  CURSOR_ARROW : "default",

  /**
   * System wait cursor
   * @see Control#setCursor
   */
  CURSOR_WAIT : "wait",

  /**
   * System cross hair cursor
   * @see Control#setCursor
   */
  CURSOR_CROSS : "crosshair",

  /**
   * System app startup cursor
   * @see Control#setCursor
   */
  CURSOR_APPSTARTING : "progress",

  /**
   * System help cursor
   * @see Control#setCursor
   */
  CURSOR_HELP : "help",

  /**
   * System resize all directions cursor
   * @see Control#setCursor
   */
  CURSOR_SIZEALL : "move",

  /**
   * System resize north-east-south-west cursor
   * @see Control#setCursor
   */
  CURSOR_SIZENESW : "ne-resize",

  /**
   * System resize north-south cursor
   * @see Control#setCursor
   */
  CURSOR_SIZENS : "row-resize",

  /**
   * System resize north-west-south-east cursor
   * @see Control#setCursor
   */
  CURSOR_SIZENWSE : "nw-resize",

  /**
   * System resize west-east cursor
   * @see Control#setCursor
   */
  CURSOR_SIZEWE : "col-resize",

  /**
   * System resize north cursor
   * @see Control#setCursor
   */
  CURSOR_SIZEN : "n-resize",

  /**
   * System resize south cursor
   * @see Control#setCursor
   */
  CURSOR_SIZES : "s-resize",

  /**
   * System resize east cursor
   * @see Control#setCursor
   */
  CURSOR_SIZEE : "e-resize",

  /**
   * System resize west cursor
   * @see Control#setCursor
   */
  CURSOR_SIZEW : "w-resize",

  /**
   * System resize north-east cursor
   * @see Control#setCursor
   */
  CURSOR_SIZENE : "ne-resize",

  /**
   * System resize south-east cursor
   * @see Control#setCursor
   */
  CURSOR_SIZESE : "se-resize",

  /**
   * System resize south-west cursor
   * @see Control#setCursor
   */
  CURSOR_SIZESW : "sw-resize",

  /**
   * System resize north-west cursor
   * @see Control#setCursor
   */
  CURSOR_SIZENW : "nw-resize",

  /**
   * System up arrow cursor
   * @see Control#setCursor
   */
  CURSOR_UPARROW : "rwt-resources/resource/widget/rap/cursors/up_arrow.cur",

  /**
   * System i-beam cursor
   * @see Control#setCursor
   */
  CURSOR_IBEAM : "text",

  /**
   * System "not allowed" cursor
   * @see Control#setCursor
   */
  CURSOR_NO : "not-allowed",

  /**
   * System hand cursor
   * @see Control#setCursor
   */
  CURSOR_HAND : "pointer"

};

/*******************************************************************************
 * Copyright (c) 2012, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

(function(){

rwt.define( "rwt.scripting", {} );

var wrapperRegistry = {};

// TODO : better name?
// TODO [rst] Define directly using rwt.define, remove surrounding function scope
rwt.scripting.EventBinding = {

  addListener : function( widget, eventType, targetFunction ) {
    this._checkEventType( eventType );
    var wrapperKey = this._getWrapperKey( widget, eventType, targetFunction );
    var wrapperList = this._getWrapperList( wrapperKey );
    var nativeType = this._getNativeEventType( widget, eventType );
    var nativeSource = this._getNativeEventSource( widget, eventType );
    var wrappedListener = this._wrapListener( widget, eventType, targetFunction );
    nativeSource.addEventListener( nativeType, wrappedListener, window );
    wrapperList.push( wrappedListener );
  },

  removeListener : function( widget, eventType, targetFunction ) {
    var wrapperKey = this._getWrapperKey( widget, eventType, targetFunction );
    var wrapperList = this._getWrapperList( wrapperKey );
    var nativeType = this._getNativeEventType( widget, eventType );
    var nativeSource = this._getNativeEventSource( widget, eventType );
    var wrappedListener = wrapperList.pop();
    nativeSource.removeEventListener( nativeType, wrappedListener, window );
  },

  _wrapListener : function( widget, eventType, targetFunction ) {
    return function( nativeEvent ) {
      try {
        var eventProxy = new rwt.scripting.EventProxy( SWT[ eventType ], widget, nativeEvent );
        var wrappedEventProxy = rwt.scripting.EventProxy.wrapAsProto( eventProxy );
        targetFunction( wrappedEventProxy );
        rwt.scripting.EventProxy.postProcessEvent( eventProxy, wrappedEventProxy, nativeEvent );
        rwt.scripting.EventProxy.disposeEventProxy( eventProxy );
      } catch( ex ) {
        var msg = "Error in scripting event type ";
        throw new Error( msg + eventType + ": " + ( ex.message ? ex.message : ex ) );
      }
    };
  },

  _getWrapperKey : function( widget, eventType, targetFunction ) {
    var result = [
      rwt.qx.Object.toHashCode( widget ),
      eventType,
      rwt.qx.Object.toHashCode( targetFunction )
    ];
    return result.join( ":" );
  },

  _getWrapperList : function( wrapperKey ) {
    if( wrapperRegistry[ wrapperKey ] == null ) {
      wrapperRegistry[ wrapperKey ] = [];
    }
    return wrapperRegistry[ wrapperKey ];
  },

  _getNativeEventSource : function( source, eventType ) {
    var result = source;
    switch( source.classname + ":" + eventType ) {
      case "rwt.widgets.List:Selection":
        result = source.getManager();
      break;
      case "rwt.widgets.Spinner:Modify":
        result = source._textfield;
      break;
      case "rwt.widgets.Combo:Modify":
      case "rwt.widgets.Combo:Verify":
        result = source._field;
      break;
    }
    return result;
  },

  _getNativeEventType : function( source, eventType ) {
    var map = this._eventTypeMapping;
    var result = "";
    if( map[ source.classname ] && map[ source.classname ][ eventType ] ) {
      result = map[ source.classname ][ eventType ];
    } else {
      result = map[ "*" ][ eventType ];
    }
    return result;
  },

  _checkEventType : function( type ) {
    if( typeof SWT[ type ] === "string" ) {
      return;
    }
    throw new Error( "Unkown event type " + type );
  },

  _eventTypeMapping : {
    "*" : {
      /**
       * @event
       * @description Sent when a key is pressed
       * @name Control#KeyDown
       * @param {Event} event
       * @see SWT.KeyDown
       */
      "KeyDown" : "keypress",
      /**
       * @event
       * @description Sent when a key is released
       * @name Control#KeyUp
       * @param {Event} event
       * @see SWT.KeyUp
       */
      "KeyUp" : "keyup",
      /**
       * @event
       * @description Sent when a mouse button is pressed
       * @name Control#MouseDown
       * @param {Event} event
       * @see SWT.MouseDown
       */
      "MouseDown" : "mousedown",
      /**
       * @event
       * @description Sent when a mouse button is released
       * @name Control#MouseUp
       * @param {Event} event
       * @see SWT.MouseUp
       */
      "MouseUp" : "mouseup",
      /**
       * @event
       * @description Sent when the mouse pointer is moved
       * @name Control#MouseMove
       * @param {Event} event
       * @see SWT.MouseMove
       */
      "MouseMove" : "mousemove",
      /**
       * @event
       * @description Sent when the mouse pointer enters the widget
       * @name Control#MouseEnter
       * @param {Event} event
       * @see SWT.MouseEnter
       */
      "MouseEnter" : "mouseover",
      /**
       * @event
       * @description Sent when the mouse pointer exits the widget
       * @name Control#MouseExit
       * @param {Event} event
       * @see SWT.MouseExit
       */
      "MouseExit" : "mouseout",
      /**
       * @event
       * @description Sent when the mouse wheel is moved
       * @name Control#MouseWheel
       * @param {Event} event
       * @see SWT.MouseWheel
       */
      "MouseWheel" : "mousewheel",
      /**
       * @event
       * @description Sent when a mouse button is clicked twice
       * @name Control#MouseDoubleClick
       * @param {Event} event
       * @see SWT.MouseDoubleClick
       */
      "MouseDoubleClick" : "dblclick",
      /**
       * @event
       * @description Sent when the widget is painted
       * @name Control#Paint
       * @param {Event} event
       * @see SWT.Paint
       */
      "Paint" : "paint",
      /**
       * @event
       * @description Sent when the widget gains focus
       * @name Control#FocusIn
       * @param {Event} event
       * @see SWT.FocusIn
       */
      "FocusIn" : "focus",
      /**
       * @event
       * @description Sent when the widget looses focus
       * @name Control#FocusOut
       * @param {Event} event
       * @see SWT.FocusOut
       */
      "FocusOut" : "blur",
      /**
       * @event
       * @description Sent when the widget appears
       * @name Control#Show
       * @param {Event} event
       * @see SWT.Show
       */
      "Show" : "appear",
      /**
       * @event
       * @description Sent when the widget is hidden
       * @name Control#Hide
       * @param {Event} event
       * @see SWT.Hide
       */
      "Hide" : "disappear"
    },
    "rwt.widgets.Scale" : {
      /**
       * @event
       * @description Sent when the widget selection is changed
       * @name Scale#Selection
       * @param {Event} event
       * @see SWT.Selection
       */
      "Selection" : "selectionChanged"
    },
    "rwt.widgets.Composite" : {
      /**
       * @event
       * @description Sent when the widget selection changes size
       * @name Composite#Resize
       * @param {Event} event
       * @see SWT.Resize
       */
      "Resize" : "clientAreaChanged"
    },
    "rwt.widgets.Button" : {
      /**
       * @event
       * @description Sent when the widget is selected
       * @name Button#Selection
       * @param {Event} event
       * @see SWT.Selection
       */
      "Selection" : "execute"
    },
    "rwt.widgets.Spinner" : {
      /**
       * @event
       * @description Sent when the widget selection is changed
       * @name Spinner#Selection
       * @param {Event} event
       * @see SWT.Selection
       */
      "Selection" : "change",
      /**
       * @event
       * @description Sent when the widget text is changed
       * @name Spinner#Modify
       * @param {Event} event
       * @see SWT.Modify
       */
      "Modify" : "changeValue"
    },
    "rwt.widgets.Text" : {
      /**
       * @event
       * @description Sent before the widget text is changed
       * @name Text#Verify
       * @param {Event} event
       * @see SWT.Verify
       */
      "Verify" : "input", // TODO [tb] : does currently not react on programatic changes
      /**
       * @event
       * @description Sent when the widget text is changed
       * @name Text#Modify
       * @param {Event} event
       * @see SWT.Modify
       */
      "Modify" : "changeValue"
    },
    "rwt.widgets.Combo" : {
      /**
       * @event
       * @description Sent before the widget text is changed
       * @name Combo#Verify
       * @param {Event} event
       * @see SWT.Verify
       */
      "Verify" : "input", // TODO [tb] : does currently not react on programatic changes
      /**
       * @event
       * @description Sent when the widget text is changed
       * @name Combo#Modify
       * @param {Event} event
       * @see SWT.Modify
       */
      "Modify" : "changeValue"
    }
  }

};

}());

/*******************************************************************************
 * Copyright (c) 2012, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

(function(){

rwt.define( "rwt.scripting", {} );

/**
 * Objects of this type are given to the handleEvent function (JavaScript) of
 * org.eclipse.rap.rwt.scripting.ClientListener (Java) instances.
 *
 * @private
 * @class RWT Scripting analoge to org.eclipse.swt.widgets.Event
 * @exports rwt.scripting.EventProxy as Event
 * @since 2.2
 * @see SWT
 */
// TODO [rst] Define directly using rwt.define, remove surrounding function scope
rwt.scripting.EventProxy = function( eventType, originalTarget, originalEvent ) {
  this.widget = rwt.scripting.WidgetProxyFactory.getWidgetProxy( originalTarget );
  this.type = eventType;
  switch( eventType ) {
    case SWT.KeyDown:
    case SWT.KeyUp:
      initKeyEvent( this, originalEvent );
    break;
    case SWT.MouseDown:
    case SWT.MouseWheel:
    case SWT.MouseUp:
    case SWT.MouseMove:
    case SWT.MouseEnter:
    case SWT.MouseExit:
    case SWT.MouseDoubleClick:
      initMouseEvent( this, originalEvent );
    break;
    case SWT.Verify:
      initVerifyEvent( this, originalEvent );
    break;
    case SWT.Paint:
      initPaintEvent( this, originalTarget );
    break;
  }
};

rwt.scripting.EventProxy.prototype = {

  /**
   * an object representing the widget that issued the event.
   *
   * @see rap.getObject
   */
  widget : null,

  /**
   * depending on the event, a flag indicating whether the operation should be
   * allowed. Setting this field to false will cancel the operation.
   *
   * Effective on KeyDown, KeyUp and Verify.
   */
  doit : true,

  /**
   * depending on the event, the character represented by the key that was
   * typed. This is the final character that results after all modifiers have
   * been applied. For non-printable keys (like arrow-keys) this field is not set.
   * Changing its value has no effect.
   *
   * Set for KeyDown, KeyUp and Verify.
   */
  character : '\u0000',

  /**
   * depending on the event, the key code of the key that was typed, as defined
   * by the key code constants in class <code>SWT</code>. When the character
   * field of the event is ambiguous, this field contains the unaffected value
   * of the original character. For example, typing Shift+M or M result in different
   * characters ( 'M' and 'm' ), but the same keyCode (109, character code for 'm').
   */
  keyCode : 0,

  /**
   * the type of event, as defined by the event type constants in the {@link SWT} object.
   */
  type : 0,

  /**
   * depending on the event, the state of the keyboard modifier keys and mouse
   * masks at the time the event was generated.
   *
   * Set for KeyDown, KeyUp, MouseDown, MouseUp, MouseMove, MouseEvnet, MouseExit and MouseDoubleClick.
   */
  stateMask : 0,

  /**
   * the button that was pressed or released; 1 for the first button, 2 for the
   * second button, and 3 for the third button, etc.
   *
   * Set for MouseDown, MouseUp, MouseMove, MouseEvnet, MouseExit and MouseDoubleClick.
   */
  button : 0,

  /**
   * x coordinate of the pointer at the time of the event
   *
   * Set for MouseDown, MouseUp, MouseMove, MouseEvnet, MouseExit and MouseDoubleClick.
   */
  x : 0,

  /**
   * y coordinate of the pointer at the time of the event
   *
   * Set for MouseDown, MouseUp, MouseMove, MouseEvnet, MouseExit and MouseDoubleClick.
   */
  y : 0,

  /**
   * depending on the event, the range of text being modified. Setting these
   * fields has no effect.
   *
   * Set for Verify.
   */
  start : 0,
  end : 0,

  /**
   * depending on the event, the new text that will be inserted.
   * Setting this field will change the text that is about to
   * be inserted or deleted.
   *
   * Set for Verify.
   */
  text : "",

  /**
   * the graphics context to use when painting.
   * <p>
   * It supports a subset of the <a href="http://www.w3.org/TR/2dcontext/">HTML5 Canvas API</a>.
   * </p>
   * Fields:
   * <ul>
   *  <li>strokeStyle</li>
   *  <li>fillStyle</li>
   *  <li>lineWidth</li>
   *  <li>lineJoin</li>
   *  <li>lineCap</li>
   *  <li>miterLimit</li>
   *  <li>globalAlpha</li>
   *</ul>
   * Methods:
   * <ul>
   *  <li>save</li>
   *  <li>restore</li>
   *  <li>beginPath</li>
   *  <li>closePath</li>
   *  <li>clearRect (Limitation: in IE 7/8 arguments are ignored, the entire canvas is cleared)</li>
   *  <li>stroke</li>
   *  <li>fill</li>
   *  <li>moveTo</li>
   *  <li>lineTo</li>
   *  <li>quadraticCurveTo</li>
   *  <li>bezierCurveTo</li>
   *  <li>rect</li>
   *  <li>arc</li>
   *  <li>drawImage</li>
   *  <li>createLinearGradient (Limitations: In IE 7/8, the gradient can be only be drawn either
   *                          vertically or horizontally. Calls to "addColorStop" must be in the
   *                          order of the offsets and can not overwrite previous colorsStops)</li>
   * </ul>
   *
   * More methods are supported on modern browser, but for IE 7/8 these are all.
   *
   * Set on Paint.
   */
  gc : null

};

rwt.scripting.EventProxy.disposeEventProxy = function( eventProxy ) {
  eventProxy.widget = null;
};

rwt.scripting.EventProxy.wrapAsProto = function( object ) {
    WrapperHelper.prototype = object;
    var result = new WrapperHelper();
    WrapperHelper.prototype = null;
    return result;
  };

rwt.scripting.EventProxy.postProcessEvent = function( event, wrappedEvent, originalEvent ) {
  switch( event.type ) {
    case SWT.Verify:
      postProcessVerifyEvent( event, wrappedEvent, originalEvent );
    break;
    case SWT.MouseWheel:
      postProcessMouseWheelEvent( event, wrappedEvent, originalEvent );
    break;
    case SWT.KeyDown:
    case SWT.KeyUp:
      postProcessKeyEvent( event, wrappedEvent, originalEvent );
    break;
  }
};

var initKeyEvent = function( event, originalEvent ) {
  var charCode = originalEvent.getCharCode();
  if( charCode !== 0 ) {
    event.character = String.fromCharCode( charCode );
    // TODO [tb] : keyCode will be off when character is not a-z
    event.keyCode = event.character.toLowerCase().charCodeAt( 0 );
  } else {
    var keyCode = getLastKeyCode();
    switch( keyCode ) {
      case 16:
        event.keyCode = SWT.SHIFT;
      break;
      case 17:
        event.keyCode = SWT.CTRL;
      break;
      case 18:
        event.keyCode = SWT.ALT;
      break;
      case 224:
        event.keyCode = SWT.COMMAND;
      break;
      default:
        event.keyCode = keyCode;
      break;
    }
  }
  setStateMask( event, originalEvent );
};

var initMouseEvent = function( event, originalEvent ) {
  var target = originalEvent.getTarget()._getTargetNode();
  var offset = rwt.html.Location.get( target, "scroll" );
  event.x = originalEvent.getPageX() - offset.left;
  event.y = originalEvent.getPageY() - offset.top;
  if( originalEvent.isLeftButtonPressed() ) {
    event.button = 1;
  } else if( originalEvent.isRightButtonPressed() ) {
    event.button = 3;
  } if( originalEvent.isMiddleButtonPressed() ) {
    event.button = 2;
  }
  setStateMask( event, originalEvent );
};

var initPaintEvent = function( event, target ) {
  var gc = rwt.widgets.util.WidgetUtil.getGC( target );
  event.gc = gc.getNativeContext();
};

var initVerifyEvent = function( event, originalEvent ) {
  var text = originalEvent.getTarget();
  if( text instanceof rwt.widgets.base.BasicText ) {
    var keyCode = getLastKeyCode();
    var newValue = text.getComputedValue();
    var oldValue = text.getValue();
    var oldSelection = text.getSelection();
    var diff = getDiff( newValue, oldValue, oldSelection, keyCode );
    if(    diff[ 0 ].length === 1
        && diff[ 1 ] === diff[ 2 ]
        && diff[ 0 ] === originalEvent.getData()
    ) {
      event.keyCode = keyCode;
      event.character = diff[ 0 ];
    }
    event.text = diff[ 0 ];
    event.start = diff[ 1 ];
    event.end = diff[ 2 ];
  }
};

var getLastKeyCode = function() {
  // NOTE : While this is a private field, this mechanism must be integrated with
  // KeyEventSupport anyway to support the doit flag better.
  return rwt.remote.KeyEventSupport.getInstance()._currentKeyCode;
};

var getDiff = function( newValue, oldValue, oldSel, keyCode ) {
  var start;
  var end;
  var text;
  if( newValue.length >= oldValue.length || oldSel[ 0 ] !== oldSel[ 1 ] ) {
    start = oldSel[ 0 ];
    end = oldSel[ 1 ];
    text = newValue.slice( start, newValue.length - ( oldValue.length - oldSel[ 1 ] ) );
  } else {
    text = "";
    if(    oldSel[ 0 ] === oldSel[ 1 ]
        && keyCode === 8 // backspace
        && ( oldValue.length - 1 ) === newValue.length
    ) {
      start = oldSel[ 0 ] - 1;
      end = oldSel[ 0 ];
    } else {
      start = oldSel[ 0 ];
      end = start + oldValue.length - newValue.length;
    }
  }
  return [ text, start, end ];
};

var setStateMask = function( event, originalEvent ) {
  event.stateMask |= originalEvent.isShiftPressed() ? SWT.SHIFT : 0;
  event.stateMask |= originalEvent.isCtrlPressed() ? SWT.CTRL : 0;
  event.stateMask |= originalEvent.isAltPressed() ? SWT.ALT : 0;
  event.stateMask |= originalEvent.isMetaPressed() ? SWT.COMMAND : 0;
};

var postProcessVerifyEvent = function( event, wrappedEvent, originalEvent ) {
  var widget = originalEvent.getTarget();
  if( wrappedEvent.doit !== false ) {
    if( event.text !== wrappedEvent.text && event.text !== "" ) {
      // insert replacement text
      originalEvent.preventDefault();
      var currentText = widget.getValue();
      var textLeft = currentText.slice( 0, event.start );
      var textRight = currentText.slice( event.end, currentText.length );
      var carret = textLeft.length + wrappedEvent.text.length;
      widget.setValue( textLeft + wrappedEvent.text + textRight );
      widget.setSelection( [ carret, carret ] );
    }
  } else {
    // undo any change
    originalEvent.preventDefault();
    widget._renderValue();
    widget._renderSelection();
  }
};

var postProcessKeyEvent = function( event, wrappedEvent, originalEvent ) {
  if( wrappedEvent.doit === false ) {
    originalEvent.preventDefault();
  }
};

var postProcessMouseWheelEvent = function( event, wrappedEvent, originalEvent ) {
  if( wrappedEvent.doit === false ) {
    originalEvent.preventDefault();
  }
};

var WrapperHelper = function(){};

}());

/*******************************************************************************
 * Copyright (c) 2012, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.define( "rwt.scripting", {} );

(function(){

// TODO [rst] Define directly using rwt.define, remove surrounding function scope
rwt.scripting.FunctionFactory = {

  createFunction : function( functionScript, name ) {
    var result;
    var code = [
      functionScript,
      "\n\n",
      "typeof ",
      name,
      " === \"undefined\" ? null : ",
      name,
      ";" ];
    try {
      result = this._secureEval.apply( window, [ code.join( "" ) ] );
    } catch( ex ) {
      var msg = "Could not parse Script for " + name + ":" + ( ex.message ? ex.message : ex );
      throw new Error( msg );
    }
    if( typeof result !== "function" ) {
      throw new Error( "Script does not define a function " + name );
    }
    return result;
  },

  _secureEval : function() {
    return eval( arguments[ 0 ] );
  }

};

}());

/*******************************************************************************
 * Copyright (c) 2012, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

(function(){

rwt.define( "rwt.scripting", {} );

/**
 * @private
 * @class RWT Scripting analoge to org.eclipse.swt.widgets.Composite and basis for Custom Widgets.
 * @description The constructor is not public.
 * @exports rwt.scripting.CompositeProxy as Composite
 * @extends Control
 * @since 2.0
 */
// TODO [rst] Define directly using rwt.define, remove surrounding function scope
rwt.scripting.CompositeProxy = function( composite ) {

  var children = null;
  if( !composite.isCreated() ) {
    children = [];
    composite.addEventListener( "create", function() {
      for( var i = 0; i < children.length; i++ ) {
        composite._getTargetNode().appendChild( children[ i ] );
      }
      composite.removeEventListener( "create", arguments.callee );
      children = null;
    } );
  }

  /**
   * @name append
   * @methodOf Composite#
   * @description Adds a given HTMLElement to the Composite.
   * @param {HTMLElement} childElement The element to append.
   */
  this.append = function( childElement ) {
    if( children ) {
      children.push( childElement );
    } else {
      composite._getTargetNode().appendChild( childElement );
    }
  };

  /**
   * @name getClientArea
   * @methodOf Composite#
   * @description Returns the client Area of the Composite
   * @returns {int[]} the client area as array [ x, y, width, height ]
   */
  this.getClientArea = function() {
    return composite.getClientArea();
  };

};

}());

/*******************************************************************************
 * Copyright (c) 2012, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

(function(){

rwt.define( "rwt.scripting", {} );

// TODO [rst] Define directly using rwt.define, remove surrounding function scope
rwt.scripting.Synchronizer = function( widget ) {
  widget.addEventListener( "changeBackgroundColor", this._onChangeBackgroundColor, this );
  widget.addEventListener( "changeTextColor", this._onChangeTextColor, this );
  widget.addEventListener( "changeVisibility", this._onChangeVisibility, this );
  widget.addEventListener( "changeEnabled", this._onChangeEnabled, this );
  widget.addEventListener( "changeToolTipText", this._onChangeToolTipText, this );
  widget.addEventListener( "changeCursor", this._onChangeCursor, this );
  switch( widget.classname ) {
    case "rwt.widgets.Button":
      widget.addEventListener( "changeText", this._onChangeButtonText, this );
    break;
    case "rwt.widgets.ProgressBar":
      widget.addEventListener( "selectionChanged", this._onChangeProgressBarSelection, this );
    break;
    case "rwt.widgets.Label":
      widget.addEventListener( "changeText", this._onChangeLabelText, this );
    break;
  }

};

rwt.scripting.Synchronizer._ENABLE_KEY = "rwt.scripting.Synchronizer.ENABLED";

rwt.scripting.Synchronizer.enable = function( widget ) {
  widget.setUserData( this._ENABLE_KEY, true );
};

rwt.scripting.Synchronizer.disable = function( widget ) {
  widget.setUserData( this._ENABLE_KEY, false );
};

rwt.scripting.Synchronizer.prototype = { // TODO : use the getter defined by the proxy?

  _onChangeBackgroundColor : function( event ) {
    var widget = event.getTarget();
    var color = widget.__user$backgroundColor;
    this._sync( widget, "background", this._convertColor( color ) );
  },

  _onChangeTextColor : function( event ) {
    var widget = event.getTarget();
    var color = widget.__user$textColor;
    this._sync( widget, "foreground", this._convertColor( color ) );
  },

  _onChangeVisibility : function( event ) {
    var widget = event.getTarget();
    this._sync( widget, "visibility", widget.getVisibility() );
  },

  _onChangeEnabled : function( event ) {
    var widget = event.getTarget();
    this._sync( widget, "enabled", widget.getEnabled() );
  },

  _onChangeCursor : function( event ) {
    var widget = event.getTarget();
    this._sync( widget, "cursor", widget.__user$cursor || null );
  },

  _onChangeToolTipText : function( event ) {
    var widget = event.getTarget();
    this._sync( widget, "toolTip", widget.getToolTipText() );
  },

  // These events are fired by "dispatchSimpleEvent" in the widgets type handler or setter:

  _onChangeButtonText : function( widget ) {
    this._sync( widget, "text", widget.getCellContent( 2 ) );
  },

  _onChangeLabelText : function( widget ) {
    this._sync( widget, "text", widget.getCellContent( 1 ) );
  },

  _onChangeProgressBarSelection : function( widget ) {
    this._sync( widget, "selection", widget._selection );
  },

  /////////
  // helper

  _sync : function( widget, property, value ) {
    // TODO : use eventUtil.getSuspended instead, catches changes made during response
    if( widget.getUserData( rwt.scripting.Synchronizer._ENABLE_KEY ) ) {
      rap.getRemoteObject( widget ).set( property, value );
    }
  },

  _convertColor : function( color ) {
    var result = null;
    if( color != null ) {
      result = rwt.util.Colors.stringToRgb( color );
    }
    return result;
  }

};


}());

/*******************************************************************************
 * Copyright (c) 2012, 2015 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

(function(){

var ObjectRegistry = rwt.remote.ObjectRegistry;
var Synchronizer = rwt.scripting.Synchronizer;
var HandlerUtil = rwt.remote.HandlerUtil;
var WidgetUtil = rwt.widgets.util.WidgetUtil;

rwt.define( "rwt.scripting", {} );

/**
 * @private
 * @class RWT Scripting analog to org.eclipse.swt.widgets.Widget. All widgets given by
 * {@link rap.getObject} are instances of this type, even if their specific subtype is not
 * documented.
 * @name Widget
 * @description The constructor is not public.
 * @since 2.2
 */

/*jshint nonew:false */
// TODO [rst] Define directly using rwt.define, remove surrounding function scope
rwt.scripting.WidgetProxyFactory = {

  _wrapperMap : {},
  _ALIAS : {
    "visibility" : "setVisible",
    "toolTip" : "setToolTipText"
  },

  getWidgetProxy : function( obj ) {
    var result = null;
    if( obj instanceof Object ) {
      var hash = rwt.qx.Object.toHashCode( obj );
      if( this._wrapperMap[ hash ] == null ) {
        if( obj instanceof rwt.widgets.Composite ) {
          result = new rwt.scripting.CompositeProxy( obj );
        } else {
          result = {};
        }
        this._wrapperMap[ hash ] = result;
        this._initWrapper( obj, result );
      }
      result = this._wrapperMap[ hash ];
    }
    return result;
  },

  _initWrapper : function( originalWidget, wrapper ) {
    if( WidgetUtil.isWidget( originalWidget ) ) {
      new Synchronizer( originalWidget );
    }
    this._attachSetter( wrapper, originalWidget );
    this._attachMethods( wrapper, originalWidget );
    this._attach$el( wrapper, originalWidget );
    if( originalWidget instanceof rwt.qx.Object ) {
      originalWidget.addEventListener( "destroy", function() {
        rwt.scripting.WidgetProxyFactory._disposeWidgetProxy( originalWidget );
      } );
    }
  },

  _disposeWidgetProxy : function( widget ) {
    var hash = rwt.qx.Object.toHashCode( widget );
    var proxy = this._wrapperMap[ hash ];
    if( proxy ) {
      var userData = widget.getUserData( HandlerUtil.SERVER_DATA );
      rwt.scripting.WidgetProxyFactory._disposeObject( proxy );
      rwt.scripting.WidgetProxyFactory._disposeObject( userData );
      delete this._wrapperMap[ hash ];
    }
  },

  _disposeObject : function( object ) {
    for( var key in object ) {
      if( object.hasOwnProperty( key ) ) {
        object[ key ] = null;
      }
    }
  },

  _attachSetter : function( proxy, source ) {
    var id = ObjectRegistry.getId( source );
    var handler = id ? ObjectRegistry.getEntry( id ).handler : null;
    if( handler ) {
      var properties = handler.properties || [];
      for( var i = 0; i < properties.length; i++ ) {
        var property = properties[ i ];
        var setterName = this._ALIAS[ property ] || "set" + rwt.util.Strings.toFirstUp( property );
        proxy[ setterName ] = this._createSetter( id, property, source );
      }
    }
  },

  _attachMethods : function( proxy, source ) {
    var id = ObjectRegistry.getId( source );
    var handler = id ? ObjectRegistry.getEntry( id ).handler : null;
    if( WidgetUtil.isWidget( source ) ) {
      bindMethods(source, proxy, HandlerUtil._widgetScriptingMethods);
    }
    if( handler ) {
      bindMethods(source, proxy, handler.scriptingMethods || {});
    }
  },

  /**
   * @name $el
   * @memberOf Widget#
   * @description Instance of {@link $} wrapping the widgets HTML element.
   */
  /**
   * @name $input
   * @memberOf Text#
   * @description Instance of {@link $} wrapping the widgets HTML <code>input</code> element.
   */
  _attach$el : function( proxy, source ) {
    if( WidgetUtil.isWidget( source ) ) {
      proxy.$el = new rwt.util.RWTQuery( source, true );
      if( source.classname === "rwt.widgets.Text" ) {
        proxy.$input = new rwt.util.RWTQuery( source.getInputElement(), true );
      }
    }
  },

  _createSetter : function( id, property, widget ) {
    var setProperty = this._setProperty;
    return function( value ) {
      Synchronizer.enable( widget );
      setProperty( id, property, value );
      Synchronizer.disable( widget );
    };
  },

  _setProperty : function( id, property, value ) {
    var props = {};
    props[ property ] = value;
    rwt.remote.MessageProcessor.processOperation( {
      "target" : id,
      "action" : "set",
      "properties" : props
    } );
  }

};

function bindMethods( source, target, methods ) {
  for( var name in methods ) {
    target[ name ] = rwt.util.Functions.bind( methods[ name ], source );
  }
}

}());

/*******************************************************************************
 * Copyright (c) 2012, 2013 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

rwt.remote.HandlerRegistry.add( "rwt.scripting.Function", {

  factory : function( properties ) {
    var scriptCode = properties.scriptCode;
    if( !scriptCode ) {
      scriptCode = rap.getObject( properties.scriptId ).getText();
    }
    var name = properties.name;
    return rwt.scripting.FunctionFactory.createFunction( scriptCode, name );
  },

  isPublic : true

} );

/*******************************************************************************
 * Copyright (c) 2010, 2015 Innoopract Informationssysteme GmbH and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Innoopract Informationssysteme GmbH - initial API and implementation
 *    EclipseSource - ongoing development
 ******************************************************************************/

namespace( "rwt.widgets.util" );

(function(){

rwt.widgets.util.Template = function( cells ) {
  this._cells = cells;
  this._cellRenderer = [];
  this._parseCells();
};

rwt.widgets.util.Template.prototype = {

  /**
   * @param {Object} options The options object.
   *
   * @param {HTMLElement} options.element The element in which to render the cells. The element
   * may have other children that will be ignored, but no assumptions should be made about the
   * amount or order of the cell elements added by this template.
   *
   * @param {int} options.zIndexOffset The z-index of the first cell.
   *
   * @returns {object} the container reference
   */
  _createContainer : function( options ) {
    if( !options.element || typeof options.element.nodeName !== "string" ) {
      throw new Error( "Not a valid target for TemplateContainer:" + options.element );
    }
    if( typeof options.zIndexOffset !== "number" ) {
      throw new Error( "Not a valid z-index:" + options.zIndexOffset );
    }
    return {
      "element" : options.element,
      "template" : this,
      "zIndexOffset" : options.zIndexOffset,
      "cellElements" : [],
      "cellCache" : []
    };
  },

  _getCellElement : function( container, cell ) {
    return container.cellElements[ cell ] || null;
  },

  _getCellByElement : function( container, element ) {
    return container.cellElements.indexOf( element );
  },

  /**
   * @param {Object} options The options object.
   * @param {Object} options.container Reference to a container created by this template
   * @param {Object} options.item The item to be rendered. Must implement API of GridItem.
   * @param {boolean} options.enabled Items are renderd as disabled unless this is true
   * @param {boolean} options.seeable Must indicate whether the container element is already in DOM
   * @param {boolean} options.markupEnabled Set to true to prevent escaping
   * @param {int[]} options.bounds The bounds in pixel and order of left, top, width, height
   */
  _render : function( options ) {
    if( !options.container || options.container.template !== this ) {
      throw new Error( "No valid TemplateContainer: " + options.container );
    }
    this._createElements( options );
    this._renderAllBounds( options );
    this._renderAllStyles( options );
    this._renderAllContent( options );
    this._updateCache( options );
  },

  getCellCount : function() {
    return this._cells.length;
  },

  getCellType : function( cell ) {
    return this._cells[ cell ].type;
  },

  getCellData : function( cell ) {
    return this._cells[ cell ];
  },

  isCellSelectable : function( cell ) {
    return this._cells[ cell ].selectable === true;
  },

  hasContent : function( item, cell ) {
    switch( this._getContentType( cell ) ) {
      case "text":
        return this._hasText( item, cell );
      case "image":
        return this._hasImage( item, cell );
      default:
        return false;
    }
  },

  getCellName : function( cell ) {
    return this._cells[ cell ].name || null;
  },

  getCellContent : function( item, cell, cellRenderOptions ) {
    if( !item ) {
      return null;
    }
    switch( this._getContentType( cell ) ) {
      case "text":
        return this._getText( item, cell, cellRenderOptions || {} );
      case "image":
        return this._getImage( item, cell, cellRenderOptions || {} );
      default:
        return null;
    }
  },

  _getText : function( item, cell, cellRenderOptions ) {
    if( this._isBound( cell ) ) {
      return item.getText( this._getIndex( cell ), cellRenderOptions.escaped );
    } else {
      return this._cells[ cell ].text || "";
    }
  },

  _getImage : function( item, cell ) {
    if( this._isBound( cell ) ) {
      return item.getImage( this._getIndex( cell ) );
    } else {
      return this._cells[ cell ].image || null;
    }
  },

  getCellForeground : function( item, cell ) {
    var result = null;
    if( item ) {
      if( this._isBound( cell ) ) {
        result = item.getCellForeground( this._getIndex( cell ) );
      }
      if( ( result === null || result === "" ) && this._cells[ cell ].foreground ) {
        result = this._cells[ cell ].foreground;
      }
    }
    return result;
  },

  getCellBackground : function( item, cell ) {
    var result = null;
    if( item ) {
      if( this._isBound( cell ) ) {
        result = item.getCellBackground( this._getIndex( cell ) );
      }
      if( ( result === null || result === "" ) && this._cells[ cell ].background ) {
        result = this._cells[ cell ].background;
      }
    }
    return result;
  },

  getCellFont : function( item, cell ){
    var result = null;
    if( item ) {
      if( this._isBound( cell ) ) {
        result = item.getCellFont( this._getIndex( cell ) );
      }
      if( ( result === null || result === "" ) && this._cells[ cell ].font ) {
        result = this._cells[ cell ].font;
      }
    }
    return result;
  },

  _createElements : function( options ) { // TODO [tb] : do during renderContent
    var elements = options.container.cellElements;
    var item = options.item;
    for( var i = 0; i < this._cells.length; i++ ) {
      if(    !elements[ i ]
          && this._cellRenderer[ i ]
          && ( this.hasContent( item, i ) || ( this.getCellBackground( item, i ) != null ) )
      ) {
        var element = this._cellRenderer[ i ].createElement( this._cells[ i ] );
        element.style.zIndex = options.container.zIndexOffset + i;
        options.container.element.appendChild( element );
        options.container.cellElements[ i ] = element;
        options.container.cellCache[ i ] = { "initialized" : false };
      }
    }
  },

  _renderAllContent : function( options ) {
    var cellRenderOptions = {
      "markupEnabled" : options.markupEnabled,
      "enabled" : options.enabled,
      "seeable" : options.seeable
    };
    var container = options.container;
    for( var i = 0; i < this._cells.length; i++ ) {
      var element = container.cellElements[ i ];
      if( element ) {
        var renderer = rwt.widgets.util.CellRendererRegistry.getInstance().getAll();
        var cellRenderer = renderer[ this._cells[ i ].type ];
        cellRenderOptions.width = container.cellCache[ i ].width;
        cellRenderOptions.height = container.cellCache[ i ].height;
        var renderContent = cellRenderer.renderContent;
        renderContent( element,
                       this.getCellContent( options.item, i, cellRenderOptions ),
                       this._cells[ i ],
                       cellRenderOptions );
      }
    }
  },

  _renderAllStyles : function( options ) {
    for( var i = 0; i < this._cells.length; i++ ) {
      var element = options.container.cellElements[ i ];
      if( element ) {
        var cache = options.container.cellCache[ i ];
        var background = this.getCellBackground( options.item, i );
        var foreground = this.getCellForeground( options.item, i );
        var font = this.getCellFont( options.item, i );
        if( cache.font !== font ) {
          cache.font = font;
          this._renderFont( element, font );
        }
        if( cache.color !== foreground ) {
          cache.color = foreground;
          this._renderForeground( element, foreground );
        }
        if( cache.backgroundColor !== background ) {
          cache.backgroundColor = background;
          this._renderBackground( element, background );
        }
      }
    }
  },

  // TODO [tb] : optimize to render only flexi content or if bounds changed or if new
  _renderAllBounds : function( options ) {
    var container = options.container;
    var boundsChanged = container.lastBounds !== options.bounds.join( "," );
    for( var i = 0; i < this._cells.length; i++ ) {
      var element = options.container.cellElements[ i ];
      if( element && ( boundsChanged || !container.cellCache[ i ].initialized ) ) {
        var cache = container.cellCache[ i ];
        element.style.left = this._getCellLeft( options, i ) + "px";
        element.style.top = this._getCellTop( options, i ) + "px";
        var width = this._getCellWidth( options, i );
        var height = this._getCellHeight( options, i );
        element.style.width = width + "px";
        element.style.height = height + "px";
        cache.width = width;
        cache.height = height;
      }
    }
  },

  _renderBackground : function( element, color ) {
    rwt.html.Style.setBackgroundColor( element, color );
  },

  _renderForeground : function( element, color ) {
    element.style.color = color || "inherit";
  },

  _renderFont : function( element, font ) {
    if( font ) {
      element.style.font = font;
    } else {
      rwt.html.Font.resetElement( element );
    }
  },

  _updateCache : function( options ) {
    var container = options.container;
    for( var i = 0; i < this._cells.length; i++ ) {
      if( container.cellCache[ i ] ) {
        container.cellCache[ i ].initialized = true;
      }
    }
    container.lastBounds = options.bounds.join( "," );
    container.lastItem = options.item;
  },

  /**
   * The type of content "text/image" the renderer expects
   */
  _getContentType : function( cell ) {
    var cellRenderer = this._cellRenderer[ cell ];
    return cellRenderer ? cellRenderer.contentType : null;
  },

  _getCellWidth : function( options, cell ) {
    if( this._cells[ cell ].width !== undefined ) {
      return this._cells[ cell ].width;
    }
    return   options.bounds[ 2 ]
           - ( this._getCellLeft( options, cell ) - options.bounds[ 0 ] )
           - this._getCellRight( options, cell );
  },

  _getCellHeight : function( options, cell ) {
    if( this._cells[ cell ].height !== undefined ) {
      return this._cells[ cell ].height;
    }
    return   options.bounds[ 3 ]
           - ( this._getCellTop( options, cell ) - options.bounds[ 1 ] )
           - this._getCellBottom( options, cell );
  },

  _getCellLeft : function( options, cell ) {
    var cellData = this._cells[ cell ];
    if( cellData.left !== undefined ) {
      return   options.bounds[ 0 ]
             + Math.round( cellData.left[ 0 ] * options.bounds[ 2 ] / 100 )
             + cellData.left[ 1 ];
    }
    var right = this._getCellRight( options, cell );
    return options.bounds[ 0 ] + options.bounds[ 2 ] - cellData.width - right;
  },

  _getCellTop : function( options, cell ) {
    var cellData = this._cells[ cell ];
    if( cellData.top !== undefined ) {
      return   options.bounds[ 1 ]
             + Math.round( cellData.top[ 0 ] * options.bounds[ 3 ] / 100 )
             + cellData.top[ 1 ];
    }
    var bottom = this._getCellBottom( options, cell );
    return options.bounds[ 1 ] + options.bounds[ 3 ] - cellData.height - bottom;
  },

  _getCellRight : function( options, cell ) {
    var cellData = this._cells[ cell ];
    if( cellData.right !== undefined ) {
      return Math.round( cellData.right[ 0 ] * options.bounds[ 2 ] / 100 ) + cellData.right[ 1 ];
    }
    return 0;
  },

  _getCellBottom : function( options, cell ) {
    var cellData = this._cells[ cell ];
    if( cellData.bottom !== undefined ) {
      return Math.round( cellData.bottom[ 0 ] * options.bounds[ 3 ] / 100 ) + cellData.bottom[ 1 ];
    }
    return 0;
  },

  _hasText : function( item, cell ) {
    if( !item ) {
      return false;
    } else if( this._isBound( cell ) ) {
      return item.hasText( this._getIndex( cell ) );
    } else {
      return this._cells[ cell ].text != null;
    }
  },

  _hasImage : function( item, cell ) {
    if( !item ) {
      return false;
    } else if( this._isBound( cell ) ) {
      return item.getImage( this._getIndex( cell ) ) !== null;
    } else {
      return this._cells[ cell ].image != null;
    }
  },

  _isBound : function( cell ) {
    return typeof this._cells[ cell ].bindingIndex === "number";
  },

  _getIndex : function( cell ) {
    return this._cells[ cell ].bindingIndex;
  },

  _parseCells : function() {
    var renderer = rwt.widgets.util.CellRendererRegistry.getInstance().getAll();
    for( var i = 0; i < this._cells.length; i++ ) {
      this._cellRenderer[ i ] = renderer[ this._cells[ i ].type ];
      if( this._cells[ i ].font ) {
        var font = this._cells[ i ].font;
        this._cells[ i ].font = rwt.html.Font.fromArray( font ).toCss();
      }
      if( this._cells[ i ].foreground ) {
        var foreground = this._cells[ i ].foreground;
        this._cells[ i ].foreground = rwt.util.Colors.rgbToRgbString( foreground );
      }
      if( this._cells[ i ].background ) {
        var background = this._cells[ i ].background;
        this._cells[ i ].background = rwt.util.Colors.rgbToRgbString( background );
      }
    }
  }

};

}());


/*******************************************************************************
 * Copyright (c) 2010, 2014 Innoopract Informationssysteme GmbH and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Innoopract Informationssysteme GmbH - initial API and implementation
 *    EclipseSource - ongoing development
 ******************************************************************************/

namespace( "rwt.widgets.util" );

(function(){

// TODO : move relevant Template.js code here
rwt.widgets.util.TemplateRenderer = function( template, parentElement, zIndexOffset ) {
  this._template = template;
  this._container = template._createContainer( {
    "element" : parentElement,
    "zIndexOffset" : zIndexOffset
  } );
};

rwt.widgets.util.TemplateRenderer.prototype = {

  renderItem : function( item ) {
    this._template._render( {
      "container" : this._container,
      "item" : item,
      "bounds" : this.targetBounds,
      "enabled" : this.targetIsEnabled,
      "markupEnabled" : this.markupEnabled,
      "seeable" : this.targetIsSeeable
    } );
  },

  isCellSelectable : function( cellElement ) {
    var cell = this._template._getCellByElement( this._container, cellElement );
    return cell !== -1 && this._template.isCellSelectable( cell );
  },

  getCellName : function( cellElement ) {
    var cell = this._template._getCellByElement( this._container, cellElement );
    return cell === -1 ? null : this._template.getCellName( cell );
  }

};

}());


/*******************************************************************************
 * Copyright (c) 2013, 2015 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

(function() {

  var TAB = String.fromCharCode( 9 );

  var eventTypes = {
    Selection : SWT.Selection,
    DefaultSelection : SWT.DefaultSelection,
    Show : SWT.Show,
    Hide : SWT.Hide
  };

  var forwardedKeys = {
    Enter : true,
    Up : true,
    Down : true,
    PageUp : true,
    PageDown : true,
    Escape : true
  };

  namespace( "rwt.widgets" );

  /**
   * @class Instances of DropDown represent the server-side counterpart of a DropDown widget
   */
  rwt.widgets.DropDown = function( parent, markupEnabled, appearance ) {
    this._ = {};
    this._.hideTimer = new rwt.client.Timer( 0 );
    this._.hideTimer.addEventListener( "interval", checkFocus, this );
    this._.parent = parent;
    this._.appearance = appearance;
    this._.customVariant = null;
    this._.styleMap = null;
    this._.popup = createPopup( appearance ); // TODO: create on demand
    this._.grid = createGrid( this._.popup, markupEnabled, appearance );
    inheritParentStyling.call( this );
    this._.visibleItemCount = 5;
    this._.items = [];
    this._.columns = null;
    this._.inMouseSelection = false;
    this._.visibility = false;
    this._.minWidth = 0;
    this._.selectionWrapping = true;
    this._.events = createEventsMap();
    addParentListeners.call( this );
    addGridListeners.call( this );
    this._.popup.addEventListener( "appear", onAppear, this );
    this._.parentFocusRoot = parent.getFocusRoot();
    this._.parentFocusRoot.addEventListener( "changeFocusedChild", onFocusChange, this );
  };

  rwt.widgets.DropDown.prototype = {

    classname : "rwt.widgets.DropDown",

    setItems : function( items ) {
      this.setSelectionIndex( -1 );
      this._.items = rwt.util.Arrays.copy( items );
      renderGridItems.call( this );
      if( this._.grid.isSeeable() ) {
        renderLayout.call( this );
      }
      updateScrollBars.call( this );
      if( this._.visibility && items.length > 0 ) {
        this.show();
      } else if( this._.visibility && items.length === 0 ) {
        this._.popup.hide();
      }
    },

    getItems : function() {
      return rwt.util.Arrays.copy( this._.items );
    },

    getItemCount : function() {
      return this._.grid.getRootItem().getChildrenLength();
    },

    /**
     * Not intended to be called by ClientScripting
     */
    setVisibleItemCount : function( itemCount ) {
      this._.visibleItemCount = itemCount;
      if( this._.grid.isSeeable() ) {
        renderLayout.call( this );
      }
      // TODO: hide dropdown completely if no items are visible
      updateScrollBars.call( this );
    },

    getVisibleItemCount : function() {
      return this._.visibleItemCount;
    },

    setSelectionIndex : function( index ) {
      if( index < -1 || index >= this.getItemCount() || isNaN( index ) ) {
        throw new Error( "Can not select item: Index " + index + " not valid" );
      }
      if( this.getSelectionIndex() === index ) {
        return;
      }
      this._.grid.deselectAll();
      if( index > -1 ) {
        var item = this._.grid.getRootItem().getChild( index );
        this._.grid.selectItem( item );
        this._.grid.setFocusItem( item );
        this._.grid.scrollItemIntoView( item );
      } else {
        this._.grid.setFocusItem( null );
        this._.grid.setTopItemIndex( 0 );
      }
      // Not called for selection changes by API/Server:
      this._.grid.dispatchSimpleEvent( "selectionChanged", { "type" : "selection" } );
    },

    getSelectionIndex : function() {
      var selection = this._.grid.getSelection();
      var result = -1;
      if( selection[ 0 ] ) {
        result = this._.grid.getRootItem().indexOf( selection[ 0 ] );
      }
      return result;
    },

    setVisible : function( value ) {
      if( value ) {
        this.show();
      } else {
        this.hide();
      }
    },

    getVisible : function() {
      return this._.visibility;
    },

    setMinWidth : function( value ) {
      this._.minWidth = value;
      if( this._.grid.isSeeable() ) {
        renderLayout.call( this );
      }
    },

    setSelectionWrapping : function( value ) {
      this._.selectionWrapping = value;
    },

    setCustomVariant : function( value ) {
      this._.customVariant = value;
      this._.styleMap = null;
      this._.popup.setCustomVariant( value );
      this._.grid.setCustomVariant( value );
    },

    show : function() {
      checkDisposed( this );
      if( !this._.visibility ) {
        this._.visibility = true;
        addMouseWheelEventFilter.call( this );
        fireEvent.call( this, "Show" );
      }
      if( this._.items.length > 0 && this._.parent.isSeeable() && !this._.popup.isSeeable() ) {
        renderLayout.call( this );
        setPopUpVisible.call( this, true );
      }
    },

    hide : function() {
      checkDisposed( this );
      if( this._.visibility ) {
        this._.visibility = false;
        removeMouseWheelEventFilter.call( this );
        fireEvent.call( this, "Hide" );
      }
      setPopUpVisible.call( this, false );
    },

    setData : function( key, value ) {
      if( !this._.widgetData ) {
        this._.widgetData = {};
      }
      if( arguments.length === 1 && key instanceof Object ) {
        rwt.util.Objects.mergeWith( this._.widgetData, key );
      } else {
        this._.widgetData[ key ] = value;
      }
    },

    getData : function( key ) {
      if( !this._.widgetData ) {
        return null;
      }
      var data = this._.widgetData[ key ];
      return data === undefined ? null : data;
    },

    addListener : function( type, listener ) {
      if( this._.events[ type ] ) {
        if( this._.events[ type ].indexOf( listener ) === -1 ) {
          this._.events[ type ].push( listener );
        }
      } else {
        throw new Error( "Unkown type " + type );
      }
    },

    removeListener : function( type, listener ) {
      if( this._ && this._.events[ type ] ) {
        var index = this._.events[ type ].indexOf( listener );
        rwt.util.Arrays.removeAt( this._.events[ type ], index );
      }
    },

    /**
     * Experimental!
     */
    setColumns : function( columns ) {
      this._.columns = columns;
      this._.grid.setColumnCount( columns.length );
      renderGridItems.call( this );
      if( this._.grid.isSeeable() ) {
        renderLayout.call( this );
      }
    },

    /**
     * Not intended to be called by ClientScripting
     */
    destroy : function() {
      if( !this.isDisposed() ) {
        var parentFocusRoot = this._.parentFocusRoot;
        if( parentFocusRoot && !parentFocusRoot.isDisposed() ) {
          parentFocusRoot.removeEventListener( "changeFocusedChild", onFocusChange, this );
        }
        if( !this._.grid.isDisposed() ) {
          this._.grid.getRootItem().setItemCount( 0 );
        }
        if( !this._.parent.isDisposed() ) {
          this._.parent.removeEventListener( "appear", onParentVisibilityChange, this );
          this._.parent.removeEventListener( "disappear", onParentVisibilityChange, this );
          this._.parent.removeEventListener( "flush", onParentFlush, this );
          this._.parent.removeEventListener( "keydown", onParentKeyDownEvent, this );
          this._.parent.removeEventListener( "keypress", onParentKeyPressEvent, this );
          this._.parent.removeEventListener( "changeFont", inheritParentStyling, this );
          this._.parent.removeEventListener( "changeTextColor", inheritParentStyling, this );
          this._.parent.removeEventListener( "changeBackgroundColor", inheritParentStyling, this );
          this._.parent.removeEventListener( "changeCursor", inheritParentStyling, this );
        }
        removeMouseWheelEventFilter.call( this );
        this._.popup.destroy();
        this._.hideTimer.dispose();
        if( this._.widgetData ) {
          for( var key in this._.widgetData ) {
            this._.widgetData[ key ] = null;
          }
        }
        for( var key in this._ ) {
          this._[ key ] = null;
        }
        this._ = null;
      }
    },

    isDisposed : function() {
      return this._ === null;
    },

    toString : function() {
      return "DropDown";
    },

    applyObjectId : function( id ) {
      this._.id = id;
      this._.popup.applyObjectId( id );
    }

  };

  ////////////
  // "statics"

  rwt.widgets.DropDown.searchItems = function( items, query, limit ) {
    var resultIndicies = [];
    var filter = function( item, index ) {
      if( query.test( item ) ) {
        resultIndicies.push( index );
        return true;
      } else {
        return false;
      }
    };
    var resultLimit = typeof limit === "number" ? limit : 0;
    var resultItems = filterArray( items, filter, resultLimit );
    return {
      "items" : resultItems,
      "indicies" : resultIndicies,
      "query" : query,
      "limit" : resultLimit
    };
  };

  rwt.widgets.DropDown.createQuery = function( str, caseSensitive, ignorePosition ) {
    var escapedStr = rwt.widgets.DropDown.escapeRegExp( str );
    return new RegExp( ( ignorePosition ? "" : "^" ) + escapedStr, caseSensitive ? "" : "i" );
  };

  rwt.widgets.DropDown.escapeRegExp = function( str ) {
    return str.replace( /[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&" );
  };

  ////////////
  // Internals

  var addParentListeners = function() {
    this._.parent.addEventListener( "appear", onParentVisibilityChange, this );
    this._.parent.addEventListener( "disappear", onParentVisibilityChange, this );
    this._.parent.addEventListener( "flush", onParentFlush, this );
    this._.parent.addEventListener( "keydown", onParentKeyDownEvent, this );
    this._.parent.addEventListener( "keypress", onParentKeyPressEvent, this );
    this._.parent.addEventListener( "changeFont", inheritParentStyling, this );
    this._.parent.addEventListener( "changeTextColor", inheritParentStyling, this );
    this._.parent.addEventListener( "changeBackgroundColor", inheritParentStyling, this );
    this._.parent.addEventListener( "changeCursor", inheritParentStyling, this );
  };

  var addGridListeners = function() {
    this._.grid.addEventListener( "create", onCreate, this );
    this._.grid.addEventListener( "selectionChanged", onSelection, this );
    this._.grid.addEventListener( "keypress", onKeyEvent, this );
    this._.grid.addEventListener( "mousedown", onMouseDown, this );
    this._.grid.addEventListener( "mouseup", onMouseUp, this );
  };

  var setPopUpVisible = function( visible ) {
    if( visible ) {
      this._.popup.show();
    } else {
      this._.popup.setVisibility( false ); // makes it disappear immediately
      this._.popup.setDisplay( false ); // forces the popup to appear after all parents are layouted
    }
  };

  var renderLayout = function() {
    var font = this._.grid.getFont();
    // NOTE: Guessing the lineheight to be 1.3
    var padding = getStyleMap.call( this ).padding;
    var itemHeight = Math.floor( font.getSize() * 1.3 ) + padding[ 0 ] + padding[ 2 ];
    var visibleItems = Math.min( this._.visibleItemCount, this.getItemCount() );
    var gridWidth = calcGridWidth.apply( this );
    var gridHeight = visibleItems * itemHeight;
    renderPosition.call( this );
    var frameWidth = getStyleMap.call( this ).border.getWidthLeft() * 2;
    this._.popup.setWidth( gridWidth + frameWidth );
    this._.popup.setHeight( gridHeight + frameWidth );
    this._.grid.setDimension( gridWidth, gridHeight );
    renderItemMetrics.apply( this, [ itemHeight, gridWidth, padding ] );
  };

  var renderPosition = function() {
    this._.popup.positionRelativeTo( this._.parent, 0, this._.parent.getHeight() );
    var docHeight = rwt.widgets.base.ClientDocument.getInstance().getInnerHeight();
    if( this._.popup.getTop() + this._.popup.getHeight() > docHeight ) {
      this._.popup.positionRelativeTo( this._.parent, 0, -1 * this._.popup.getHeight() );
    }
  };

  var calcGridWidth = function() {
    var frameWidth = getStyleMap.call( this ).border.getWidthLeft() * 2;
    var result = this._.parent.getWidth() - frameWidth;
    if( this._.minWidth > 0 ) {
      var padding = getStyleMap.call( this ).padding;
      var scrollbarWidth = 0;
      if( this._.visibleItemCount < this.getItemCount() ) {
        scrollbarWidth = this._.grid.getVerticalBar().getWidth();
      }
      var preferredWidth = this._.minWidth + padding[ 1 ] + padding[ 3 ] + scrollbarWidth;
      result = Math.max( result, preferredWidth );
    }
    if( this._.columns ) {
      var columnsSum = 0;
      for( var i = 0; i < this._.columns.length; i++ ) {
        columnsSum += this._.columns[ i ];
      }
      if( columnsSum > result ) {
        result = columnsSum;
      }
    }
    return result;
  };

  var renderItemMetrics = function( itemHeight, itemWidth, padding ) {
    this._.grid.setItemHeight( itemHeight );
    if( this._.columns != null ) {
      var left = 0;
      for( var i = 0; i < this._.columns.length; i++ ) {
        var column = this._.columns[ i ];
        this._.grid.setItemMetrics(
          i,  // column
          left, // left
          column, // width
          0, // imageLeft
          0, // imageWidth
          left + padding[ 3 ], // textLeft
          column - padding[ 1 ] - padding[ 3 ], // textWidth
          0, // checkLeft
          0 // checkWith
        );
        left += column;
      }
    } else {
      this._.grid.setItemMetrics(
        0,  // column
        0, // left
        itemWidth, // width
        0, // imageLeft
        0, // imageWidth
        padding[ 3 ], // textLeft
        itemWidth - padding[ 1 ] - padding[ 3 ], // textWidth
        0, // checkLeft
        0 // checkWith
      );
    }
  };

  var renderGridItems = function() {
    var rootItem = this._.grid.getRootItem();
    var items = this._.items;
    rootItem.setItemCount( 0 );
    rootItem.setItemCount( items.length );
    for( var i = 0; i < items.length; i++ ) {
      var gridItem = new rwt.widgets.GridItem( rootItem, i, false );
      gridItem.applyObjectId( this._.id + "-listitem-" + i );
      if( this._.columns ) {
        gridItem.setTexts( items[ i ].split( TAB ) );
      } else {
        gridItem.setTexts( [ items[ i ] ] );
      }
    }
  };

  var onParentVisibilityChange = function() {
    if( this._.visibility ) {
      if( this._.parent.isSeeable() ) {
        this.show(); // makes popup visible if items are present and handles layout
      } else {
        setPopUpVisible.call( this, false );
      }
    }
  };

  var onParentKeyDownEvent = function( event ) {
    // NOTE: This prevents the underlying Shell from closing. Shell is listening for keydown.
    var key = event.getKeyIdentifier();
    if( this._.visibility && ( key === "Enter" || key === "Escape" ) ) {
      event.stopPropagation();
    }
  };

  var onParentKeyPressEvent = function( event ) {
    var key = event.getKeyIdentifier();
    if( this._.visibility && forwardedKeys[ key ] && !event.isAltPressed() ) {
      event.preventDefault();
      if( this._.selectionWrapping ) {
        selectWithWrapping.call( this, event );
      } else {
        selectWithoutWrapping.call( this, event );
      }
    }
  };

  var selectWithWrapping = function( event ) {
    var key = event.getKeyIdentifier();
    if( key === "Down" && this.getSelectionIndex() === -1 && this.getItemCount() > 0 ) {
      this.setSelectionIndex( 0 );
    } else if( key === "Up" && this.getSelectionIndex() === 0 ) {
      this.setSelectionIndex( -1 );
    } else if( key === "Down" && this.getSelectionIndex() === this.getItemCount() - 1 ) {
      this.setSelectionIndex( -1 );
    } else if( key === "Up" && this.getSelectionIndex() === -1 && this.getItemCount() > 0 ) {
      this.setSelectionIndex( this.getItemCount() - 1 );
    } else {
      this._.grid.dispatchEvent( event );
    }
  };

  var selectWithoutWrapping = function( event ) {
    var key = event.getKeyIdentifier();
    var allowSelection = this.getSelectionIndex() === -1 && this.getItemCount() > 0;
    if( ( key === "Down" || key === "PageDown" ) && allowSelection ) {
      this.setSelectionIndex( 0 );
    } else if( ( key === "Up" || key === "PageUp" ) && allowSelection ) {
      this.setSelectionIndex( this.getItemCount() - 1 );
    } else {
      this._.grid.dispatchEvent( event );
    }
  };

  var onParentFlush = function( event ) {
    var changes = event.getData();
    var layouted = changes.top || changes.left || changes.width || changes.height;
    if( layouted && this._.parent.isInDom() && this._.visibility ) {
      renderLayout.call( this );
    }
  };

  var onKeyEvent = function( event ) {
    switch( event.getKeyIdentifier() ) {
      case "Enter":
        rwt.client.Timer.once( function() {
          // NOTE : This async call ensures that the key events is processed before the
          //        DefaultSelection event. A better solution would be to do this for all forwarded
          //        key events, but this would be complicated since the event is disposed by the
          //        time dispatch would be called on the grid.
          fireEvent.call( this, "DefaultSelection" );
        }, this, 0 );
      break;
      case "Escape":
        this.hide();
      break;
    }
  };

  var onSelection = function( event ) {
    if( event.type === "selection" ) {
      fireEvent.call( this, "Selection" );
    }
  };

  var onMouseDown = function( event ) {
    if( event.getOriginalTarget() instanceof rwt.widgets.base.GridRowContainer ) {
      this._.inMouseSelection = true;
    }
  };

  var onMouseUp = function( event ) {
    if(    this._.inMouseSelection
        && event.getOriginalTarget() instanceof rwt.widgets.base.GridRowContainer )
    {
      this._.inMouseSelection = false;
      fireEvent.call( this, "DefaultSelection" );
    }
  };

  var onCreate = function() {
    var selectedItem = this._.grid.getSelection()[ 0 ];
    if( selectedItem ) {
      this._.grid.scrollItemIntoView( selectedItem );
    }
  };

  var onAppear = function() {
    // NOTE: widget absolute position can change without changing it's relative postion, therefore:
    renderPosition.call( this );
  };

  var onFocusChange = function() {
    // NOTE : There is no secure way to get the newly focused widget at this point because
    //        it may have another focus root. Therefore we use this timeout and check afterwards:
    this._.hideTimer.start();
  };

  var fireEvent = function( type ) {
    var event = {
      "text" : "",
      "index" : -1
    };
    if( type === "Selection" || type === "DefaultSelection" ) {
      var selection = this._.grid.getSelection();
      if( selection.length > 0 ) {
        event.index = this.getSelectionIndex();
        event.text = this._.items[ event.index ];
      }
      notify.apply( this, [ type, event ] );
      if( !rwt.remote.EventUtil.getSuspended() ) { // TODO [tb] : ClientScripting must reset flag
        if( type === "DefaultSelection" && selection.length > 0 ) {
          this.hide();
        }
      }
    } else {
      notify.apply( this, [ type, event ] );
    }
  };

  var checkFocus = function() {
    this._.hideTimer.stop();
    if( !hasFocus( this._.parent ) && this._.visibility ) {
      this.hide();
    }
  };

  var updateScrollBars = function() {
    var scrollable = this._.visibleItemCount < this.getItemCount();
    // TODO [tb] : Horizontal scrolling would require measuring all items preferred width
    this._.grid.setScrollBarsVisible( false, scrollable );
  };

  var notify = function( type, event ) {
    var listeners = this._.events[ type ];
    var eventProxy = rwt.util.Objects.mergeWith( {
      "widget" : this,
      "type" : eventTypes[ type ]
    }, event );
    for( var i = 0; i < listeners.length; i++ ) {
      listeners[ i ]( eventProxy );
    }
  };

  var createPopup = function( appearance ) {
    var result = new rwt.widgets.base.Popup();
    result.addToDocument();
    result.setBackgroundColor( "#ffffff" );
    result.setDisplay( false );
    result.setRestrictToPageOnOpen( false );
    result.setAutoHide( false );
    result.setAppearance( appearance + "-popup" );
    return result;
  };

  var createGrid = function( parent, markupEnabled, appearance ) {
    var result = new rwt.widgets.Grid( {
      "fullSelection" : true,
      "appearance" : appearance,
      "markupEnabled" : markupEnabled
    } );
    result.setLocation( 0, 0 );
    result.setParent( parent );
    result.setTreeColumn( -1 ); // TODO [tb] : should be default?
    result.setScrollBarsVisible( false, false );
    result.getRenderConfig().focused = true;
    result.addEventListener( "changeFocused", function() {
      result.getRenderConfig().focused = true;
    } );
    return result;
  };

  var inheritParentStyling = function() {
    this._.grid.setFont( this._.parent.getFont() );
    this._.grid.setTextColor( this._.parent.getTextColor() );
    this._.grid.setBackgroundColor( this._.parent.getBackgroundColor() );
    // [if] "default" fallback is needed to suppress ibeam cursor shown in Chrome and IE, when no
    // cursor (null) is set - bug 434311
    this._.grid.setCursor( this._.parent.getCursor() || "default" );
  };

  var checkDisposed = function( dropdown ) {
    if( dropdown.isDisposed() ) {
      throw new Error( "DropDown is disposed" );
    }
  };

  var createEventsMap = function() {
    var result = {};
    for( var key in eventTypes ) {
      result[ key ] = [];
    }
    return result;
  };

  var hasFocus = function( control ) {
    var root = control.getFocusRoot();
    if( root ) {
      return    control.getFocused()
             || ( control.contains && control.contains( root.getFocusedChild() ) );
    }
    return false;
  };

  var filterArray = function( arr, func, limit ) {
    var result = [];
    if( typeof arr.filter === "function" && limit === 0 ) {
      result = arr.filter( func );
    } else {
      for( var i = 0; i < arr.length; i++ ) {
        if( func( arr[ i ], i ) ) {
          result.push( arr[ i ] );
          if( limit !== 0 && result.length === limit ) {
            break;
          }
        }
      }
    }
    return result;
  };

  var getStyleMap = function() {
    if( this._.styleMap == null ) {
      var manager = rwt.theme.AppearanceManager.getInstance();
      var states = {};
      if( this._.customVariant ) {
        states[ this._.customVariant ] = true;
      }
      this._.styleMap = {
        "border" : manager.styleFrom( this._.appearance + "-popup", states ).border,
        "padding" : manager.styleFrom( this._.appearance + "-cell", states ).padding
      };
    }
    return this._.styleMap;
  };

  var addMouseWheelEventFilter = function() {
    rwt.event.EventHandler.setMouseEventFilter( filterMouseEvent, this );
  };

  var removeMouseWheelEventFilter = function() {
    var currentFilter = rwt.event.EventHandler.getMouseEventFilter();
    if( currentFilter && currentFilter[ 0 ] === filterMouseEvent && currentFilter[ 1 ] === this ) {
      rwt.event.EventHandler.setMouseEventFilter( null );
    }
  };

  var filterMouseEvent = function( event ) {
    if( event.getType() === "mousedown" ) {
      var target = event.getTarget();
      if(    target !== this._.popup && !this._.popup.contains( target )
          && target !== this._.parent && !this._.parent.contains( target ) )
      {
        this.hide();
      }
    } else if( event.getType() === "mousewheel" ) {
      event.preventDefault();
      this._.grid.getRowContainer().dispatchEvent( event );
      return false;
    }
    return true;
  };

}() );

/*******************************************************************************
 * Copyright (c) 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

namespace( "rwt.widgets.util" );

rwt.widgets.util.DropDownSynchronizer = function( dropdown ) {
  dropdown.addListener( "Show", this._onVisibleChanged );
  dropdown.addListener( "Hide", this._onVisibleChanged );
  dropdown.addListener( "Selection", this._onSelectionChanged );
  dropdown.addListener( "DefaultSelection", this._onSelectionChanged );
};

rwt.widgets.util.DropDownSynchronizer.prototype = {

  _onVisibleChanged : function( event ) {
    if( !rwt.remote.EventUtil.getSuspended() ) {
      var dropdown = event.widget;
      var connection = rwt.remote.Connection.getInstance();
      connection.getRemoteObject( dropdown ).set( "visible", dropdown.getVisible() );
    }
  },

  _onSelectionChanged : function( event ) {
    if( !rwt.remote.EventUtil.getSuspended() ) {
      var dropdown = event.widget;
      var remoteObject = rwt.remote.Connection.getInstance().getRemoteObject( dropdown );
      remoteObject.set( "selectionIndex", dropdown.getSelectionIndex() );
      // TODO : merge multiple changes? How long?
      remoteObject.notify( event.type, { "text" : event.text, "index" : event.index } );
    }
  }

};

/*******************************************************************************
 * Copyright (c) 2013, 2014 EclipseSource and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    EclipseSource - initial API and implementation
 ******************************************************************************/

/*jshint nonew:false */
(function() {
  'use strict';

  rap.registerTypeHandler( "rwt.widgets.DropDown", {

    factory : function( properties ) {
      var control = rwt.remote.ObjectRegistry.getObject( properties.parent );
      var dropdown = new rwt.widgets.DropDown( control, properties.markupEnabled, "dropdown" );
      new rwt.widgets.util.DropDownSynchronizer( dropdown );
      return dropdown;
    },

    properties : [ "items", "visible", "visibleItemCount", "columns", "data", "selectionIndex" ],

    events : [ "Selection", "DefaultSelection" ],

    methods : [ "addListener", "removeListener" ],

    methodHandler: {
      "addListener": function( widget, properties ) {
        rwt.remote.HandlerUtil.callWithTarget( properties.listenerId, function( targetFunction ) {
          widget.addListener( properties.eventType, targetFunction );
        } );
      },
      "removeListener": function( widget, properties ) {
        rwt.remote.HandlerUtil.callWithTarget( properties.listenerId, function( targetFunction ) {
          widget.removeListener( properties.eventType, targetFunction );
        } );
      }
    },

    destructor : "destroy"

  } );

}() );

rwt.theme.AppearanceManager.getInstance().setCurrentTheme( {
  name : "rwtAppearance",
  appearances : {

  "empty" : {
  },

  "widget" : {
  },

  "image" : {
  },

  /*
  ---------------------------------------------------------------------------
    CORE
  ---------------------------------------------------------------------------
  */

  "cursor-dnd-move" : {
    style : function() {
      return {
        source : rwt.remote.Connection.RESOURCE_PATH + "widget/rap/cursors/move.gif"
      };
    }
  },

  "cursor-dnd-copy" : {
    style : function() {
      return {
        source : rwt.remote.Connection.RESOURCE_PATH + "widget/rap/cursors/copy.gif"
      };
    }
  },

  "cursor-dnd-alias" : {
    style : function() {
      return {
        source : rwt.remote.Connection.RESOURCE_PATH + "widget/rap/cursors/alias.gif"
      };
    }
  },

  "cursor-dnd-nodrop" : {
    style : function() {
      return {
        source : rwt.remote.Connection.RESOURCE_PATH + "widget/rap/cursors/nodrop.gif"
      };
    }
  },

  "client-document" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      return {
        font : tv.getCssFont( "Display", "font" ),
        textColor : "black",
        backgroundColor : "white",
        backgroundImage : tv.getCssImage( "Display", "background-image" )
      };
    }
  },

  "client-document-blocker" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      var result = {
        cursor : "default",
        animation : tv.getCssAnimation( "Shell-DisplayOverlay", "animation" ),
        backgroundColor : tv.getCssColor( "Shell-DisplayOverlay", "background-color" ),
        backgroundImage : tv.getCssImage( "Shell-DisplayOverlay", "background-image" ),
        opacity : tv.getCssFloat( "Shell-DisplayOverlay", "opacity" )
      };
      if(    result.backgroundImage == null
          && result.backgroundColor == "undefined" ) {
        // A background image or color is always needed for mshtml to
        // block the events successfully.
        result.backgroundImage = "static/image/blank.gif";
      }
      return result;
    }
  },

  "atom" : {
    style : function() {
      return {
        cursor : "default",
        spacing : 4,
        width : "auto",
        height : "auto",
        horizontalChildrenAlign : "center",
        verticalChildrenAlign : "middle"
      };
    }
  },

  // Note: This appearance applies to qooxdoo labels.
  //       For SWT Label, see apperance "label-wrapper".
  //       Any styles set for this appearance cannot be overridden by themeing
  //       of controls that include a label! This is because the "inheritance"
  //       feature does not overwrite theme property values from themes.
  "label" : {
  },

  // Appearance used for qooxdoo "labelObjects" which are part of Atoms etc.
  "label-graytext" : {
    style : function( states ) {
    }
  },

  "htmlcontainer" : {
    include : "label"
  },

  "popup" : {
  },

  "iframe" : {
    style : function() {
      return { };
    }
  },

  /*
  ---------------------------------------------------------------------------
    RESIZER
  ---------------------------------------------------------------------------
  */

  // TODO [rst] necessary?

  "resizer" : {
    style : function() {
      return {};
    }
  },

  "resizer-frame" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      return {
        border : tv.getCssNamedBorder( "shadow" )
      };
    }
  },

  "widget-tool-tip" : {
    include : "popup",

    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      var result = {};
      result.border = tv.getCssBorder( "Widget-ToolTip", "border" );
      result.animation = tv.getCssAnimation( "Widget-ToolTip", "animation" );
      result.padding = tv.getCssBoxDimensions( "Widget-ToolTip", "padding" );
      result.textColor = tv.getCssColor( "Widget-ToolTip", "color" );
      result.font = tv.getCssFont( "Widget-ToolTip", "font" );
      result.backgroundColor = tv.getCssColor( "Widget-ToolTip", "background-color" );
      result.backgroundImage = tv.getCssImage( "Widget-ToolTip", "background-image" );
      result.backgroundGradient = tv.getCssGradient( "Widget-ToolTip", "background-image" );
      result.opacity = tv.getCssFloat( "Widget-ToolTip", "opacity" );
      result.shadow = tv.getCssShadow( "Widget-ToolTip", "box-shadow" );
      result.textAlign = tv.getCssIdentifier( "Widget-ToolTip", "text-align" );
      var getPointer = function( direction ) {
        var store = rwt.theme.ThemeStore.getInstance();
        var states = {};
        states[ direction ] = true;
        var result = store.getSizedImage( "Widget-ToolTip-Pointer", states, "background-image" );
        return result[ 0 ] ? result : null;
      };
      result.pointers = [
        getPointer( "up" ),
        getPointer( "right" ),
        getPointer( "down" ),
        getPointer( "left" )
      ];
      return result;
    }
  }
,

  "composite" : {
    style : function( states ) {
      var result = {};
      var tv = new rwt.theme.ThemeValues( states );
      result.backgroundColor = tv.getCssColor( "Composite", "background-color" );
      result.backgroundImage = tv.getCssImage( "Composite", "background-image" );
      result.backgroundRepeat = tv.getCssIdentifier( "Composite", "background-repeat" );
      result.backgroundPosition = tv.getCssIdentifier( "Composite", "background-position" );
      result.backgroundGradient = tv.getCssGradient( "Composite", "background-image" );
      result.border = tv.getCssBorder( "Composite", "border" );
      result.opacity = tv.getCssFloat( "Composite", "opacity" );
      result.shadow = tv.getCssShadow( "Composite", "box-shadow" );
      result.animation = tv.getCssAnimation( "Composite", "animation" );
      return result;
    }
  }
,

  "button" : {
    include : "atom",

    style : function( states ) {
      // [tb] exists for compatibility with the original qooxdoo button
      var result = {};
      var tv = new rwt.theme.ThemeValues( states );
      result.font = tv.getCssFont( "Button", "font" );
      var decoration = tv.getCssIdentifier( "Button", "text-decoration" );
      if( decoration != null && decoration !== "none" ) {
        var decoratedFont = new rwt.html.Font();
        decoratedFont.setSize( result.font.getSize() );
        decoratedFont.setFamily( result.font.getFamily() );
        decoratedFont.setBold( result.font.getBold() );
        decoratedFont.setItalic( result.font.getItalic() );
        decoratedFont.setDecoration( decoration );
        result.font = decoratedFont;
      }
      result.textColor = tv.getCssColor( "Button", "color" );
      result.backgroundColor = tv.getCssColor( "Button", "background-color" );
      result.backgroundImage = tv.getCssImage( "Button", "background-image" );
      result.backgroundRepeat = tv.getCssIdentifier( "Button", "background-repeat" );
      result.backgroundPosition = tv.getCssIdentifier( "Button", "background-position" );
      result.backgroundGradient = tv.getCssGradient( "Button", "background-image" );
      result.border = tv.getCssBorder( "Button", "border" );
      result.spacing = tv.getCssDimension( "Button", "spacing" );
      result.padding = tv.getCssBoxDimensions( "Button", "padding" );
      result.cursor = tv.getCssCursor( "Button", "cursor" );
      result.opacity = tv.getCssFloat( "Button", "opacity" );
      result.textShadow = tv.getCssShadow( "Button", "text-shadow" );
      result.shadow = tv.getCssShadow( "Button", "box-shadow" );
      return result;
    }
  },

  "push-button" : {
    include : "button",

    style : function( states ) {
      var result = {};
      var tv = new rwt.theme.ThemeValues( states );
      result.animation = tv.getCssAnimation( "Button", "animation" );
      if( states.rwt_ARROW ) {
        result.icon = tv.getCssSizedImage( "Button-ArrowIcon", "background-image" );
      }
      return result;
    }
  },

  // ------------------------------------------------------------------------
  // CheckBox

  "check-box" : {
    include : "button",

    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      return {
        selectionIndicator : tv.getCssSizedImage( "Button-CheckIcon", "background-image" )
      };
    }
  },


  // ------------------------------------------------------------------------
  // RadioButton

  "radio-button" : {
    include : "button",

    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      return {
        selectionIndicator : tv.getCssSizedImage( "Button-RadioIcon", "background-image" )
      };
    }
  }
,

  "combo" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      var result = {};
      result.border = tv.getCssBorder( "Combo", "border" );
      result.backgroundColor = tv.getCssColor( "Combo", "background-color" );
      result.backgroundGradient = tv.getCssGradient( "Combo", "background-image" );
      result.textColor = tv.getCssColor( "Combo", "color" );
      result.font = tv.getCssFont( "Combo", "font" );
      result.shadow = tv.getCssShadow( "Combo", "box-shadow" );
      return result;
    }
  },

  "combo-list" : {
    style : function() {
      return {};
    }
  },

  "combo-list-popup" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      return {
        border : tv.getCssBorder( "Combo-List", "border" ),
        shadow : tv.getCssShadow( "Combo-List", "box-shadow" )
      };
    }
  },

  "combo-list-row" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      return {
        foreground : tv.getCssColor( "Combo-List-Item", "color" ),
        background : tv.getCssColor( "Combo-List-Item", "background-color" ),
        backgroundImage : tv.getCssImage( "Combo-List-Item", "background-image" ),
        backgroundGradient : tv.getCssGradient( "Combo-List-Item", "background-image" ),
        textDecoration : tv.getCssIdentifier( "Combo-List-Item", "text-decoration" ),
        textShadow : tv.getCssShadow( "Combo-List-Item", "text-shadow" )
      };
    }
  },

  "combo-list-row-overlay" : {
    style : function() {
      return {
        foreground : "undefined",
        background : "undefined",
        backgroundImage : null,
        backgroundGradient : null
      };
    }
  },

  "combo-list-cell" : {
    style : function( states ) {
       var tv = new rwt.theme.ThemeValues( states );
       return {
         padding : tv.getCssBoxDimensions( "Combo-List-Item", "padding" )
       };
    }
  },

  "combo-field" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      var result = {};
      result.font = tv.getCssFont( "Combo", "font" );
      // [if] Do not apply top/bottom paddings on the client
      var cssPadding = tv.getCssBoxDimensions( "Combo-Field", "padding" );
      result.paddingRight = cssPadding[ 1 ];
      result.paddingLeft = cssPadding[ 3 ];
      result.width = null;
      result.height = null;
      result.left = 0;
      result.right = tv.getCssDimension( "Combo-Button", "width" );
      result.top = 0;
      result.bottom = 0;
      result.textColor = tv.getCssColor( "Combo", "color" );
      result.textShadow = tv.getCssShadow( "Combo", "text-shadow" );
      return result;
    }
  },

  "combo-button" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      var result = {};
      var border = tv.getCssBorder( "Combo-Button", "border" );
      var borderLeft = tv.getCssBorder( "Combo-Button", "border-left" );
      result.border = tv.mergeBorders( border, null, null, null, borderLeft );
      result.width = tv.getCssDimension( "Combo-Button", "width" );
      result.height = null;
      result.top = 0;
      result.bottom = 0;
      result.right = 0;
      result.icon = tv.getCssSizedImage( "Combo-Button-Icon", "background-image" );
      if( result.icon === rwt.theme.ThemeValues.NONE_IMAGE_SIZED ) {
        result.icon = tv.getCssSizedImage( "Combo-Button", "background-image" );
      } else {
        result.backgroundImage = tv.getCssImage( "Combo-Button", "background-image" );
      }
      result.backgroundGradient = tv.getCssGradient( "Combo-Button", "background-image" );
      // TODO [rst] rather use button.bgcolor?
      result.backgroundColor = tv.getCssColor( "Combo-Button", "background-color" );
      result.cursor = tv.getCssCursor( "Combo-Button", "cursor" );
      return result;
    }
  }
,

  "coolbar" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      var result = {};
      result.border = tv.getCssBorder( "*", "border" );
      result.backgroundGradient = tv.getCssGradient( "CoolBar", "background-image" );
      result.backgroundImage = tv.getCssImage( "CoolBar", "background-image" );
      return result;
    }
  },

  "coolitem" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      var result = {};
      result.border = tv.getCssBorder( "*", "border" );
      return result;
    }
  },

  "coolitem-handle" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      var result = {};
      if( states.vertical ) {
        result.height = tv.getCssDimension( "CoolItem-Handle", "width" );
      } else {
        result.width = tv.getCssDimension( "CoolItem-Handle", "width" );
      }
      result.border = tv.getCssBorder( "CoolItem-Handle", "border" );
      result.margin = [ 1, 2, 1, 0 ];
      result.cursor = "col-resize";
      return result;
    }
  }
,

  "ctabfolder" : {
    style: function( states ) {
      var result = {};
      var tv = new rwt.theme.ThemeValues( states );
      result.font = tv.getCssFont( "CTabItem", "font" );
      result.textColor = tv.getCssColor( "CTabItem", "color" );
      return result;
    }
  },

  "ctabfolder-body" : {
    style: function( states ) {
      var result = {};
      var tv = new rwt.theme.ThemeValues( states );
      result.backgroundColor = tv.getCssColor( "CTabItem", "background-color" );
      var width = states.rwt_BORDER ? 1 : 0;
      var color = tv.getCssColor( "CTabFolder", "border-color" );
      var radii = tv.getCssBoxDimensions( "CTabFolder", "border-radius" );
      if( radii.join( "" ) !== "0000" ) {
        if( states.barTop ) {
          radii = [ radii[ 0 ], radii[ 1 ], 0, 0 ];
        } else {
          radii = [ 0, 0, radii[ 2 ], radii[ 3 ] ];
        }
      }
      result.border = new rwt.html.Border( width, "solid", color, radii );
      return result;
    }
  },

  "ctabfolder-frame" : {
    style: function( states ) {
      var result = {};
      if( !states.rwt_FLAT ) {
        // get the background color for selected items
        var statesWithSelected = { "selected": true };
        for( var property in states ) {
          statesWithSelected[ property ] = states[ property ];
        }
        var tv = new rwt.theme.ThemeValues( statesWithSelected );
        var color = tv.getCssColor( "CTabItem", "background-color" );
        result.border = new rwt.html.Border( 2, "solid", color );
      } else {
        result.border = "undefined";
      }
      result.backgroundColor = "undefined";
      return result;
    }
  },

  "ctabfolder-separator" : {
    style: function( states ) {
      var result = {};
      var tv = new rwt.theme.ThemeValues( states );
      var color = tv.getCssColor( "CTabFolder", "border-color" );
      var border;
      if( states.barTop ) {
        border = new rwt.html.Border( [ 0, 0, 1, 0 ], "solid", color );
      } else {
        border = new rwt.html.Border( [ 1, 0, 0, 0 ], "solid", color );
      }
      result.border = border;
      return result;
    }
  },

  "ctab-item" : {
    style: function( states ) {
      var result = {};
      var tv = new rwt.theme.ThemeValues( states );
      result.font = tv.getCssFont( "CTabItem", "font" );
      var decoration = tv.getCssIdentifier( "CTabItem", "text-decoration" );
      if( decoration != null && decoration !== "none" ) {
        var decoratedFont = new rwt.html.Font();
        decoratedFont.setSize( result.font.getSize() );
        decoratedFont.setFamily( result.font.getFamily() );
        decoratedFont.setBold( result.font.getBold() );
        decoratedFont.setItalic( result.font.getItalic() );
        decoratedFont.setDecoration( decoration );
        result.font = decoratedFont;
      }
      var padding = tv.getCssBoxDimensions( "CTabItem", "padding" );
      result.paddingLeft = padding[ 3 ];
      result.paddingRight = padding[ 1 ];
      result.spacing = tv.getCssDimension( "CTabItem", "spacing" );
      result.textColor = tv.getCssColor( "CTabItem", "color" );
      result.textShadow = tv.getCssShadow( "CTabItem", "text-shadow" );
      var color = tv.getCssColor( "CTabFolder", "border-color" );
      // create a copy of the radii from theme
      var radii = tv.getCssBoxDimensions( "CTabFolder", "border-radius" ).slice( 0 );
      // cut off rounded corners at opposite side of tabs
      if( states.barTop ) {
        radii[ 2 ] = 0;
        radii[ 3 ] = 0;
      } else {
        radii[ 0 ] = 0;
        radii[ 1 ] = 0;
      }
      var rounded = radii[ 0 ] > 0 || radii[ 1 ] > 0 || radii[ 2 ] > 0 || radii[ 3 ] > 0;
      var borderWidths = [ 0, 0, 0, 0 ];
      if( !states.nextSelected ) {
        borderWidths[ 1 ] = 1;
      }
      if( states.selected ) {
        borderWidths[ 3 ] = 1;
        if( states.barTop ) {
          borderWidths[ 0 ] = 1;
        } else {
          borderWidths[ 2 ] = 1;
        }
      }
      if( states.firstItem && states.rwt_BORDER && !rounded ) {
        borderWidths[ 3 ] = 1;
      }
      if( rounded && states.selected ) {
        result.border = new rwt.html.Border( borderWidths, "solid", color, radii );
        result.containerOverflow = false;
      } else {
        result.border = new rwt.html.Border( borderWidths, "solid", color );
      }
      result.backgroundColor = tv.getCssColor( "CTabItem", "background-color" );
      result.backgroundImage = tv.getCssImage( "CTabItem", "background-image" );
      result.backgroundGradient = tv.getCssGradient( "CTabItem", "background-image" );
      result.cursor = "default";
      return result;
    }
  },

  "ctabfolder-button" : {
    style : function( states ) {
      var result = {};
      var tv = new rwt.theme.ThemeValues( states );
      if( states.over ) {
        result.backgroundColor = "white";
        var color = tv.getCssColor( "CTabFolder", "border-color" );
        result.border = new rwt.html.Border( 1, "solid", color );
      } else {
        result.backgroundColor = "undefined";
        result.border = "undefined";
      }
      return result;
    }
  },

  "ctabfolder-drop-down-button" : {
    include : "ctabfolder-button",
    style : function( states ) {
      var result = {};
      var tv = new rwt.theme.ThemeValues( states );
      result.icon = tv.getCssSizedImage( "CTabFolder-DropDownButton-Icon", "background-image" );
      return result;
    }
  }
,

  "group-box" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      return {
        backgroundColor : tv.getCssColor( "Group", "background-color" ),
        border : tv.getCssBorder( "Group", "border" ),
        font : tv.getCssFont( "Group", "font"),
        textColor : tv.getCssColor( "Group", "color" )
      };
    }
  },

  "group-box-legend" : {
    include : "atom",
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      return {
        top : 0,
        left : 0,
        border : tv.getCssBorder( "Group-Label", "border" ),
        padding : tv.getCssBoxDimensions( "Group-Label", "padding" ),
        margin : tv.getCssBoxDimensions( "Group-Label", "margin" ),
        backgroundColor : tv.getCssColor( "Group-Label", "background-color" ),
        backgroundImage : tv.getCssImage( "Group-Label", "background-image" ),
        backgroundRepeat : tv.getCssIdentifier( "Group-Label", "background-repeat" ),
        backgroundPosition : tv.getCssIdentifier( "Group-Label", "background-position" ),
        backgroundGradient : tv.getCssGradient( "Group-Label", "background-image" ),
        font : tv.getCssFont( "Group", "font"),
        textColor : tv.getCssColor( "Group-Label", "color" ),
        textShadow : tv.getCssShadow( "Group-Label", "text-shadow" )
      };
    }
  },

  "group-box-frame" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      var margin = tv.getCssBoxDimensions( "Group-Frame", "margin" );
      return {
        top : margin[ 0 ],
        right : margin[ 1 ],
        bottom : margin[ 2 ],
        left : margin[ 3 ],
        border : tv.getCssBorder( "Group-Frame", "border" )
      };
    }
  }
,

  "label-wrapper" : {
    style : function( states ) {
      var result = {};
      var tv = new rwt.theme.ThemeValues( states );
      result.font = tv.getCssFont( "Label", "font" );
      var decoration = tv.getCssIdentifier( "Label", "text-decoration" );
      if( decoration != null && decoration != "none" ) {
        var decoratedFont = new rwt.html.Font();
        decoratedFont.setSize( result.font.getSize() );
        decoratedFont.setFamily( result.font.getFamily() );
        decoratedFont.setBold( result.font.getBold() );
        decoratedFont.setItalic( result.font.getItalic() );
        decoratedFont.setDecoration( decoration );
        result.font = decoratedFont;
      }
      result.textColor = tv.getCssColor( "Label", "color" );
      result.backgroundColor = tv.getCssColor( "Label", "background-color" );
      result.backgroundImage = tv.getCssImage( "Label", "background-image" );
      result.backgroundRepeat = tv.getCssIdentifier( "Label", "background-repeat" );
      result.backgroundPosition = tv.getCssIdentifier( "Label", "background-position" );
      result.backgroundGradient = tv.getCssGradient( "Label", "background-image" );
      result.border = tv.getCssBorder( "Label", "border" );
      result.cursor = tv.getCssCursor( "Label", "cursor" );
      result.opacity = tv.getCssFloat( "Label", "opacity" );
      result.textShadow = tv.getCssShadow( "Label", "text-shadow" );
      return result;
    }
  },

  "separator-line" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      var result = {};
      if( states.rwt_VERTICAL ) {
        result.width = tv.getCssDimension( "Label-SeparatorLine", "width" );
      } else {
        result.height = tv.getCssDimension( "Label-SeparatorLine", "width" );
      }
      result.border = tv.getCssBorder( "Label-SeparatorLine", "border" );
      result.backgroundColor = tv.getCssColor( "Label-SeparatorLine", "background-color" );
      result.backgroundImage = tv.getCssImage( "Label-SeparatorLine", "background-image" );
      result.backgroundGradient = tv.getCssGradient( "Label-SeparatorLine", "background-image" );
      return result;
    }
  },

  "separator" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      return {
        backgroundColor : tv.getCssColor( "Label", "background-color" ),
        backgroundImage : tv.getCssImage( "Label", "background-image" ),
        backgroundGradient : tv.getCssGradient( "Label", "background-image" ),
        border : tv.getCssBorder( "Label", "border" ),
        cursor : tv.getCssCursor( "Label", "cursor" ),
        opacity : tv.getCssFloat( "Label", "opacity" )
      };
    }
  }
,

 "link" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      return {
        cursor: "default",
        padding : 2,
        font : tv.getCssFont( "Link", "font" ),
        border : tv.getCssBorder( "Link", "border" ),
        textColor : tv.getCssColor( "Link", "color" ),
        backgroundColor : tv.getCssColor( "Link", "background-color" ),
        backgroundImage : tv.getCssImage( "Link", "background-image" ),
        backgroundRepeat : tv.getCssIdentifier( "Link", "background-repeat" ),
        backgroundPosition : tv.getCssIdentifier( "Link", "background-position" ),
        textShadow : tv.getCssShadow( "Link", "text-shadow" )
      };
    }
  },

  "link-hyperlink" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      return {
        textColor : tv.getCssColor( "Link-Hyperlink", "color" ),
        textShadow : tv.getCssShadow( "Link-Hyperlink", "text-shadow" ),
        textDecoration : tv.getCssIdentifier( "Link-Hyperlink", "text-decoration" ),
        cursor : states.disabled ? "default" : "pointer"
      };
    }
  }
,

  "list" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      var result = {};
      result.cursor = "default";
      result.overflow = "hidden";
      result.font = tv.getCssFont( "List", "font" );
      result.textColor = tv.getCssColor( "List", "color" );
      result.backgroundColor = tv.getCssColor( "List", "background-color" );
      result.border = tv.getCssBorder( "List", "border" );
      return result;
    }
  },

  "list-item" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      var result = {
        height : "auto",
        horizontalChildrenAlign : "left",
        verticalChildrenAlign : "top",
        spacing : 4
      };
      var gridColor = tv.getCssColor( "List-GridLine", "color" );
      if( gridColor !== "undefined" ) {
        result.border = new rwt.html.Border( [ 0, 0, 1, 0 ], "solid", gridColor );
      }
      var textColor = tv.getCssColor( "List-Item", "color" );
      result.textColor = textColor === "undefined" ? "inherit" : textColor;
      result.backgroundColor = tv.getCssColor( "List-Item", "background-color" );
      result.backgroundImage = tv.getCssImage( "List-Item", "background-image" );
      result.backgroundRepeat = tv.getCssIdentifier( "List-Item", "background-repeat" );
      result.backgroundPosition = tv.getCssIdentifier( "List-Item", "background-position" );
      result.backgroundGradient = tv.getCssGradient( "List-Item", "background-image" );
      result.textShadow = tv.getCssShadow( "List-Item", "text-shadow" );
      result.padding = tv.getCssBoxDimensions( "List-Item", "padding" );
      return result;
    }
  }
,

  "menu" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      return {
        width : "auto",
        height : "auto",
        textColor : tv.getCssColor( "Menu", "color" ),
        backgroundColor : tv.getCssColor( "Menu", "background-color" ),
        backgroundImage : tv.getCssImage( "Menu", "background-image" ),
        backgroundGradient : tv.getCssGradient( "Menu", "background-image" ),
        animation : tv.getCssAnimation( "Menu", "animation" ),
        font : tv.getCssFont( "Menu", "font" ),
        overflow : "hidden",
        border : tv.getCssBorder( "Menu", "border" ),
        padding : tv.getCssBoxDimensions( "Menu", "padding" ),
        opacity : tv.getCssFloat( "Menu", "opacity" ),
        shadow : tv.getCssShadow( "Menu", "box-shadow" )
      };
    }
  },

  "menu-item" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      var result = {
        spacing : 2,
        padding : tv.getCssBoxDimensions( "MenuItem", "padding" ),
        backgroundImage : tv.getCssImage( "MenuItem", "background-image" ),
        backgroundGradient : tv.getCssGradient( "MenuItem", "background-image" ),
        backgroundColor : tv.getCssColor( "MenuItem", "background-color" ),
        height : states.onMenuBar ? "100%" : "auto",
        opacity : tv.getCssFloat( "MenuItem", "opacity" ),
        textShadow : tv.getCssShadow( "MenuItem", "text-shadow" )
      };
      result.textColor = tv.getCssColor( "MenuItem", "color" );
      if( states.cascade ) {
        result.arrow = tv.getCssSizedImage( "MenuItem-CascadeIcon", "background-image" );
      } else {
        result.arrow = null;
      }
      if( states.selected ) {
        if( states.check ) {
           result.selectionIndicator
             = tv.getCssSizedImage( "MenuItem-CheckIcon", "background-image" );
        } else if( states.radio ) {
           result.selectionIndicator
             = tv.getCssSizedImage( "MenuItem-RadioIcon", "background-image" );
        }
      } else {
        if( states.radio ) {
          var radioWidth = tv.getCssSizedImage( "MenuItem-RadioIcon", "background-image" )[ 1 ];
          result.selectionIndicator = [ null, radioWidth, 0 ];
        } else if( states.check ) {
          var checkWidth = tv.getCssSizedImage( "MenuItem-CheckIcon", "background-image" )[ 1 ];
          result.selectionIndicator = [ null, checkWidth, 0 ];
        } else {
          result.selectionIndicator = null;
        }
      }
      return result;
    }
  },

  "menu-separator" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      return {
        height : "auto",
        marginTop : 3,
        marginBottom : 2,
        padding : tv.getCssBoxDimensions( "MenuItem", "padding" )
      };
    }
  },

  "menu-separator-line" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      return {
        right : 0,
        left : 0,
        height : 0,
        border : tv.getCssNamedBorder( "verticalDivider" )
      };
    }
  }
,

  "progressbar" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      var result = {};
      result.border = tv.getCssBorder( "ProgressBar", "border" );
      result.backgroundColor = tv.getCssColor( "ProgressBar", "background-color" );
      result.backgroundImage = tv.getCssImage( "ProgressBar", "background-image" );
      result.backgroundGradient = tv.getCssGradient( "ProgressBar", "background-image" );
      result.indicatorColor = tv.getCssColor( "ProgressBar-Indicator", "background-color" );
      result.indicatorImage = tv.getCssImage( "ProgressBar-Indicator", "background-image" );
      result.indicatorGradient = tv.getCssGradient( "ProgressBar-Indicator", "background-image" );
      result.indicatorOpacity = tv.getCssFloat( "ProgressBar-Indicator", "opacity" );
      return result;
    }
  },

  "scrollbar-blocker" : {
    style : function() {
      return {
        backgroundColor : "black",
        opacity : 0.2
      };
    }
  }
,

  "window" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      var result = {};
      // padding is only applied on the server, since client area content is
      // positioned absolutely
      result.backgroundColor = tv.getCssColor( "Shell", "background-color" );
      result.backgroundImage = tv.getCssImage( "Shell", "background-image" );
      result.backgroundGradient = tv.getCssGradient( "Shell", "background-image" );
      result.border = tv.getCssBorder( "Shell", "border" );
      result.minWidth = states.rwt_TITLE ? 80 : 5;
      result.minHeight = states.rwt_TITLE ? 25 : 5;
      result.opacity = tv.getCssFloat( "Shell", "opacity" );
      result.shadow = tv.getCssShadow( "Shell", "box-shadow" );
      result.animation = tv.getCssAnimation( "Shell", "animation" );
      return result;
    }
  },

  "window-captionbar" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      var result = {
        verticalChildrenAlign : "middle"
      };
      result.margin = tv.getCssBoxDimensions( "Shell-Titlebar", "margin" );
      result.padding = tv.getCssBoxDimensions( "Shell-Titlebar", "padding" );
      result.textColor = tv.getCssColor( "Shell-Titlebar", "color" );
      result.backgroundColor = tv.getCssColor( "Shell-Titlebar", "background-color" );
      result.backgroundImage = tv.getCssImage( "Shell-Titlebar", "background-image" );
      result.backgroundGradient = tv.getCssGradient( "Shell-Titlebar", "background-image" );
      result.border = tv.getCssBorder( "Shell-Titlebar", "border" );
      if( states.rwt_TITLE ) {
        result.minHeight = tv.getCssDimension( "Shell-Titlebar", "height" );
      } else {
        result.minHeight = 0;
      }
      result.maxHeight = result.minHeight;
      result.textShadow = tv.getCssShadow( "Shell-Titlebar", "text-shadow" );
      return result;
    }
  },

  "window-resize-frame" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      return {
        border : tv.getCssNamedBorder( "shadow" )
      };
    }
  },

  "window-captionbar-icon" : {
    style : function() {
      return {
        marginRight : 2
      };
    }
  },

  "window-captionbar-title" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      return {
        cursor : "default",
        font : tv.getCssFont( "Shell-Titlebar", "font" ),
        marginRight : 2
      };
    }
  },

  "window-captionbar-minimize-button" : {
    style : function( states ) {
      var result = {};
      var tv = new rwt.theme.ThemeValues( states );
      result.icon = tv.getCssSizedImage( "Shell-MinButton", "background-image" );
      result.margin = tv.getCssBoxDimensions( "Shell-MinButton", "margin" );
      return result;
    }
  },

  "window-captionbar-maximize-button" : {
    style : function( states ) {
      var result = {};
      var tv = new rwt.theme.ThemeValues( states );
      result.icon = tv.getCssSizedImage( "Shell-MaxButton", "background-image" );
      result.margin = tv.getCssBoxDimensions( "Shell-MaxButton", "margin" );
      return result;
    }
  },

  "window-captionbar-restore-button" : {
    include : "window-captionbar-maximize-button"
  },

  "window-captionbar-close-button" : {
    style : function( states ) {
      var result = {};
      var tv = new rwt.theme.ThemeValues( states );
      result.icon = tv.getCssSizedImage( "Shell-CloseButton", "background-image" );
      result.margin = tv.getCssBoxDimensions( "Shell-CloseButton", "margin" );
      return result;
    }
  },

  "window-statusbar" : {
    style : function() {
      return {};
    }
  },

  "window-statusbar-text" : {
    style : function() {
      return {};
    }
  }
,

  "spinner" : {
    style : function( states ) {
      var result = {};
      var tv = new rwt.theme.ThemeValues( states );
      result.font = tv.getCssFont( "Spinner", "font" );
      result.textColor = tv.getCssColor( "Spinner", "color" );
      result.backgroundColor = tv.getCssColor( "Spinner", "background-color" );
      result.border = tv.getCssBorder( "Spinner", "border" );
      result.backgroundGradient = tv.getCssGradient( "Spinner", "background-image" );
      result.shadow = tv.getCssShadow( "Spinner", "box-shadow" );
      return result;
    }
  },

  "spinner-text-field" : {
    style : function( states ) {
      var result = {};
      var tv = new rwt.theme.ThemeValues( states );
      // [if] Do not apply top/bottom paddings on the client
      var cssPadding = tv.getCssBoxDimensions( "Spinner-Field", "padding" );
      result.paddingRight = cssPadding[ 1 ];
      result.paddingLeft = cssPadding[ 3 ];
      result.top = 0;
      result.left = 0;
      result.right = 0;
      result.bottom = 0;
      result.textColor = tv.getCssColor( "Spinner", "color" );
      result.textShadow = tv.getCssShadow( "Spinner", "text-shadow" );
      return result;
    }
  },

  "spinner-button-up" : {
    style : function( states ) {
      var result = {};
      var tv = new rwt.theme.ThemeValues( states );
      var border = tv.getCssBorder( "Spinner-UpButton", "border" );
      var borderLeft = tv.getCssBorder( "Spinner-UpButton", "border-left" );
      result.border = tv.mergeBorders( border, null, null, null, borderLeft );
      result.width = tv.getCssDimension( "Spinner-UpButton", "width" );
      result.icon = tv.getCssSizedImage( "Spinner-UpButton-Icon", "background-image" );
      if( result.icon === rwt.theme.ThemeValues.NONE_IMAGE ) {
        result.icon = tv.getCssSizedImage( "Spinner-UpButton", "background-image" );
      } else {
        result.backgroundImage = tv.getCssImage( "Spinner-UpButton", "background-image" );
      }
      result.backgroundGradient = tv.getCssGradient( "Spinner-UpButton", "background-image" );
      result.backgroundColor = tv.getCssColor( "Spinner-UpButton", "background-color" );
      result.cursor = tv.getCssCursor( "Spinner-UpButton", "cursor" );
      return result;
    }
  },

  "spinner-button-down" : {
    style : function( states ) {
      var result = {};
      var tv = new rwt.theme.ThemeValues( states );
      var border = tv.getCssBorder( "Spinner-DownButton", "border" );
      var borderLeft = tv.getCssBorder( "Spinner-DownButton", "border-left" );
      result.border = tv.mergeBorders( border, null, null, null, borderLeft );
      result.width = tv.getCssDimension( "Spinner-DownButton", "width" );
      result.icon = tv.getCssSizedImage( "Spinner-DownButton-Icon", "background-image" );
      if( result.icon === rwt.theme.ThemeValues.NONE_IMAGE ) {
        result.icon = tv.getCssSizedImage( "Spinner-DownButton", "background-image" );
      } else {
        result.backgroundImage = tv.getCssImage( "Spinner-DownButton", "background-image" );
      }
      result.backgroundGradient = tv.getCssGradient( "Spinner-DownButton", "background-image" );
      result.backgroundColor = tv.getCssColor( "Spinner-DownButton", "background-color" );
      result.cursor = tv.getCssCursor( "Spinner-DownButton", "cursor" );
      return result;
    }
  }
,

  "tab-view" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      var result = {};
      result.textColor = tv.getCssColor( "*", "color" );
      result.font = tv.getCssFont( "TabFolder", "font" );
      result.spacing = -1;
      result.border = tv.getCssBorder( "TabFolder", "border" );
      return result;
    }
  },

  "tab-view-bar" : {
    style : function() {
      return {
        height : "auto"
      };
    }
  },

  "tab-view-pane" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      var result = {};
      result.overflow = "hidden";
      result.backgroundColor = tv.getCssColor( "*", "background-color" );
      result.border = tv.getCssBorder( "TabFolder-ContentContainer", "border" );
      return result;
    }
  },

  "tab-item" : {
    style : function( states ) {
      var result = {};
      var tv = new rwt.theme.ThemeValues( states );
      var containerBorder = tv.getCssBorder( "TabFolder-ContentContainer", "border" );
      result.padding = tv.getCssBoxDimensions( "TabItem", "padding" );
      if( states.checked ) {
        result.zIndex = 1; // TODO [rst] Doesn't this interfere with our z-order?
        if( states.barTop ) {
          // Hack to hide the content containder border below the selected tab
          result.paddingBottom = result.padding[ 2 ] + containerBorder.getWidthTop() + 1;
        } else {
          // Hack to hide the content containder border below the selected tab
          result.paddingTop = result.padding[ 0 ] + containerBorder.getWidthTop() + 1;
        }
      } else {
        result.zIndex = 0; // TODO [rst] Doesn't this interfere with our z-order?
      }
      result.border = tv.getCssBorder( "TabItem", "border" );
      result.margin = tv.getCssBoxDimensions( "TabItem", "margin" );
      result.textColor = tv.getCssColor( "TabItem", "color" );
      result.backgroundColor = tv.getCssColor( "TabItem", "background-color" );
      result.backgroundImage = tv.getCssImage( "TabItem", "background-image" );
      result.backgroundRepeat = tv.getCssIdentifier( "TabItem", "background-repeat" );
      result.backgroundPosition = tv.getCssIdentifier( "TabItem", "background-position" );
      result.backgroundGradient = tv.getCssGradient( "TabItem", "background-image" );
      result.textShadow = tv.getCssShadow( "TabItem", "text-shadow" );
      return result;
    }
  }
,

  "table" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      return {
        textColor : tv.getCssColor( "Table", "color" ),
        font : tv.getCssFont( "Table", "font" ),
        border : tv.getCssBorder( "Table", "border" ),
        backgroundColor : tv.getCssColor( "Table", "background-color" ),
        backgroundImage : tv.getCssImage( "Table", "background-image" ),
        backgroundGradient : tv.getCssGradient( "Table", "background-image" )
      };
    }
  },

  "table-column" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      var result = {
        cursor : "default",
        spacing : 2,
        opacity : states.moving ? 0.85 : 1.0
      };
      result.padding = tv.getCssBoxDimensions( "TableColumn", "padding" );
      result.textColor = tv.getCssColor( "TableColumn", "color" );
      result.font = tv.getCssFont( "TableColumn", "font" );
      result.backgroundColor = tv.getCssColor( "TableColumn", "background-color" );
      result.backgroundImage = tv.getCssImage( "TableColumn", "background-image" );
      result.backgroundGradient = tv.getCssGradient( "TableColumn", "background-image" );
      var borderColors = [ null, null, null, null ];
      var borderWidths = [ 0, 0, 0, 0 ];
      var borderStyles = [ "solid", "solid", "solid", "solid" ];
      if( !states.dummy ) {
        var gridLineStates = { "vertical" : true, "header" : true };
        var tvGrid = new rwt.theme.ThemeValues( gridLineStates );
        var gridColor = tvGrid.getCssColor( "Table-GridLine", "color" );
        gridColor = gridColor == "undefined" ? "transparent" : gridColor;
        borderColors[ 1 ] = gridColor;
        borderWidths[ 1 ] = 1;
        if( states.moving ) {
          borderColors[ 3 ] = gridColor;
          borderWidths[ 3 ] = 1;
        }
      }
      var borderBottom = tv.getCssBorder( "TableColumn", "border-bottom" );
      borderWidths[ 2 ] = borderBottom.getWidthBottom();
      borderStyles[ 2 ] = borderBottom.getStyleBottom();
      borderColors[ 2 ] = borderBottom.getColorBottom();
      result.border = new rwt.html.Border( borderWidths, borderStyles, borderColors );
      result.textShadow = tv.getCssShadow( "TableColumn", "text-shadow" );
      result.textOverflow = tv.getCssIdentifier( "TableColumn", "text-overflow" );
      return result;
    }
  },

  "table-column-resizer" : {
    style : function() {
      return {
        width : 3,
        opacity : 0.3,
        backgroundColor : "black"
      };
    }
  },

  "table-column-sort-indicator" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      var result = {};
      result.backgroundImage = tv.getCssSizedImage( "TableColumn-SortIndicator", "background-image" );
      return result;
    }
  },

  "table-row" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      var result = {};
      result.background = tv.getCssColor( "TableItem", "background-color" );
      result.backgroundImage = tv.getCssImage( "TableItem", "background-image" );
      result.backgroundGradient = tv.getCssGradient( "TableItem", "background-image" );
      result.foreground = tv.getCssColor( "TableItem", "color" );
      result.textDecoration = tv.getCssIdentifier( "TableItem", "text-decoration" );
      result.textShadow = tv.getCssShadow( "TableItem", "text-shadow" );
      result.textOverflow = tv.getCssIdentifier( "TableItem", "text-overflow" );
      return result;
    }
  },

  "table-row-overlay" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      var result = {};
      result.background = tv.getCssColor( "Table-RowOverlay", "background-color" );
      result.backgroundAlpha = tv.getCssAlpha( "Table-RowOverlay", "background-color" );
      result.backgroundImage = tv.getCssImage( "Table-RowOverlay", "background-image" );
      result.backgroundGradient = tv.getCssGradient( "Table-RowOverlay", "background-image" );
      result.foreground = tv.getCssColor( "Table-RowOverlay", "color" );
      return result;
    }
  },

  "table-row-check-box" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      return {
        backgroundImage : tv.getCssImage( "Table-Checkbox", "background-image" )
      };
    }
  },

  "table-gridline-vertical" : {
    style : function() {
      var verticalState = { "vertical" : true };
      var tv = new rwt.theme.ThemeValues( verticalState );
      var gridColor = tv.getCssColor( "Table-GridLine", "color" );
      gridColor = gridColor == "undefined" ? "transparent" : gridColor;
      var result = {};
      result.border = new rwt.html.Border( [ 0, 0, 0, 1 ], "solid", gridColor );
      return result;
    }
  },

  "table-cell" : {
    style : function( states ) {
       var tv = new rwt.theme.ThemeValues( states );
       var result = {};
       result.spacing = tv.getCssDimension( "Table-Cell", "spacing" );
       result.padding = tv.getCssBoxDimensions( "Table-Cell", "padding" );
       return result;
    }
  }
,

  "text-field" : {
    style : function( states ) {
      var result = {};
      var tv = new rwt.theme.ThemeValues( states );
      result.font = tv.getCssFont( "Text", "font" );
      result.textColor = tv.getCssColor( "Text", "color" );
      result.backgroundColor = tv.getCssColor( "Text", "background-color" );
      result.backgroundImage = tv.getCssImage( "Text", "background-image" );
      result.backgroundRepeat = tv.getCssIdentifier( "Text", "background-repeat" );
      result.backgroundPosition = tv.getCssIdentifier( "Text", "background-position" );
      result.backgroundGradient = tv.getCssGradient( "Text", "background-image" );
      result.border = tv.getCssBorder( "Text", "border" );
      // [if] Do not apply top/bottom paddings on the client
      var cssPadding = tv.getCssBoxDimensions( "Text", "padding" );
      result.paddingRight = cssPadding[ 1 ];
      result.paddingLeft = cssPadding[ 3 ];
      result.textShadow = tv.getCssShadow( "Text", "text-shadow" );
      result.shadow = tv.getCssShadow( "Text", "box-shadow" );
      return result;
    }
  },

  "text-field-icon" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      var selector = states.search ? "Text-Search-Icon" : "Text-Cancel-Icon";
      return {
        icon : tv.getCssSizedImage( selector, "background-image" ),
        spacing : tv.getCssDimension( selector, "spacing" )
      };
    }
  },

  "text-field-message" : {
    style : function( states ) {
      var result = {};
      var tv = new rwt.theme.ThemeValues( states );
      result.textColor = tv.getCssColor( "Text-Message", "color" );
      // [if] Do not apply top/bottom paddings on the client
      var cssPadding = tv.getCssBoxDimensions( "Text", "padding" );
      result.paddingRight = cssPadding[ 1 ];
      result.paddingLeft = cssPadding[ 3 ];
      result.horizontalChildrenAlign = "left";
      result.textShadow = tv.getCssShadow( "Text-Message", "text-shadow" );
      return result;
    }
  },

  "text-area" : {
    include : "text-field",
    style : function() {
      return {
        padding : [ 0, 0, 0, 3 ]
      };
    }
  }
,

  "toolbar" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      return {
        font : tv.getCssFont( "ToolBar", "font" ),
        overflow : "hidden",
        border : tv.getCssBorder( "ToolBar", "border" ),
        textColor : tv.getCssColor( "ToolBar", "color" ),
        backgroundColor : tv.getCssColor( "ToolBar", "background-color" ),
        backgroundGradient : tv.getCssGradient( "ToolBar", "background-image" ),
        backgroundImage : tv.getCssImage( "ToolBar", "background-image" ),
        opacity : tv.getCssFloat( "ToolBar", "opacity" )
      };
    }
  },

  "toolbar-separator" : {
    style : function() {
      return {};
    }
  },

  "toolbar-separator-line" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      var result = null;
      if( states.vertical ) {
        result = {
          left : 2,
          height : 2,
          right : 2,
          border : tv.getCssNamedBorder( "verticalDivider" )
        };
      } else {
        result = {
          top : 2,
          width : 2,
          bottom : 2,
          border : tv.getCssNamedBorder( "horizontalDivider" )
        };
      }
      return result;
    }
  },

  "toolbar-button" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      var result = {
        cursor : "default",
        overflow : "hidden",
        width : "auto",
        verticalChildrenAlign : "middle"
      };
      result.spacing = tv.getCssDimension( "ToolItem", "spacing" );
      result.animation = tv.getCssAnimation( "ToolItem", "animation" );
      var textColor = tv.getCssColor( "ToolItem", "color" );
      result.textColor = textColor === "undefined" ? "inherit" : textColor;
      result.textShadow = tv.getCssShadow( "ToolItem", "text-shadow" );
      result.backgroundColor = tv.getCssColor( "ToolItem", "background-color" );
      result.opacity = tv.getCssFloat( "ToolItem", "opacity" );
      result.backgroundImage = tv.getCssImage( "ToolItem", "background-image" );
      result.backgroundGradient = tv.getCssGradient( "ToolItem", "background-image" );
      result.border = tv.getCssBorder( "ToolItem", "border" );
      result.padding = tv.getCssBoxDimensions( "ToolItem", "padding" );
      result.vertical = !states.rwt_RIGHT;
      result.horizontalChildrenAlign = ( states.rwt_VERTICAL && states.rwt_RIGHT ) ? "left" : "center";
      if( states.dropDown ) {
        result.dropDownArrow = tv.getCssSizedImage( "ToolItem-DropDownIcon", "background-image" );
        result.separatorBorder = tv.getCssBorder( "ToolItem-DropDownIcon", "border" );
      } else {
        result.dropDownArrow = null;
        result.separatorBorder = null;
      }
      return result;
    }
  }
,

  "tree" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      return {
        backgroundColor : tv.getCssColor( "Tree", "background-color" ),
        textColor : tv.getCssColor( "Tree", "color" ),
        font : tv.getCssFont( "Tree", "font" ),
        border : tv.getCssBorder( "Tree", "border" )
      };
    }
  },

  "tree-row" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      var result = {};
      result.background = tv.getCssColor( "TreeItem", "background-color" );
      result.backgroundImage = tv.getCssImage( "TreeItem", "background-image" );
      result.backgroundGradient = tv.getCssGradient( "TreeItem", "background-image" );
      result.foreground = tv.getCssColor( "TreeItem", "color" );
      result.textDecoration = tv.getCssIdentifier( "TreeItem", "text-decoration" );
      result.textShadow = tv.getCssShadow( "TreeItem", "text-shadow" );
      result.textOverflow = tv.getCssIdentifier( "TreeItem", "text-overflow" );
      return result;
    }
  },

  "tree-row-overlay" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      var result = {};
      result.background = tv.getCssColor( "Tree-RowOverlay", "background-color" );
      result.backgroundAlpha = tv.getCssAlpha( "Tree-RowOverlay", "background-color" );
      result.backgroundImage = tv.getCssImage( "Tree-RowOverlay", "background-image" );
      result.backgroundGradient = tv.getCssGradient( "Tree-RowOverlay", "background-image" );
      result.foreground = tv.getCssColor( "Tree-RowOverlay", "color" );
      return result;
    }
  },

  "tree-row-check-box" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      return {
        backgroundImage : tv.getCssImage( "Tree-Checkbox", "background-image" )
      };
    }
  },

  "tree-row-indent" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      return {
        backgroundImage : tv.getCssImage( "Tree-Indent", "background-image" )
      };
    }
  },

  "tree-column" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      var result = {};
      result.cursor = "default";
      result.spacing = 2;
      result.textColor = tv.getCssColor( "TreeColumn", "color" );
      result.font = tv.getCssFont( "TreeColumn", "font" );
      if( states.footer ) {
        //result.backgroundColor = "#efefef"; // this would make it "merged" with scrollbars
        result.backgroundColor = "#dddddd";
        result.backgroundImage = null;
        result.backgroundGradient = null;
      } else {
        result.backgroundColor = tv.getCssColor( "TreeColumn", "background-color" );
        result.backgroundImage = tv.getCssImage( "TreeColumn", "background-image" );
        result.backgroundGradient = tv.getCssGradient( "TreeColumn", "background-image" );
      }
      result.opacity = states.moving ? 0.85 : 1.0;
      result.padding = tv.getCssBoxDimensions( "TreeColumn", "padding" );
      var borderColors = [ null, null, null, null ];
      var borderWidths = [ 0, 0, 0, 0 ];
      var borderStyles = [ "solid", "solid", "solid", "solid" ];
      if( !states.dummy && !states.footer ) {
        var gridLineStates = { "vertical" : true, "header" : true };
        var tvGrid = new rwt.theme.ThemeValues( gridLineStates );
        var gridColor = tvGrid.getCssColor( "Tree-GridLine", "color" );
        gridColor = gridColor == "undefined" ? "transparent" : gridColor;
        borderColors[ 1 ] = gridColor;
        borderWidths[ 1 ] = 1;
        if( states.moving ) {
          borderColors[ 3 ] = gridColor;
          borderWidths[ 3 ] = 1;
        }
      }
      var borderBottom = tv.getCssBorder( "TreeColumn", "border-bottom" );
      if( states.footer ) {
        borderWidths[ 0 ] = borderBottom.getWidthBottom();
        borderStyles[ 0 ] = "solid";
        borderColors[ 0 ] = "#000000";
      } else {
        borderWidths[ 2 ] = borderBottom.getWidthBottom();
        borderStyles[ 2 ] = borderBottom.getStyleBottom();
        borderColors[ 2 ] = borderBottom.getColorBottom();
      }
      result.border = new rwt.html.Border( borderWidths, borderStyles, borderColors );
      result.textShadow = tv.getCssShadow( "TreeColumn", "text-shadow" );
      result.textOverflow = tv.getCssIdentifier( "TreeColumn", "text-overflow" );
      return result;
    }
  },

  "tree-column-sort-indicator" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      var result = {};
      result.backgroundImage = tv.getCssSizedImage( "TreeColumn-SortIndicator", "background-image" );
      return result;
    }
  },

  "tree-column-chevron" : {
    style : function( states ) {
      var result = {};
      var path = rwt.remote.Connection.RESOURCE_PATH + "widget/rap/";
      if( states.loading ) {
        result.backgroundImage = [ path + "tree/loading.gif", 16, 16 ];
      } else {
        var source = path + "arrows/chevron-";
        source += states.expanded ? "left" : "right";
        source += states.mouseover ? "-hover" : "";
        source += ".png";
        result.backgroundImage = [ source, 10, 7 ];
      }
      return result;
    }
  },

  "tree-cell" : {
    style : function( states ) {
       var tv = new rwt.theme.ThemeValues( states );
       var result = {};
       result.spacing = tv.getCssDimension( "Tree-Cell", "spacing" );
       result.padding = tv.getCssBoxDimensions( "Tree-Cell", "padding" );
       return result;
    }
  }
,

  "scale" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      return {
        border : tv.getCssBorder( "Scale", "border" ),
        font : tv.getCssFont( "*", "font" ),
        textColor : tv.getCssColor( "*", "color" ),
        backgroundColor : tv.getCssColor( "Scale", "background-color" ),
        backgroundImage : tv.getCssImage( "Scale", "background-image" ),
        backgroundGradient : tv.getCssGradient( "Scale", "background-image" ),
      };
    }
  },

  "scale-line" : {
    include : "image",

    style : function( states ) {
      var result = {};
      var path = rwt.remote.Connection.RESOURCE_PATH + "widget/rap/scale/";
      if( states[ "rwt_HORIZONTAL" ] ) {
        result.left = rwt.widgets.Scale.PADDING;
        result.top = rwt.widgets.Scale.SCALE_LINE_OFFSET;
        result.source = path + "h_line.gif";
      } else {
        result.left = rwt.widgets.Scale.SCALE_LINE_OFFSET;
        result.top = rwt.widgets.Scale.PADDING;
        result.source = path + "v_line.gif";
      }
      return result;
    }
  },

  "scale-thumb" : {
    include : "atom",

    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      var result = {};
      if( states[ "rwt_HORIZONTAL" ] ) {
        result.left = rwt.widgets.Scale.PADDING;
        result.top = rwt.widgets.Scale.THUMB_OFFSET;
        // TODO: make it themable
        result.width = 11;
        result.height = 21;
      } else {
        result.left = rwt.widgets.Scale.THUMB_OFFSET;
        result.top = rwt.widgets.Scale.PADDING;
        // TODO: make it themable
        result.width = 21;
        result.height = 11;
      }
      result.border = tv.getCssBorder( "Scale-Thumb", "border" );
      result.backgroundColor = tv.getCssColor( "Scale-Thumb", "background-color" );
      result.backgroundImage = tv.getCssImage( "Scale-Thumb", "background-image" );
      result.backgroundGradient = tv.getCssGradient( "Scale-Thumb", "background-image" );
      return result;
    }
  }
,

  "datetime-date" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      var result = {};
      result.border = tv.getCssBorder( "DateTime", "border" );
      result.font = tv.getCssFont( "DateTime", "font" );
      result.textColor = tv.getCssColor( "DateTime", "color" );
      result.backgroundColor = tv.getCssColor( "DateTime", "background-color" );
      result.backgroundGradient = tv.getCssGradient( "DateTime", "background-image" );
      result.textShadow = tv.getCssShadow( "DateTime", "text-shadow" );
      result.shadow = tv.getCssShadow( "DateTime", "box-shadow" );
      return result;
    }
  },

  "datetime-time" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      var result = {};
      result.border = tv.getCssBorder( "DateTime", "border" );
      result.font = tv.getCssFont( "DateTime", "font" );
      result.textColor = tv.getCssColor( "DateTime", "color" );
      result.backgroundColor = tv.getCssColor( "DateTime", "background-color" );
      result.backgroundGradient = tv.getCssGradient( "DateTime", "background-image" );
      result.textShadow = tv.getCssShadow( "DateTime", "text-shadow" );
      result.shadow = tv.getCssShadow( "DateTime", "box-shadow" );
      return result;
    }
  },

  "datetime-calendar" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      var result = {};
      result.border = tv.getCssBorder( "DateTime", "border" );
      result.font = tv.getCssFont( "DateTime", "font" );
      result.textColor = tv.getCssColor( "DateTime", "color" );
      result.backgroundColor = tv.getCssColor( "DateTime", "background-color" );
      result.textShadow = tv.getCssShadow( "DateTime", "text-shadow" );
      return result;
    }
  },

  "datetime-field" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      var result = {
        cursor : "default",
        textAlign : "center",
        padding : [ 0, 3 ]
      };
      if( !states.disabled ) {
        result.textColor = tv.getCssColor( "DateTime-Field", "color" );
        result.backgroundColor = tv.getCssColor( "DateTime-Field", "background-color" );
      } else {
        result.textColor = tv.getCssColor( "*", "color" );
        result.backgroundColor = "undefined";
      }
      result.textShadow = tv.getCssShadow( "DateTime-Field", "text-shadow" );
      return result;
    }
  },

  "datetime-separator" : {
    style : function() {
      return {
        cursor : "default"
      };
    }
  },

  "datetime-button-up" : {
    style : function( states ) {
      var result = {};
      var tv = new rwt.theme.ThemeValues( states );
      var border = tv.getCssBorder( "DateTime-UpButton", "border" );
      var borderLeft = tv.getCssBorder( "DateTime-UpButton", "border-left" );
      result.border = tv.mergeBorders( border, null, null, null, borderLeft );
      result.width = tv.getCssDimension( "DateTime-UpButton", "width" );
      result.icon = tv.getCssSizedImage( "DateTime-UpButton-Icon", "background-image" );
      if( result.icon === rwt.theme.ThemeValues.NONE_IMAGE ) {
        result.icon = tv.getCssSizedImage( "DateTime-UpButton", "background-image" );
      } else {
        result.backgroundImage = tv.getCssImage( "DateTime-UpButton", "background-image" );
      }
      result.backgroundGradient = tv.getCssGradient( "DateTime-UpButton", "background-image" );
      result.backgroundColor = tv.getCssColor( "DateTime-UpButton", "background-color" );
      result.cursor = tv.getCssCursor( "DateTime-UpButton", "cursor" );
      return result;
    }
  },

  "datetime-button-down" : {
    style : function( states ) {
      var result = {};
      var tv = new rwt.theme.ThemeValues( states );
      var border = tv.getCssBorder( "DateTime-DownButton", "border" );
      var borderLeft = tv.getCssBorder( "DateTime-DownButton", "border-left" );
      result.border = tv.mergeBorders( border, null, null, null, borderLeft );
      result.width = tv.getCssDimension( "DateTime-DownButton", "width" );
      result.icon = tv.getCssSizedImage( "DateTime-DownButton-Icon", "background-image" );
      if( result.icon === rwt.theme.ThemeValues.NONE_IMAGE ) {
        result.icon = tv.getCssSizedImage( "DateTime-DownButton", "background-image" );
      } else {
        result.backgroundImage = tv.getCssImage( "DateTime-DownButton", "background-image" );
      }
      result.backgroundGradient = tv.getCssGradient( "DateTime-DownButton", "background-image" );
      result.backgroundColor = tv.getCssColor( "DateTime-DownButton", "background-color" );
      result.cursor = tv.getCssCursor( "DateTime-DownButton", "cursor" );
      return result;
    }
  },

  "datetime-drop-down-button" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      var result = {};
      var border = tv.getCssBorder( "DateTime-DropDownButton", "border" );
      var borderLeft = tv.getCssBorder( "DateTime-DropDownButton", "border-left" );
      result.border = tv.mergeBorders( border, null, null, null, borderLeft );
      result.icon = tv.getCssSizedImage( "DateTime-DropDownButton-Icon", "background-image" );
      if( result.icon === rwt.theme.ThemeValues.NONE_IMAGE ) {
        result.icon = tv.getCssSizedImage( "DateTime-DropDownButton", "background-image" );
      } else {
        result.backgroundImage = tv.getCssImage( "DateTime-DropDownButton", "background-image" );
      }
      result.backgroundGradient = tv.getCssGradient( "DateTime-DropDownButton", "background-image" );
      result.backgroundColor = tv.getCssColor( "DateTime-DropDownButton", "background-color" );
      result.cursor = tv.getCssCursor( "DateTime-DropDownButton", "cursor" );
      return result;
    }
  },

  "datetime-drop-down-calendar" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      var result = {};
      result.border = tv.getCssBorder( "DateTime-DropDownCalendar", "border" );
      result.backgroundColor = tv.getCssColor( "DateTime", "background-color" );
      return result;
    }
  },

  //------------------------------------------------------------------------
  // Calendar

  "calendar-navBar" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      return {
        border : tv.getCssBorder( "DateTime-Calendar-Navbar", "border" ),
        backgroundColor : tv.getCssColor( "DateTime-Calendar-Navbar", "background-color" ),
        backgroundImage : tv.getCssImage( "DateTime-Calendar-Navbar", "background-image" ),
        backgroundGradient : tv.getCssGradient( "DateTime-Calendar-Navbar", "background-image" ),
        padding : [ 4, 4, 4, 4 ]
      };
    }
  },

  "calendar-toolbar-button" : {
    style : function( states ) {
      var result = {
        spacing : 4,
        width : 16,
        height : 16,
        clipWidth : 16,
        clipHeight : 16,
        verticalChildrenAlign : "middle"
      };
      if (states.pressed || states.checked || states.abandoned) {
        result.padding = [ 2, 0, 0, 2 ];
      } else {
        result.padding = 2;
      }
      return result;
    }
  },

  "calendar-toolbar-previous-year-button" : {
    include: "calendar-toolbar-button",

    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      return {
        icon : tv.getCssSizedImage( "DateTime-Calendar-PreviousYearButton", "background-image" ),
        cursor : tv.getCssCursor( "DateTime-Calendar-PreviousYearButton", "cursor" )
      };
    }
  },

  "calendar-toolbar-previous-month-button" : {
    include: "calendar-toolbar-button",

    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      return {
        icon : tv.getCssSizedImage( "DateTime-Calendar-PreviousMonthButton", "background-image" ),
        cursor : tv.getCssCursor( "DateTime-Calendar-PreviousMonthButton", "cursor" )
      };
    }
  },

  "calendar-toolbar-next-month-button" : {
    include: "calendar-toolbar-button",

    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      return {
        icon : tv.getCssSizedImage( "DateTime-Calendar-NextMonthButton", "background-image" ),
        cursor : tv.getCssCursor( "DateTime-Calendar-NextMonthButton", "cursor" )
      };
    }
  },

  "calendar-toolbar-next-year-button" : {
    include: "calendar-toolbar-button",

    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      return {
        icon : tv.getCssSizedImage( "DateTime-Calendar-NextYearButton", "background-image" ),
        cursor : tv.getCssCursor( "DateTime-Calendar-NextYearButton", "cursor" )
      };
    }
  },

  "calendar-monthyear" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      return {
        font : tv.getCssFont( "DateTime-Calendar-Navbar", "font" ),
        textAlign : "center",
        textColor : tv.getCssColor( "DateTime-Calendar-Navbar", "color" ),
        textShadow : tv.getCssShadow( "DateTime-Calendar-Navbar", "text-shadow" ),
        verticalAlign : "middle",
        cursor : "default"
      };
    }
  },

  "calendar-datepane" : {
    style : function( states ) {
      return {
        backgroundColor : "undefined"
      };
    }
  },

  "calendar-week" : {
    style : function( states ) {
      var border;
      if( states.header ) {
        border = new rwt.html.Border( [ 0, 1, 1, 0 ], "solid", "gray" );
      } else {
        border = new rwt.html.Border( [ 0, 1, 0, 0 ], "solid", "gray" );
      }
      return {
        textAlign : "center",
        verticalAlign : "middle",
        border : border
      };
    }
  },

  "calendar-weekday" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      var border = new rwt.html.Border( [ 0, 0, 1, 0 ], "solid", "gray" );
      // FIXME: [if] Bigger font size leads to text cutoff
      var font = tv.getCssFont( "DateTime", "font" );
      var smallFont = rwt.html.Font.fromString( font.toCss() );
      smallFont.setSize( 11 );
      return {
        font : smallFont,
        border : border,
        textAlign : "center"
      };
    }
  },

  "calendar-day" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      var result = {
        textAlign : "center",
        verticalAlign : "middle"
      };
      if( states.disabled ) {
        result.textColor = tv.getCssColor( "*", "color" );
        result.backgroundColor = "undefined";
      } else {
        result.textColor = tv.getCssColor( "DateTime-Calendar-Day", "color" );
        result.backgroundColor = tv.getCssColor( "DateTime-Calendar-Day", "background-color" );
      }
      result.border = tv.getCssBorder( "DateTime-Calendar-Day", "border" );
      result.textShadow = tv.getCssShadow( "DateTime-Calendar-Day", "text-shadow" );
      return result;
    }
  }
,

  "expand-bar" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      var result = {};
      result.border = tv.getCssBorder( "ExpandBar", "border" );
      result.font = tv.getCssFont( "ExpandBar", "font" );
      result.textColor = tv.getCssColor( "ExpandBar", "color" );
      return result;
    }
  },

  "expand-item" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      return {
        overflow : "hidden",
        border : tv.getCssBorder( "ExpandItem", "border" ),
        chevronIcon : tv.getCssSizedImage( "ExpandItem-Button", "background-image" )
      };
    }
  },

  "expand-item-header" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      return {
        width : "100%",
        horizontalChildrenAlign : "left",
        padding : [ 0, 4, 0, 4 ],
        border : tv.getCssBorder( "ExpandItem-Header", "border" ),
        backgroundColor : tv.getCssColor( "ExpandItem-Header", "background-color" ),
        cursor : tv.getCssCursor( "ExpandItem-Header", "cursor" ),
        backgroundImage : tv.getCssImage( "ExpandItem-Header", "background-image" ),
        backgroundGradient : tv.getCssGradient( "ExpandItem-Header", "background-image" ),
        textShadow : tv.getCssShadow( "ExpandItem-Header", "text-shadow" )
      };
    }
  }
,

  "sash" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      return {
        backgroundColor : tv.getCssColor( "Sash", "background-color" ),
        backgroundImage : tv.getCssImage( "Sash", "background-image" ),
        border : tv.getCssBorder( "Sash", "border" ),
        cursor : states.disabled ? "undefined" : states.horizontal ? "row-resize" : "col-resize"
      };
    }
  },

  "sash-slider" : {
    style : function() {
      return {
        zIndex : 1e7,
        opacity : 0.3,
        backgroundColor : "black"
      };
    }
  },

  "sash-handle" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      var result = {};
      result.backgroundImage = tv.getCssImage( "Sash-Handle", "background-image" );
      result.backgroundGradient = tv.getCssGradient( "Sash-Handle", "background-image" );
      result.backgroundRepeat = "no-repeat";
      return result;
    }
  }
,

  "slider" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      return {
        border : tv.getCssBorder( "Slider", "border" ),
        font : tv.getCssFont( "*", "font" ),
        textColor : tv.getCssColor( "*", "color" ),
        backgroundColor : tv.getCssColor( "Slider", "background-color" )
      };
    }
  },

  "slider-thumb" : {
    include : "atom",
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      var result = {};
      result.backgroundColor = tv.getCssColor( "Slider-Thumb", "background-color" );
      result.border = tv.getCssBorder( "Slider-Thumb", "border" );
      result.backgroundImage = tv.getCssImage( "Slider-Thumb", "background-image" );
      result.backgroundGradient = tv.getCssGradient( "Slider-Thumb", "background-image" );
      return result;
    }
  },

  "slider-min-button" : {
    include : "atom",
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      var result = {};
      result.padding = tv.getCssBoxDimensions( "Slider-DownButton", "padding" );
      result.backgroundColor = tv.getCssColor( "Slider-DownButton", "background-color" );
      result.icon = tv.getCssSizedImage( "Slider-DownButton-Icon", "background-image" );
      if( result.icon === rwt.theme.ThemeValues.NONE_IMAGE_SIZED ) {
        result.icon = tv.getCssSizedImage( "Slider-DownButton", "background-image" );
      } else {
        result.backgroundImage = tv.getCssImage( "Slider-DownButton", "background-image" );
      }
      result.backgroundGradient = tv.getCssGradient( "Slider-DownButton", "background-image" );
      result.border = tv.getCssBorder( "Slider-DownButton", "border" );
      if( states[ "rwt_HORIZONTAL" ] ) {
        result.width = 16;
      } else {
        result.height = 16;
      }
      result.cursor = tv.getCssCursor( "Slider-DownButton", "cursor" );
      return result;
    }
  },

  "slider-max-button" : {
    include : "atom",
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      var result = {};
      result.padding = tv.getCssBoxDimensions( "Slider-UpButton", "padding" );
      result.backgroundColor = tv.getCssColor( "Slider-UpButton", "background-color" );
      result.icon = tv.getCssSizedImage( "Slider-UpButton-Icon", "background-image" );
      if( result.icon === rwt.theme.ThemeValues.NONE_IMAGE_SIZED ) {
        result.icon = tv.getCssSizedImage( "Slider-UpButton", "background-image" );
      } else {
        result.backgroundImage = tv.getCssImage( "Slider-UpButton", "background-image" );
      }
      result.backgroundGradient = tv.getCssGradient( "Slider-UpButton", "background-image" );
      result.border = tv.getCssBorder( "Slider-UpButton", "border" );
      if( states[ "rwt_HORIZONTAL" ] ) {
        result.width = 16;
      } else {
        result.height = 16;
      }
      result.cursor = tv.getCssCursor( "Slider-UpButton", "cursor" );
      return result;
    }
  }
,

  "tool-tip" : {
    include : "popup",

    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      var result = {};
      result.width = "auto";
      result.height = "auto";
      result.minWidth = 36;
      result.minHeight = 36;
      result.cursor = tv.getCssCursor( "ToolTip", "cursor" );
      result.font = tv.getCssFont( "ToolTip", "font" );
      result.textColor = tv.getCssColor( "ToolTip", "color" );
      result.padding = tv.getCssBoxDimensions( "ToolTip", "padding" );
      result.border = tv.getCssBorder( "ToolTip", "border" );
      result.backgroundColor = tv.getCssColor( "ToolTip", "background-color" );
      result.backgroundImage = tv.getCssImage( "ToolTip", "background-image" );
      result.backgroundGradient = tv.getCssGradient( "ToolTip", "background-image" );
      result.animation = tv.getCssAnimation( "ToolTip", "animation" );
      result.opacity = tv.getCssFloat( "ToolTip", "opacity" );
      result.shadow = tv.getCssShadow( "ToolTip", "box-shadow" );
      return result;
    }
  },

  "tool-tip-image" : {
    include: "image",
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      return {
        source : tv.getCssImage( "ToolTip-Image", "background-image" )
      };
    }
  },

  "tool-tip-text" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      return {
        font : tv.getCssFont( "ToolTip-Text", "font" ),
        textColor : tv.getCssColor( "ToolTip-Text", "color" ),
        textShadow : tv.getCssShadow( "ToolTip-Text", "text-shadow" )
      };
    }
  },

  "tool-tip-message" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      return {
        font : tv.getCssFont( "ToolTip-Message", "font" ),
        textColor : tv.getCssColor( "ToolTip-Message", "color" ),
        textShadow : tv.getCssShadow( "ToolTip-Message", "text-shadow" )
      };
    }
  }
,

  "ccombo" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      var result = {};
      result.border = tv.getCssBorder( "CCombo", "border" );
      result.backgroundColor = tv.getCssColor( "CCombo", "background-color" );
      result.backgroundGradient = tv.getCssGradient( "CCombo", "background-image" );
      result.textColor = tv.getCssColor( "CCombo", "color" );
      result.font = tv.getCssFont( "CCombo", "font" );
      result.shadow = tv.getCssShadow( "CCombo", "box-shadow" );
      return result;
    }
  },

  "ccombo-list" : {
    style : function() {
      return {};
    }
  },

  "ccombo-list-popup" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      return {
        border : tv.getCssBorder( "CCombo-List", "border" ),
        shadow : tv.getCssShadow( "CCombo-List", "box-shadow" )
      };
    }
  },

  "ccombo-list-row" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      return {
        foreground : tv.getCssColor( "CCombo-List-Item", "color" ),
        background : tv.getCssColor( "CCombo-List-Item", "background-color" ),
        backgroundImage : tv.getCssImage( "CCombo-List-Item", "background-image" ),
        backgroundGradient : tv.getCssGradient( "CCombo-List-Item", "background-image" ),
        textDecoration : tv.getCssIdentifier( "CCombo-List-Item", "text-decoration" ),
        textShadow : tv.getCssShadow( "CCombo-List-Item", "text-shadow" )
      };
    }
  },

  "ccombo-list-row-overlay" : {
    style : function() {
      return {
        foreground : "undefined",
        background : "undefined",
        backgroundImage : null,
        backgroundGradient : null
      };
    }
  },

  "ccombo-list-cell" : {
    style : function( states ) {
       var tv = new rwt.theme.ThemeValues( states );
       return {
         padding : tv.getCssBoxDimensions( "CCombo-List-Item", "padding" )
       };
    }
  },

  "ccombo-field" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      var result = {};
      result.font = tv.getCssFont( "CCombo", "font" );
      // [if] Do not apply top/bottom paddings on the client
      var cssPadding = tv.getCssBoxDimensions( "CCombo-Field", "padding" );
      result.paddingRight = cssPadding[ 1 ];
      result.paddingLeft = cssPadding[ 3 ];
      result.width = null;
      result.height = null;
      result.left = 0;
      result.right = tv.getCssDimension( "CCombo-Button", "width" );
      result.top = 0;
      result.bottom = 0;
      result.textColor = tv.getCssColor( "CCombo", "color" );
      result.textShadow = tv.getCssShadow( "CCombo", "text-shadow" );
      return result;
    }
  },

  "ccombo-button" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      var result = {};
      var border = tv.getCssBorder( "CCombo-Button", "border" );
      var borderLeft = tv.getCssBorder( "CCombo-Button", "border-left" );
      result.border = tv.mergeBorders( border, null, null, null, borderLeft );
      result.width = tv.getCssDimension( "CCombo-Button", "width" );
      result.height = null;
      result.top = 0;
      result.bottom = 0;
      result.right = 0;
      result.icon = tv.getCssSizedImage( "CCombo-Button-Icon", "background-image" );
      if( result.icon === rwt.theme.ThemeValues.NONE_IMAGE_SIZED ) {
        result.icon = tv.getCssSizedImage( "CCombo-Button", "background-image" );
      } else {
        result.backgroundImage = tv.getCssImage( "CCombo-Button", "background-image" );
      }
      result.backgroundGradient = tv.getCssGradient( "CCombo-Button", "background-image" );
      // TODO [rst] rather use button.bgcolor?
      result.backgroundColor = tv.getCssColor( "CCombo-Button", "background-color" );
      result.cursor = tv.getCssCursor( "CCombo-Button", "cursor" );
      return result;
    }
  }
,

  "clabel" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      var result = {};
      result.textColor = tv.getCssColor( "CLabel", "color" );
      result.backgroundColor = tv.getCssColor( "CLabel", "background-color" );
      result.font = tv.getCssFont( "CLabel", "font" );
      if( states.rwt_SHADOW_IN ) {
        result.border = tv.getCssNamedBorder( "thinInset" );
      } else if( states.rwt_SHADOW_OUT ) {
        result.border = tv.getCssNamedBorder( "thinOutset" );
      } else {
        result.border = tv.getCssBorder( "CLabel", "border" );
      }
      result.backgroundImage = tv.getCssImage( "CLabel", "background-image" );
      result.backgroundRepeat = tv.getCssIdentifier( "CLabel", "background-repeat" );
      result.backgroundPosition = tv.getCssIdentifier( "CLabel", "background-position" );
      result.backgroundGradient = tv.getCssGradient( "CLabel", "background-image" );
      result.cursor = tv.getCssCursor( "CLabel", "cursor" );
      result.padding = tv.getCssBoxDimensions( "CLabel", "padding" );
      result.spacing = tv.getCssDimension( "CLabel", "spacing" );
      result.opacity = tv.getCssFloat( "CLabel", "opacity" );
      result.textShadow = tv.getCssShadow( "CLabel", "text-shadow" );
      return result;
    }
  }
,

  "browser" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      return {
        border : tv.getCssBorder( "Browser", "border" ),
        backgroundColor : "white"
      };
    }
  }
,

  "scrolledcomposite" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      var result = {};
      if( states.rwt_BORDER ) {
        result.border = tv.getCssNamedBorder( "shadow" );
      } else {
        result.border = tv.getCssBorder( "*", "border" );
      }
      return result;
    }
  }
,

  "scrollbar" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      var result = {
        border : tv.getCssBorder( "ScrollBar", "border" ),
        backgroundColor : tv.getCssColor( "ScrollBar", "background-color" ),
        backgroundImage : tv.getCssImage( "ScrollBar", "background-image" ),
        backgroundGradient : tv.getCssGradient( "ScrollBar", "background-image" ),
        opacity : tv.getCssFloat( "ScrollBar", "opacity" )
      };
      var width = tv.getCssDimension( "ScrollBar", "width" );
      if( states[ "rwt_HORIZONTAL" ] ) {
        result.height = width;
      } else {
        result.width = width;
      }
      return result;
    }
  },

  "scrollbar-thumb" : {
    include : "atom",
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      var result = {};
      result.backgroundColor = tv.getCssColor( "ScrollBar-Thumb", "background-color" );
      result.border = tv.getCssBorder( "ScrollBar-Thumb", "border" );
      result.backgroundImage = tv.getCssImage( "ScrollBar-Thumb", "background-image" );
      result.backgroundGradient = tv.getCssGradient( "ScrollBar-Thumb", "background-image" );
      result.icon = tv.getCssSizedImage( "ScrollBar-Thumb-Icon", "background-image" );
      return result;
    }
  },

  "scrollbar-min-button" : {
    include : "atom",
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      var result = {};
      result.backgroundColor = tv.getCssColor( "ScrollBar-DownButton", "background-color" );
      result.icon = tv.getCssSizedImage( "ScrollBar-DownButton-Icon", "background-image" );
      if( result.icon === rwt.theme.ThemeValues.NONE_IMAGE_SIZED ) {
        result.icon = tv.getCssSizedImage( "ScrollBar-DownButton", "background-image" );
      } else {
        result.backgroundImage = tv.getCssImage( "ScrollBar-DownButton", "background-image" );
      }
      result.backgroundGradient = tv.getCssGradient( "ScrollBar-DownButton", "background-image" );
      result.border = tv.getCssBorder( "ScrollBar-DownButton", "border" );
      var width = tv.getCssDimension( "ScrollBar", "width" );
      if( states[ "rwt_HORIZONTAL" ] ) {
        result.width = width;
      } else {
        result.height = width;
      }
      result.cursor = tv.getCssCursor( "ScrollBar-DownButton", "cursor" );
      return result;
    }
  },

  "scrollbar-max-button" : {
    include : "atom",
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      var result = {};
      result.backgroundColor = tv.getCssColor( "ScrollBar-UpButton", "background-color" );
      result.icon = tv.getCssSizedImage( "ScrollBar-UpButton-Icon", "background-image" );
      if( result.icon === rwt.theme.ThemeValues.NONE_IMAGE_SIZED ) {
        result.icon = tv.getCssSizedImage( "ScrollBar-UpButton", "background-image" );
      } else {
        result.backgroundImage = tv.getCssImage( "ScrollBar-UpButton", "background-image" );
      }
      result.backgroundGradient = tv.getCssGradient( "ScrollBar-UpButton", "background-image" );
      result.border = tv.getCssBorder( "ScrollBar-UpButton", "border" );
      var width = tv.getCssDimension( "ScrollBar", "width" );
      if( states[ "rwt_HORIZONTAL" ] ) {
        result.width = width;
      } else {
        result.height = width;
      }
      result.cursor = tv.getCssCursor( "ScrollBar-UpButton", "cursor" );
      return result;
    }
  }
,

 "file-upload" : {
    include : "atom",

    style : function( states ) {
      var result = {};
      var tv = new rwt.theme.ThemeValues( states );
      result.font = tv.getCssFont( "FileUpload", "font" );
      result.textColor = tv.getCssColor( "FileUpload", "color" );
      result.backgroundColor = tv.getCssColor( "FileUpload", "background-color" );
      result.backgroundImage = tv.getCssImage( "FileUpload", "background-image" );
      result.backgroundRepeat = tv.getCssIdentifier( "FileUpload", "background-repeat" );
      result.backgroundPosition = tv.getCssIdentifier( "FileUpload", "background-position" );
      result.backgroundGradient = tv.getCssGradient( "FileUpload", "background-image" );
      result.border = tv.getCssBorder( "FileUpload", "border" );
      result.spacing = tv.getCssDimension( "FileUpload", "spacing" );
      result.padding = tv.getCssBoxDimensions( "FileUpload", "padding" );
      result.cursor = tv.getCssCursor( "FileUpload", "cursor" );
      result.opacity = tv.getCssFloat( "FileUpload", "opacity" );
      result.textShadow = tv.getCssShadow( "FileUpload", "text-shadow" );
      result.animation = tv.getCssAnimation( "FileUpload", "animation" );
      return result;
    }
  }
,

  "dropdown" : {
    style : function() {
      return {};
    }
  },

  "dropdown-popup" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      return {
        border : tv.getCssBorder( "DropDown", "border" ),
        shadow : tv.getCssShadow( "DropDown", "box-shadow" )
      };
    }
  },

  "dropdown-row" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      return {
        foreground : tv.getCssColor( "DropDown-Item", "color" ),
        background : tv.getCssColor( "DropDown-Item", "background-color" ),
        backgroundImage : tv.getCssImage( "DropDown-Item", "background-image" ),
        backgroundGradient : tv.getCssGradient( "DropDown-Item", "background-image" ),
        textDecoration : tv.getCssIdentifier( "DropDown-Item", "text-decoration" ),
        textShadow : tv.getCssShadow( "DropDown-Item", "text-shadow" )
      };
    }
  },

  "dropdown-row-overlay" : {
    style : function() {
      return {
        foreground : "undefined",
        background : "undefined",
        backgroundImage : null,
        backgroundGradient : null
      };
    }
  },

  "dropdown-cell" : {
    style : function( states ) {
       var tv = new rwt.theme.ThemeValues( states );
       return {
         padding : tv.getCssBoxDimensions( "DropDown-Item", "padding" )
       };
    }
  }
,

  "hyperlink" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      return {
        font: tv.getCssFont( "*", "font" ),
        textColor : states.disabled ? tv.getCssColor( "*", "color" ) : "undefined",
        cursor : states.disabled ? "default" : "pointer",
        spacing : 4,
        width : "auto",
        height : "auto",
        horizontalChildrenAlign : "left",
        verticalChildrenAlign : "middle"
      }
    }
  }
,

  "formtext" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      return {
        textColor       : tv.getCssColor( "FormText", "color" ),
        backgroundColor : tv.getCssColor( "FormText", "background-color" ),
        font            : tv.getCssFont( "FormText", "font" ),
        border          : tv.getCssBorder( "FormText", "border" )
      }
    }
  },

  "formtext-text" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      return {
        cursor          : "default"
      }
    }
  },

  "formtext-image" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      return {
      }
    }
  },

  "formtext-bullet" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      return {
      }
    }
  },

  "formtext-hyperlink" : {
    style : function( states ) {
      var tv = new rwt.theme.ThemeValues( states );
      return {
        cursor          : "pointer"
      }
    }
  }

  }
} );

